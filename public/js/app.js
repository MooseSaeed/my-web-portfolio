/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@vue/compiler-core/dist/compiler-core.esm-bundler.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@vue/compiler-core/dist/compiler-core.esm-bundler.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "generateCodeFrame": () => (/* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_0__.generateCodeFrame),
/* harmony export */   "BASE_TRANSITION": () => (/* binding */ BASE_TRANSITION),
/* harmony export */   "CAMELIZE": () => (/* binding */ CAMELIZE),
/* harmony export */   "CAPITALIZE": () => (/* binding */ CAPITALIZE),
/* harmony export */   "CREATE_BLOCK": () => (/* binding */ CREATE_BLOCK),
/* harmony export */   "CREATE_COMMENT": () => (/* binding */ CREATE_COMMENT),
/* harmony export */   "CREATE_ELEMENT_BLOCK": () => (/* binding */ CREATE_ELEMENT_BLOCK),
/* harmony export */   "CREATE_ELEMENT_VNODE": () => (/* binding */ CREATE_ELEMENT_VNODE),
/* harmony export */   "CREATE_SLOTS": () => (/* binding */ CREATE_SLOTS),
/* harmony export */   "CREATE_STATIC": () => (/* binding */ CREATE_STATIC),
/* harmony export */   "CREATE_TEXT": () => (/* binding */ CREATE_TEXT),
/* harmony export */   "CREATE_VNODE": () => (/* binding */ CREATE_VNODE),
/* harmony export */   "FRAGMENT": () => (/* binding */ FRAGMENT),
/* harmony export */   "GUARD_REACTIVE_PROPS": () => (/* binding */ GUARD_REACTIVE_PROPS),
/* harmony export */   "IS_MEMO_SAME": () => (/* binding */ IS_MEMO_SAME),
/* harmony export */   "IS_REF": () => (/* binding */ IS_REF),
/* harmony export */   "KEEP_ALIVE": () => (/* binding */ KEEP_ALIVE),
/* harmony export */   "MERGE_PROPS": () => (/* binding */ MERGE_PROPS),
/* harmony export */   "NORMALIZE_CLASS": () => (/* binding */ NORMALIZE_CLASS),
/* harmony export */   "NORMALIZE_PROPS": () => (/* binding */ NORMALIZE_PROPS),
/* harmony export */   "NORMALIZE_STYLE": () => (/* binding */ NORMALIZE_STYLE),
/* harmony export */   "OPEN_BLOCK": () => (/* binding */ OPEN_BLOCK),
/* harmony export */   "POP_SCOPE_ID": () => (/* binding */ POP_SCOPE_ID),
/* harmony export */   "PUSH_SCOPE_ID": () => (/* binding */ PUSH_SCOPE_ID),
/* harmony export */   "RENDER_LIST": () => (/* binding */ RENDER_LIST),
/* harmony export */   "RENDER_SLOT": () => (/* binding */ RENDER_SLOT),
/* harmony export */   "RESOLVE_COMPONENT": () => (/* binding */ RESOLVE_COMPONENT),
/* harmony export */   "RESOLVE_DIRECTIVE": () => (/* binding */ RESOLVE_DIRECTIVE),
/* harmony export */   "RESOLVE_DYNAMIC_COMPONENT": () => (/* binding */ RESOLVE_DYNAMIC_COMPONENT),
/* harmony export */   "RESOLVE_FILTER": () => (/* binding */ RESOLVE_FILTER),
/* harmony export */   "SET_BLOCK_TRACKING": () => (/* binding */ SET_BLOCK_TRACKING),
/* harmony export */   "SUSPENSE": () => (/* binding */ SUSPENSE),
/* harmony export */   "TELEPORT": () => (/* binding */ TELEPORT),
/* harmony export */   "TO_DISPLAY_STRING": () => (/* binding */ TO_DISPLAY_STRING),
/* harmony export */   "TO_HANDLERS": () => (/* binding */ TO_HANDLERS),
/* harmony export */   "TO_HANDLER_KEY": () => (/* binding */ TO_HANDLER_KEY),
/* harmony export */   "UNREF": () => (/* binding */ UNREF),
/* harmony export */   "WITH_CTX": () => (/* binding */ WITH_CTX),
/* harmony export */   "WITH_DIRECTIVES": () => (/* binding */ WITH_DIRECTIVES),
/* harmony export */   "WITH_MEMO": () => (/* binding */ WITH_MEMO),
/* harmony export */   "advancePositionWithClone": () => (/* binding */ advancePositionWithClone),
/* harmony export */   "advancePositionWithMutation": () => (/* binding */ advancePositionWithMutation),
/* harmony export */   "assert": () => (/* binding */ assert),
/* harmony export */   "baseCompile": () => (/* binding */ baseCompile),
/* harmony export */   "baseParse": () => (/* binding */ baseParse),
/* harmony export */   "buildDirectiveArgs": () => (/* binding */ buildDirectiveArgs),
/* harmony export */   "buildProps": () => (/* binding */ buildProps),
/* harmony export */   "buildSlots": () => (/* binding */ buildSlots),
/* harmony export */   "checkCompatEnabled": () => (/* binding */ checkCompatEnabled),
/* harmony export */   "createArrayExpression": () => (/* binding */ createArrayExpression),
/* harmony export */   "createAssignmentExpression": () => (/* binding */ createAssignmentExpression),
/* harmony export */   "createBlockStatement": () => (/* binding */ createBlockStatement),
/* harmony export */   "createCacheExpression": () => (/* binding */ createCacheExpression),
/* harmony export */   "createCallExpression": () => (/* binding */ createCallExpression),
/* harmony export */   "createCompilerError": () => (/* binding */ createCompilerError),
/* harmony export */   "createCompoundExpression": () => (/* binding */ createCompoundExpression),
/* harmony export */   "createConditionalExpression": () => (/* binding */ createConditionalExpression),
/* harmony export */   "createForLoopParams": () => (/* binding */ createForLoopParams),
/* harmony export */   "createFunctionExpression": () => (/* binding */ createFunctionExpression),
/* harmony export */   "createIfStatement": () => (/* binding */ createIfStatement),
/* harmony export */   "createInterpolation": () => (/* binding */ createInterpolation),
/* harmony export */   "createObjectExpression": () => (/* binding */ createObjectExpression),
/* harmony export */   "createObjectProperty": () => (/* binding */ createObjectProperty),
/* harmony export */   "createReturnStatement": () => (/* binding */ createReturnStatement),
/* harmony export */   "createRoot": () => (/* binding */ createRoot),
/* harmony export */   "createSequenceExpression": () => (/* binding */ createSequenceExpression),
/* harmony export */   "createSimpleExpression": () => (/* binding */ createSimpleExpression),
/* harmony export */   "createStructuralDirectiveTransform": () => (/* binding */ createStructuralDirectiveTransform),
/* harmony export */   "createTemplateLiteral": () => (/* binding */ createTemplateLiteral),
/* harmony export */   "createTransformContext": () => (/* binding */ createTransformContext),
/* harmony export */   "createVNodeCall": () => (/* binding */ createVNodeCall),
/* harmony export */   "extractIdentifiers": () => (/* binding */ extractIdentifiers),
/* harmony export */   "findDir": () => (/* binding */ findDir),
/* harmony export */   "findProp": () => (/* binding */ findProp),
/* harmony export */   "generate": () => (/* binding */ generate),
/* harmony export */   "getBaseTransformPreset": () => (/* binding */ getBaseTransformPreset),
/* harmony export */   "getInnerRange": () => (/* binding */ getInnerRange),
/* harmony export */   "getMemoedVNodeCall": () => (/* binding */ getMemoedVNodeCall),
/* harmony export */   "getVNodeBlockHelper": () => (/* binding */ getVNodeBlockHelper),
/* harmony export */   "getVNodeHelper": () => (/* binding */ getVNodeHelper),
/* harmony export */   "hasDynamicKeyVBind": () => (/* binding */ hasDynamicKeyVBind),
/* harmony export */   "hasScopeRef": () => (/* binding */ hasScopeRef),
/* harmony export */   "helperNameMap": () => (/* binding */ helperNameMap),
/* harmony export */   "injectProp": () => (/* binding */ injectProp),
/* harmony export */   "isBuiltInType": () => (/* binding */ isBuiltInType),
/* harmony export */   "isCoreComponent": () => (/* binding */ isCoreComponent),
/* harmony export */   "isFunctionType": () => (/* binding */ isFunctionType),
/* harmony export */   "isInDestructureAssignment": () => (/* binding */ isInDestructureAssignment),
/* harmony export */   "isMemberExpression": () => (/* binding */ isMemberExpression),
/* harmony export */   "isMemberExpressionBrowser": () => (/* binding */ isMemberExpressionBrowser),
/* harmony export */   "isMemberExpressionNode": () => (/* binding */ isMemberExpressionNode),
/* harmony export */   "isReferencedIdentifier": () => (/* binding */ isReferencedIdentifier),
/* harmony export */   "isSimpleIdentifier": () => (/* binding */ isSimpleIdentifier),
/* harmony export */   "isSlotOutlet": () => (/* binding */ isSlotOutlet),
/* harmony export */   "isStaticArgOf": () => (/* binding */ isStaticArgOf),
/* harmony export */   "isStaticExp": () => (/* binding */ isStaticExp),
/* harmony export */   "isStaticProperty": () => (/* binding */ isStaticProperty),
/* harmony export */   "isStaticPropertyKey": () => (/* binding */ isStaticPropertyKey),
/* harmony export */   "isTemplateNode": () => (/* binding */ isTemplateNode),
/* harmony export */   "isText": () => (/* binding */ isText),
/* harmony export */   "isVSlot": () => (/* binding */ isVSlot),
/* harmony export */   "locStub": () => (/* binding */ locStub),
/* harmony export */   "makeBlock": () => (/* binding */ makeBlock),
/* harmony export */   "noopDirectiveTransform": () => (/* binding */ noopDirectiveTransform),
/* harmony export */   "processExpression": () => (/* binding */ processExpression),
/* harmony export */   "processFor": () => (/* binding */ processFor),
/* harmony export */   "processIf": () => (/* binding */ processIf),
/* harmony export */   "processSlotOutlet": () => (/* binding */ processSlotOutlet),
/* harmony export */   "registerRuntimeHelpers": () => (/* binding */ registerRuntimeHelpers),
/* harmony export */   "resolveComponentType": () => (/* binding */ resolveComponentType),
/* harmony export */   "toValidAssetId": () => (/* binding */ toValidAssetId),
/* harmony export */   "trackSlotScopes": () => (/* binding */ trackSlotScopes),
/* harmony export */   "trackVForSlotScopes": () => (/* binding */ trackVForSlotScopes),
/* harmony export */   "transform": () => (/* binding */ transform),
/* harmony export */   "transformBind": () => (/* binding */ transformBind),
/* harmony export */   "transformElement": () => (/* binding */ transformElement),
/* harmony export */   "transformExpression": () => (/* binding */ transformExpression),
/* harmony export */   "transformModel": () => (/* binding */ transformModel),
/* harmony export */   "transformOn": () => (/* binding */ transformOn),
/* harmony export */   "traverseNode": () => (/* binding */ traverseNode),
/* harmony export */   "walkBlockDeclarations": () => (/* binding */ walkBlockDeclarations),
/* harmony export */   "walkFunctionParams": () => (/* binding */ walkFunctionParams),
/* harmony export */   "walkIdentifiers": () => (/* binding */ walkIdentifiers),
/* harmony export */   "warnDeprecation": () => (/* binding */ warnDeprecation)
/* harmony export */ });
/* harmony import */ var _vue_shared__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vue/shared */ "./node_modules/@vue/compiler-core/node_modules/@vue/shared/dist/shared.esm-bundler.js");



function defaultOnError(error) {
    throw error;
}
function defaultOnWarn(msg) {
    ( true) && console.warn(`[Vue warn] ${msg.message}`);
}
function createCompilerError(code, loc, messages, additionalMessage) {
    const msg =  true
        ? (messages || errorMessages)[code] + (additionalMessage || ``)
        : 0;
    const error = new SyntaxError(String(msg));
    error.code = code;
    error.loc = loc;
    return error;
}
const errorMessages = {
    // parse errors
    [0 /* ABRUPT_CLOSING_OF_EMPTY_COMMENT */]: 'Illegal comment.',
    [1 /* CDATA_IN_HTML_CONTENT */]: 'CDATA section is allowed only in XML context.',
    [2 /* DUPLICATE_ATTRIBUTE */]: 'Duplicate attribute.',
    [3 /* END_TAG_WITH_ATTRIBUTES */]: 'End tag cannot have attributes.',
    [4 /* END_TAG_WITH_TRAILING_SOLIDUS */]: "Illegal '/' in tags.",
    [5 /* EOF_BEFORE_TAG_NAME */]: 'Unexpected EOF in tag.',
    [6 /* EOF_IN_CDATA */]: 'Unexpected EOF in CDATA section.',
    [7 /* EOF_IN_COMMENT */]: 'Unexpected EOF in comment.',
    [8 /* EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT */]: 'Unexpected EOF in script.',
    [9 /* EOF_IN_TAG */]: 'Unexpected EOF in tag.',
    [10 /* INCORRECTLY_CLOSED_COMMENT */]: 'Incorrectly closed comment.',
    [11 /* INCORRECTLY_OPENED_COMMENT */]: 'Incorrectly opened comment.',
    [12 /* INVALID_FIRST_CHARACTER_OF_TAG_NAME */]: "Illegal tag name. Use '&lt;' to print '<'.",
    [13 /* MISSING_ATTRIBUTE_VALUE */]: 'Attribute value was expected.',
    [14 /* MISSING_END_TAG_NAME */]: 'End tag name was expected.',
    [15 /* MISSING_WHITESPACE_BETWEEN_ATTRIBUTES */]: 'Whitespace was expected.',
    [16 /* NESTED_COMMENT */]: "Unexpected '<!--' in comment.",
    [17 /* UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME */]: 'Attribute name cannot contain U+0022 ("), U+0027 (\'), and U+003C (<).',
    [18 /* UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE */]: 'Unquoted attribute value cannot contain U+0022 ("), U+0027 (\'), U+003C (<), U+003D (=), and U+0060 (`).',
    [19 /* UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME */]: "Attribute name cannot start with '='.",
    [21 /* UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME */]: "'<?' is allowed only in XML context.",
    [20 /* UNEXPECTED_NULL_CHARACTER */]: `Unexpected null character.`,
    [22 /* UNEXPECTED_SOLIDUS_IN_TAG */]: "Illegal '/' in tags.",
    // Vue-specific parse errors
    [23 /* X_INVALID_END_TAG */]: 'Invalid end tag.',
    [24 /* X_MISSING_END_TAG */]: 'Element is missing end tag.',
    [25 /* X_MISSING_INTERPOLATION_END */]: 'Interpolation end sign was not found.',
    [27 /* X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END */]: 'End bracket for dynamic directive argument was not found. ' +
        'Note that dynamic directive argument cannot contain spaces.',
    [26 /* X_MISSING_DIRECTIVE_NAME */]: 'Legal directive name was expected.',
    // transform errors
    [28 /* X_V_IF_NO_EXPRESSION */]: `v-if/v-else-if is missing expression.`,
    [29 /* X_V_IF_SAME_KEY */]: `v-if/else branches must use unique keys.`,
    [30 /* X_V_ELSE_NO_ADJACENT_IF */]: `v-else/v-else-if has no adjacent v-if or v-else-if.`,
    [31 /* X_V_FOR_NO_EXPRESSION */]: `v-for is missing expression.`,
    [32 /* X_V_FOR_MALFORMED_EXPRESSION */]: `v-for has invalid expression.`,
    [33 /* X_V_FOR_TEMPLATE_KEY_PLACEMENT */]: `<template v-for> key should be placed on the <template> tag.`,
    [34 /* X_V_BIND_NO_EXPRESSION */]: `v-bind is missing expression.`,
    [35 /* X_V_ON_NO_EXPRESSION */]: `v-on is missing expression.`,
    [36 /* X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET */]: `Unexpected custom directive on <slot> outlet.`,
    [37 /* X_V_SLOT_MIXED_SLOT_USAGE */]: `Mixed v-slot usage on both the component and nested <template>.` +
        `When there are multiple named slots, all slots should use <template> ` +
        `syntax to avoid scope ambiguity.`,
    [38 /* X_V_SLOT_DUPLICATE_SLOT_NAMES */]: `Duplicate slot names found. `,
    [39 /* X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN */]: `Extraneous children found when component already has explicitly named ` +
        `default slot. These children will be ignored.`,
    [40 /* X_V_SLOT_MISPLACED */]: `v-slot can only be used on components or <template> tags.`,
    [41 /* X_V_MODEL_NO_EXPRESSION */]: `v-model is missing expression.`,
    [42 /* X_V_MODEL_MALFORMED_EXPRESSION */]: `v-model value must be a valid JavaScript member expression.`,
    [43 /* X_V_MODEL_ON_SCOPE_VARIABLE */]: `v-model cannot be used on v-for or v-slot scope variables because they are not writable.`,
    [44 /* X_INVALID_EXPRESSION */]: `Error parsing JavaScript expression: `,
    [45 /* X_KEEP_ALIVE_INVALID_CHILDREN */]: `<KeepAlive> expects exactly one child component.`,
    // generic errors
    [46 /* X_PREFIX_ID_NOT_SUPPORTED */]: `"prefixIdentifiers" option is not supported in this build of compiler.`,
    [47 /* X_MODULE_MODE_NOT_SUPPORTED */]: `ES module mode is not supported in this build of compiler.`,
    [48 /* X_CACHE_HANDLER_NOT_SUPPORTED */]: `"cacheHandlers" option is only supported when the "prefixIdentifiers" option is enabled.`,
    [49 /* X_SCOPE_ID_NOT_SUPPORTED */]: `"scopeId" option is only supported in module mode.`,
    // just to fulfill types
    [50 /* __EXTEND_POINT__ */]: ``
};

const FRAGMENT = Symbol(( true) ? `Fragment` : 0);
const TELEPORT = Symbol(( true) ? `Teleport` : 0);
const SUSPENSE = Symbol(( true) ? `Suspense` : 0);
const KEEP_ALIVE = Symbol(( true) ? `KeepAlive` : 0);
const BASE_TRANSITION = Symbol(( true) ? `BaseTransition` : 0);
const OPEN_BLOCK = Symbol(( true) ? `openBlock` : 0);
const CREATE_BLOCK = Symbol(( true) ? `createBlock` : 0);
const CREATE_ELEMENT_BLOCK = Symbol(( true) ? `createElementBlock` : 0);
const CREATE_VNODE = Symbol(( true) ? `createVNode` : 0);
const CREATE_ELEMENT_VNODE = Symbol(( true) ? `createElementVNode` : 0);
const CREATE_COMMENT = Symbol(( true) ? `createCommentVNode` : 0);
const CREATE_TEXT = Symbol(( true) ? `createTextVNode` : 0);
const CREATE_STATIC = Symbol(( true) ? `createStaticVNode` : 0);
const RESOLVE_COMPONENT = Symbol(( true) ? `resolveComponent` : 0);
const RESOLVE_DYNAMIC_COMPONENT = Symbol(( true) ? `resolveDynamicComponent` : 0);
const RESOLVE_DIRECTIVE = Symbol(( true) ? `resolveDirective` : 0);
const RESOLVE_FILTER = Symbol(( true) ? `resolveFilter` : 0);
const WITH_DIRECTIVES = Symbol(( true) ? `withDirectives` : 0);
const RENDER_LIST = Symbol(( true) ? `renderList` : 0);
const RENDER_SLOT = Symbol(( true) ? `renderSlot` : 0);
const CREATE_SLOTS = Symbol(( true) ? `createSlots` : 0);
const TO_DISPLAY_STRING = Symbol(( true) ? `toDisplayString` : 0);
const MERGE_PROPS = Symbol(( true) ? `mergeProps` : 0);
const NORMALIZE_CLASS = Symbol(( true) ? `normalizeClass` : 0);
const NORMALIZE_STYLE = Symbol(( true) ? `normalizeStyle` : 0);
const NORMALIZE_PROPS = Symbol(( true) ? `normalizeProps` : 0);
const GUARD_REACTIVE_PROPS = Symbol(( true) ? `guardReactiveProps` : 0);
const TO_HANDLERS = Symbol(( true) ? `toHandlers` : 0);
const CAMELIZE = Symbol(( true) ? `camelize` : 0);
const CAPITALIZE = Symbol(( true) ? `capitalize` : 0);
const TO_HANDLER_KEY = Symbol(( true) ? `toHandlerKey` : 0);
const SET_BLOCK_TRACKING = Symbol(( true) ? `setBlockTracking` : 0);
const PUSH_SCOPE_ID = Symbol(( true) ? `pushScopeId` : 0);
const POP_SCOPE_ID = Symbol(( true) ? `popScopeId` : 0);
const WITH_CTX = Symbol(( true) ? `withCtx` : 0);
const UNREF = Symbol(( true) ? `unref` : 0);
const IS_REF = Symbol(( true) ? `isRef` : 0);
const WITH_MEMO = Symbol(( true) ? `withMemo` : 0);
const IS_MEMO_SAME = Symbol(( true) ? `isMemoSame` : 0);
// Name mapping for runtime helpers that need to be imported from 'vue' in
// generated code. Make sure these are correctly exported in the runtime!
// Using `any` here because TS doesn't allow symbols as index type.
const helperNameMap = {
    [FRAGMENT]: `Fragment`,
    [TELEPORT]: `Teleport`,
    [SUSPENSE]: `Suspense`,
    [KEEP_ALIVE]: `KeepAlive`,
    [BASE_TRANSITION]: `BaseTransition`,
    [OPEN_BLOCK]: `openBlock`,
    [CREATE_BLOCK]: `createBlock`,
    [CREATE_ELEMENT_BLOCK]: `createElementBlock`,
    [CREATE_VNODE]: `createVNode`,
    [CREATE_ELEMENT_VNODE]: `createElementVNode`,
    [CREATE_COMMENT]: `createCommentVNode`,
    [CREATE_TEXT]: `createTextVNode`,
    [CREATE_STATIC]: `createStaticVNode`,
    [RESOLVE_COMPONENT]: `resolveComponent`,
    [RESOLVE_DYNAMIC_COMPONENT]: `resolveDynamicComponent`,
    [RESOLVE_DIRECTIVE]: `resolveDirective`,
    [RESOLVE_FILTER]: `resolveFilter`,
    [WITH_DIRECTIVES]: `withDirectives`,
    [RENDER_LIST]: `renderList`,
    [RENDER_SLOT]: `renderSlot`,
    [CREATE_SLOTS]: `createSlots`,
    [TO_DISPLAY_STRING]: `toDisplayString`,
    [MERGE_PROPS]: `mergeProps`,
    [NORMALIZE_CLASS]: `normalizeClass`,
    [NORMALIZE_STYLE]: `normalizeStyle`,
    [NORMALIZE_PROPS]: `normalizeProps`,
    [GUARD_REACTIVE_PROPS]: `guardReactiveProps`,
    [TO_HANDLERS]: `toHandlers`,
    [CAMELIZE]: `camelize`,
    [CAPITALIZE]: `capitalize`,
    [TO_HANDLER_KEY]: `toHandlerKey`,
    [SET_BLOCK_TRACKING]: `setBlockTracking`,
    [PUSH_SCOPE_ID]: `pushScopeId`,
    [POP_SCOPE_ID]: `popScopeId`,
    [WITH_CTX]: `withCtx`,
    [UNREF]: `unref`,
    [IS_REF]: `isRef`,
    [WITH_MEMO]: `withMemo`,
    [IS_MEMO_SAME]: `isMemoSame`
};
function registerRuntimeHelpers(helpers) {
    Object.getOwnPropertySymbols(helpers).forEach(s => {
        helperNameMap[s] = helpers[s];
    });
}

// AST Utilities ---------------------------------------------------------------
// Some expressions, e.g. sequence and conditional expressions, are never
// associated with template nodes, so their source locations are just a stub.
// Container types like CompoundExpression also don't need a real location.
const locStub = {
    source: '',
    start: { line: 1, column: 1, offset: 0 },
    end: { line: 1, column: 1, offset: 0 }
};
function createRoot(children, loc = locStub) {
    return {
        type: 0 /* ROOT */,
        children,
        helpers: [],
        components: [],
        directives: [],
        hoists: [],
        imports: [],
        cached: 0,
        temps: 0,
        codegenNode: undefined,
        loc
    };
}
function createVNodeCall(context, tag, props, children, patchFlag, dynamicProps, directives, isBlock = false, disableTracking = false, isComponent = false, loc = locStub) {
    if (context) {
        if (isBlock) {
            context.helper(OPEN_BLOCK);
            context.helper(getVNodeBlockHelper(context.inSSR, isComponent));
        }
        else {
            context.helper(getVNodeHelper(context.inSSR, isComponent));
        }
        if (directives) {
            context.helper(WITH_DIRECTIVES);
        }
    }
    return {
        type: 13 /* VNODE_CALL */,
        tag,
        props,
        children,
        patchFlag,
        dynamicProps,
        directives,
        isBlock,
        disableTracking,
        isComponent,
        loc
    };
}
function createArrayExpression(elements, loc = locStub) {
    return {
        type: 17 /* JS_ARRAY_EXPRESSION */,
        loc,
        elements
    };
}
function createObjectExpression(properties, loc = locStub) {
    return {
        type: 15 /* JS_OBJECT_EXPRESSION */,
        loc,
        properties
    };
}
function createObjectProperty(key, value) {
    return {
        type: 16 /* JS_PROPERTY */,
        loc: locStub,
        key: (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(key) ? createSimpleExpression(key, true) : key,
        value
    };
}
function createSimpleExpression(content, isStatic = false, loc = locStub, constType = 0 /* NOT_CONSTANT */) {
    return {
        type: 4 /* SIMPLE_EXPRESSION */,
        loc,
        content,
        isStatic,
        constType: isStatic ? 3 /* CAN_STRINGIFY */ : constType
    };
}
function createInterpolation(content, loc) {
    return {
        type: 5 /* INTERPOLATION */,
        loc,
        content: (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(content)
            ? createSimpleExpression(content, false, loc)
            : content
    };
}
function createCompoundExpression(children, loc = locStub) {
    return {
        type: 8 /* COMPOUND_EXPRESSION */,
        loc,
        children
    };
}
function createCallExpression(callee, args = [], loc = locStub) {
    return {
        type: 14 /* JS_CALL_EXPRESSION */,
        loc,
        callee,
        arguments: args
    };
}
function createFunctionExpression(params, returns = undefined, newline = false, isSlot = false, loc = locStub) {
    return {
        type: 18 /* JS_FUNCTION_EXPRESSION */,
        params,
        returns,
        newline,
        isSlot,
        loc
    };
}
function createConditionalExpression(test, consequent, alternate, newline = true) {
    return {
        type: 19 /* JS_CONDITIONAL_EXPRESSION */,
        test,
        consequent,
        alternate,
        newline,
        loc: locStub
    };
}
function createCacheExpression(index, value, isVNode = false) {
    return {
        type: 20 /* JS_CACHE_EXPRESSION */,
        index,
        value,
        isVNode,
        loc: locStub
    };
}
function createBlockStatement(body) {
    return {
        type: 21 /* JS_BLOCK_STATEMENT */,
        body,
        loc: locStub
    };
}
function createTemplateLiteral(elements) {
    return {
        type: 22 /* JS_TEMPLATE_LITERAL */,
        elements,
        loc: locStub
    };
}
function createIfStatement(test, consequent, alternate) {
    return {
        type: 23 /* JS_IF_STATEMENT */,
        test,
        consequent,
        alternate,
        loc: locStub
    };
}
function createAssignmentExpression(left, right) {
    return {
        type: 24 /* JS_ASSIGNMENT_EXPRESSION */,
        left,
        right,
        loc: locStub
    };
}
function createSequenceExpression(expressions) {
    return {
        type: 25 /* JS_SEQUENCE_EXPRESSION */,
        expressions,
        loc: locStub
    };
}
function createReturnStatement(returns) {
    return {
        type: 26 /* JS_RETURN_STATEMENT */,
        returns,
        loc: locStub
    };
}

const isStaticExp = (p) => p.type === 4 /* SIMPLE_EXPRESSION */ && p.isStatic;
const isBuiltInType = (tag, expected) => tag === expected || tag === (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hyphenate)(expected);
function isCoreComponent(tag) {
    if (isBuiltInType(tag, 'Teleport')) {
        return TELEPORT;
    }
    else if (isBuiltInType(tag, 'Suspense')) {
        return SUSPENSE;
    }
    else if (isBuiltInType(tag, 'KeepAlive')) {
        return KEEP_ALIVE;
    }
    else if (isBuiltInType(tag, 'BaseTransition')) {
        return BASE_TRANSITION;
    }
}
const nonIdentifierRE = /^\d|[^\$\w]/;
const isSimpleIdentifier = (name) => !nonIdentifierRE.test(name);
const validFirstIdentCharRE = /[A-Za-z_$\xA0-\uFFFF]/;
const validIdentCharRE = /[\.\?\w$\xA0-\uFFFF]/;
const whitespaceRE = /\s+[.[]\s*|\s*[.[]\s+/g;
/**
 * Simple lexer to check if an expression is a member expression. This is
 * lax and only checks validity at the root level (i.e. does not validate exps
 * inside square brackets), but it's ok since these are only used on template
 * expressions and false positives are invalid expressions in the first place.
 */
const isMemberExpressionBrowser = (path) => {
    // remove whitespaces around . or [ first
    path = path.trim().replace(whitespaceRE, s => s.trim());
    let state = 0 /* inMemberExp */;
    let stateStack = [];
    let currentOpenBracketCount = 0;
    let currentOpenParensCount = 0;
    let currentStringType = null;
    for (let i = 0; i < path.length; i++) {
        const char = path.charAt(i);
        switch (state) {
            case 0 /* inMemberExp */:
                if (char === '[') {
                    stateStack.push(state);
                    state = 1 /* inBrackets */;
                    currentOpenBracketCount++;
                }
                else if (char === '(') {
                    stateStack.push(state);
                    state = 2 /* inParens */;
                    currentOpenParensCount++;
                }
                else if (!(i === 0 ? validFirstIdentCharRE : validIdentCharRE).test(char)) {
                    return false;
                }
                break;
            case 1 /* inBrackets */:
                if (char === `'` || char === `"` || char === '`') {
                    stateStack.push(state);
                    state = 3 /* inString */;
                    currentStringType = char;
                }
                else if (char === `[`) {
                    currentOpenBracketCount++;
                }
                else if (char === `]`) {
                    if (!--currentOpenBracketCount) {
                        state = stateStack.pop();
                    }
                }
                break;
            case 2 /* inParens */:
                if (char === `'` || char === `"` || char === '`') {
                    stateStack.push(state);
                    state = 3 /* inString */;
                    currentStringType = char;
                }
                else if (char === `(`) {
                    currentOpenParensCount++;
                }
                else if (char === `)`) {
                    // if the exp ends as a call then it should not be considered valid
                    if (i === path.length - 1) {
                        return false;
                    }
                    if (!--currentOpenParensCount) {
                        state = stateStack.pop();
                    }
                }
                break;
            case 3 /* inString */:
                if (char === currentStringType) {
                    state = stateStack.pop();
                    currentStringType = null;
                }
                break;
        }
    }
    return !currentOpenBracketCount && !currentOpenParensCount;
};
const isMemberExpressionNode = _vue_shared__WEBPACK_IMPORTED_MODULE_0__.NOOP
    ;
const isMemberExpression = isMemberExpressionBrowser
    ;
function getInnerRange(loc, offset, length) {
    const source = loc.source.slice(offset, offset + length);
    const newLoc = {
        source,
        start: advancePositionWithClone(loc.start, loc.source, offset),
        end: loc.end
    };
    if (length != null) {
        newLoc.end = advancePositionWithClone(loc.start, loc.source, offset + length);
    }
    return newLoc;
}
function advancePositionWithClone(pos, source, numberOfCharacters = source.length) {
    return advancePositionWithMutation((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)({}, pos), source, numberOfCharacters);
}
// advance by mutation without cloning (for performance reasons), since this
// gets called a lot in the parser
function advancePositionWithMutation(pos, source, numberOfCharacters = source.length) {
    let linesCount = 0;
    let lastNewLinePos = -1;
    for (let i = 0; i < numberOfCharacters; i++) {
        if (source.charCodeAt(i) === 10 /* newline char code */) {
            linesCount++;
            lastNewLinePos = i;
        }
    }
    pos.offset += numberOfCharacters;
    pos.line += linesCount;
    pos.column =
        lastNewLinePos === -1
            ? pos.column + numberOfCharacters
            : numberOfCharacters - lastNewLinePos;
    return pos;
}
function assert(condition, msg) {
    /* istanbul ignore if */
    if (!condition) {
        throw new Error(msg || `unexpected compiler condition`);
    }
}
function findDir(node, name, allowEmpty = false) {
    for (let i = 0; i < node.props.length; i++) {
        const p = node.props[i];
        if (p.type === 7 /* DIRECTIVE */ &&
            (allowEmpty || p.exp) &&
            ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(name) ? p.name === name : name.test(p.name))) {
            return p;
        }
    }
}
function findProp(node, name, dynamicOnly = false, allowEmpty = false) {
    for (let i = 0; i < node.props.length; i++) {
        const p = node.props[i];
        if (p.type === 6 /* ATTRIBUTE */) {
            if (dynamicOnly)
                continue;
            if (p.name === name && (p.value || allowEmpty)) {
                return p;
            }
        }
        else if (p.name === 'bind' &&
            (p.exp || allowEmpty) &&
            isStaticArgOf(p.arg, name)) {
            return p;
        }
    }
}
function isStaticArgOf(arg, name) {
    return !!(arg && isStaticExp(arg) && arg.content === name);
}
function hasDynamicKeyVBind(node) {
    return node.props.some(p => p.type === 7 /* DIRECTIVE */ &&
        p.name === 'bind' &&
        (!p.arg || // v-bind="obj"
            p.arg.type !== 4 /* SIMPLE_EXPRESSION */ || // v-bind:[_ctx.foo]
            !p.arg.isStatic) // v-bind:[foo]
    );
}
function isText(node) {
    return node.type === 5 /* INTERPOLATION */ || node.type === 2 /* TEXT */;
}
function isVSlot(p) {
    return p.type === 7 /* DIRECTIVE */ && p.name === 'slot';
}
function isTemplateNode(node) {
    return (node.type === 1 /* ELEMENT */ && node.tagType === 3 /* TEMPLATE */);
}
function isSlotOutlet(node) {
    return node.type === 1 /* ELEMENT */ && node.tagType === 2 /* SLOT */;
}
function getVNodeHelper(ssr, isComponent) {
    return ssr || isComponent ? CREATE_VNODE : CREATE_ELEMENT_VNODE;
}
function getVNodeBlockHelper(ssr, isComponent) {
    return ssr || isComponent ? CREATE_BLOCK : CREATE_ELEMENT_BLOCK;
}
const propsHelperSet = new Set([NORMALIZE_PROPS, GUARD_REACTIVE_PROPS]);
function getUnnormalizedProps(props, callPath = []) {
    if (props &&
        !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(props) &&
        props.type === 14 /* JS_CALL_EXPRESSION */) {
        const callee = props.callee;
        if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(callee) && propsHelperSet.has(callee)) {
            return getUnnormalizedProps(props.arguments[0], callPath.concat(props));
        }
    }
    return [props, callPath];
}
function injectProp(node, prop, context) {
    let propsWithInjection;
    /**
     * 1. mergeProps(...)
     * 2. toHandlers(...)
     * 3. normalizeProps(...)
     * 4. normalizeProps(guardReactiveProps(...))
     *
     * we need to get the real props before normalization
     */
    let props = node.type === 13 /* VNODE_CALL */ ? node.props : node.arguments[2];
    let callPath = [];
    let parentCall;
    if (props &&
        !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(props) &&
        props.type === 14 /* JS_CALL_EXPRESSION */) {
        const ret = getUnnormalizedProps(props);
        props = ret[0];
        callPath = ret[1];
        parentCall = callPath[callPath.length - 1];
    }
    if (props == null || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(props)) {
        propsWithInjection = createObjectExpression([prop]);
    }
    else if (props.type === 14 /* JS_CALL_EXPRESSION */) {
        // merged props... add ours
        // only inject key to object literal if it's the first argument so that
        // if doesn't override user provided keys
        const first = props.arguments[0];
        if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(first) && first.type === 15 /* JS_OBJECT_EXPRESSION */) {
            first.properties.unshift(prop);
        }
        else {
            if (props.callee === TO_HANDLERS) {
                // #2366
                propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [
                    createObjectExpression([prop]),
                    props
                ]);
            }
            else {
                props.arguments.unshift(createObjectExpression([prop]));
            }
        }
        !propsWithInjection && (propsWithInjection = props);
    }
    else if (props.type === 15 /* JS_OBJECT_EXPRESSION */) {
        let alreadyExists = false;
        // check existing key to avoid overriding user provided keys
        if (prop.key.type === 4 /* SIMPLE_EXPRESSION */) {
            const propKeyName = prop.key.content;
            alreadyExists = props.properties.some(p => p.key.type === 4 /* SIMPLE_EXPRESSION */ &&
                p.key.content === propKeyName);
        }
        if (!alreadyExists) {
            props.properties.unshift(prop);
        }
        propsWithInjection = props;
    }
    else {
        // single v-bind with expression, return a merged replacement
        propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [
            createObjectExpression([prop]),
            props
        ]);
        // in the case of nested helper call, e.g. `normalizeProps(guardReactiveProps(props))`,
        // it will be rewritten as `normalizeProps(mergeProps({ key: 0 }, props))`,
        // the `guardReactiveProps` will no longer be needed
        if (parentCall && parentCall.callee === GUARD_REACTIVE_PROPS) {
            parentCall = callPath[callPath.length - 2];
        }
    }
    if (node.type === 13 /* VNODE_CALL */) {
        if (parentCall) {
            parentCall.arguments[0] = propsWithInjection;
        }
        else {
            node.props = propsWithInjection;
        }
    }
    else {
        if (parentCall) {
            parentCall.arguments[0] = propsWithInjection;
        }
        else {
            node.arguments[2] = propsWithInjection;
        }
    }
}
function toValidAssetId(name, type) {
    // see issue#4422, we need adding identifier on validAssetId if variable `name` has specific character
    return `_${type}_${name.replace(/[^\w]/g, (searchValue, replaceValue) => {
        return searchValue === '-' ? '_' : name.charCodeAt(replaceValue).toString();
    })}`;
}
// Check if a node contains expressions that reference current context scope ids
function hasScopeRef(node, ids) {
    if (!node || Object.keys(ids).length === 0) {
        return false;
    }
    switch (node.type) {
        case 1 /* ELEMENT */:
            for (let i = 0; i < node.props.length; i++) {
                const p = node.props[i];
                if (p.type === 7 /* DIRECTIVE */ &&
                    (hasScopeRef(p.arg, ids) || hasScopeRef(p.exp, ids))) {
                    return true;
                }
            }
            return node.children.some(c => hasScopeRef(c, ids));
        case 11 /* FOR */:
            if (hasScopeRef(node.source, ids)) {
                return true;
            }
            return node.children.some(c => hasScopeRef(c, ids));
        case 9 /* IF */:
            return node.branches.some(b => hasScopeRef(b, ids));
        case 10 /* IF_BRANCH */:
            if (hasScopeRef(node.condition, ids)) {
                return true;
            }
            return node.children.some(c => hasScopeRef(c, ids));
        case 4 /* SIMPLE_EXPRESSION */:
            return (!node.isStatic &&
                isSimpleIdentifier(node.content) &&
                !!ids[node.content]);
        case 8 /* COMPOUND_EXPRESSION */:
            return node.children.some(c => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(c) && hasScopeRef(c, ids));
        case 5 /* INTERPOLATION */:
        case 12 /* TEXT_CALL */:
            return hasScopeRef(node.content, ids);
        case 2 /* TEXT */:
        case 3 /* COMMENT */:
            return false;
        default:
            if ((true)) ;
            return false;
    }
}
function getMemoedVNodeCall(node) {
    if (node.type === 14 /* JS_CALL_EXPRESSION */ && node.callee === WITH_MEMO) {
        return node.arguments[1].returns;
    }
    else {
        return node;
    }
}
function makeBlock(node, { helper, removeHelper, inSSR }) {
    if (!node.isBlock) {
        node.isBlock = true;
        removeHelper(getVNodeHelper(inSSR, node.isComponent));
        helper(OPEN_BLOCK);
        helper(getVNodeBlockHelper(inSSR, node.isComponent));
    }
}

const deprecationData = {
    ["COMPILER_IS_ON_ELEMENT" /* COMPILER_IS_ON_ELEMENT */]: {
        message: `Platform-native elements with "is" prop will no longer be ` +
            `treated as components in Vue 3 unless the "is" value is explicitly ` +
            `prefixed with "vue:".`,
        link: `https://v3-migration.vuejs.org/breaking-changes/custom-elements-interop.html`
    },
    ["COMPILER_V_BIND_SYNC" /* COMPILER_V_BIND_SYNC */]: {
        message: key => `.sync modifier for v-bind has been removed. Use v-model with ` +
            `argument instead. \`v-bind:${key}.sync\` should be changed to ` +
            `\`v-model:${key}\`.`,
        link: `https://v3-migration.vuejs.org/breaking-changes/v-model.html`
    },
    ["COMPILER_V_BIND_PROP" /* COMPILER_V_BIND_PROP */]: {
        message: `.prop modifier for v-bind has been removed and no longer necessary. ` +
            `Vue 3 will automatically set a binding as DOM property when appropriate.`
    },
    ["COMPILER_V_BIND_OBJECT_ORDER" /* COMPILER_V_BIND_OBJECT_ORDER */]: {
        message: `v-bind="obj" usage is now order sensitive and behaves like JavaScript ` +
            `object spread: it will now overwrite an existing non-mergeable attribute ` +
            `that appears before v-bind in the case of conflict. ` +
            `To retain 2.x behavior, move v-bind to make it the first attribute. ` +
            `You can also suppress this warning if the usage is intended.`,
        link: `https://v3-migration.vuejs.org/breaking-changes/v-bind.html`
    },
    ["COMPILER_V_ON_NATIVE" /* COMPILER_V_ON_NATIVE */]: {
        message: `.native modifier for v-on has been removed as is no longer necessary.`,
        link: `https://v3-migration.vuejs.org/breaking-changes/v-on-native-modifier-removed.html`
    },
    ["COMPILER_V_IF_V_FOR_PRECEDENCE" /* COMPILER_V_IF_V_FOR_PRECEDENCE */]: {
        message: `v-if / v-for precedence when used on the same element has changed ` +
            `in Vue 3: v-if now takes higher precedence and will no longer have ` +
            `access to v-for scope variables. It is best to avoid the ambiguity ` +
            `with <template> tags or use a computed property that filters v-for ` +
            `data source.`,
        link: `https://v3-migration.vuejs.org/breaking-changes/v-if-v-for.html`
    },
    ["COMPILER_NATIVE_TEMPLATE" /* COMPILER_NATIVE_TEMPLATE */]: {
        message: `<template> with no special directives will render as a native template ` +
            `element instead of its inner content in Vue 3.`
    },
    ["COMPILER_INLINE_TEMPLATE" /* COMPILER_INLINE_TEMPLATE */]: {
        message: `"inline-template" has been removed in Vue 3.`,
        link: `https://v3-migration.vuejs.org/breaking-changes/inline-template-attribute.html`
    },
    ["COMPILER_FILTER" /* COMPILER_FILTERS */]: {
        message: `filters have been removed in Vue 3. ` +
            `The "|" symbol will be treated as native JavaScript bitwise OR operator. ` +
            `Use method calls or computed properties instead.`,
        link: `https://v3-migration.vuejs.org/breaking-changes/filters.html`
    }
};
function getCompatValue(key, context) {
    const config = context.options
        ? context.options.compatConfig
        : context.compatConfig;
    const value = config && config[key];
    if (key === 'MODE') {
        return value || 3; // compiler defaults to v3 behavior
    }
    else {
        return value;
    }
}
function isCompatEnabled(key, context) {
    const mode = getCompatValue('MODE', context);
    const value = getCompatValue(key, context);
    // in v3 mode, only enable if explicitly set to true
    // otherwise enable for any non-false value
    return mode === 3 ? value === true : value !== false;
}
function checkCompatEnabled(key, context, loc, ...args) {
    const enabled = isCompatEnabled(key, context);
    if (( true) && enabled) {
        warnDeprecation(key, context, loc, ...args);
    }
    return enabled;
}
function warnDeprecation(key, context, loc, ...args) {
    const val = getCompatValue(key, context);
    if (val === 'suppress-warning') {
        return;
    }
    const { message, link } = deprecationData[key];
    const msg = `(deprecation ${key}) ${typeof message === 'function' ? message(...args) : message}${link ? `\n  Details: ${link}` : ``}`;
    const err = new SyntaxError(msg);
    err.code = key;
    if (loc)
        err.loc = loc;
    context.onWarn(err);
}

// The default decoder only provides escapes for characters reserved as part of
// the template syntax, and is only used if the custom renderer did not provide
// a platform-specific decoder.
const decodeRE = /&(gt|lt|amp|apos|quot);/g;
const decodeMap = {
    gt: '>',
    lt: '<',
    amp: '&',
    apos: "'",
    quot: '"'
};
const defaultParserOptions = {
    delimiters: [`{{`, `}}`],
    getNamespace: () => 0 /* HTML */,
    getTextMode: () => 0 /* DATA */,
    isVoidTag: _vue_shared__WEBPACK_IMPORTED_MODULE_0__.NO,
    isPreTag: _vue_shared__WEBPACK_IMPORTED_MODULE_0__.NO,
    isCustomElement: _vue_shared__WEBPACK_IMPORTED_MODULE_0__.NO,
    decodeEntities: (rawText) => rawText.replace(decodeRE, (_, p1) => decodeMap[p1]),
    onError: defaultOnError,
    onWarn: defaultOnWarn,
    comments: ("development" !== 'production')
};
function baseParse(content, options = {}) {
    const context = createParserContext(content, options);
    const start = getCursor(context);
    return createRoot(parseChildren(context, 0 /* DATA */, []), getSelection(context, start));
}
function createParserContext(content, rawOptions) {
    const options = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)({}, defaultParserOptions);
    let key;
    for (key in rawOptions) {
        // @ts-ignore
        options[key] =
            rawOptions[key] === undefined
                ? defaultParserOptions[key]
                : rawOptions[key];
    }
    return {
        options,
        column: 1,
        line: 1,
        offset: 0,
        originalSource: content,
        source: content,
        inPre: false,
        inVPre: false,
        onWarn: options.onWarn
    };
}
function parseChildren(context, mode, ancestors) {
    const parent = last(ancestors);
    const ns = parent ? parent.ns : 0 /* HTML */;
    const nodes = [];
    while (!isEnd(context, mode, ancestors)) {
        const s = context.source;
        let node = undefined;
        if (mode === 0 /* DATA */ || mode === 1 /* RCDATA */) {
            if (!context.inVPre && startsWith(s, context.options.delimiters[0])) {
                // '{{'
                node = parseInterpolation(context, mode);
            }
            else if (mode === 0 /* DATA */ && s[0] === '<') {
                // https://html.spec.whatwg.org/multipage/parsing.html#tag-open-state
                if (s.length === 1) {
                    emitError(context, 5 /* EOF_BEFORE_TAG_NAME */, 1);
                }
                else if (s[1] === '!') {
                    // https://html.spec.whatwg.org/multipage/parsing.html#markup-declaration-open-state
                    if (startsWith(s, '<!--')) {
                        node = parseComment(context);
                    }
                    else if (startsWith(s, '<!DOCTYPE')) {
                        // Ignore DOCTYPE by a limitation.
                        node = parseBogusComment(context);
                    }
                    else if (startsWith(s, '<![CDATA[')) {
                        if (ns !== 0 /* HTML */) {
                            node = parseCDATA(context, ancestors);
                        }
                        else {
                            emitError(context, 1 /* CDATA_IN_HTML_CONTENT */);
                            node = parseBogusComment(context);
                        }
                    }
                    else {
                        emitError(context, 11 /* INCORRECTLY_OPENED_COMMENT */);
                        node = parseBogusComment(context);
                    }
                }
                else if (s[1] === '/') {
                    // https://html.spec.whatwg.org/multipage/parsing.html#end-tag-open-state
                    if (s.length === 2) {
                        emitError(context, 5 /* EOF_BEFORE_TAG_NAME */, 2);
                    }
                    else if (s[2] === '>') {
                        emitError(context, 14 /* MISSING_END_TAG_NAME */, 2);
                        advanceBy(context, 3);
                        continue;
                    }
                    else if (/[a-z]/i.test(s[2])) {
                        emitError(context, 23 /* X_INVALID_END_TAG */);
                        parseTag(context, 1 /* End */, parent);
                        continue;
                    }
                    else {
                        emitError(context, 12 /* INVALID_FIRST_CHARACTER_OF_TAG_NAME */, 2);
                        node = parseBogusComment(context);
                    }
                }
                else if (/[a-z]/i.test(s[1])) {
                    node = parseElement(context, ancestors);
                    // 2.x <template> with no directive compat
                    if (isCompatEnabled("COMPILER_NATIVE_TEMPLATE" /* COMPILER_NATIVE_TEMPLATE */, context) &&
                        node &&
                        node.tag === 'template' &&
                        !node.props.some(p => p.type === 7 /* DIRECTIVE */ &&
                            isSpecialTemplateDirective(p.name))) {
                        ( true) &&
                            warnDeprecation("COMPILER_NATIVE_TEMPLATE" /* COMPILER_NATIVE_TEMPLATE */, context, node.loc);
                        node = node.children;
                    }
                }
                else if (s[1] === '?') {
                    emitError(context, 21 /* UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME */, 1);
                    node = parseBogusComment(context);
                }
                else {
                    emitError(context, 12 /* INVALID_FIRST_CHARACTER_OF_TAG_NAME */, 1);
                }
            }
        }
        if (!node) {
            node = parseText(context, mode);
        }
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(node)) {
            for (let i = 0; i < node.length; i++) {
                pushNode(nodes, node[i]);
            }
        }
        else {
            pushNode(nodes, node);
        }
    }
    // Whitespace handling strategy like v2
    let removedWhitespace = false;
    if (mode !== 2 /* RAWTEXT */ && mode !== 1 /* RCDATA */) {
        const shouldCondense = context.options.whitespace !== 'preserve';
        for (let i = 0; i < nodes.length; i++) {
            const node = nodes[i];
            if (!context.inPre && node.type === 2 /* TEXT */) {
                if (!/[^\t\r\n\f ]/.test(node.content)) {
                    const prev = nodes[i - 1];
                    const next = nodes[i + 1];
                    // Remove if:
                    // - the whitespace is the first or last node, or:
                    // - (condense mode) the whitespace is adjacent to a comment, or:
                    // - (condense mode) the whitespace is between two elements AND contains newline
                    if (!prev ||
                        !next ||
                        (shouldCondense &&
                            (prev.type === 3 /* COMMENT */ ||
                                next.type === 3 /* COMMENT */ ||
                                (prev.type === 1 /* ELEMENT */ &&
                                    next.type === 1 /* ELEMENT */ &&
                                    /[\r\n]/.test(node.content))))) {
                        removedWhitespace = true;
                        nodes[i] = null;
                    }
                    else {
                        // Otherwise, the whitespace is condensed into a single space
                        node.content = ' ';
                    }
                }
                else if (shouldCondense) {
                    // in condense mode, consecutive whitespaces in text are condensed
                    // down to a single space.
                    node.content = node.content.replace(/[\t\r\n\f ]+/g, ' ');
                }
            }
            // Remove comment nodes if desired by configuration.
            else if (node.type === 3 /* COMMENT */ && !context.options.comments) {
                removedWhitespace = true;
                nodes[i] = null;
            }
        }
        if (context.inPre && parent && context.options.isPreTag(parent.tag)) {
            // remove leading newline per html spec
            // https://html.spec.whatwg.org/multipage/grouping-content.html#the-pre-element
            const first = nodes[0];
            if (first && first.type === 2 /* TEXT */) {
                first.content = first.content.replace(/^\r?\n/, '');
            }
        }
    }
    return removedWhitespace ? nodes.filter(Boolean) : nodes;
}
function pushNode(nodes, node) {
    if (node.type === 2 /* TEXT */) {
        const prev = last(nodes);
        // Merge if both this and the previous node are text and those are
        // consecutive. This happens for cases like "a < b".
        if (prev &&
            prev.type === 2 /* TEXT */ &&
            prev.loc.end.offset === node.loc.start.offset) {
            prev.content += node.content;
            prev.loc.end = node.loc.end;
            prev.loc.source += node.loc.source;
            return;
        }
    }
    nodes.push(node);
}
function parseCDATA(context, ancestors) {
    advanceBy(context, 9);
    const nodes = parseChildren(context, 3 /* CDATA */, ancestors);
    if (context.source.length === 0) {
        emitError(context, 6 /* EOF_IN_CDATA */);
    }
    else {
        advanceBy(context, 3);
    }
    return nodes;
}
function parseComment(context) {
    const start = getCursor(context);
    let content;
    // Regular comment.
    const match = /--(\!)?>/.exec(context.source);
    if (!match) {
        content = context.source.slice(4);
        advanceBy(context, context.source.length);
        emitError(context, 7 /* EOF_IN_COMMENT */);
    }
    else {
        if (match.index <= 3) {
            emitError(context, 0 /* ABRUPT_CLOSING_OF_EMPTY_COMMENT */);
        }
        if (match[1]) {
            emitError(context, 10 /* INCORRECTLY_CLOSED_COMMENT */);
        }
        content = context.source.slice(4, match.index);
        // Advancing with reporting nested comments.
        const s = context.source.slice(0, match.index);
        let prevIndex = 1, nestedIndex = 0;
        while ((nestedIndex = s.indexOf('<!--', prevIndex)) !== -1) {
            advanceBy(context, nestedIndex - prevIndex + 1);
            if (nestedIndex + 4 < s.length) {
                emitError(context, 16 /* NESTED_COMMENT */);
            }
            prevIndex = nestedIndex + 1;
        }
        advanceBy(context, match.index + match[0].length - prevIndex + 1);
    }
    return {
        type: 3 /* COMMENT */,
        content,
        loc: getSelection(context, start)
    };
}
function parseBogusComment(context) {
    const start = getCursor(context);
    const contentStart = context.source[1] === '?' ? 1 : 2;
    let content;
    const closeIndex = context.source.indexOf('>');
    if (closeIndex === -1) {
        content = context.source.slice(contentStart);
        advanceBy(context, context.source.length);
    }
    else {
        content = context.source.slice(contentStart, closeIndex);
        advanceBy(context, closeIndex + 1);
    }
    return {
        type: 3 /* COMMENT */,
        content,
        loc: getSelection(context, start)
    };
}
function parseElement(context, ancestors) {
    // Start tag.
    const wasInPre = context.inPre;
    const wasInVPre = context.inVPre;
    const parent = last(ancestors);
    const element = parseTag(context, 0 /* Start */, parent);
    const isPreBoundary = context.inPre && !wasInPre;
    const isVPreBoundary = context.inVPre && !wasInVPre;
    if (element.isSelfClosing || context.options.isVoidTag(element.tag)) {
        // #4030 self-closing <pre> tag
        if (isPreBoundary) {
            context.inPre = false;
        }
        if (isVPreBoundary) {
            context.inVPre = false;
        }
        return element;
    }
    // Children.
    ancestors.push(element);
    const mode = context.options.getTextMode(element, parent);
    const children = parseChildren(context, mode, ancestors);
    ancestors.pop();
    // 2.x inline-template compat
    {
        const inlineTemplateProp = element.props.find(p => p.type === 6 /* ATTRIBUTE */ && p.name === 'inline-template');
        if (inlineTemplateProp &&
            checkCompatEnabled("COMPILER_INLINE_TEMPLATE" /* COMPILER_INLINE_TEMPLATE */, context, inlineTemplateProp.loc)) {
            const loc = getSelection(context, element.loc.end);
            inlineTemplateProp.value = {
                type: 2 /* TEXT */,
                content: loc.source,
                loc
            };
        }
    }
    element.children = children;
    // End tag.
    if (startsWithEndTagOpen(context.source, element.tag)) {
        parseTag(context, 1 /* End */, parent);
    }
    else {
        emitError(context, 24 /* X_MISSING_END_TAG */, 0, element.loc.start);
        if (context.source.length === 0 && element.tag.toLowerCase() === 'script') {
            const first = children[0];
            if (first && startsWith(first.loc.source, '<!--')) {
                emitError(context, 8 /* EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT */);
            }
        }
    }
    element.loc = getSelection(context, element.loc.start);
    if (isPreBoundary) {
        context.inPre = false;
    }
    if (isVPreBoundary) {
        context.inVPre = false;
    }
    return element;
}
const isSpecialTemplateDirective = /*#__PURE__*/ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.makeMap)(`if,else,else-if,for,slot`);
function parseTag(context, type, parent) {
    // Tag open.
    const start = getCursor(context);
    const match = /^<\/?([a-z][^\t\r\n\f />]*)/i.exec(context.source);
    const tag = match[1];
    const ns = context.options.getNamespace(tag, parent);
    advanceBy(context, match[0].length);
    advanceSpaces(context);
    // save current state in case we need to re-parse attributes with v-pre
    const cursor = getCursor(context);
    const currentSource = context.source;
    // check <pre> tag
    if (context.options.isPreTag(tag)) {
        context.inPre = true;
    }
    // Attributes.
    let props = parseAttributes(context, type);
    // check v-pre
    if (type === 0 /* Start */ &&
        !context.inVPre &&
        props.some(p => p.type === 7 /* DIRECTIVE */ && p.name === 'pre')) {
        context.inVPre = true;
        // reset context
        (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)(context, cursor);
        context.source = currentSource;
        // re-parse attrs and filter out v-pre itself
        props = parseAttributes(context, type).filter(p => p.name !== 'v-pre');
    }
    // Tag close.
    let isSelfClosing = false;
    if (context.source.length === 0) {
        emitError(context, 9 /* EOF_IN_TAG */);
    }
    else {
        isSelfClosing = startsWith(context.source, '/>');
        if (type === 1 /* End */ && isSelfClosing) {
            emitError(context, 4 /* END_TAG_WITH_TRAILING_SOLIDUS */);
        }
        advanceBy(context, isSelfClosing ? 2 : 1);
    }
    if (type === 1 /* End */) {
        return;
    }
    // 2.x deprecation checks
    if (( true) &&
        isCompatEnabled("COMPILER_V_IF_V_FOR_PRECEDENCE" /* COMPILER_V_IF_V_FOR_PRECEDENCE */, context)) {
        let hasIf = false;
        let hasFor = false;
        for (let i = 0; i < props.length; i++) {
            const p = props[i];
            if (p.type === 7 /* DIRECTIVE */) {
                if (p.name === 'if') {
                    hasIf = true;
                }
                else if (p.name === 'for') {
                    hasFor = true;
                }
            }
            if (hasIf && hasFor) {
                warnDeprecation("COMPILER_V_IF_V_FOR_PRECEDENCE" /* COMPILER_V_IF_V_FOR_PRECEDENCE */, context, getSelection(context, start));
                break;
            }
        }
    }
    let tagType = 0 /* ELEMENT */;
    if (!context.inVPre) {
        if (tag === 'slot') {
            tagType = 2 /* SLOT */;
        }
        else if (tag === 'template') {
            if (props.some(p => p.type === 7 /* DIRECTIVE */ && isSpecialTemplateDirective(p.name))) {
                tagType = 3 /* TEMPLATE */;
            }
        }
        else if (isComponent(tag, props, context)) {
            tagType = 1 /* COMPONENT */;
        }
    }
    return {
        type: 1 /* ELEMENT */,
        ns,
        tag,
        tagType,
        props,
        isSelfClosing,
        children: [],
        loc: getSelection(context, start),
        codegenNode: undefined // to be created during transform phase
    };
}
function isComponent(tag, props, context) {
    const options = context.options;
    if (options.isCustomElement(tag)) {
        return false;
    }
    if (tag === 'component' ||
        /^[A-Z]/.test(tag) ||
        isCoreComponent(tag) ||
        (options.isBuiltInComponent && options.isBuiltInComponent(tag)) ||
        (options.isNativeTag && !options.isNativeTag(tag))) {
        return true;
    }
    // at this point the tag should be a native tag, but check for potential "is"
    // casting
    for (let i = 0; i < props.length; i++) {
        const p = props[i];
        if (p.type === 6 /* ATTRIBUTE */) {
            if (p.name === 'is' && p.value) {
                if (p.value.content.startsWith('vue:')) {
                    return true;
                }
                else if (checkCompatEnabled("COMPILER_IS_ON_ELEMENT" /* COMPILER_IS_ON_ELEMENT */, context, p.loc)) {
                    return true;
                }
            }
        }
        else {
            // directive
            // v-is (TODO Deprecate)
            if (p.name === 'is') {
                return true;
            }
            else if (
            // :is on plain element - only treat as component in compat mode
            p.name === 'bind' &&
                isStaticArgOf(p.arg, 'is') &&
                true &&
                checkCompatEnabled("COMPILER_IS_ON_ELEMENT" /* COMPILER_IS_ON_ELEMENT */, context, p.loc)) {
                return true;
            }
        }
    }
}
function parseAttributes(context, type) {
    const props = [];
    const attributeNames = new Set();
    while (context.source.length > 0 &&
        !startsWith(context.source, '>') &&
        !startsWith(context.source, '/>')) {
        if (startsWith(context.source, '/')) {
            emitError(context, 22 /* UNEXPECTED_SOLIDUS_IN_TAG */);
            advanceBy(context, 1);
            advanceSpaces(context);
            continue;
        }
        if (type === 1 /* End */) {
            emitError(context, 3 /* END_TAG_WITH_ATTRIBUTES */);
        }
        const attr = parseAttribute(context, attributeNames);
        // Trim whitespace between class
        // https://github.com/vuejs/core/issues/4251
        if (attr.type === 6 /* ATTRIBUTE */ &&
            attr.value &&
            attr.name === 'class') {
            attr.value.content = attr.value.content.replace(/\s+/g, ' ').trim();
        }
        if (type === 0 /* Start */) {
            props.push(attr);
        }
        if (/^[^\t\r\n\f />]/.test(context.source)) {
            emitError(context, 15 /* MISSING_WHITESPACE_BETWEEN_ATTRIBUTES */);
        }
        advanceSpaces(context);
    }
    return props;
}
function parseAttribute(context, nameSet) {
    // Name.
    const start = getCursor(context);
    const match = /^[^\t\r\n\f />][^\t\r\n\f />=]*/.exec(context.source);
    const name = match[0];
    if (nameSet.has(name)) {
        emitError(context, 2 /* DUPLICATE_ATTRIBUTE */);
    }
    nameSet.add(name);
    if (name[0] === '=') {
        emitError(context, 19 /* UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME */);
    }
    {
        const pattern = /["'<]/g;
        let m;
        while ((m = pattern.exec(name))) {
            emitError(context, 17 /* UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME */, m.index);
        }
    }
    advanceBy(context, name.length);
    // Value
    let value = undefined;
    if (/^[\t\r\n\f ]*=/.test(context.source)) {
        advanceSpaces(context);
        advanceBy(context, 1);
        advanceSpaces(context);
        value = parseAttributeValue(context);
        if (!value) {
            emitError(context, 13 /* MISSING_ATTRIBUTE_VALUE */);
        }
    }
    const loc = getSelection(context, start);
    if (!context.inVPre && /^(v-[A-Za-z0-9-]|:|\.|@|#)/.test(name)) {
        const match = /(?:^v-([a-z0-9-]+))?(?:(?::|^\.|^@|^#)(\[[^\]]+\]|[^\.]+))?(.+)?$/i.exec(name);
        let isPropShorthand = startsWith(name, '.');
        let dirName = match[1] ||
            (isPropShorthand || startsWith(name, ':')
                ? 'bind'
                : startsWith(name, '@')
                    ? 'on'
                    : 'slot');
        let arg;
        if (match[2]) {
            const isSlot = dirName === 'slot';
            const startOffset = name.lastIndexOf(match[2]);
            const loc = getSelection(context, getNewPosition(context, start, startOffset), getNewPosition(context, start, startOffset + match[2].length + ((isSlot && match[3]) || '').length));
            let content = match[2];
            let isStatic = true;
            if (content.startsWith('[')) {
                isStatic = false;
                if (!content.endsWith(']')) {
                    emitError(context, 27 /* X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END */);
                    content = content.slice(1);
                }
                else {
                    content = content.slice(1, content.length - 1);
                }
            }
            else if (isSlot) {
                // #1241 special case for v-slot: vuetify relies extensively on slot
                // names containing dots. v-slot doesn't have any modifiers and Vue 2.x
                // supports such usage so we are keeping it consistent with 2.x.
                content += match[3] || '';
            }
            arg = {
                type: 4 /* SIMPLE_EXPRESSION */,
                content,
                isStatic,
                constType: isStatic
                    ? 3 /* CAN_STRINGIFY */
                    : 0 /* NOT_CONSTANT */,
                loc
            };
        }
        if (value && value.isQuoted) {
            const valueLoc = value.loc;
            valueLoc.start.offset++;
            valueLoc.start.column++;
            valueLoc.end = advancePositionWithClone(valueLoc.start, value.content);
            valueLoc.source = valueLoc.source.slice(1, -1);
        }
        const modifiers = match[3] ? match[3].slice(1).split('.') : [];
        if (isPropShorthand)
            modifiers.push('prop');
        // 2.x compat v-bind:foo.sync -> v-model:foo
        if (dirName === 'bind' && arg) {
            if (modifiers.includes('sync') &&
                checkCompatEnabled("COMPILER_V_BIND_SYNC" /* COMPILER_V_BIND_SYNC */, context, loc, arg.loc.source)) {
                dirName = 'model';
                modifiers.splice(modifiers.indexOf('sync'), 1);
            }
            if (( true) && modifiers.includes('prop')) {
                checkCompatEnabled("COMPILER_V_BIND_PROP" /* COMPILER_V_BIND_PROP */, context, loc);
            }
        }
        return {
            type: 7 /* DIRECTIVE */,
            name: dirName,
            exp: value && {
                type: 4 /* SIMPLE_EXPRESSION */,
                content: value.content,
                isStatic: false,
                // Treat as non-constant by default. This can be potentially set to
                // other values by `transformExpression` to make it eligible for hoisting.
                constType: 0 /* NOT_CONSTANT */,
                loc: value.loc
            },
            arg,
            modifiers,
            loc
        };
    }
    // missing directive name or illegal directive name
    if (!context.inVPre && startsWith(name, 'v-')) {
        emitError(context, 26 /* X_MISSING_DIRECTIVE_NAME */);
    }
    return {
        type: 6 /* ATTRIBUTE */,
        name,
        value: value && {
            type: 2 /* TEXT */,
            content: value.content,
            loc: value.loc
        },
        loc
    };
}
function parseAttributeValue(context) {
    const start = getCursor(context);
    let content;
    const quote = context.source[0];
    const isQuoted = quote === `"` || quote === `'`;
    if (isQuoted) {
        // Quoted value.
        advanceBy(context, 1);
        const endIndex = context.source.indexOf(quote);
        if (endIndex === -1) {
            content = parseTextData(context, context.source.length, 4 /* ATTRIBUTE_VALUE */);
        }
        else {
            content = parseTextData(context, endIndex, 4 /* ATTRIBUTE_VALUE */);
            advanceBy(context, 1);
        }
    }
    else {
        // Unquoted
        const match = /^[^\t\r\n\f >]+/.exec(context.source);
        if (!match) {
            return undefined;
        }
        const unexpectedChars = /["'<=`]/g;
        let m;
        while ((m = unexpectedChars.exec(match[0]))) {
            emitError(context, 18 /* UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE */, m.index);
        }
        content = parseTextData(context, match[0].length, 4 /* ATTRIBUTE_VALUE */);
    }
    return { content, isQuoted, loc: getSelection(context, start) };
}
function parseInterpolation(context, mode) {
    const [open, close] = context.options.delimiters;
    const closeIndex = context.source.indexOf(close, open.length);
    if (closeIndex === -1) {
        emitError(context, 25 /* X_MISSING_INTERPOLATION_END */);
        return undefined;
    }
    const start = getCursor(context);
    advanceBy(context, open.length);
    const innerStart = getCursor(context);
    const innerEnd = getCursor(context);
    const rawContentLength = closeIndex - open.length;
    const rawContent = context.source.slice(0, rawContentLength);
    const preTrimContent = parseTextData(context, rawContentLength, mode);
    const content = preTrimContent.trim();
    const startOffset = preTrimContent.indexOf(content);
    if (startOffset > 0) {
        advancePositionWithMutation(innerStart, rawContent, startOffset);
    }
    const endOffset = rawContentLength - (preTrimContent.length - content.length - startOffset);
    advancePositionWithMutation(innerEnd, rawContent, endOffset);
    advanceBy(context, close.length);
    return {
        type: 5 /* INTERPOLATION */,
        content: {
            type: 4 /* SIMPLE_EXPRESSION */,
            isStatic: false,
            // Set `isConstant` to false by default and will decide in transformExpression
            constType: 0 /* NOT_CONSTANT */,
            content,
            loc: getSelection(context, innerStart, innerEnd)
        },
        loc: getSelection(context, start)
    };
}
function parseText(context, mode) {
    const endTokens = mode === 3 /* CDATA */ ? [']]>'] : ['<', context.options.delimiters[0]];
    let endIndex = context.source.length;
    for (let i = 0; i < endTokens.length; i++) {
        const index = context.source.indexOf(endTokens[i], 1);
        if (index !== -1 && endIndex > index) {
            endIndex = index;
        }
    }
    const start = getCursor(context);
    const content = parseTextData(context, endIndex, mode);
    return {
        type: 2 /* TEXT */,
        content,
        loc: getSelection(context, start)
    };
}
/**
 * Get text data with a given length from the current location.
 * This translates HTML entities in the text data.
 */
function parseTextData(context, length, mode) {
    const rawText = context.source.slice(0, length);
    advanceBy(context, length);
    if (mode === 2 /* RAWTEXT */ ||
        mode === 3 /* CDATA */ ||
        !rawText.includes('&')) {
        return rawText;
    }
    else {
        // DATA or RCDATA containing "&"". Entity decoding required.
        return context.options.decodeEntities(rawText, mode === 4 /* ATTRIBUTE_VALUE */);
    }
}
function getCursor(context) {
    const { column, line, offset } = context;
    return { column, line, offset };
}
function getSelection(context, start, end) {
    end = end || getCursor(context);
    return {
        start,
        end,
        source: context.originalSource.slice(start.offset, end.offset)
    };
}
function last(xs) {
    return xs[xs.length - 1];
}
function startsWith(source, searchString) {
    return source.startsWith(searchString);
}
function advanceBy(context, numberOfCharacters) {
    const { source } = context;
    advancePositionWithMutation(context, source, numberOfCharacters);
    context.source = source.slice(numberOfCharacters);
}
function advanceSpaces(context) {
    const match = /^[\t\r\n\f ]+/.exec(context.source);
    if (match) {
        advanceBy(context, match[0].length);
    }
}
function getNewPosition(context, start, numberOfCharacters) {
    return advancePositionWithClone(start, context.originalSource.slice(start.offset, numberOfCharacters), numberOfCharacters);
}
function emitError(context, code, offset, loc = getCursor(context)) {
    if (offset) {
        loc.offset += offset;
        loc.column += offset;
    }
    context.options.onError(createCompilerError(code, {
        start: loc,
        end: loc,
        source: ''
    }));
}
function isEnd(context, mode, ancestors) {
    const s = context.source;
    switch (mode) {
        case 0 /* DATA */:
            if (startsWith(s, '</')) {
                // TODO: probably bad performance
                for (let i = ancestors.length - 1; i >= 0; --i) {
                    if (startsWithEndTagOpen(s, ancestors[i].tag)) {
                        return true;
                    }
                }
            }
            break;
        case 1 /* RCDATA */:
        case 2 /* RAWTEXT */: {
            const parent = last(ancestors);
            if (parent && startsWithEndTagOpen(s, parent.tag)) {
                return true;
            }
            break;
        }
        case 3 /* CDATA */:
            if (startsWith(s, ']]>')) {
                return true;
            }
            break;
    }
    return !s;
}
function startsWithEndTagOpen(source, tag) {
    return (startsWith(source, '</') &&
        source.slice(2, 2 + tag.length).toLowerCase() === tag.toLowerCase() &&
        /[\t\r\n\f />]/.test(source[2 + tag.length] || '>'));
}

function hoistStatic(root, context) {
    walk(root, context, 
    // Root node is unfortunately non-hoistable due to potential parent
    // fallthrough attributes.
    isSingleElementRoot(root, root.children[0]));
}
function isSingleElementRoot(root, child) {
    const { children } = root;
    return (children.length === 1 &&
        child.type === 1 /* ELEMENT */ &&
        !isSlotOutlet(child));
}
function walk(node, context, doNotHoistNode = false) {
    const { children } = node;
    const originalCount = children.length;
    let hoistedCount = 0;
    for (let i = 0; i < children.length; i++) {
        const child = children[i];
        // only plain elements & text calls are eligible for hoisting.
        if (child.type === 1 /* ELEMENT */ &&
            child.tagType === 0 /* ELEMENT */) {
            const constantType = doNotHoistNode
                ? 0 /* NOT_CONSTANT */
                : getConstantType(child, context);
            if (constantType > 0 /* NOT_CONSTANT */) {
                if (constantType >= 2 /* CAN_HOIST */) {
                    child.codegenNode.patchFlag =
                        -1 /* HOISTED */ + (( true) ? ` /* HOISTED */` : 0);
                    child.codegenNode = context.hoist(child.codegenNode);
                    hoistedCount++;
                    continue;
                }
            }
            else {
                // node may contain dynamic children, but its props may be eligible for
                // hoisting.
                const codegenNode = child.codegenNode;
                if (codegenNode.type === 13 /* VNODE_CALL */) {
                    const flag = getPatchFlag(codegenNode);
                    if ((!flag ||
                        flag === 512 /* NEED_PATCH */ ||
                        flag === 1 /* TEXT */) &&
                        getGeneratedPropsConstantType(child, context) >=
                            2 /* CAN_HOIST */) {
                        const props = getNodeProps(child);
                        if (props) {
                            codegenNode.props = context.hoist(props);
                        }
                    }
                    if (codegenNode.dynamicProps) {
                        codegenNode.dynamicProps = context.hoist(codegenNode.dynamicProps);
                    }
                }
            }
        }
        else if (child.type === 12 /* TEXT_CALL */ &&
            getConstantType(child.content, context) >= 2 /* CAN_HOIST */) {
            child.codegenNode = context.hoist(child.codegenNode);
            hoistedCount++;
        }
        // walk further
        if (child.type === 1 /* ELEMENT */) {
            const isComponent = child.tagType === 1 /* COMPONENT */;
            if (isComponent) {
                context.scopes.vSlot++;
            }
            walk(child, context);
            if (isComponent) {
                context.scopes.vSlot--;
            }
        }
        else if (child.type === 11 /* FOR */) {
            // Do not hoist v-for single child because it has to be a block
            walk(child, context, child.children.length === 1);
        }
        else if (child.type === 9 /* IF */) {
            for (let i = 0; i < child.branches.length; i++) {
                // Do not hoist v-if single child because it has to be a block
                walk(child.branches[i], context, child.branches[i].children.length === 1);
            }
        }
    }
    if (hoistedCount && context.transformHoist) {
        context.transformHoist(children, context, node);
    }
    // all children were hoisted - the entire children array is hoistable.
    if (hoistedCount &&
        hoistedCount === originalCount &&
        node.type === 1 /* ELEMENT */ &&
        node.tagType === 0 /* ELEMENT */ &&
        node.codegenNode &&
        node.codegenNode.type === 13 /* VNODE_CALL */ &&
        (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(node.codegenNode.children)) {
        node.codegenNode.children = context.hoist(createArrayExpression(node.codegenNode.children));
    }
}
function getConstantType(node, context) {
    const { constantCache } = context;
    switch (node.type) {
        case 1 /* ELEMENT */:
            if (node.tagType !== 0 /* ELEMENT */) {
                return 0 /* NOT_CONSTANT */;
            }
            const cached = constantCache.get(node);
            if (cached !== undefined) {
                return cached;
            }
            const codegenNode = node.codegenNode;
            if (codegenNode.type !== 13 /* VNODE_CALL */) {
                return 0 /* NOT_CONSTANT */;
            }
            if (codegenNode.isBlock &&
                node.tag !== 'svg' &&
                node.tag !== 'foreignObject') {
                return 0 /* NOT_CONSTANT */;
            }
            const flag = getPatchFlag(codegenNode);
            if (!flag) {
                let returnType = 3 /* CAN_STRINGIFY */;
                // Element itself has no patch flag. However we still need to check:
                // 1. Even for a node with no patch flag, it is possible for it to contain
                // non-hoistable expressions that refers to scope variables, e.g. compiler
                // injected keys or cached event handlers. Therefore we need to always
                // check the codegenNode's props to be sure.
                const generatedPropsType = getGeneratedPropsConstantType(node, context);
                if (generatedPropsType === 0 /* NOT_CONSTANT */) {
                    constantCache.set(node, 0 /* NOT_CONSTANT */);
                    return 0 /* NOT_CONSTANT */;
                }
                if (generatedPropsType < returnType) {
                    returnType = generatedPropsType;
                }
                // 2. its children.
                for (let i = 0; i < node.children.length; i++) {
                    const childType = getConstantType(node.children[i], context);
                    if (childType === 0 /* NOT_CONSTANT */) {
                        constantCache.set(node, 0 /* NOT_CONSTANT */);
                        return 0 /* NOT_CONSTANT */;
                    }
                    if (childType < returnType) {
                        returnType = childType;
                    }
                }
                // 3. if the type is not already CAN_SKIP_PATCH which is the lowest non-0
                // type, check if any of the props can cause the type to be lowered
                // we can skip can_patch because it's guaranteed by the absence of a
                // patchFlag.
                if (returnType > 1 /* CAN_SKIP_PATCH */) {
                    for (let i = 0; i < node.props.length; i++) {
                        const p = node.props[i];
                        if (p.type === 7 /* DIRECTIVE */ && p.name === 'bind' && p.exp) {
                            const expType = getConstantType(p.exp, context);
                            if (expType === 0 /* NOT_CONSTANT */) {
                                constantCache.set(node, 0 /* NOT_CONSTANT */);
                                return 0 /* NOT_CONSTANT */;
                            }
                            if (expType < returnType) {
                                returnType = expType;
                            }
                        }
                    }
                }
                // only svg/foreignObject could be block here, however if they are
                // static then they don't need to be blocks since there will be no
                // nested updates.
                if (codegenNode.isBlock) {
                    context.removeHelper(OPEN_BLOCK);
                    context.removeHelper(getVNodeBlockHelper(context.inSSR, codegenNode.isComponent));
                    codegenNode.isBlock = false;
                    context.helper(getVNodeHelper(context.inSSR, codegenNode.isComponent));
                }
                constantCache.set(node, returnType);
                return returnType;
            }
            else {
                constantCache.set(node, 0 /* NOT_CONSTANT */);
                return 0 /* NOT_CONSTANT */;
            }
        case 2 /* TEXT */:
        case 3 /* COMMENT */:
            return 3 /* CAN_STRINGIFY */;
        case 9 /* IF */:
        case 11 /* FOR */:
        case 10 /* IF_BRANCH */:
            return 0 /* NOT_CONSTANT */;
        case 5 /* INTERPOLATION */:
        case 12 /* TEXT_CALL */:
            return getConstantType(node.content, context);
        case 4 /* SIMPLE_EXPRESSION */:
            return node.constType;
        case 8 /* COMPOUND_EXPRESSION */:
            let returnType = 3 /* CAN_STRINGIFY */;
            for (let i = 0; i < node.children.length; i++) {
                const child = node.children[i];
                if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(child) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isSymbol)(child)) {
                    continue;
                }
                const childType = getConstantType(child, context);
                if (childType === 0 /* NOT_CONSTANT */) {
                    return 0 /* NOT_CONSTANT */;
                }
                else if (childType < returnType) {
                    returnType = childType;
                }
            }
            return returnType;
        default:
            if ((true)) ;
            return 0 /* NOT_CONSTANT */;
    }
}
const allowHoistedHelperSet = new Set([
    NORMALIZE_CLASS,
    NORMALIZE_STYLE,
    NORMALIZE_PROPS,
    GUARD_REACTIVE_PROPS
]);
function getConstantTypeOfHelperCall(value, context) {
    if (value.type === 14 /* JS_CALL_EXPRESSION */ &&
        !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(value.callee) &&
        allowHoistedHelperSet.has(value.callee)) {
        const arg = value.arguments[0];
        if (arg.type === 4 /* SIMPLE_EXPRESSION */) {
            return getConstantType(arg, context);
        }
        else if (arg.type === 14 /* JS_CALL_EXPRESSION */) {
            // in the case of nested helper call, e.g. `normalizeProps(guardReactiveProps(exp))`
            return getConstantTypeOfHelperCall(arg, context);
        }
    }
    return 0 /* NOT_CONSTANT */;
}
function getGeneratedPropsConstantType(node, context) {
    let returnType = 3 /* CAN_STRINGIFY */;
    const props = getNodeProps(node);
    if (props && props.type === 15 /* JS_OBJECT_EXPRESSION */) {
        const { properties } = props;
        for (let i = 0; i < properties.length; i++) {
            const { key, value } = properties[i];
            const keyType = getConstantType(key, context);
            if (keyType === 0 /* NOT_CONSTANT */) {
                return keyType;
            }
            if (keyType < returnType) {
                returnType = keyType;
            }
            let valueType;
            if (value.type === 4 /* SIMPLE_EXPRESSION */) {
                valueType = getConstantType(value, context);
            }
            else if (value.type === 14 /* JS_CALL_EXPRESSION */) {
                // some helper calls can be hoisted,
                // such as the `normalizeProps` generated by the compiler for pre-normalize class,
                // in this case we need to respect the ConstantType of the helper's arguments
                valueType = getConstantTypeOfHelperCall(value, context);
            }
            else {
                valueType = 0 /* NOT_CONSTANT */;
            }
            if (valueType === 0 /* NOT_CONSTANT */) {
                return valueType;
            }
            if (valueType < returnType) {
                returnType = valueType;
            }
        }
    }
    return returnType;
}
function getNodeProps(node) {
    const codegenNode = node.codegenNode;
    if (codegenNode.type === 13 /* VNODE_CALL */) {
        return codegenNode.props;
    }
}
function getPatchFlag(node) {
    const flag = node.patchFlag;
    return flag ? parseInt(flag, 10) : undefined;
}

function createTransformContext(root, { filename = '', prefixIdentifiers = false, hoistStatic = false, cacheHandlers = false, nodeTransforms = [], directiveTransforms = {}, transformHoist = null, isBuiltInComponent = _vue_shared__WEBPACK_IMPORTED_MODULE_0__.NOOP, isCustomElement = _vue_shared__WEBPACK_IMPORTED_MODULE_0__.NOOP, expressionPlugins = [], scopeId = null, slotted = true, ssr = false, inSSR = false, ssrCssVars = ``, bindingMetadata = _vue_shared__WEBPACK_IMPORTED_MODULE_0__.EMPTY_OBJ, inline = false, isTS = false, onError = defaultOnError, onWarn = defaultOnWarn, compatConfig }) {
    const nameMatch = filename.replace(/\?.*$/, '').match(/([^/\\]+)\.\w+$/);
    const context = {
        // options
        selfName: nameMatch && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.capitalize)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.camelize)(nameMatch[1])),
        prefixIdentifiers,
        hoistStatic,
        cacheHandlers,
        nodeTransforms,
        directiveTransforms,
        transformHoist,
        isBuiltInComponent,
        isCustomElement,
        expressionPlugins,
        scopeId,
        slotted,
        ssr,
        inSSR,
        ssrCssVars,
        bindingMetadata,
        inline,
        isTS,
        onError,
        onWarn,
        compatConfig,
        // state
        root,
        helpers: new Map(),
        components: new Set(),
        directives: new Set(),
        hoists: [],
        imports: [],
        constantCache: new Map(),
        temps: 0,
        cached: 0,
        identifiers: Object.create(null),
        scopes: {
            vFor: 0,
            vSlot: 0,
            vPre: 0,
            vOnce: 0
        },
        parent: null,
        currentNode: root,
        childIndex: 0,
        inVOnce: false,
        // methods
        helper(name) {
            const count = context.helpers.get(name) || 0;
            context.helpers.set(name, count + 1);
            return name;
        },
        removeHelper(name) {
            const count = context.helpers.get(name);
            if (count) {
                const currentCount = count - 1;
                if (!currentCount) {
                    context.helpers.delete(name);
                }
                else {
                    context.helpers.set(name, currentCount);
                }
            }
        },
        helperString(name) {
            return `_${helperNameMap[context.helper(name)]}`;
        },
        replaceNode(node) {
            /* istanbul ignore if */
            if ((true)) {
                if (!context.currentNode) {
                    throw new Error(`Node being replaced is already removed.`);
                }
                if (!context.parent) {
                    throw new Error(`Cannot replace root node.`);
                }
            }
            context.parent.children[context.childIndex] = context.currentNode = node;
        },
        removeNode(node) {
            if (( true) && !context.parent) {
                throw new Error(`Cannot remove root node.`);
            }
            const list = context.parent.children;
            const removalIndex = node
                ? list.indexOf(node)
                : context.currentNode
                    ? context.childIndex
                    : -1;
            /* istanbul ignore if */
            if (( true) && removalIndex < 0) {
                throw new Error(`node being removed is not a child of current parent`);
            }
            if (!node || node === context.currentNode) {
                // current node removed
                context.currentNode = null;
                context.onNodeRemoved();
            }
            else {
                // sibling node removed
                if (context.childIndex > removalIndex) {
                    context.childIndex--;
                    context.onNodeRemoved();
                }
            }
            context.parent.children.splice(removalIndex, 1);
        },
        onNodeRemoved: () => { },
        addIdentifiers(exp) {
        },
        removeIdentifiers(exp) {
        },
        hoist(exp) {
            if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(exp))
                exp = createSimpleExpression(exp);
            context.hoists.push(exp);
            const identifier = createSimpleExpression(`_hoisted_${context.hoists.length}`, false, exp.loc, 2 /* CAN_HOIST */);
            identifier.hoisted = exp;
            return identifier;
        },
        cache(exp, isVNode = false) {
            return createCacheExpression(context.cached++, exp, isVNode);
        }
    };
    {
        context.filters = new Set();
    }
    return context;
}
function transform(root, options) {
    const context = createTransformContext(root, options);
    traverseNode(root, context);
    if (options.hoistStatic) {
        hoistStatic(root, context);
    }
    if (!options.ssr) {
        createRootCodegen(root, context);
    }
    // finalize meta information
    root.helpers = [...context.helpers.keys()];
    root.components = [...context.components];
    root.directives = [...context.directives];
    root.imports = context.imports;
    root.hoists = context.hoists;
    root.temps = context.temps;
    root.cached = context.cached;
    {
        root.filters = [...context.filters];
    }
}
function createRootCodegen(root, context) {
    const { helper } = context;
    const { children } = root;
    if (children.length === 1) {
        const child = children[0];
        // if the single child is an element, turn it into a block.
        if (isSingleElementRoot(root, child) && child.codegenNode) {
            // single element root is never hoisted so codegenNode will never be
            // SimpleExpressionNode
            const codegenNode = child.codegenNode;
            if (codegenNode.type === 13 /* VNODE_CALL */) {
                makeBlock(codegenNode, context);
            }
            root.codegenNode = codegenNode;
        }
        else {
            // - single <slot/>, IfNode, ForNode: already blocks.
            // - single text node: always patched.
            // root codegen falls through via genNode()
            root.codegenNode = child;
        }
    }
    else if (children.length > 1) {
        // root has multiple nodes - return a fragment block.
        let patchFlag = 64 /* STABLE_FRAGMENT */;
        let patchFlagText = _vue_shared__WEBPACK_IMPORTED_MODULE_0__.PatchFlagNames[64];
        // check if the fragment actually contains a single valid child with
        // the rest being comments
        if (( true) &&
            children.filter(c => c.type !== 3 /* COMMENT */).length === 1) {
            patchFlag |= 2048 /* DEV_ROOT_FRAGMENT */;
            patchFlagText += `, ${_vue_shared__WEBPACK_IMPORTED_MODULE_0__.PatchFlagNames[2048]}`;
        }
        root.codegenNode = createVNodeCall(context, helper(FRAGMENT), undefined, root.children, patchFlag + (( true) ? ` /* ${patchFlagText} */` : 0), undefined, undefined, true, undefined, false /* isComponent */);
    }
    else ;
}
function traverseChildren(parent, context) {
    let i = 0;
    const nodeRemoved = () => {
        i--;
    };
    for (; i < parent.children.length; i++) {
        const child = parent.children[i];
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(child))
            continue;
        context.parent = parent;
        context.childIndex = i;
        context.onNodeRemoved = nodeRemoved;
        traverseNode(child, context);
    }
}
function traverseNode(node, context) {
    context.currentNode = node;
    // apply transform plugins
    const { nodeTransforms } = context;
    const exitFns = [];
    for (let i = 0; i < nodeTransforms.length; i++) {
        const onExit = nodeTransforms[i](node, context);
        if (onExit) {
            if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(onExit)) {
                exitFns.push(...onExit);
            }
            else {
                exitFns.push(onExit);
            }
        }
        if (!context.currentNode) {
            // node was removed
            return;
        }
        else {
            // node may have been replaced
            node = context.currentNode;
        }
    }
    switch (node.type) {
        case 3 /* COMMENT */:
            if (!context.ssr) {
                // inject import for the Comment symbol, which is needed for creating
                // comment nodes with `createVNode`
                context.helper(CREATE_COMMENT);
            }
            break;
        case 5 /* INTERPOLATION */:
            // no need to traverse, but we need to inject toString helper
            if (!context.ssr) {
                context.helper(TO_DISPLAY_STRING);
            }
            break;
        // for container types, further traverse downwards
        case 9 /* IF */:
            for (let i = 0; i < node.branches.length; i++) {
                traverseNode(node.branches[i], context);
            }
            break;
        case 10 /* IF_BRANCH */:
        case 11 /* FOR */:
        case 1 /* ELEMENT */:
        case 0 /* ROOT */:
            traverseChildren(node, context);
            break;
    }
    // exit transforms
    context.currentNode = node;
    let i = exitFns.length;
    while (i--) {
        exitFns[i]();
    }
}
function createStructuralDirectiveTransform(name, fn) {
    const matches = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(name)
        ? (n) => n === name
        : (n) => name.test(n);
    return (node, context) => {
        if (node.type === 1 /* ELEMENT */) {
            const { props } = node;
            // structural directive transforms are not concerned with slots
            // as they are handled separately in vSlot.ts
            if (node.tagType === 3 /* TEMPLATE */ && props.some(isVSlot)) {
                return;
            }
            const exitFns = [];
            for (let i = 0; i < props.length; i++) {
                const prop = props[i];
                if (prop.type === 7 /* DIRECTIVE */ && matches(prop.name)) {
                    // structural directives are removed to avoid infinite recursion
                    // also we remove them *before* applying so that it can further
                    // traverse itself in case it moves the node around
                    props.splice(i, 1);
                    i--;
                    const onExit = fn(node, prop, context);
                    if (onExit)
                        exitFns.push(onExit);
                }
            }
            return exitFns;
        }
    };
}

const PURE_ANNOTATION = `/*#__PURE__*/`;
function createCodegenContext(ast, { mode = 'function', prefixIdentifiers = mode === 'module', sourceMap = false, filename = `template.vue.html`, scopeId = null, optimizeImports = false, runtimeGlobalName = `Vue`, runtimeModuleName = `vue`, ssrRuntimeModuleName = 'vue/server-renderer', ssr = false, isTS = false, inSSR = false }) {
    const context = {
        mode,
        prefixIdentifiers,
        sourceMap,
        filename,
        scopeId,
        optimizeImports,
        runtimeGlobalName,
        runtimeModuleName,
        ssrRuntimeModuleName,
        ssr,
        isTS,
        inSSR,
        source: ast.loc.source,
        code: ``,
        column: 1,
        line: 1,
        offset: 0,
        indentLevel: 0,
        pure: false,
        map: undefined,
        helper(key) {
            return `_${helperNameMap[key]}`;
        },
        push(code, node) {
            context.code += code;
        },
        indent() {
            newline(++context.indentLevel);
        },
        deindent(withoutNewLine = false) {
            if (withoutNewLine) {
                --context.indentLevel;
            }
            else {
                newline(--context.indentLevel);
            }
        },
        newline() {
            newline(context.indentLevel);
        }
    };
    function newline(n) {
        context.push('\n' + `  `.repeat(n));
    }
    return context;
}
function generate(ast, options = {}) {
    const context = createCodegenContext(ast, options);
    if (options.onContextCreated)
        options.onContextCreated(context);
    const { mode, push, prefixIdentifiers, indent, deindent, newline, scopeId, ssr } = context;
    const hasHelpers = ast.helpers.length > 0;
    const useWithBlock = !prefixIdentifiers && mode !== 'module';
    // preambles
    // in setup() inline mode, the preamble is generated in a sub context
    // and returned separately.
    const preambleContext = context;
    {
        genFunctionPreamble(ast, preambleContext);
    }
    // enter render function
    const functionName = ssr ? `ssrRender` : `render`;
    const args = ssr ? ['_ctx', '_push', '_parent', '_attrs'] : ['_ctx', '_cache'];
    const signature = args.join(', ');
    {
        push(`function ${functionName}(${signature}) {`);
    }
    indent();
    if (useWithBlock) {
        push(`with (_ctx) {`);
        indent();
        // function mode const declarations should be inside with block
        // also they should be renamed to avoid collision with user properties
        if (hasHelpers) {
            push(`const { ${ast.helpers
                .map(s => `${helperNameMap[s]}: _${helperNameMap[s]}`)
                .join(', ')} } = _Vue`);
            push(`\n`);
            newline();
        }
    }
    // generate asset resolution statements
    if (ast.components.length) {
        genAssets(ast.components, 'component', context);
        if (ast.directives.length || ast.temps > 0) {
            newline();
        }
    }
    if (ast.directives.length) {
        genAssets(ast.directives, 'directive', context);
        if (ast.temps > 0) {
            newline();
        }
    }
    if (ast.filters && ast.filters.length) {
        newline();
        genAssets(ast.filters, 'filter', context);
        newline();
    }
    if (ast.temps > 0) {
        push(`let `);
        for (let i = 0; i < ast.temps; i++) {
            push(`${i > 0 ? `, ` : ``}_temp${i}`);
        }
    }
    if (ast.components.length || ast.directives.length || ast.temps) {
        push(`\n`);
        newline();
    }
    // generate the VNode tree expression
    if (!ssr) {
        push(`return `);
    }
    if (ast.codegenNode) {
        genNode(ast.codegenNode, context);
    }
    else {
        push(`null`);
    }
    if (useWithBlock) {
        deindent();
        push(`}`);
    }
    deindent();
    push(`}`);
    return {
        ast,
        code: context.code,
        preamble: ``,
        // SourceMapGenerator does have toJSON() method but it's not in the types
        map: context.map ? context.map.toJSON() : undefined
    };
}
function genFunctionPreamble(ast, context) {
    const { ssr, prefixIdentifiers, push, newline, runtimeModuleName, runtimeGlobalName, ssrRuntimeModuleName } = context;
    const VueBinding = runtimeGlobalName;
    const aliasHelper = (s) => `${helperNameMap[s]}: _${helperNameMap[s]}`;
    // Generate const declaration for helpers
    // In prefix mode, we place the const declaration at top so it's done
    // only once; But if we not prefixing, we place the declaration inside the
    // with block so it doesn't incur the `in` check cost for every helper access.
    if (ast.helpers.length > 0) {
        {
            // "with" mode.
            // save Vue in a separate variable to avoid collision
            push(`const _Vue = ${VueBinding}\n`);
            // in "with" mode, helpers are declared inside the with block to avoid
            // has check cost, but hoists are lifted out of the function - we need
            // to provide the helper here.
            if (ast.hoists.length) {
                const staticHelpers = [
                    CREATE_VNODE,
                    CREATE_ELEMENT_VNODE,
                    CREATE_COMMENT,
                    CREATE_TEXT,
                    CREATE_STATIC
                ]
                    .filter(helper => ast.helpers.includes(helper))
                    .map(aliasHelper)
                    .join(', ');
                push(`const { ${staticHelpers} } = _Vue\n`);
            }
        }
    }
    genHoists(ast.hoists, context);
    newline();
    push(`return `);
}
function genAssets(assets, type, { helper, push, newline, isTS }) {
    const resolver = helper(type === 'filter'
        ? RESOLVE_FILTER
        : type === 'component'
            ? RESOLVE_COMPONENT
            : RESOLVE_DIRECTIVE);
    for (let i = 0; i < assets.length; i++) {
        let id = assets[i];
        // potential component implicit self-reference inferred from SFC filename
        const maybeSelfReference = id.endsWith('__self');
        if (maybeSelfReference) {
            id = id.slice(0, -6);
        }
        push(`const ${toValidAssetId(id, type)} = ${resolver}(${JSON.stringify(id)}${maybeSelfReference ? `, true` : ``})${isTS ? `!` : ``}`);
        if (i < assets.length - 1) {
            newline();
        }
    }
}
function genHoists(hoists, context) {
    if (!hoists.length) {
        return;
    }
    context.pure = true;
    const { push, newline, helper, scopeId, mode } = context;
    newline();
    for (let i = 0; i < hoists.length; i++) {
        const exp = hoists[i];
        if (exp) {
            push(`const _hoisted_${i + 1} = ${``}`);
            genNode(exp, context);
            newline();
        }
    }
    context.pure = false;
}
function isText$1(n) {
    return ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(n) ||
        n.type === 4 /* SIMPLE_EXPRESSION */ ||
        n.type === 2 /* TEXT */ ||
        n.type === 5 /* INTERPOLATION */ ||
        n.type === 8 /* COMPOUND_EXPRESSION */);
}
function genNodeListAsArray(nodes, context) {
    const multilines = nodes.length > 3 ||
        ((( true)) && nodes.some(n => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(n) || !isText$1(n)));
    context.push(`[`);
    multilines && context.indent();
    genNodeList(nodes, context, multilines);
    multilines && context.deindent();
    context.push(`]`);
}
function genNodeList(nodes, context, multilines = false, comma = true) {
    const { push, newline } = context;
    for (let i = 0; i < nodes.length; i++) {
        const node = nodes[i];
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(node)) {
            push(node);
        }
        else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(node)) {
            genNodeListAsArray(node, context);
        }
        else {
            genNode(node, context);
        }
        if (i < nodes.length - 1) {
            if (multilines) {
                comma && push(',');
                newline();
            }
            else {
                comma && push(', ');
            }
        }
    }
}
function genNode(node, context) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(node)) {
        context.push(node);
        return;
    }
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isSymbol)(node)) {
        context.push(context.helper(node));
        return;
    }
    switch (node.type) {
        case 1 /* ELEMENT */:
        case 9 /* IF */:
        case 11 /* FOR */:
            ( true) &&
                assert(node.codegenNode != null, `Codegen node is missing for element/if/for node. ` +
                    `Apply appropriate transforms first.`);
            genNode(node.codegenNode, context);
            break;
        case 2 /* TEXT */:
            genText(node, context);
            break;
        case 4 /* SIMPLE_EXPRESSION */:
            genExpression(node, context);
            break;
        case 5 /* INTERPOLATION */:
            genInterpolation(node, context);
            break;
        case 12 /* TEXT_CALL */:
            genNode(node.codegenNode, context);
            break;
        case 8 /* COMPOUND_EXPRESSION */:
            genCompoundExpression(node, context);
            break;
        case 3 /* COMMENT */:
            genComment(node, context);
            break;
        case 13 /* VNODE_CALL */:
            genVNodeCall(node, context);
            break;
        case 14 /* JS_CALL_EXPRESSION */:
            genCallExpression(node, context);
            break;
        case 15 /* JS_OBJECT_EXPRESSION */:
            genObjectExpression(node, context);
            break;
        case 17 /* JS_ARRAY_EXPRESSION */:
            genArrayExpression(node, context);
            break;
        case 18 /* JS_FUNCTION_EXPRESSION */:
            genFunctionExpression(node, context);
            break;
        case 19 /* JS_CONDITIONAL_EXPRESSION */:
            genConditionalExpression(node, context);
            break;
        case 20 /* JS_CACHE_EXPRESSION */:
            genCacheExpression(node, context);
            break;
        case 21 /* JS_BLOCK_STATEMENT */:
            genNodeList(node.body, context, true, false);
            break;
        // SSR only types
        case 22 /* JS_TEMPLATE_LITERAL */:
            break;
        case 23 /* JS_IF_STATEMENT */:
            break;
        case 24 /* JS_ASSIGNMENT_EXPRESSION */:
            break;
        case 25 /* JS_SEQUENCE_EXPRESSION */:
            break;
        case 26 /* JS_RETURN_STATEMENT */:
            break;
        /* istanbul ignore next */
        case 10 /* IF_BRANCH */:
            // noop
            break;
        default:
            if ((true)) {
                assert(false, `unhandled codegen node type: ${node.type}`);
                // make sure we exhaust all possible types
                const exhaustiveCheck = node;
                return exhaustiveCheck;
            }
    }
}
function genText(node, context) {
    context.push(JSON.stringify(node.content), node);
}
function genExpression(node, context) {
    const { content, isStatic } = node;
    context.push(isStatic ? JSON.stringify(content) : content, node);
}
function genInterpolation(node, context) {
    const { push, helper, pure } = context;
    if (pure)
        push(PURE_ANNOTATION);
    push(`${helper(TO_DISPLAY_STRING)}(`);
    genNode(node.content, context);
    push(`)`);
}
function genCompoundExpression(node, context) {
    for (let i = 0; i < node.children.length; i++) {
        const child = node.children[i];
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(child)) {
            context.push(child);
        }
        else {
            genNode(child, context);
        }
    }
}
function genExpressionAsPropertyKey(node, context) {
    const { push } = context;
    if (node.type === 8 /* COMPOUND_EXPRESSION */) {
        push(`[`);
        genCompoundExpression(node, context);
        push(`]`);
    }
    else if (node.isStatic) {
        // only quote keys if necessary
        const text = isSimpleIdentifier(node.content)
            ? node.content
            : JSON.stringify(node.content);
        push(text, node);
    }
    else {
        push(`[${node.content}]`, node);
    }
}
function genComment(node, context) {
    const { push, helper, pure } = context;
    if (pure) {
        push(PURE_ANNOTATION);
    }
    push(`${helper(CREATE_COMMENT)}(${JSON.stringify(node.content)})`, node);
}
function genVNodeCall(node, context) {
    const { push, helper, pure } = context;
    const { tag, props, children, patchFlag, dynamicProps, directives, isBlock, disableTracking, isComponent } = node;
    if (directives) {
        push(helper(WITH_DIRECTIVES) + `(`);
    }
    if (isBlock) {
        push(`(${helper(OPEN_BLOCK)}(${disableTracking ? `true` : ``}), `);
    }
    if (pure) {
        push(PURE_ANNOTATION);
    }
    const callHelper = isBlock
        ? getVNodeBlockHelper(context.inSSR, isComponent)
        : getVNodeHelper(context.inSSR, isComponent);
    push(helper(callHelper) + `(`, node);
    genNodeList(genNullableArgs([tag, props, children, patchFlag, dynamicProps]), context);
    push(`)`);
    if (isBlock) {
        push(`)`);
    }
    if (directives) {
        push(`, `);
        genNode(directives, context);
        push(`)`);
    }
}
function genNullableArgs(args) {
    let i = args.length;
    while (i--) {
        if (args[i] != null)
            break;
    }
    return args.slice(0, i + 1).map(arg => arg || `null`);
}
// JavaScript
function genCallExpression(node, context) {
    const { push, helper, pure } = context;
    const callee = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(node.callee) ? node.callee : helper(node.callee);
    if (pure) {
        push(PURE_ANNOTATION);
    }
    push(callee + `(`, node);
    genNodeList(node.arguments, context);
    push(`)`);
}
function genObjectExpression(node, context) {
    const { push, indent, deindent, newline } = context;
    const { properties } = node;
    if (!properties.length) {
        push(`{}`, node);
        return;
    }
    const multilines = properties.length > 1 ||
        ((( true)) &&
            properties.some(p => p.value.type !== 4 /* SIMPLE_EXPRESSION */));
    push(multilines ? `{` : `{ `);
    multilines && indent();
    for (let i = 0; i < properties.length; i++) {
        const { key, value } = properties[i];
        // key
        genExpressionAsPropertyKey(key, context);
        push(`: `);
        // value
        genNode(value, context);
        if (i < properties.length - 1) {
            // will only reach this if it's multilines
            push(`,`);
            newline();
        }
    }
    multilines && deindent();
    push(multilines ? `}` : ` }`);
}
function genArrayExpression(node, context) {
    genNodeListAsArray(node.elements, context);
}
function genFunctionExpression(node, context) {
    const { push, indent, deindent } = context;
    const { params, returns, body, newline, isSlot } = node;
    if (isSlot) {
        // wrap slot functions with owner context
        push(`_${helperNameMap[WITH_CTX]}(`);
    }
    push(`(`, node);
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(params)) {
        genNodeList(params, context);
    }
    else if (params) {
        genNode(params, context);
    }
    push(`) => `);
    if (newline || body) {
        push(`{`);
        indent();
    }
    if (returns) {
        if (newline) {
            push(`return `);
        }
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(returns)) {
            genNodeListAsArray(returns, context);
        }
        else {
            genNode(returns, context);
        }
    }
    else if (body) {
        genNode(body, context);
    }
    if (newline || body) {
        deindent();
        push(`}`);
    }
    if (isSlot) {
        if (node.isNonScopedSlot) {
            push(`, undefined, true`);
        }
        push(`)`);
    }
}
function genConditionalExpression(node, context) {
    const { test, consequent, alternate, newline: needNewline } = node;
    const { push, indent, deindent, newline } = context;
    if (test.type === 4 /* SIMPLE_EXPRESSION */) {
        const needsParens = !isSimpleIdentifier(test.content);
        needsParens && push(`(`);
        genExpression(test, context);
        needsParens && push(`)`);
    }
    else {
        push(`(`);
        genNode(test, context);
        push(`)`);
    }
    needNewline && indent();
    context.indentLevel++;
    needNewline || push(` `);
    push(`? `);
    genNode(consequent, context);
    context.indentLevel--;
    needNewline && newline();
    needNewline || push(` `);
    push(`: `);
    const isNested = alternate.type === 19 /* JS_CONDITIONAL_EXPRESSION */;
    if (!isNested) {
        context.indentLevel++;
    }
    genNode(alternate, context);
    if (!isNested) {
        context.indentLevel--;
    }
    needNewline && deindent(true /* without newline */);
}
function genCacheExpression(node, context) {
    const { push, helper, indent, deindent, newline } = context;
    push(`_cache[${node.index}] || (`);
    if (node.isVNode) {
        indent();
        push(`${helper(SET_BLOCK_TRACKING)}(-1),`);
        newline();
    }
    push(`_cache[${node.index}] = `);
    genNode(node.value, context);
    if (node.isVNode) {
        push(`,`);
        newline();
        push(`${helper(SET_BLOCK_TRACKING)}(1),`);
        newline();
        push(`_cache[${node.index}]`);
        deindent();
    }
    push(`)`);
}

function walkIdentifiers(root, onIdentifier, includeAll = false, parentStack = [], knownIds = Object.create(null)) {
    {
        return;
    }
}
function isReferencedIdentifier(id, parent, parentStack) {
    {
        return false;
    }
}
function isInDestructureAssignment(parent, parentStack) {
    if (parent &&
        (parent.type === 'ObjectProperty' || parent.type === 'ArrayPattern')) {
        let i = parentStack.length;
        while (i--) {
            const p = parentStack[i];
            if (p.type === 'AssignmentExpression') {
                return true;
            }
            else if (p.type !== 'ObjectProperty' && !p.type.endsWith('Pattern')) {
                break;
            }
        }
    }
    return false;
}
function walkFunctionParams(node, onIdent) {
    for (const p of node.params) {
        for (const id of extractIdentifiers(p)) {
            onIdent(id);
        }
    }
}
function walkBlockDeclarations(block, onIdent) {
    for (const stmt of block.body) {
        if (stmt.type === 'VariableDeclaration') {
            if (stmt.declare)
                continue;
            for (const decl of stmt.declarations) {
                for (const id of extractIdentifiers(decl.id)) {
                    onIdent(id);
                }
            }
        }
        else if (stmt.type === 'FunctionDeclaration' ||
            stmt.type === 'ClassDeclaration') {
            if (stmt.declare || !stmt.id)
                continue;
            onIdent(stmt.id);
        }
    }
}
function extractIdentifiers(param, nodes = []) {
    switch (param.type) {
        case 'Identifier':
            nodes.push(param);
            break;
        case 'MemberExpression':
            let object = param;
            while (object.type === 'MemberExpression') {
                object = object.object;
            }
            nodes.push(object);
            break;
        case 'ObjectPattern':
            for (const prop of param.properties) {
                if (prop.type === 'RestElement') {
                    extractIdentifiers(prop.argument, nodes);
                }
                else {
                    extractIdentifiers(prop.value, nodes);
                }
            }
            break;
        case 'ArrayPattern':
            param.elements.forEach(element => {
                if (element)
                    extractIdentifiers(element, nodes);
            });
            break;
        case 'RestElement':
            extractIdentifiers(param.argument, nodes);
            break;
        case 'AssignmentPattern':
            extractIdentifiers(param.left, nodes);
            break;
    }
    return nodes;
}
const isFunctionType = (node) => {
    return /Function(?:Expression|Declaration)$|Method$/.test(node.type);
};
const isStaticProperty = (node) => node &&
    (node.type === 'ObjectProperty' || node.type === 'ObjectMethod') &&
    !node.computed;
const isStaticPropertyKey = (node, parent) => isStaticProperty(parent) && parent.key === node;

// these keywords should not appear inside expressions, but operators like
// typeof, instanceof and in are allowed
const prohibitedKeywordRE = new RegExp('\\b' +
    ('do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' +
        'super,throw,while,yield,delete,export,import,return,switch,default,' +
        'extends,finally,continue,debugger,function,arguments,typeof,void')
        .split(',')
        .join('\\b|\\b') +
    '\\b');
// strip strings in expressions
const stripStringRE = /'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g;
/**
 * Validate a non-prefixed expression.
 * This is only called when using the in-browser runtime compiler since it
 * doesn't prefix expressions.
 */
function validateBrowserExpression(node, context, asParams = false, asRawStatements = false) {
    const exp = node.content;
    // empty expressions are validated per-directive since some directives
    // do allow empty expressions.
    if (!exp.trim()) {
        return;
    }
    try {
        new Function(asRawStatements
            ? ` ${exp} `
            : `return ${asParams ? `(${exp}) => {}` : `(${exp})`}`);
    }
    catch (e) {
        let message = e.message;
        const keywordMatch = exp
            .replace(stripStringRE, '')
            .match(prohibitedKeywordRE);
        if (keywordMatch) {
            message = `avoid using JavaScript keyword as property name: "${keywordMatch[0]}"`;
        }
        context.onError(createCompilerError(44 /* X_INVALID_EXPRESSION */, node.loc, undefined, message));
    }
}

const transformExpression = (node, context) => {
    if (node.type === 5 /* INTERPOLATION */) {
        node.content = processExpression(node.content, context);
    }
    else if (node.type === 1 /* ELEMENT */) {
        // handle directives on element
        for (let i = 0; i < node.props.length; i++) {
            const dir = node.props[i];
            // do not process for v-on & v-for since they are special handled
            if (dir.type === 7 /* DIRECTIVE */ && dir.name !== 'for') {
                const exp = dir.exp;
                const arg = dir.arg;
                // do not process exp if this is v-on:arg - we need special handling
                // for wrapping inline statements.
                if (exp &&
                    exp.type === 4 /* SIMPLE_EXPRESSION */ &&
                    !(dir.name === 'on' && arg)) {
                    dir.exp = processExpression(exp, context, 
                    // slot args must be processed as function params
                    dir.name === 'slot');
                }
                if (arg && arg.type === 4 /* SIMPLE_EXPRESSION */ && !arg.isStatic) {
                    dir.arg = processExpression(arg, context);
                }
            }
        }
    }
};
// Important: since this function uses Node.js only dependencies, it should
// always be used with a leading !true check so that it can be
// tree-shaken from the browser build.
function processExpression(node, context, 
// some expressions like v-slot props & v-for aliases should be parsed as
// function params
asParams = false, 
// v-on handler values may contain multiple statements
asRawStatements = false, localVars = Object.create(context.identifiers)) {
    {
        if ((true)) {
            // simple in-browser validation (same logic in 2.x)
            validateBrowserExpression(node, context, asParams, asRawStatements);
        }
        return node;
    }
}

const transformIf = createStructuralDirectiveTransform(/^(if|else|else-if)$/, (node, dir, context) => {
    return processIf(node, dir, context, (ifNode, branch, isRoot) => {
        // #1587: We need to dynamically increment the key based on the current
        // node's sibling nodes, since chained v-if/else branches are
        // rendered at the same depth
        const siblings = context.parent.children;
        let i = siblings.indexOf(ifNode);
        let key = 0;
        while (i-- >= 0) {
            const sibling = siblings[i];
            if (sibling && sibling.type === 9 /* IF */) {
                key += sibling.branches.length;
            }
        }
        // Exit callback. Complete the codegenNode when all children have been
        // transformed.
        return () => {
            if (isRoot) {
                ifNode.codegenNode = createCodegenNodeForBranch(branch, key, context);
            }
            else {
                // attach this branch's codegen node to the v-if root.
                const parentCondition = getParentCondition(ifNode.codegenNode);
                parentCondition.alternate = createCodegenNodeForBranch(branch, key + ifNode.branches.length - 1, context);
            }
        };
    });
});
// target-agnostic transform used for both Client and SSR
function processIf(node, dir, context, processCodegen) {
    if (dir.name !== 'else' &&
        (!dir.exp || !dir.exp.content.trim())) {
        const loc = dir.exp ? dir.exp.loc : node.loc;
        context.onError(createCompilerError(28 /* X_V_IF_NO_EXPRESSION */, dir.loc));
        dir.exp = createSimpleExpression(`true`, false, loc);
    }
    if ( true && dir.exp) {
        validateBrowserExpression(dir.exp, context);
    }
    if (dir.name === 'if') {
        const branch = createIfBranch(node, dir);
        const ifNode = {
            type: 9 /* IF */,
            loc: node.loc,
            branches: [branch]
        };
        context.replaceNode(ifNode);
        if (processCodegen) {
            return processCodegen(ifNode, branch, true);
        }
    }
    else {
        // locate the adjacent v-if
        const siblings = context.parent.children;
        const comments = [];
        let i = siblings.indexOf(node);
        while (i-- >= -1) {
            const sibling = siblings[i];
            if (( true) && sibling && sibling.type === 3 /* COMMENT */) {
                context.removeNode(sibling);
                comments.unshift(sibling);
                continue;
            }
            if (sibling &&
                sibling.type === 2 /* TEXT */ &&
                !sibling.content.trim().length) {
                context.removeNode(sibling);
                continue;
            }
            if (sibling && sibling.type === 9 /* IF */) {
                // Check if v-else was followed by v-else-if
                if (dir.name === 'else-if' &&
                    sibling.branches[sibling.branches.length - 1].condition === undefined) {
                    context.onError(createCompilerError(30 /* X_V_ELSE_NO_ADJACENT_IF */, node.loc));
                }
                // move the node to the if node's branches
                context.removeNode();
                const branch = createIfBranch(node, dir);
                if (( true) &&
                    comments.length &&
                    // #3619 ignore comments if the v-if is direct child of <transition>
                    !(context.parent &&
                        context.parent.type === 1 /* ELEMENT */ &&
                        isBuiltInType(context.parent.tag, 'transition'))) {
                    branch.children = [...comments, ...branch.children];
                }
                // check if user is forcing same key on different branches
                if (true) {
                    const key = branch.userKey;
                    if (key) {
                        sibling.branches.forEach(({ userKey }) => {
                            if (isSameKey(userKey, key)) {
                                context.onError(createCompilerError(29 /* X_V_IF_SAME_KEY */, branch.userKey.loc));
                            }
                        });
                    }
                }
                sibling.branches.push(branch);
                const onExit = processCodegen && processCodegen(sibling, branch, false);
                // since the branch was removed, it will not be traversed.
                // make sure to traverse here.
                traverseNode(branch, context);
                // call on exit
                if (onExit)
                    onExit();
                // make sure to reset currentNode after traversal to indicate this
                // node has been removed.
                context.currentNode = null;
            }
            else {
                context.onError(createCompilerError(30 /* X_V_ELSE_NO_ADJACENT_IF */, node.loc));
            }
            break;
        }
    }
}
function createIfBranch(node, dir) {
    return {
        type: 10 /* IF_BRANCH */,
        loc: node.loc,
        condition: dir.name === 'else' ? undefined : dir.exp,
        children: node.tagType === 3 /* TEMPLATE */ && !findDir(node, 'for')
            ? node.children
            : [node],
        userKey: findProp(node, `key`)
    };
}
function createCodegenNodeForBranch(branch, keyIndex, context) {
    if (branch.condition) {
        return createConditionalExpression(branch.condition, createChildrenCodegenNode(branch, keyIndex, context), 
        // make sure to pass in asBlock: true so that the comment node call
        // closes the current block.
        createCallExpression(context.helper(CREATE_COMMENT), [
            ( true) ? '"v-if"' : 0,
            'true'
        ]));
    }
    else {
        return createChildrenCodegenNode(branch, keyIndex, context);
    }
}
function createChildrenCodegenNode(branch, keyIndex, context) {
    const { helper } = context;
    const keyProperty = createObjectProperty(`key`, createSimpleExpression(`${keyIndex}`, false, locStub, 2 /* CAN_HOIST */));
    const { children } = branch;
    const firstChild = children[0];
    const needFragmentWrapper = children.length !== 1 || firstChild.type !== 1 /* ELEMENT */;
    if (needFragmentWrapper) {
        if (children.length === 1 && firstChild.type === 11 /* FOR */) {
            // optimize away nested fragments when child is a ForNode
            const vnodeCall = firstChild.codegenNode;
            injectProp(vnodeCall, keyProperty, context);
            return vnodeCall;
        }
        else {
            let patchFlag = 64 /* STABLE_FRAGMENT */;
            let patchFlagText = _vue_shared__WEBPACK_IMPORTED_MODULE_0__.PatchFlagNames[64];
            // check if the fragment actually contains a single valid child with
            // the rest being comments
            if (( true) &&
                children.filter(c => c.type !== 3 /* COMMENT */).length === 1) {
                patchFlag |= 2048 /* DEV_ROOT_FRAGMENT */;
                patchFlagText += `, ${_vue_shared__WEBPACK_IMPORTED_MODULE_0__.PatchFlagNames[2048]}`;
            }
            return createVNodeCall(context, helper(FRAGMENT), createObjectExpression([keyProperty]), children, patchFlag + (( true) ? ` /* ${patchFlagText} */` : 0), undefined, undefined, true, false, false /* isComponent */, branch.loc);
        }
    }
    else {
        const ret = firstChild.codegenNode;
        const vnodeCall = getMemoedVNodeCall(ret);
        // Change createVNode to createBlock.
        if (vnodeCall.type === 13 /* VNODE_CALL */) {
            makeBlock(vnodeCall, context);
        }
        // inject branch key
        injectProp(vnodeCall, keyProperty, context);
        return ret;
    }
}
function isSameKey(a, b) {
    if (!a || a.type !== b.type) {
        return false;
    }
    if (a.type === 6 /* ATTRIBUTE */) {
        if (a.value.content !== b.value.content) {
            return false;
        }
    }
    else {
        // directive
        const exp = a.exp;
        const branchExp = b.exp;
        if (exp.type !== branchExp.type) {
            return false;
        }
        if (exp.type !== 4 /* SIMPLE_EXPRESSION */ ||
            exp.isStatic !== branchExp.isStatic ||
            exp.content !== branchExp.content) {
            return false;
        }
    }
    return true;
}
function getParentCondition(node) {
    while (true) {
        if (node.type === 19 /* JS_CONDITIONAL_EXPRESSION */) {
            if (node.alternate.type === 19 /* JS_CONDITIONAL_EXPRESSION */) {
                node = node.alternate;
            }
            else {
                return node;
            }
        }
        else if (node.type === 20 /* JS_CACHE_EXPRESSION */) {
            node = node.value;
        }
    }
}

const transformFor = createStructuralDirectiveTransform('for', (node, dir, context) => {
    const { helper, removeHelper } = context;
    return processFor(node, dir, context, forNode => {
        // create the loop render function expression now, and add the
        // iterator on exit after all children have been traversed
        const renderExp = createCallExpression(helper(RENDER_LIST), [
            forNode.source
        ]);
        const isTemplate = isTemplateNode(node);
        const memo = findDir(node, 'memo');
        const keyProp = findProp(node, `key`);
        const keyExp = keyProp &&
            (keyProp.type === 6 /* ATTRIBUTE */
                ? createSimpleExpression(keyProp.value.content, true)
                : keyProp.exp);
        const keyProperty = keyProp ? createObjectProperty(`key`, keyExp) : null;
        const isStableFragment = forNode.source.type === 4 /* SIMPLE_EXPRESSION */ &&
            forNode.source.constType > 0 /* NOT_CONSTANT */;
        const fragmentFlag = isStableFragment
            ? 64 /* STABLE_FRAGMENT */
            : keyProp
                ? 128 /* KEYED_FRAGMENT */
                : 256 /* UNKEYED_FRAGMENT */;
        forNode.codegenNode = createVNodeCall(context, helper(FRAGMENT), undefined, renderExp, fragmentFlag +
            (( true) ? ` /* ${_vue_shared__WEBPACK_IMPORTED_MODULE_0__.PatchFlagNames[fragmentFlag]} */` : 0), undefined, undefined, true /* isBlock */, !isStableFragment /* disableTracking */, false /* isComponent */, node.loc);
        return () => {
            // finish the codegen now that all children have been traversed
            let childBlock;
            const { children } = forNode;
            // check <template v-for> key placement
            if (( true) && isTemplate) {
                node.children.some(c => {
                    if (c.type === 1 /* ELEMENT */) {
                        const key = findProp(c, 'key');
                        if (key) {
                            context.onError(createCompilerError(33 /* X_V_FOR_TEMPLATE_KEY_PLACEMENT */, key.loc));
                            return true;
                        }
                    }
                });
            }
            const needFragmentWrapper = children.length !== 1 || children[0].type !== 1 /* ELEMENT */;
            const slotOutlet = isSlotOutlet(node)
                ? node
                : isTemplate &&
                    node.children.length === 1 &&
                    isSlotOutlet(node.children[0])
                    ? node.children[0] // api-extractor somehow fails to infer this
                    : null;
            if (slotOutlet) {
                // <slot v-for="..."> or <template v-for="..."><slot/></template>
                childBlock = slotOutlet.codegenNode;
                if (isTemplate && keyProperty) {
                    // <template v-for="..." :key="..."><slot/></template>
                    // we need to inject the key to the renderSlot() call.
                    // the props for renderSlot is passed as the 3rd argument.
                    injectProp(childBlock, keyProperty, context);
                }
            }
            else if (needFragmentWrapper) {
                // <template v-for="..."> with text or multi-elements
                // should generate a fragment block for each loop
                childBlock = createVNodeCall(context, helper(FRAGMENT), keyProperty ? createObjectExpression([keyProperty]) : undefined, node.children, 64 /* STABLE_FRAGMENT */ +
                    (( true)
                        ? ` /* ${_vue_shared__WEBPACK_IMPORTED_MODULE_0__.PatchFlagNames[64]} */`
                        : 0), undefined, undefined, true, undefined, false /* isComponent */);
            }
            else {
                // Normal element v-for. Directly use the child's codegenNode
                // but mark it as a block.
                childBlock = children[0]
                    .codegenNode;
                if (isTemplate && keyProperty) {
                    injectProp(childBlock, keyProperty, context);
                }
                if (childBlock.isBlock !== !isStableFragment) {
                    if (childBlock.isBlock) {
                        // switch from block to vnode
                        removeHelper(OPEN_BLOCK);
                        removeHelper(getVNodeBlockHelper(context.inSSR, childBlock.isComponent));
                    }
                    else {
                        // switch from vnode to block
                        removeHelper(getVNodeHelper(context.inSSR, childBlock.isComponent));
                    }
                }
                childBlock.isBlock = !isStableFragment;
                if (childBlock.isBlock) {
                    helper(OPEN_BLOCK);
                    helper(getVNodeBlockHelper(context.inSSR, childBlock.isComponent));
                }
                else {
                    helper(getVNodeHelper(context.inSSR, childBlock.isComponent));
                }
            }
            if (memo) {
                const loop = createFunctionExpression(createForLoopParams(forNode.parseResult, [
                    createSimpleExpression(`_cached`)
                ]));
                loop.body = createBlockStatement([
                    createCompoundExpression([`const _memo = (`, memo.exp, `)`]),
                    createCompoundExpression([
                        `if (_cached`,
                        ...(keyExp ? [` && _cached.key === `, keyExp] : []),
                        ` && ${context.helperString(IS_MEMO_SAME)}(_cached, _memo)) return _cached`
                    ]),
                    createCompoundExpression([`const _item = `, childBlock]),
                    createSimpleExpression(`_item.memo = _memo`),
                    createSimpleExpression(`return _item`)
                ]);
                renderExp.arguments.push(loop, createSimpleExpression(`_cache`), createSimpleExpression(String(context.cached++)));
            }
            else {
                renderExp.arguments.push(createFunctionExpression(createForLoopParams(forNode.parseResult), childBlock, true /* force newline */));
            }
        };
    });
});
// target-agnostic transform used for both Client and SSR
function processFor(node, dir, context, processCodegen) {
    if (!dir.exp) {
        context.onError(createCompilerError(31 /* X_V_FOR_NO_EXPRESSION */, dir.loc));
        return;
    }
    const parseResult = parseForExpression(
    // can only be simple expression because vFor transform is applied
    // before expression transform.
    dir.exp, context);
    if (!parseResult) {
        context.onError(createCompilerError(32 /* X_V_FOR_MALFORMED_EXPRESSION */, dir.loc));
        return;
    }
    const { addIdentifiers, removeIdentifiers, scopes } = context;
    const { source, value, key, index } = parseResult;
    const forNode = {
        type: 11 /* FOR */,
        loc: dir.loc,
        source,
        valueAlias: value,
        keyAlias: key,
        objectIndexAlias: index,
        parseResult,
        children: isTemplateNode(node) ? node.children : [node]
    };
    context.replaceNode(forNode);
    // bookkeeping
    scopes.vFor++;
    const onExit = processCodegen && processCodegen(forNode);
    return () => {
        scopes.vFor--;
        if (onExit)
            onExit();
    };
}
const forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/;
// This regex doesn't cover the case if key or index aliases have destructuring,
// but those do not make sense in the first place, so this works in practice.
const forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/;
const stripParensRE = /^\(|\)$/g;
function parseForExpression(input, context) {
    const loc = input.loc;
    const exp = input.content;
    const inMatch = exp.match(forAliasRE);
    if (!inMatch)
        return;
    const [, LHS, RHS] = inMatch;
    const result = {
        source: createAliasExpression(loc, RHS.trim(), exp.indexOf(RHS, LHS.length)),
        value: undefined,
        key: undefined,
        index: undefined
    };
    if (true) {
        validateBrowserExpression(result.source, context);
    }
    let valueContent = LHS.trim().replace(stripParensRE, '').trim();
    const trimmedOffset = LHS.indexOf(valueContent);
    const iteratorMatch = valueContent.match(forIteratorRE);
    if (iteratorMatch) {
        valueContent = valueContent.replace(forIteratorRE, '').trim();
        const keyContent = iteratorMatch[1].trim();
        let keyOffset;
        if (keyContent) {
            keyOffset = exp.indexOf(keyContent, trimmedOffset + valueContent.length);
            result.key = createAliasExpression(loc, keyContent, keyOffset);
            if (true) {
                validateBrowserExpression(result.key, context, true);
            }
        }
        if (iteratorMatch[2]) {
            const indexContent = iteratorMatch[2].trim();
            if (indexContent) {
                result.index = createAliasExpression(loc, indexContent, exp.indexOf(indexContent, result.key
                    ? keyOffset + keyContent.length
                    : trimmedOffset + valueContent.length));
                if (true) {
                    validateBrowserExpression(result.index, context, true);
                }
            }
        }
    }
    if (valueContent) {
        result.value = createAliasExpression(loc, valueContent, trimmedOffset);
        if (true) {
            validateBrowserExpression(result.value, context, true);
        }
    }
    return result;
}
function createAliasExpression(range, content, offset) {
    return createSimpleExpression(content, false, getInnerRange(range, offset, content.length));
}
function createForLoopParams({ value, key, index }, memoArgs = []) {
    return createParamsList([value, key, index, ...memoArgs]);
}
function createParamsList(args) {
    let i = args.length;
    while (i--) {
        if (args[i])
            break;
    }
    return args
        .slice(0, i + 1)
        .map((arg, i) => arg || createSimpleExpression(`_`.repeat(i + 1), false));
}

const defaultFallback = createSimpleExpression(`undefined`, false);
// A NodeTransform that:
// 1. Tracks scope identifiers for scoped slots so that they don't get prefixed
//    by transformExpression. This is only applied in non-browser builds with
//    { prefixIdentifiers: true }.
// 2. Track v-slot depths so that we know a slot is inside another slot.
//    Note the exit callback is executed before buildSlots() on the same node,
//    so only nested slots see positive numbers.
const trackSlotScopes = (node, context) => {
    if (node.type === 1 /* ELEMENT */ &&
        (node.tagType === 1 /* COMPONENT */ ||
            node.tagType === 3 /* TEMPLATE */)) {
        // We are only checking non-empty v-slot here
        // since we only care about slots that introduce scope variables.
        const vSlot = findDir(node, 'slot');
        if (vSlot) {
            vSlot.exp;
            context.scopes.vSlot++;
            return () => {
                context.scopes.vSlot--;
            };
        }
    }
};
// A NodeTransform that tracks scope identifiers for scoped slots with v-for.
// This transform is only applied in non-browser builds with { prefixIdentifiers: true }
const trackVForSlotScopes = (node, context) => {
    let vFor;
    if (isTemplateNode(node) &&
        node.props.some(isVSlot) &&
        (vFor = findDir(node, 'for'))) {
        const result = (vFor.parseResult = parseForExpression(vFor.exp, context));
        if (result) {
            const { value, key, index } = result;
            const { addIdentifiers, removeIdentifiers } = context;
            value && addIdentifiers(value);
            key && addIdentifiers(key);
            index && addIdentifiers(index);
            return () => {
                value && removeIdentifiers(value);
                key && removeIdentifiers(key);
                index && removeIdentifiers(index);
            };
        }
    }
};
const buildClientSlotFn = (props, children, loc) => createFunctionExpression(props, children, false /* newline */, true /* isSlot */, children.length ? children[0].loc : loc);
// Instead of being a DirectiveTransform, v-slot processing is called during
// transformElement to build the slots object for a component.
function buildSlots(node, context, buildSlotFn = buildClientSlotFn) {
    context.helper(WITH_CTX);
    const { children, loc } = node;
    const slotsProperties = [];
    const dynamicSlots = [];
    // If the slot is inside a v-for or another v-slot, force it to be dynamic
    // since it likely uses a scope variable.
    let hasDynamicSlots = context.scopes.vSlot > 0 || context.scopes.vFor > 0;
    // 1. Check for slot with slotProps on component itself.
    //    <Comp v-slot="{ prop }"/>
    const onComponentSlot = findDir(node, 'slot', true);
    if (onComponentSlot) {
        const { arg, exp } = onComponentSlot;
        if (arg && !isStaticExp(arg)) {
            hasDynamicSlots = true;
        }
        slotsProperties.push(createObjectProperty(arg || createSimpleExpression('default', true), buildSlotFn(exp, children, loc)));
    }
    // 2. Iterate through children and check for template slots
    //    <template v-slot:foo="{ prop }">
    let hasTemplateSlots = false;
    let hasNamedDefaultSlot = false;
    const implicitDefaultChildren = [];
    const seenSlotNames = new Set();
    for (let i = 0; i < children.length; i++) {
        const slotElement = children[i];
        let slotDir;
        if (!isTemplateNode(slotElement) ||
            !(slotDir = findDir(slotElement, 'slot', true))) {
            // not a <template v-slot>, skip.
            if (slotElement.type !== 3 /* COMMENT */) {
                implicitDefaultChildren.push(slotElement);
            }
            continue;
        }
        if (onComponentSlot) {
            // already has on-component slot - this is incorrect usage.
            context.onError(createCompilerError(37 /* X_V_SLOT_MIXED_SLOT_USAGE */, slotDir.loc));
            break;
        }
        hasTemplateSlots = true;
        const { children: slotChildren, loc: slotLoc } = slotElement;
        const { arg: slotName = createSimpleExpression(`default`, true), exp: slotProps, loc: dirLoc } = slotDir;
        // check if name is dynamic.
        let staticSlotName;
        if (isStaticExp(slotName)) {
            staticSlotName = slotName ? slotName.content : `default`;
        }
        else {
            hasDynamicSlots = true;
        }
        const slotFunction = buildSlotFn(slotProps, slotChildren, slotLoc);
        // check if this slot is conditional (v-if/v-for)
        let vIf;
        let vElse;
        let vFor;
        if ((vIf = findDir(slotElement, 'if'))) {
            hasDynamicSlots = true;
            dynamicSlots.push(createConditionalExpression(vIf.exp, buildDynamicSlot(slotName, slotFunction), defaultFallback));
        }
        else if ((vElse = findDir(slotElement, /^else(-if)?$/, true /* allowEmpty */))) {
            // find adjacent v-if
            let j = i;
            let prev;
            while (j--) {
                prev = children[j];
                if (prev.type !== 3 /* COMMENT */) {
                    break;
                }
            }
            if (prev && isTemplateNode(prev) && findDir(prev, 'if')) {
                // remove node
                children.splice(i, 1);
                i--;
                // attach this slot to previous conditional
                let conditional = dynamicSlots[dynamicSlots.length - 1];
                while (conditional.alternate.type === 19 /* JS_CONDITIONAL_EXPRESSION */) {
                    conditional = conditional.alternate;
                }
                conditional.alternate = vElse.exp
                    ? createConditionalExpression(vElse.exp, buildDynamicSlot(slotName, slotFunction), defaultFallback)
                    : buildDynamicSlot(slotName, slotFunction);
            }
            else {
                context.onError(createCompilerError(30 /* X_V_ELSE_NO_ADJACENT_IF */, vElse.loc));
            }
        }
        else if ((vFor = findDir(slotElement, 'for'))) {
            hasDynamicSlots = true;
            const parseResult = vFor.parseResult ||
                parseForExpression(vFor.exp, context);
            if (parseResult) {
                // Render the dynamic slots as an array and add it to the createSlot()
                // args. The runtime knows how to handle it appropriately.
                dynamicSlots.push(createCallExpression(context.helper(RENDER_LIST), [
                    parseResult.source,
                    createFunctionExpression(createForLoopParams(parseResult), buildDynamicSlot(slotName, slotFunction), true /* force newline */)
                ]));
            }
            else {
                context.onError(createCompilerError(32 /* X_V_FOR_MALFORMED_EXPRESSION */, vFor.loc));
            }
        }
        else {
            // check duplicate static names
            if (staticSlotName) {
                if (seenSlotNames.has(staticSlotName)) {
                    context.onError(createCompilerError(38 /* X_V_SLOT_DUPLICATE_SLOT_NAMES */, dirLoc));
                    continue;
                }
                seenSlotNames.add(staticSlotName);
                if (staticSlotName === 'default') {
                    hasNamedDefaultSlot = true;
                }
            }
            slotsProperties.push(createObjectProperty(slotName, slotFunction));
        }
    }
    if (!onComponentSlot) {
        const buildDefaultSlotProperty = (props, children) => {
            const fn = buildSlotFn(props, children, loc);
            if (context.compatConfig) {
                fn.isNonScopedSlot = true;
            }
            return createObjectProperty(`default`, fn);
        };
        if (!hasTemplateSlots) {
            // implicit default slot (on component)
            slotsProperties.push(buildDefaultSlotProperty(undefined, children));
        }
        else if (implicitDefaultChildren.length &&
            // #3766
            // with whitespace: 'preserve', whitespaces between slots will end up in
            // implicitDefaultChildren. Ignore if all implicit children are whitespaces.
            implicitDefaultChildren.some(node => isNonWhitespaceContent(node))) {
            // implicit default slot (mixed with named slots)
            if (hasNamedDefaultSlot) {
                context.onError(createCompilerError(39 /* X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN */, implicitDefaultChildren[0].loc));
            }
            else {
                slotsProperties.push(buildDefaultSlotProperty(undefined, implicitDefaultChildren));
            }
        }
    }
    const slotFlag = hasDynamicSlots
        ? 2 /* DYNAMIC */
        : hasForwardedSlots(node.children)
            ? 3 /* FORWARDED */
            : 1 /* STABLE */;
    let slots = createObjectExpression(slotsProperties.concat(createObjectProperty(`_`, 
    // 2 = compiled but dynamic = can skip normalization, but must run diff
    // 1 = compiled and static = can skip normalization AND diff as optimized
    createSimpleExpression(slotFlag + (( true) ? ` /* ${_vue_shared__WEBPACK_IMPORTED_MODULE_0__.slotFlagsText[slotFlag]} */` : 0), false))), loc);
    if (dynamicSlots.length) {
        slots = createCallExpression(context.helper(CREATE_SLOTS), [
            slots,
            createArrayExpression(dynamicSlots)
        ]);
    }
    return {
        slots,
        hasDynamicSlots
    };
}
function buildDynamicSlot(name, fn) {
    return createObjectExpression([
        createObjectProperty(`name`, name),
        createObjectProperty(`fn`, fn)
    ]);
}
function hasForwardedSlots(children) {
    for (let i = 0; i < children.length; i++) {
        const child = children[i];
        switch (child.type) {
            case 1 /* ELEMENT */:
                if (child.tagType === 2 /* SLOT */ ||
                    hasForwardedSlots(child.children)) {
                    return true;
                }
                break;
            case 9 /* IF */:
                if (hasForwardedSlots(child.branches))
                    return true;
                break;
            case 10 /* IF_BRANCH */:
            case 11 /* FOR */:
                if (hasForwardedSlots(child.children))
                    return true;
                break;
        }
    }
    return false;
}
function isNonWhitespaceContent(node) {
    if (node.type !== 2 /* TEXT */ && node.type !== 12 /* TEXT_CALL */)
        return true;
    return node.type === 2 /* TEXT */
        ? !!node.content.trim()
        : isNonWhitespaceContent(node.content);
}

// some directive transforms (e.g. v-model) may return a symbol for runtime
// import, which should be used instead of a resolveDirective call.
const directiveImportMap = new WeakMap();
// generate a JavaScript AST for this element's codegen
const transformElement = (node, context) => {
    // perform the work on exit, after all child expressions have been
    // processed and merged.
    return function postTransformElement() {
        node = context.currentNode;
        if (!(node.type === 1 /* ELEMENT */ &&
            (node.tagType === 0 /* ELEMENT */ ||
                node.tagType === 1 /* COMPONENT */))) {
            return;
        }
        const { tag, props } = node;
        const isComponent = node.tagType === 1 /* COMPONENT */;
        // The goal of the transform is to create a codegenNode implementing the
        // VNodeCall interface.
        let vnodeTag = isComponent
            ? resolveComponentType(node, context)
            : `"${tag}"`;
        const isDynamicComponent = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(vnodeTag) && vnodeTag.callee === RESOLVE_DYNAMIC_COMPONENT;
        let vnodeProps;
        let vnodeChildren;
        let vnodePatchFlag;
        let patchFlag = 0;
        let vnodeDynamicProps;
        let dynamicPropNames;
        let vnodeDirectives;
        let shouldUseBlock = 
        // dynamic component may resolve to plain elements
        isDynamicComponent ||
            vnodeTag === TELEPORT ||
            vnodeTag === SUSPENSE ||
            (!isComponent &&
                // <svg> and <foreignObject> must be forced into blocks so that block
                // updates inside get proper isSVG flag at runtime. (#639, #643)
                // This is technically web-specific, but splitting the logic out of core
                // leads to too much unnecessary complexity.
                (tag === 'svg' || tag === 'foreignObject'));
        // props
        if (props.length > 0) {
            const propsBuildResult = buildProps(node, context);
            vnodeProps = propsBuildResult.props;
            patchFlag = propsBuildResult.patchFlag;
            dynamicPropNames = propsBuildResult.dynamicPropNames;
            const directives = propsBuildResult.directives;
            vnodeDirectives =
                directives && directives.length
                    ? createArrayExpression(directives.map(dir => buildDirectiveArgs(dir, context)))
                    : undefined;
            if (propsBuildResult.shouldUseBlock) {
                shouldUseBlock = true;
            }
        }
        // children
        if (node.children.length > 0) {
            if (vnodeTag === KEEP_ALIVE) {
                // Although a built-in component, we compile KeepAlive with raw children
                // instead of slot functions so that it can be used inside Transition
                // or other Transition-wrapping HOCs.
                // To ensure correct updates with block optimizations, we need to:
                // 1. Force keep-alive into a block. This avoids its children being
                //    collected by a parent block.
                shouldUseBlock = true;
                // 2. Force keep-alive to always be updated, since it uses raw children.
                patchFlag |= 1024 /* DYNAMIC_SLOTS */;
                if (( true) && node.children.length > 1) {
                    context.onError(createCompilerError(45 /* X_KEEP_ALIVE_INVALID_CHILDREN */, {
                        start: node.children[0].loc.start,
                        end: node.children[node.children.length - 1].loc.end,
                        source: ''
                    }));
                }
            }
            const shouldBuildAsSlots = isComponent &&
                // Teleport is not a real component and has dedicated runtime handling
                vnodeTag !== TELEPORT &&
                // explained above.
                vnodeTag !== KEEP_ALIVE;
            if (shouldBuildAsSlots) {
                const { slots, hasDynamicSlots } = buildSlots(node, context);
                vnodeChildren = slots;
                if (hasDynamicSlots) {
                    patchFlag |= 1024 /* DYNAMIC_SLOTS */;
                }
            }
            else if (node.children.length === 1 && vnodeTag !== TELEPORT) {
                const child = node.children[0];
                const type = child.type;
                // check for dynamic text children
                const hasDynamicTextChild = type === 5 /* INTERPOLATION */ ||
                    type === 8 /* COMPOUND_EXPRESSION */;
                if (hasDynamicTextChild &&
                    getConstantType(child, context) === 0 /* NOT_CONSTANT */) {
                    patchFlag |= 1 /* TEXT */;
                }
                // pass directly if the only child is a text node
                // (plain / interpolation / expression)
                if (hasDynamicTextChild || type === 2 /* TEXT */) {
                    vnodeChildren = child;
                }
                else {
                    vnodeChildren = node.children;
                }
            }
            else {
                vnodeChildren = node.children;
            }
        }
        // patchFlag & dynamicPropNames
        if (patchFlag !== 0) {
            if ((true)) {
                if (patchFlag < 0) {
                    // special flags (negative and mutually exclusive)
                    vnodePatchFlag = patchFlag + ` /* ${_vue_shared__WEBPACK_IMPORTED_MODULE_0__.PatchFlagNames[patchFlag]} */`;
                }
                else {
                    // bitwise flags
                    const flagNames = Object.keys(_vue_shared__WEBPACK_IMPORTED_MODULE_0__.PatchFlagNames)
                        .map(Number)
                        .filter(n => n > 0 && patchFlag & n)
                        .map(n => _vue_shared__WEBPACK_IMPORTED_MODULE_0__.PatchFlagNames[n])
                        .join(`, `);
                    vnodePatchFlag = patchFlag + ` /* ${flagNames} */`;
                }
            }
            else {}
            if (dynamicPropNames && dynamicPropNames.length) {
                vnodeDynamicProps = stringifyDynamicPropNames(dynamicPropNames);
            }
        }
        node.codegenNode = createVNodeCall(context, vnodeTag, vnodeProps, vnodeChildren, vnodePatchFlag, vnodeDynamicProps, vnodeDirectives, !!shouldUseBlock, false /* disableTracking */, isComponent, node.loc);
    };
};
function resolveComponentType(node, context, ssr = false) {
    let { tag } = node;
    // 1. dynamic component
    const isExplicitDynamic = isComponentTag(tag);
    const isProp = findProp(node, 'is');
    if (isProp) {
        if (isExplicitDynamic ||
            (isCompatEnabled("COMPILER_IS_ON_ELEMENT" /* COMPILER_IS_ON_ELEMENT */, context))) {
            const exp = isProp.type === 6 /* ATTRIBUTE */
                ? isProp.value && createSimpleExpression(isProp.value.content, true)
                : isProp.exp;
            if (exp) {
                return createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT), [
                    exp
                ]);
            }
        }
        else if (isProp.type === 6 /* ATTRIBUTE */ &&
            isProp.value.content.startsWith('vue:')) {
            // <button is="vue:xxx">
            // if not <component>, only is value that starts with "vue:" will be
            // treated as component by the parse phase and reach here, unless it's
            // compat mode where all is values are considered components
            tag = isProp.value.content.slice(4);
        }
    }
    // 1.5 v-is (TODO: Deprecate)
    const isDir = !isExplicitDynamic && findDir(node, 'is');
    if (isDir && isDir.exp) {
        return createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT), [
            isDir.exp
        ]);
    }
    // 2. built-in components (Teleport, Transition, KeepAlive, Suspense...)
    const builtIn = isCoreComponent(tag) || context.isBuiltInComponent(tag);
    if (builtIn) {
        // built-ins are simply fallthroughs / have special handling during ssr
        // so we don't need to import their runtime equivalents
        if (!ssr)
            context.helper(builtIn);
        return builtIn;
    }
    // 5. user component (resolve)
    context.helper(RESOLVE_COMPONENT);
    context.components.add(tag);
    return toValidAssetId(tag, `component`);
}
function buildProps(node, context, props = node.props, ssr = false) {
    const { tag, loc: elementLoc, children } = node;
    const isComponent = node.tagType === 1 /* COMPONENT */;
    let properties = [];
    const mergeArgs = [];
    const runtimeDirectives = [];
    const hasChildren = children.length > 0;
    let shouldUseBlock = false;
    // patchFlag analysis
    let patchFlag = 0;
    let hasRef = false;
    let hasClassBinding = false;
    let hasStyleBinding = false;
    let hasHydrationEventBinding = false;
    let hasDynamicKeys = false;
    let hasVnodeHook = false;
    const dynamicPropNames = [];
    const analyzePatchFlag = ({ key, value }) => {
        if (isStaticExp(key)) {
            const name = key.content;
            const isEventHandler = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isOn)(name);
            if (!isComponent &&
                isEventHandler &&
                // omit the flag for click handlers because hydration gives click
                // dedicated fast path.
                name.toLowerCase() !== 'onclick' &&
                // omit v-model handlers
                name !== 'onUpdate:modelValue' &&
                // omit onVnodeXXX hooks
                !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isReservedProp)(name)) {
                hasHydrationEventBinding = true;
            }
            if (isEventHandler && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isReservedProp)(name)) {
                hasVnodeHook = true;
            }
            if (value.type === 20 /* JS_CACHE_EXPRESSION */ ||
                ((value.type === 4 /* SIMPLE_EXPRESSION */ ||
                    value.type === 8 /* COMPOUND_EXPRESSION */) &&
                    getConstantType(value, context) > 0)) {
                // skip if the prop is a cached handler or has constant value
                return;
            }
            if (name === 'ref') {
                hasRef = true;
            }
            else if (name === 'class') {
                hasClassBinding = true;
            }
            else if (name === 'style') {
                hasStyleBinding = true;
            }
            else if (name !== 'key' && !dynamicPropNames.includes(name)) {
                dynamicPropNames.push(name);
            }
            // treat the dynamic class and style binding of the component as dynamic props
            if (isComponent &&
                (name === 'class' || name === 'style') &&
                !dynamicPropNames.includes(name)) {
                dynamicPropNames.push(name);
            }
        }
        else {
            hasDynamicKeys = true;
        }
    };
    for (let i = 0; i < props.length; i++) {
        // static attribute
        const prop = props[i];
        if (prop.type === 6 /* ATTRIBUTE */) {
            const { loc, name, value } = prop;
            let isStatic = true;
            if (name === 'ref') {
                hasRef = true;
                if (context.scopes.vFor > 0) {
                    properties.push(createObjectProperty(createSimpleExpression('ref_for', true), createSimpleExpression('true')));
                }
            }
            // skip is on <component>, or is="vue:xxx"
            if (name === 'is' &&
                (isComponentTag(tag) ||
                    (value && value.content.startsWith('vue:')) ||
                    (isCompatEnabled("COMPILER_IS_ON_ELEMENT" /* COMPILER_IS_ON_ELEMENT */, context)))) {
                continue;
            }
            properties.push(createObjectProperty(createSimpleExpression(name, true, getInnerRange(loc, 0, name.length)), createSimpleExpression(value ? value.content : '', isStatic, value ? value.loc : loc)));
        }
        else {
            // directives
            const { name, arg, exp, loc } = prop;
            const isVBind = name === 'bind';
            const isVOn = name === 'on';
            // skip v-slot - it is handled by its dedicated transform.
            if (name === 'slot') {
                if (!isComponent) {
                    context.onError(createCompilerError(40 /* X_V_SLOT_MISPLACED */, loc));
                }
                continue;
            }
            // skip v-once/v-memo - they are handled by dedicated transforms.
            if (name === 'once' || name === 'memo') {
                continue;
            }
            // skip v-is and :is on <component>
            if (name === 'is' ||
                (isVBind &&
                    isStaticArgOf(arg, 'is') &&
                    (isComponentTag(tag) ||
                        (isCompatEnabled("COMPILER_IS_ON_ELEMENT" /* COMPILER_IS_ON_ELEMENT */, context))))) {
                continue;
            }
            // skip v-on in SSR compilation
            if (isVOn && ssr) {
                continue;
            }
            if (
            // #938: elements with dynamic keys should be forced into blocks
            (isVBind && isStaticArgOf(arg, 'key')) ||
                // inline before-update hooks need to force block so that it is invoked
                // before children
                (isVOn && hasChildren && isStaticArgOf(arg, 'vue:before-update'))) {
                shouldUseBlock = true;
            }
            if (isVBind && isStaticArgOf(arg, 'ref') && context.scopes.vFor > 0) {
                properties.push(createObjectProperty(createSimpleExpression('ref_for', true), createSimpleExpression('true')));
            }
            // special case for v-bind and v-on with no argument
            if (!arg && (isVBind || isVOn)) {
                hasDynamicKeys = true;
                if (exp) {
                    if (properties.length) {
                        mergeArgs.push(createObjectExpression(dedupeProperties(properties), elementLoc));
                        properties = [];
                    }
                    if (isVBind) {
                        {
                            // 2.x v-bind object order compat
                            if ((true)) {
                                const hasOverridableKeys = mergeArgs.some(arg => {
                                    if (arg.type === 15 /* JS_OBJECT_EXPRESSION */) {
                                        return arg.properties.some(({ key }) => {
                                            if (key.type !== 4 /* SIMPLE_EXPRESSION */ ||
                                                !key.isStatic) {
                                                return true;
                                            }
                                            return (key.content !== 'class' &&
                                                key.content !== 'style' &&
                                                !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isOn)(key.content));
                                        });
                                    }
                                    else {
                                        // dynamic expression
                                        return true;
                                    }
                                });
                                if (hasOverridableKeys) {
                                    checkCompatEnabled("COMPILER_V_BIND_OBJECT_ORDER" /* COMPILER_V_BIND_OBJECT_ORDER */, context, loc);
                                }
                            }
                            if (isCompatEnabled("COMPILER_V_BIND_OBJECT_ORDER" /* COMPILER_V_BIND_OBJECT_ORDER */, context)) {
                                mergeArgs.unshift(exp);
                                continue;
                            }
                        }
                        mergeArgs.push(exp);
                    }
                    else {
                        // v-on="obj" -> toHandlers(obj)
                        mergeArgs.push({
                            type: 14 /* JS_CALL_EXPRESSION */,
                            loc,
                            callee: context.helper(TO_HANDLERS),
                            arguments: [exp]
                        });
                    }
                }
                else {
                    context.onError(createCompilerError(isVBind
                        ? 34 /* X_V_BIND_NO_EXPRESSION */
                        : 35 /* X_V_ON_NO_EXPRESSION */, loc));
                }
                continue;
            }
            const directiveTransform = context.directiveTransforms[name];
            if (directiveTransform) {
                // has built-in directive transform.
                const { props, needRuntime } = directiveTransform(prop, node, context);
                !ssr && props.forEach(analyzePatchFlag);
                properties.push(...props);
                if (needRuntime) {
                    runtimeDirectives.push(prop);
                    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isSymbol)(needRuntime)) {
                        directiveImportMap.set(prop, needRuntime);
                    }
                }
            }
            else if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isBuiltInDirective)(name)) {
                // no built-in transform, this is a user custom directive.
                runtimeDirectives.push(prop);
                // custom dirs may use beforeUpdate so they need to force blocks
                // to ensure before-update gets called before children update
                if (hasChildren) {
                    shouldUseBlock = true;
                }
            }
        }
    }
    let propsExpression = undefined;
    // has v-bind="object" or v-on="object", wrap with mergeProps
    if (mergeArgs.length) {
        if (properties.length) {
            mergeArgs.push(createObjectExpression(dedupeProperties(properties), elementLoc));
        }
        if (mergeArgs.length > 1) {
            propsExpression = createCallExpression(context.helper(MERGE_PROPS), mergeArgs, elementLoc);
        }
        else {
            // single v-bind with nothing else - no need for a mergeProps call
            propsExpression = mergeArgs[0];
        }
    }
    else if (properties.length) {
        propsExpression = createObjectExpression(dedupeProperties(properties), elementLoc);
    }
    // patchFlag analysis
    if (hasDynamicKeys) {
        patchFlag |= 16 /* FULL_PROPS */;
    }
    else {
        if (hasClassBinding && !isComponent) {
            patchFlag |= 2 /* CLASS */;
        }
        if (hasStyleBinding && !isComponent) {
            patchFlag |= 4 /* STYLE */;
        }
        if (dynamicPropNames.length) {
            patchFlag |= 8 /* PROPS */;
        }
        if (hasHydrationEventBinding) {
            patchFlag |= 32 /* HYDRATE_EVENTS */;
        }
    }
    if (!shouldUseBlock &&
        (patchFlag === 0 || patchFlag === 32 /* HYDRATE_EVENTS */) &&
        (hasRef || hasVnodeHook || runtimeDirectives.length > 0)) {
        patchFlag |= 512 /* NEED_PATCH */;
    }
    // pre-normalize props, SSR is skipped for now
    if (!context.inSSR && propsExpression) {
        switch (propsExpression.type) {
            case 15 /* JS_OBJECT_EXPRESSION */:
                // means that there is no v-bind,
                // but still need to deal with dynamic key binding
                let classKeyIndex = -1;
                let styleKeyIndex = -1;
                let hasDynamicKey = false;
                for (let i = 0; i < propsExpression.properties.length; i++) {
                    const key = propsExpression.properties[i].key;
                    if (isStaticExp(key)) {
                        if (key.content === 'class') {
                            classKeyIndex = i;
                        }
                        else if (key.content === 'style') {
                            styleKeyIndex = i;
                        }
                    }
                    else if (!key.isHandlerKey) {
                        hasDynamicKey = true;
                    }
                }
                const classProp = propsExpression.properties[classKeyIndex];
                const styleProp = propsExpression.properties[styleKeyIndex];
                // no dynamic key
                if (!hasDynamicKey) {
                    if (classProp && !isStaticExp(classProp.value)) {
                        classProp.value = createCallExpression(context.helper(NORMALIZE_CLASS), [classProp.value]);
                    }
                    if (styleProp &&
                        !isStaticExp(styleProp.value) &&
                        // the static style is compiled into an object,
                        // so use `hasStyleBinding` to ensure that it is a dynamic style binding
                        (hasStyleBinding ||
                            // v-bind:style and style both exist,
                            // v-bind:style with static literal object
                            styleProp.value.type === 17 /* JS_ARRAY_EXPRESSION */)) {
                        styleProp.value = createCallExpression(context.helper(NORMALIZE_STYLE), [styleProp.value]);
                    }
                }
                else {
                    // dynamic key binding, wrap with `normalizeProps`
                    propsExpression = createCallExpression(context.helper(NORMALIZE_PROPS), [propsExpression]);
                }
                break;
            case 14 /* JS_CALL_EXPRESSION */:
                // mergeProps call, do nothing
                break;
            default:
                // single v-bind
                propsExpression = createCallExpression(context.helper(NORMALIZE_PROPS), [
                    createCallExpression(context.helper(GUARD_REACTIVE_PROPS), [
                        propsExpression
                    ])
                ]);
                break;
        }
    }
    return {
        props: propsExpression,
        directives: runtimeDirectives,
        patchFlag,
        dynamicPropNames,
        shouldUseBlock
    };
}
// Dedupe props in an object literal.
// Literal duplicated attributes would have been warned during the parse phase,
// however, it's possible to encounter duplicated `onXXX` handlers with different
// modifiers. We also need to merge static and dynamic class / style attributes.
// - onXXX handlers / style: merge into array
// - class: merge into single expression with concatenation
function dedupeProperties(properties) {
    const knownProps = new Map();
    const deduped = [];
    for (let i = 0; i < properties.length; i++) {
        const prop = properties[i];
        // dynamic keys are always allowed
        if (prop.key.type === 8 /* COMPOUND_EXPRESSION */ || !prop.key.isStatic) {
            deduped.push(prop);
            continue;
        }
        const name = prop.key.content;
        const existing = knownProps.get(name);
        if (existing) {
            if (name === 'style' || name === 'class' || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isOn)(name)) {
                mergeAsArray(existing, prop);
            }
            // unexpected duplicate, should have emitted error during parse
        }
        else {
            knownProps.set(name, prop);
            deduped.push(prop);
        }
    }
    return deduped;
}
function mergeAsArray(existing, incoming) {
    if (existing.value.type === 17 /* JS_ARRAY_EXPRESSION */) {
        existing.value.elements.push(incoming.value);
    }
    else {
        existing.value = createArrayExpression([existing.value, incoming.value], existing.loc);
    }
}
function buildDirectiveArgs(dir, context) {
    const dirArgs = [];
    const runtime = directiveImportMap.get(dir);
    if (runtime) {
        // built-in directive with runtime
        dirArgs.push(context.helperString(runtime));
    }
    else {
        {
            // inject statement for resolving directive
            context.helper(RESOLVE_DIRECTIVE);
            context.directives.add(dir.name);
            dirArgs.push(toValidAssetId(dir.name, `directive`));
        }
    }
    const { loc } = dir;
    if (dir.exp)
        dirArgs.push(dir.exp);
    if (dir.arg) {
        if (!dir.exp) {
            dirArgs.push(`void 0`);
        }
        dirArgs.push(dir.arg);
    }
    if (Object.keys(dir.modifiers).length) {
        if (!dir.arg) {
            if (!dir.exp) {
                dirArgs.push(`void 0`);
            }
            dirArgs.push(`void 0`);
        }
        const trueExpression = createSimpleExpression(`true`, false, loc);
        dirArgs.push(createObjectExpression(dir.modifiers.map(modifier => createObjectProperty(modifier, trueExpression)), loc));
    }
    return createArrayExpression(dirArgs, dir.loc);
}
function stringifyDynamicPropNames(props) {
    let propsNamesString = `[`;
    for (let i = 0, l = props.length; i < l; i++) {
        propsNamesString += JSON.stringify(props[i]);
        if (i < l - 1)
            propsNamesString += ', ';
    }
    return propsNamesString + `]`;
}
function isComponentTag(tag) {
    return tag === 'component' || tag === 'Component';
}

( true)
    ? Object.freeze({})
    : 0;
( true) ? Object.freeze([]) : 0;
const cacheStringFunction = (fn) => {
    const cache = Object.create(null);
    return ((str) => {
        const hit = cache[str];
        return hit || (cache[str] = fn(str));
    });
};
const camelizeRE = /-(\w)/g;
/**
 * @private
 */
const camelize = cacheStringFunction((str) => {
    return str.replace(camelizeRE, (_, c) => (c ? c.toUpperCase() : ''));
});

const transformSlotOutlet = (node, context) => {
    if (isSlotOutlet(node)) {
        const { children, loc } = node;
        const { slotName, slotProps } = processSlotOutlet(node, context);
        const slotArgs = [
            context.prefixIdentifiers ? `_ctx.$slots` : `$slots`,
            slotName,
            '{}',
            'undefined',
            'true'
        ];
        let expectedLen = 2;
        if (slotProps) {
            slotArgs[2] = slotProps;
            expectedLen = 3;
        }
        if (children.length) {
            slotArgs[3] = createFunctionExpression([], children, false, false, loc);
            expectedLen = 4;
        }
        if (context.scopeId && !context.slotted) {
            expectedLen = 5;
        }
        slotArgs.splice(expectedLen); // remove unused arguments
        node.codegenNode = createCallExpression(context.helper(RENDER_SLOT), slotArgs, loc);
    }
};
function processSlotOutlet(node, context) {
    let slotName = `"default"`;
    let slotProps = undefined;
    const nonNameProps = [];
    for (let i = 0; i < node.props.length; i++) {
        const p = node.props[i];
        if (p.type === 6 /* ATTRIBUTE */) {
            if (p.value) {
                if (p.name === 'name') {
                    slotName = JSON.stringify(p.value.content);
                }
                else {
                    p.name = camelize(p.name);
                    nonNameProps.push(p);
                }
            }
        }
        else {
            if (p.name === 'bind' && isStaticArgOf(p.arg, 'name')) {
                if (p.exp)
                    slotName = p.exp;
            }
            else {
                if (p.name === 'bind' && p.arg && isStaticExp(p.arg)) {
                    p.arg.content = camelize(p.arg.content);
                }
                nonNameProps.push(p);
            }
        }
    }
    if (nonNameProps.length > 0) {
        const { props, directives } = buildProps(node, context, nonNameProps);
        slotProps = props;
        if (directives.length) {
            context.onError(createCompilerError(36 /* X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET */, directives[0].loc));
        }
    }
    return {
        slotName,
        slotProps
    };
}

const fnExpRE = /^\s*([\w$_]+|(async\s*)?\([^)]*?\))\s*=>|^\s*(async\s+)?function(?:\s+[\w$]+)?\s*\(/;
const transformOn = (dir, node, context, augmentor) => {
    const { loc, modifiers, arg } = dir;
    if (!dir.exp && !modifiers.length) {
        context.onError(createCompilerError(35 /* X_V_ON_NO_EXPRESSION */, loc));
    }
    let eventName;
    if (arg.type === 4 /* SIMPLE_EXPRESSION */) {
        if (arg.isStatic) {
            let rawName = arg.content;
            // TODO deprecate @vnodeXXX usage
            if (rawName.startsWith('vue:')) {
                rawName = `vnode-${rawName.slice(4)}`;
            }
            // for all event listeners, auto convert it to camelCase. See issue #2249
            eventName = createSimpleExpression((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.toHandlerKey)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.camelize)(rawName)), true, arg.loc);
        }
        else {
            // #2388
            eventName = createCompoundExpression([
                `${context.helperString(TO_HANDLER_KEY)}(`,
                arg,
                `)`
            ]);
        }
    }
    else {
        // already a compound expression.
        eventName = arg;
        eventName.children.unshift(`${context.helperString(TO_HANDLER_KEY)}(`);
        eventName.children.push(`)`);
    }
    // handler processing
    let exp = dir.exp;
    if (exp && !exp.content.trim()) {
        exp = undefined;
    }
    let shouldCache = context.cacheHandlers && !exp && !context.inVOnce;
    if (exp) {
        const isMemberExp = isMemberExpression(exp.content);
        const isInlineStatement = !(isMemberExp || fnExpRE.test(exp.content));
        const hasMultipleStatements = exp.content.includes(`;`);
        if (true) {
            validateBrowserExpression(exp, context, false, hasMultipleStatements);
        }
        if (isInlineStatement || (shouldCache && isMemberExp)) {
            // wrap inline statement in a function expression
            exp = createCompoundExpression([
                `${isInlineStatement
                    ? `$event`
                    : `${``}(...args)`} => ${hasMultipleStatements ? `{` : `(`}`,
                exp,
                hasMultipleStatements ? `}` : `)`
            ]);
        }
    }
    let ret = {
        props: [
            createObjectProperty(eventName, exp || createSimpleExpression(`() => {}`, false, loc))
        ]
    };
    // apply extended compiler augmentor
    if (augmentor) {
        ret = augmentor(ret);
    }
    if (shouldCache) {
        // cache handlers so that it's always the same handler being passed down.
        // this avoids unnecessary re-renders when users use inline handlers on
        // components.
        ret.props[0].value = context.cache(ret.props[0].value);
    }
    // mark the key as handler for props normalization check
    ret.props.forEach(p => (p.key.isHandlerKey = true));
    return ret;
};

// v-bind without arg is handled directly in ./transformElements.ts due to it affecting
// codegen for the entire props object. This transform here is only for v-bind
// *with* args.
const transformBind = (dir, _node, context) => {
    const { exp, modifiers, loc } = dir;
    const arg = dir.arg;
    if (arg.type !== 4 /* SIMPLE_EXPRESSION */) {
        arg.children.unshift(`(`);
        arg.children.push(`) || ""`);
    }
    else if (!arg.isStatic) {
        arg.content = `${arg.content} || ""`;
    }
    // .sync is replaced by v-model:arg
    if (modifiers.includes('camel')) {
        if (arg.type === 4 /* SIMPLE_EXPRESSION */) {
            if (arg.isStatic) {
                arg.content = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.camelize)(arg.content);
            }
            else {
                arg.content = `${context.helperString(CAMELIZE)}(${arg.content})`;
            }
        }
        else {
            arg.children.unshift(`${context.helperString(CAMELIZE)}(`);
            arg.children.push(`)`);
        }
    }
    if (!context.inSSR) {
        if (modifiers.includes('prop')) {
            injectPrefix(arg, '.');
        }
        if (modifiers.includes('attr')) {
            injectPrefix(arg, '^');
        }
    }
    if (!exp ||
        (exp.type === 4 /* SIMPLE_EXPRESSION */ && !exp.content.trim())) {
        context.onError(createCompilerError(34 /* X_V_BIND_NO_EXPRESSION */, loc));
        return {
            props: [createObjectProperty(arg, createSimpleExpression('', true, loc))]
        };
    }
    return {
        props: [createObjectProperty(arg, exp)]
    };
};
const injectPrefix = (arg, prefix) => {
    if (arg.type === 4 /* SIMPLE_EXPRESSION */) {
        if (arg.isStatic) {
            arg.content = prefix + arg.content;
        }
        else {
            arg.content = `\`${prefix}\${${arg.content}}\``;
        }
    }
    else {
        arg.children.unshift(`'${prefix}' + (`);
        arg.children.push(`)`);
    }
};

// Merge adjacent text nodes and expressions into a single expression
// e.g. <div>abc {{ d }} {{ e }}</div> should have a single expression node as child.
const transformText = (node, context) => {
    if (node.type === 0 /* ROOT */ ||
        node.type === 1 /* ELEMENT */ ||
        node.type === 11 /* FOR */ ||
        node.type === 10 /* IF_BRANCH */) {
        // perform the transform on node exit so that all expressions have already
        // been processed.
        return () => {
            const children = node.children;
            let currentContainer = undefined;
            let hasText = false;
            for (let i = 0; i < children.length; i++) {
                const child = children[i];
                if (isText(child)) {
                    hasText = true;
                    for (let j = i + 1; j < children.length; j++) {
                        const next = children[j];
                        if (isText(next)) {
                            if (!currentContainer) {
                                currentContainer = children[i] = {
                                    type: 8 /* COMPOUND_EXPRESSION */,
                                    loc: child.loc,
                                    children: [child]
                                };
                            }
                            // merge adjacent text node into current
                            currentContainer.children.push(` + `, next);
                            children.splice(j, 1);
                            j--;
                        }
                        else {
                            currentContainer = undefined;
                            break;
                        }
                    }
                }
            }
            if (!hasText ||
                // if this is a plain element with a single text child, leave it
                // as-is since the runtime has dedicated fast path for this by directly
                // setting textContent of the element.
                // for component root it's always normalized anyway.
                (children.length === 1 &&
                    (node.type === 0 /* ROOT */ ||
                        (node.type === 1 /* ELEMENT */ &&
                            node.tagType === 0 /* ELEMENT */ &&
                            // #3756
                            // custom directives can potentially add DOM elements arbitrarily,
                            // we need to avoid setting textContent of the element at runtime
                            // to avoid accidentally overwriting the DOM elements added
                            // by the user through custom directives.
                            !node.props.find(p => p.type === 7 /* DIRECTIVE */ &&
                                !context.directiveTransforms[p.name]) &&
                            // in compat mode, <template> tags with no special directives
                            // will be rendered as a fragment so its children must be
                            // converted into vnodes.
                            !(node.tag === 'template'))))) {
                return;
            }
            // pre-convert text nodes into createTextVNode(text) calls to avoid
            // runtime normalization.
            for (let i = 0; i < children.length; i++) {
                const child = children[i];
                if (isText(child) || child.type === 8 /* COMPOUND_EXPRESSION */) {
                    const callArgs = [];
                    // createTextVNode defaults to single whitespace, so if it is a
                    // single space the code could be an empty call to save bytes.
                    if (child.type !== 2 /* TEXT */ || child.content !== ' ') {
                        callArgs.push(child);
                    }
                    // mark dynamic text with flag so it gets patched inside a block
                    if (!context.ssr &&
                        getConstantType(child, context) === 0 /* NOT_CONSTANT */) {
                        callArgs.push(1 /* TEXT */ +
                            (( true) ? ` /* ${_vue_shared__WEBPACK_IMPORTED_MODULE_0__.PatchFlagNames[1]} */` : 0));
                    }
                    children[i] = {
                        type: 12 /* TEXT_CALL */,
                        content: child,
                        loc: child.loc,
                        codegenNode: createCallExpression(context.helper(CREATE_TEXT), callArgs)
                    };
                }
            }
        };
    }
};

const seen = new WeakSet();
const transformOnce = (node, context) => {
    if (node.type === 1 /* ELEMENT */ && findDir(node, 'once', true)) {
        if (seen.has(node) || context.inVOnce) {
            return;
        }
        seen.add(node);
        context.inVOnce = true;
        context.helper(SET_BLOCK_TRACKING);
        return () => {
            context.inVOnce = false;
            const cur = context.currentNode;
            if (cur.codegenNode) {
                cur.codegenNode = context.cache(cur.codegenNode, true /* isVNode */);
            }
        };
    }
};

const transformModel = (dir, node, context) => {
    const { exp, arg } = dir;
    if (!exp) {
        context.onError(createCompilerError(41 /* X_V_MODEL_NO_EXPRESSION */, dir.loc));
        return createTransformProps();
    }
    const rawExp = exp.loc.source;
    const expString = exp.type === 4 /* SIMPLE_EXPRESSION */ ? exp.content : rawExp;
    // im SFC <script setup> inline mode, the exp may have been transformed into
    // _unref(exp)
    context.bindingMetadata[rawExp];
    const maybeRef = !true    /* SETUP_CONST */;
    if (!expString.trim() ||
        (!isMemberExpression(expString) && !maybeRef)) {
        context.onError(createCompilerError(42 /* X_V_MODEL_MALFORMED_EXPRESSION */, exp.loc));
        return createTransformProps();
    }
    const propName = arg ? arg : createSimpleExpression('modelValue', true);
    const eventName = arg
        ? isStaticExp(arg)
            ? `onUpdate:${arg.content}`
            : createCompoundExpression(['"onUpdate:" + ', arg])
        : `onUpdate:modelValue`;
    let assignmentExp;
    const eventArg = context.isTS ? `($event: any)` : `$event`;
    {
        assignmentExp = createCompoundExpression([
            `${eventArg} => ((`,
            exp,
            `) = $event)`
        ]);
    }
    const props = [
        // modelValue: foo
        createObjectProperty(propName, dir.exp),
        // "onUpdate:modelValue": $event => (foo = $event)
        createObjectProperty(eventName, assignmentExp)
    ];
    // modelModifiers: { foo: true, "bar-baz": true }
    if (dir.modifiers.length && node.tagType === 1 /* COMPONENT */) {
        const modifiers = dir.modifiers
            .map(m => (isSimpleIdentifier(m) ? m : JSON.stringify(m)) + `: true`)
            .join(`, `);
        const modifiersKey = arg
            ? isStaticExp(arg)
                ? `${arg.content}Modifiers`
                : createCompoundExpression([arg, ' + "Modifiers"'])
            : `modelModifiers`;
        props.push(createObjectProperty(modifiersKey, createSimpleExpression(`{ ${modifiers} }`, false, dir.loc, 2 /* CAN_HOIST */)));
    }
    return createTransformProps(props);
};
function createTransformProps(props = []) {
    return { props };
}

const validDivisionCharRE = /[\w).+\-_$\]]/;
const transformFilter = (node, context) => {
    if (!isCompatEnabled("COMPILER_FILTER" /* COMPILER_FILTERS */, context)) {
        return;
    }
    if (node.type === 5 /* INTERPOLATION */) {
        // filter rewrite is applied before expression transform so only
        // simple expressions are possible at this stage
        rewriteFilter(node.content, context);
    }
    if (node.type === 1 /* ELEMENT */) {
        node.props.forEach((prop) => {
            if (prop.type === 7 /* DIRECTIVE */ &&
                prop.name !== 'for' &&
                prop.exp) {
                rewriteFilter(prop.exp, context);
            }
        });
    }
};
function rewriteFilter(node, context) {
    if (node.type === 4 /* SIMPLE_EXPRESSION */) {
        parseFilter(node, context);
    }
    else {
        for (let i = 0; i < node.children.length; i++) {
            const child = node.children[i];
            if (typeof child !== 'object')
                continue;
            if (child.type === 4 /* SIMPLE_EXPRESSION */) {
                parseFilter(child, context);
            }
            else if (child.type === 8 /* COMPOUND_EXPRESSION */) {
                rewriteFilter(node, context);
            }
            else if (child.type === 5 /* INTERPOLATION */) {
                rewriteFilter(child.content, context);
            }
        }
    }
}
function parseFilter(node, context) {
    const exp = node.content;
    let inSingle = false;
    let inDouble = false;
    let inTemplateString = false;
    let inRegex = false;
    let curly = 0;
    let square = 0;
    let paren = 0;
    let lastFilterIndex = 0;
    let c, prev, i, expression, filters = [];
    for (i = 0; i < exp.length; i++) {
        prev = c;
        c = exp.charCodeAt(i);
        if (inSingle) {
            if (c === 0x27 && prev !== 0x5c)
                inSingle = false;
        }
        else if (inDouble) {
            if (c === 0x22 && prev !== 0x5c)
                inDouble = false;
        }
        else if (inTemplateString) {
            if (c === 0x60 && prev !== 0x5c)
                inTemplateString = false;
        }
        else if (inRegex) {
            if (c === 0x2f && prev !== 0x5c)
                inRegex = false;
        }
        else if (c === 0x7c && // pipe
            exp.charCodeAt(i + 1) !== 0x7c &&
            exp.charCodeAt(i - 1) !== 0x7c &&
            !curly &&
            !square &&
            !paren) {
            if (expression === undefined) {
                // first filter, end of expression
                lastFilterIndex = i + 1;
                expression = exp.slice(0, i).trim();
            }
            else {
                pushFilter();
            }
        }
        else {
            switch (c) {
                case 0x22:
                    inDouble = true;
                    break; // "
                case 0x27:
                    inSingle = true;
                    break; // '
                case 0x60:
                    inTemplateString = true;
                    break; // `
                case 0x28:
                    paren++;
                    break; // (
                case 0x29:
                    paren--;
                    break; // )
                case 0x5b:
                    square++;
                    break; // [
                case 0x5d:
                    square--;
                    break; // ]
                case 0x7b:
                    curly++;
                    break; // {
                case 0x7d:
                    curly--;
                    break; // }
            }
            if (c === 0x2f) {
                // /
                let j = i - 1;
                let p;
                // find first non-whitespace prev char
                for (; j >= 0; j--) {
                    p = exp.charAt(j);
                    if (p !== ' ')
                        break;
                }
                if (!p || !validDivisionCharRE.test(p)) {
                    inRegex = true;
                }
            }
        }
    }
    if (expression === undefined) {
        expression = exp.slice(0, i).trim();
    }
    else if (lastFilterIndex !== 0) {
        pushFilter();
    }
    function pushFilter() {
        filters.push(exp.slice(lastFilterIndex, i).trim());
        lastFilterIndex = i + 1;
    }
    if (filters.length) {
        ( true) &&
            warnDeprecation("COMPILER_FILTER" /* COMPILER_FILTERS */, context, node.loc);
        for (i = 0; i < filters.length; i++) {
            expression = wrapFilter(expression, filters[i], context);
        }
        node.content = expression;
    }
}
function wrapFilter(exp, filter, context) {
    context.helper(RESOLVE_FILTER);
    const i = filter.indexOf('(');
    if (i < 0) {
        context.filters.add(filter);
        return `${toValidAssetId(filter, 'filter')}(${exp})`;
    }
    else {
        const name = filter.slice(0, i);
        const args = filter.slice(i + 1);
        context.filters.add(name);
        return `${toValidAssetId(name, 'filter')}(${exp}${args !== ')' ? ',' + args : args}`;
    }
}

const seen$1 = new WeakSet();
const transformMemo = (node, context) => {
    if (node.type === 1 /* ELEMENT */) {
        const dir = findDir(node, 'memo');
        if (!dir || seen$1.has(node)) {
            return;
        }
        seen$1.add(node);
        return () => {
            const codegenNode = node.codegenNode ||
                context.currentNode.codegenNode;
            if (codegenNode && codegenNode.type === 13 /* VNODE_CALL */) {
                // non-component sub tree should be turned into a block
                if (node.tagType !== 1 /* COMPONENT */) {
                    makeBlock(codegenNode, context);
                }
                node.codegenNode = createCallExpression(context.helper(WITH_MEMO), [
                    dir.exp,
                    createFunctionExpression(undefined, codegenNode),
                    `_cache`,
                    String(context.cached++)
                ]);
            }
        };
    }
};

function getBaseTransformPreset(prefixIdentifiers) {
    return [
        [
            transformOnce,
            transformIf,
            transformMemo,
            transformFor,
            ...([transformFilter] ),
            ...(( true)
                    ? [transformExpression]
                    : 0),
            transformSlotOutlet,
            transformElement,
            trackSlotScopes,
            transformText
        ],
        {
            on: transformOn,
            bind: transformBind,
            model: transformModel
        }
    ];
}
// we name it `baseCompile` so that higher order compilers like
// @vue/compiler-dom can export `compile` while re-exporting everything else.
function baseCompile(template, options = {}) {
    const onError = options.onError || defaultOnError;
    const isModuleMode = options.mode === 'module';
    /* istanbul ignore if */
    {
        if (options.prefixIdentifiers === true) {
            onError(createCompilerError(46 /* X_PREFIX_ID_NOT_SUPPORTED */));
        }
        else if (isModuleMode) {
            onError(createCompilerError(47 /* X_MODULE_MODE_NOT_SUPPORTED */));
        }
    }
    const prefixIdentifiers = !true ;
    if (options.cacheHandlers) {
        onError(createCompilerError(48 /* X_CACHE_HANDLER_NOT_SUPPORTED */));
    }
    if (options.scopeId && !isModuleMode) {
        onError(createCompilerError(49 /* X_SCOPE_ID_NOT_SUPPORTED */));
    }
    const ast = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(template) ? baseParse(template, options) : template;
    const [nodeTransforms, directiveTransforms] = getBaseTransformPreset();
    transform(ast, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)({}, options, {
        prefixIdentifiers,
        nodeTransforms: [
            ...nodeTransforms,
            ...(options.nodeTransforms || []) // user transforms
        ],
        directiveTransforms: (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)({}, directiveTransforms, options.directiveTransforms || {} // user transforms
        )
    }));
    return generate(ast, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)({}, options, {
        prefixIdentifiers
    }));
}

const noopDirectiveTransform = () => ({ props: [] });




/***/ }),

/***/ "./node_modules/@vue/compiler-core/node_modules/@vue/shared/dist/shared.esm-bundler.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@vue/compiler-core/node_modules/@vue/shared/dist/shared.esm-bundler.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EMPTY_ARR": () => (/* binding */ EMPTY_ARR),
/* harmony export */   "EMPTY_OBJ": () => (/* binding */ EMPTY_OBJ),
/* harmony export */   "NO": () => (/* binding */ NO),
/* harmony export */   "NOOP": () => (/* binding */ NOOP),
/* harmony export */   "PatchFlagNames": () => (/* binding */ PatchFlagNames),
/* harmony export */   "camelize": () => (/* binding */ camelize),
/* harmony export */   "capitalize": () => (/* binding */ capitalize),
/* harmony export */   "def": () => (/* binding */ def),
/* harmony export */   "escapeHtml": () => (/* binding */ escapeHtml),
/* harmony export */   "escapeHtmlComment": () => (/* binding */ escapeHtmlComment),
/* harmony export */   "extend": () => (/* binding */ extend),
/* harmony export */   "generateCodeFrame": () => (/* binding */ generateCodeFrame),
/* harmony export */   "getGlobalThis": () => (/* binding */ getGlobalThis),
/* harmony export */   "hasChanged": () => (/* binding */ hasChanged),
/* harmony export */   "hasOwn": () => (/* binding */ hasOwn),
/* harmony export */   "hyphenate": () => (/* binding */ hyphenate),
/* harmony export */   "includeBooleanAttr": () => (/* binding */ includeBooleanAttr),
/* harmony export */   "invokeArrayFns": () => (/* binding */ invokeArrayFns),
/* harmony export */   "isArray": () => (/* binding */ isArray),
/* harmony export */   "isBooleanAttr": () => (/* binding */ isBooleanAttr),
/* harmony export */   "isBuiltInDirective": () => (/* binding */ isBuiltInDirective),
/* harmony export */   "isDate": () => (/* binding */ isDate),
/* harmony export */   "isFunction": () => (/* binding */ isFunction),
/* harmony export */   "isGloballyWhitelisted": () => (/* binding */ isGloballyWhitelisted),
/* harmony export */   "isHTMLTag": () => (/* binding */ isHTMLTag),
/* harmony export */   "isIntegerKey": () => (/* binding */ isIntegerKey),
/* harmony export */   "isKnownHtmlAttr": () => (/* binding */ isKnownHtmlAttr),
/* harmony export */   "isKnownSvgAttr": () => (/* binding */ isKnownSvgAttr),
/* harmony export */   "isMap": () => (/* binding */ isMap),
/* harmony export */   "isModelListener": () => (/* binding */ isModelListener),
/* harmony export */   "isNoUnitNumericStyleProp": () => (/* binding */ isNoUnitNumericStyleProp),
/* harmony export */   "isObject": () => (/* binding */ isObject),
/* harmony export */   "isOn": () => (/* binding */ isOn),
/* harmony export */   "isPlainObject": () => (/* binding */ isPlainObject),
/* harmony export */   "isPromise": () => (/* binding */ isPromise),
/* harmony export */   "isReservedProp": () => (/* binding */ isReservedProp),
/* harmony export */   "isSSRSafeAttrName": () => (/* binding */ isSSRSafeAttrName),
/* harmony export */   "isSVGTag": () => (/* binding */ isSVGTag),
/* harmony export */   "isSet": () => (/* binding */ isSet),
/* harmony export */   "isSpecialBooleanAttr": () => (/* binding */ isSpecialBooleanAttr),
/* harmony export */   "isString": () => (/* binding */ isString),
/* harmony export */   "isSymbol": () => (/* binding */ isSymbol),
/* harmony export */   "isVoidTag": () => (/* binding */ isVoidTag),
/* harmony export */   "looseEqual": () => (/* binding */ looseEqual),
/* harmony export */   "looseIndexOf": () => (/* binding */ looseIndexOf),
/* harmony export */   "makeMap": () => (/* binding */ makeMap),
/* harmony export */   "normalizeClass": () => (/* binding */ normalizeClass),
/* harmony export */   "normalizeProps": () => (/* binding */ normalizeProps),
/* harmony export */   "normalizeStyle": () => (/* binding */ normalizeStyle),
/* harmony export */   "objectToString": () => (/* binding */ objectToString),
/* harmony export */   "parseStringStyle": () => (/* binding */ parseStringStyle),
/* harmony export */   "propsToAttrMap": () => (/* binding */ propsToAttrMap),
/* harmony export */   "remove": () => (/* binding */ remove),
/* harmony export */   "slotFlagsText": () => (/* binding */ slotFlagsText),
/* harmony export */   "stringifyStyle": () => (/* binding */ stringifyStyle),
/* harmony export */   "toDisplayString": () => (/* binding */ toDisplayString),
/* harmony export */   "toHandlerKey": () => (/* binding */ toHandlerKey),
/* harmony export */   "toNumber": () => (/* binding */ toNumber),
/* harmony export */   "toRawType": () => (/* binding */ toRawType),
/* harmony export */   "toTypeString": () => (/* binding */ toTypeString)
/* harmony export */ });
/**
 * Make a map and return a function for checking if a key
 * is in that map.
 * IMPORTANT: all calls of this function must be prefixed with
 * \/\*#\_\_PURE\_\_\*\/
 * So that rollup can tree-shake them if necessary.
 */
function makeMap(str, expectsLowerCase) {
    const map = Object.create(null);
    const list = str.split(',');
    for (let i = 0; i < list.length; i++) {
        map[list[i]] = true;
    }
    return expectsLowerCase ? val => !!map[val.toLowerCase()] : val => !!map[val];
}

/**
 * dev only flag -> name mapping
 */
const PatchFlagNames = {
    [1 /* TEXT */]: `TEXT`,
    [2 /* CLASS */]: `CLASS`,
    [4 /* STYLE */]: `STYLE`,
    [8 /* PROPS */]: `PROPS`,
    [16 /* FULL_PROPS */]: `FULL_PROPS`,
    [32 /* HYDRATE_EVENTS */]: `HYDRATE_EVENTS`,
    [64 /* STABLE_FRAGMENT */]: `STABLE_FRAGMENT`,
    [128 /* KEYED_FRAGMENT */]: `KEYED_FRAGMENT`,
    [256 /* UNKEYED_FRAGMENT */]: `UNKEYED_FRAGMENT`,
    [512 /* NEED_PATCH */]: `NEED_PATCH`,
    [1024 /* DYNAMIC_SLOTS */]: `DYNAMIC_SLOTS`,
    [2048 /* DEV_ROOT_FRAGMENT */]: `DEV_ROOT_FRAGMENT`,
    [-1 /* HOISTED */]: `HOISTED`,
    [-2 /* BAIL */]: `BAIL`
};

/**
 * Dev only
 */
const slotFlagsText = {
    [1 /* STABLE */]: 'STABLE',
    [2 /* DYNAMIC */]: 'DYNAMIC',
    [3 /* FORWARDED */]: 'FORWARDED'
};

const GLOBALS_WHITE_LISTED = 'Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,' +
    'decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,' +
    'Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt';
const isGloballyWhitelisted = /*#__PURE__*/ makeMap(GLOBALS_WHITE_LISTED);

const range = 2;
function generateCodeFrame(source, start = 0, end = source.length) {
    // Split the content into individual lines but capture the newline sequence
    // that separated each line. This is important because the actual sequence is
    // needed to properly take into account the full line length for offset
    // comparison
    let lines = source.split(/(\r?\n)/);
    // Separate the lines and newline sequences into separate arrays for easier referencing
    const newlineSequences = lines.filter((_, idx) => idx % 2 === 1);
    lines = lines.filter((_, idx) => idx % 2 === 0);
    let count = 0;
    const res = [];
    for (let i = 0; i < lines.length; i++) {
        count +=
            lines[i].length +
                ((newlineSequences[i] && newlineSequences[i].length) || 0);
        if (count >= start) {
            for (let j = i - range; j <= i + range || end > count; j++) {
                if (j < 0 || j >= lines.length)
                    continue;
                const line = j + 1;
                res.push(`${line}${' '.repeat(Math.max(3 - String(line).length, 0))}|  ${lines[j]}`);
                const lineLength = lines[j].length;
                const newLineSeqLength = (newlineSequences[j] && newlineSequences[j].length) || 0;
                if (j === i) {
                    // push underline
                    const pad = start - (count - (lineLength + newLineSeqLength));
                    const length = Math.max(1, end > count ? lineLength - pad : end - start);
                    res.push(`   |  ` + ' '.repeat(pad) + '^'.repeat(length));
                }
                else if (j > i) {
                    if (end > count) {
                        const length = Math.max(Math.min(end - count, lineLength), 1);
                        res.push(`   |  ` + '^'.repeat(length));
                    }
                    count += lineLength + newLineSeqLength;
                }
            }
            break;
        }
    }
    return res.join('\n');
}

/**
 * On the client we only need to offer special cases for boolean attributes that
 * have different names from their corresponding dom properties:
 * - itemscope -> N/A
 * - allowfullscreen -> allowFullscreen
 * - formnovalidate -> formNoValidate
 * - ismap -> isMap
 * - nomodule -> noModule
 * - novalidate -> noValidate
 * - readonly -> readOnly
 */
const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
const isSpecialBooleanAttr = /*#__PURE__*/ makeMap(specialBooleanAttrs);
/**
 * The full list is needed during SSR to produce the correct initial markup.
 */
const isBooleanAttr = /*#__PURE__*/ makeMap(specialBooleanAttrs +
    `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,` +
    `loop,open,required,reversed,scoped,seamless,` +
    `checked,muted,multiple,selected`);
/**
 * Boolean attributes should be included if the value is truthy or ''.
 * e.g. `<select multiple>` compiles to `{ multiple: '' }`
 */
function includeBooleanAttr(value) {
    return !!value || value === '';
}
const unsafeAttrCharRE = /[>/="'\u0009\u000a\u000c\u0020]/;
const attrValidationCache = {};
function isSSRSafeAttrName(name) {
    if (attrValidationCache.hasOwnProperty(name)) {
        return attrValidationCache[name];
    }
    const isUnsafe = unsafeAttrCharRE.test(name);
    if (isUnsafe) {
        console.error(`unsafe attribute name: ${name}`);
    }
    return (attrValidationCache[name] = !isUnsafe);
}
const propsToAttrMap = {
    acceptCharset: 'accept-charset',
    className: 'class',
    htmlFor: 'for',
    httpEquiv: 'http-equiv'
};
/**
 * CSS properties that accept plain numbers
 */
const isNoUnitNumericStyleProp = /*#__PURE__*/ makeMap(`animation-iteration-count,border-image-outset,border-image-slice,` +
    `border-image-width,box-flex,box-flex-group,box-ordinal-group,column-count,` +
    `columns,flex,flex-grow,flex-positive,flex-shrink,flex-negative,flex-order,` +
    `grid-row,grid-row-end,grid-row-span,grid-row-start,grid-column,` +
    `grid-column-end,grid-column-span,grid-column-start,font-weight,line-clamp,` +
    `line-height,opacity,order,orphans,tab-size,widows,z-index,zoom,` +
    // SVG
    `fill-opacity,flood-opacity,stop-opacity,stroke-dasharray,stroke-dashoffset,` +
    `stroke-miterlimit,stroke-opacity,stroke-width`);
/**
 * Known attributes, this is used for stringification of runtime static nodes
 * so that we don't stringify bindings that cannot be set from HTML.
 * Don't also forget to allow `data-*` and `aria-*`!
 * Generated from https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes
 */
const isKnownHtmlAttr = /*#__PURE__*/ makeMap(`accept,accept-charset,accesskey,action,align,allow,alt,async,` +
    `autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,` +
    `border,buffered,capture,challenge,charset,checked,cite,class,code,` +
    `codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,` +
    `coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,` +
    `disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,` +
    `formaction,formenctype,formmethod,formnovalidate,formtarget,headers,` +
    `height,hidden,high,href,hreflang,http-equiv,icon,id,importance,integrity,` +
    `ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,` +
    `manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,` +
    `open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,` +
    `referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,` +
    `selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,` +
    `start,step,style,summary,tabindex,target,title,translate,type,usemap,` +
    `value,width,wrap`);
/**
 * Generated from https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute
 */
const isKnownSvgAttr = /*#__PURE__*/ makeMap(`xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,` +
    `arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,` +
    `baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,` +
    `clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,` +
    `color-interpolation-filters,color-profile,color-rendering,` +
    `contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,` +
    `descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,` +
    `dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,` +
    `fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,` +
    `font-family,font-size,font-size-adjust,font-stretch,font-style,` +
    `font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,` +
    `glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,` +
    `gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,` +
    `horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,` +
    `k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,` +
    `lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,` +
    `marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,` +
    `mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,` +
    `name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,` +
    `overflow,overline-position,overline-thickness,panose-1,paint-order,path,` +
    `pathLength,patternContentUnits,patternTransform,patternUnits,ping,` +
    `pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,` +
    `preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,` +
    `rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,` +
    `restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,` +
    `specularConstant,specularExponent,speed,spreadMethod,startOffset,` +
    `stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,` +
    `strikethrough-position,strikethrough-thickness,string,stroke,` +
    `stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,` +
    `stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,` +
    `systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,` +
    `text-decoration,text-rendering,textLength,to,transform,transform-origin,` +
    `type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,` +
    `unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,` +
    `v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,` +
    `vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,` +
    `writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,` +
    `xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xml:base,xml:lang,` +
    `xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan`);

function normalizeStyle(value) {
    if (isArray(value)) {
        const res = {};
        for (let i = 0; i < value.length; i++) {
            const item = value[i];
            const normalized = isString(item)
                ? parseStringStyle(item)
                : normalizeStyle(item);
            if (normalized) {
                for (const key in normalized) {
                    res[key] = normalized[key];
                }
            }
        }
        return res;
    }
    else if (isString(value)) {
        return value;
    }
    else if (isObject(value)) {
        return value;
    }
}
const listDelimiterRE = /;(?![^(]*\))/g;
const propertyDelimiterRE = /:(.+)/;
function parseStringStyle(cssText) {
    const ret = {};
    cssText.split(listDelimiterRE).forEach(item => {
        if (item) {
            const tmp = item.split(propertyDelimiterRE);
            tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
        }
    });
    return ret;
}
function stringifyStyle(styles) {
    let ret = '';
    if (!styles || isString(styles)) {
        return ret;
    }
    for (const key in styles) {
        const value = styles[key];
        const normalizedKey = key.startsWith(`--`) ? key : hyphenate(key);
        if (isString(value) ||
            (typeof value === 'number' && isNoUnitNumericStyleProp(normalizedKey))) {
            // only render valid values
            ret += `${normalizedKey}:${value};`;
        }
    }
    return ret;
}
function normalizeClass(value) {
    let res = '';
    if (isString(value)) {
        res = value;
    }
    else if (isArray(value)) {
        for (let i = 0; i < value.length; i++) {
            const normalized = normalizeClass(value[i]);
            if (normalized) {
                res += normalized + ' ';
            }
        }
    }
    else if (isObject(value)) {
        for (const name in value) {
            if (value[name]) {
                res += name + ' ';
            }
        }
    }
    return res.trim();
}
function normalizeProps(props) {
    if (!props)
        return null;
    let { class: klass, style } = props;
    if (klass && !isString(klass)) {
        props.class = normalizeClass(klass);
    }
    if (style) {
        props.style = normalizeStyle(style);
    }
    return props;
}

// These tag configs are shared between compiler-dom and runtime-dom, so they
// https://developer.mozilla.org/en-US/docs/Web/HTML/Element
const HTML_TAGS = 'html,body,base,head,link,meta,style,title,address,article,aside,footer,' +
    'header,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,' +
    'figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,' +
    'data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,' +
    'time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,' +
    'canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,' +
    'th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,' +
    'option,output,progress,select,textarea,details,dialog,menu,' +
    'summary,template,blockquote,iframe,tfoot';
// https://developer.mozilla.org/en-US/docs/Web/SVG/Element
const SVG_TAGS = 'svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,' +
    'defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,' +
    'feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,' +
    'feDistanceLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,' +
    'feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,' +
    'fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,' +
    'foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,' +
    'mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,' +
    'polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,' +
    'text,textPath,title,tspan,unknown,use,view';
const VOID_TAGS = 'area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr';
/**
 * Compiler only.
 * Do NOT use in runtime code paths unless behind `(process.env.NODE_ENV !== 'production')` flag.
 */
const isHTMLTag = /*#__PURE__*/ makeMap(HTML_TAGS);
/**
 * Compiler only.
 * Do NOT use in runtime code paths unless behind `(process.env.NODE_ENV !== 'production')` flag.
 */
const isSVGTag = /*#__PURE__*/ makeMap(SVG_TAGS);
/**
 * Compiler only.
 * Do NOT use in runtime code paths unless behind `(process.env.NODE_ENV !== 'production')` flag.
 */
const isVoidTag = /*#__PURE__*/ makeMap(VOID_TAGS);

const escapeRE = /["'&<>]/;
function escapeHtml(string) {
    const str = '' + string;
    const match = escapeRE.exec(str);
    if (!match) {
        return str;
    }
    let html = '';
    let escaped;
    let index;
    let lastIndex = 0;
    for (index = match.index; index < str.length; index++) {
        switch (str.charCodeAt(index)) {
            case 34: // "
                escaped = '&quot;';
                break;
            case 38: // &
                escaped = '&amp;';
                break;
            case 39: // '
                escaped = '&#39;';
                break;
            case 60: // <
                escaped = '&lt;';
                break;
            case 62: // >
                escaped = '&gt;';
                break;
            default:
                continue;
        }
        if (lastIndex !== index) {
            html += str.slice(lastIndex, index);
        }
        lastIndex = index + 1;
        html += escaped;
    }
    return lastIndex !== index ? html + str.slice(lastIndex, index) : html;
}
// https://www.w3.org/TR/html52/syntax.html#comments
const commentStripRE = /^-?>|<!--|-->|--!>|<!-$/g;
function escapeHtmlComment(src) {
    return src.replace(commentStripRE, '');
}

function looseCompareArrays(a, b) {
    if (a.length !== b.length)
        return false;
    let equal = true;
    for (let i = 0; equal && i < a.length; i++) {
        equal = looseEqual(a[i], b[i]);
    }
    return equal;
}
function looseEqual(a, b) {
    if (a === b)
        return true;
    let aValidType = isDate(a);
    let bValidType = isDate(b);
    if (aValidType || bValidType) {
        return aValidType && bValidType ? a.getTime() === b.getTime() : false;
    }
    aValidType = isArray(a);
    bValidType = isArray(b);
    if (aValidType || bValidType) {
        return aValidType && bValidType ? looseCompareArrays(a, b) : false;
    }
    aValidType = isObject(a);
    bValidType = isObject(b);
    if (aValidType || bValidType) {
        /* istanbul ignore if: this if will probably never be called */
        if (!aValidType || !bValidType) {
            return false;
        }
        const aKeysCount = Object.keys(a).length;
        const bKeysCount = Object.keys(b).length;
        if (aKeysCount !== bKeysCount) {
            return false;
        }
        for (const key in a) {
            const aHasKey = a.hasOwnProperty(key);
            const bHasKey = b.hasOwnProperty(key);
            if ((aHasKey && !bHasKey) ||
                (!aHasKey && bHasKey) ||
                !looseEqual(a[key], b[key])) {
                return false;
            }
        }
    }
    return String(a) === String(b);
}
function looseIndexOf(arr, val) {
    return arr.findIndex(item => looseEqual(item, val));
}

/**
 * For converting {{ interpolation }} values to displayed strings.
 * @private
 */
const toDisplayString = (val) => {
    return isString(val)
        ? val
        : val == null
            ? ''
            : isArray(val) ||
                (isObject(val) &&
                    (val.toString === objectToString || !isFunction(val.toString)))
                ? JSON.stringify(val, replacer, 2)
                : String(val);
};
const replacer = (_key, val) => {
    // can't use isRef here since @vue/shared has no deps
    if (val && val.__v_isRef) {
        return replacer(_key, val.value);
    }
    else if (isMap(val)) {
        return {
            [`Map(${val.size})`]: [...val.entries()].reduce((entries, [key, val]) => {
                entries[`${key} =>`] = val;
                return entries;
            }, {})
        };
    }
    else if (isSet(val)) {
        return {
            [`Set(${val.size})`]: [...val.values()]
        };
    }
    else if (isObject(val) && !isArray(val) && !isPlainObject(val)) {
        return String(val);
    }
    return val;
};

const EMPTY_OBJ = ( true)
    ? Object.freeze({})
    : 0;
const EMPTY_ARR = ( true) ? Object.freeze([]) : 0;
const NOOP = () => { };
/**
 * Always return false.
 */
const NO = () => false;
const onRE = /^on[^a-z]/;
const isOn = (key) => onRE.test(key);
const isModelListener = (key) => key.startsWith('onUpdate:');
const extend = Object.assign;
const remove = (arr, el) => {
    const i = arr.indexOf(el);
    if (i > -1) {
        arr.splice(i, 1);
    }
};
const hasOwnProperty = Object.prototype.hasOwnProperty;
const hasOwn = (val, key) => hasOwnProperty.call(val, key);
const isArray = Array.isArray;
const isMap = (val) => toTypeString(val) === '[object Map]';
const isSet = (val) => toTypeString(val) === '[object Set]';
const isDate = (val) => val instanceof Date;
const isFunction = (val) => typeof val === 'function';
const isString = (val) => typeof val === 'string';
const isSymbol = (val) => typeof val === 'symbol';
const isObject = (val) => val !== null && typeof val === 'object';
const isPromise = (val) => {
    return isObject(val) && isFunction(val.then) && isFunction(val.catch);
};
const objectToString = Object.prototype.toString;
const toTypeString = (value) => objectToString.call(value);
const toRawType = (value) => {
    // extract "RawType" from strings like "[object RawType]"
    return toTypeString(value).slice(8, -1);
};
const isPlainObject = (val) => toTypeString(val) === '[object Object]';
const isIntegerKey = (key) => isString(key) &&
    key !== 'NaN' &&
    key[0] !== '-' &&
    '' + parseInt(key, 10) === key;
const isReservedProp = /*#__PURE__*/ makeMap(
// the leading comma is intentional so empty string "" is also included
',key,ref,ref_for,ref_key,' +
    'onVnodeBeforeMount,onVnodeMounted,' +
    'onVnodeBeforeUpdate,onVnodeUpdated,' +
    'onVnodeBeforeUnmount,onVnodeUnmounted');
const isBuiltInDirective = /*#__PURE__*/ makeMap('bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo');
const cacheStringFunction = (fn) => {
    const cache = Object.create(null);
    return ((str) => {
        const hit = cache[str];
        return hit || (cache[str] = fn(str));
    });
};
const camelizeRE = /-(\w)/g;
/**
 * @private
 */
const camelize = cacheStringFunction((str) => {
    return str.replace(camelizeRE, (_, c) => (c ? c.toUpperCase() : ''));
});
const hyphenateRE = /\B([A-Z])/g;
/**
 * @private
 */
const hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, '-$1').toLowerCase());
/**
 * @private
 */
const capitalize = cacheStringFunction((str) => str.charAt(0).toUpperCase() + str.slice(1));
/**
 * @private
 */
const toHandlerKey = cacheStringFunction((str) => str ? `on${capitalize(str)}` : ``);
// compare whether a value has changed, accounting for NaN.
const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
const invokeArrayFns = (fns, arg) => {
    for (let i = 0; i < fns.length; i++) {
        fns[i](arg);
    }
};
const def = (obj, key, value) => {
    Object.defineProperty(obj, key, {
        configurable: true,
        enumerable: false,
        value
    });
};
const toNumber = (val) => {
    const n = parseFloat(val);
    return isNaN(n) ? val : n;
};
let _globalThis;
const getGlobalThis = () => {
    return (_globalThis ||
        (_globalThis =
            typeof globalThis !== 'undefined'
                ? globalThis
                : typeof self !== 'undefined'
                    ? self
                    : typeof window !== 'undefined'
                        ? window
                        : typeof __webpack_require__.g !== 'undefined'
                            ? __webpack_require__.g
                            : {}));
};




/***/ }),

/***/ "./node_modules/@vue/compiler-dom/dist/compiler-dom.esm-bundler.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@vue/compiler-dom/dist/compiler-dom.esm-bundler.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BASE_TRANSITION": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.BASE_TRANSITION),
/* harmony export */   "CAMELIZE": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CAMELIZE),
/* harmony export */   "CAPITALIZE": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CAPITALIZE),
/* harmony export */   "CREATE_BLOCK": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CREATE_BLOCK),
/* harmony export */   "CREATE_COMMENT": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CREATE_COMMENT),
/* harmony export */   "CREATE_ELEMENT_BLOCK": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CREATE_ELEMENT_BLOCK),
/* harmony export */   "CREATE_ELEMENT_VNODE": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CREATE_ELEMENT_VNODE),
/* harmony export */   "CREATE_SLOTS": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CREATE_SLOTS),
/* harmony export */   "CREATE_STATIC": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CREATE_STATIC),
/* harmony export */   "CREATE_TEXT": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CREATE_TEXT),
/* harmony export */   "CREATE_VNODE": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CREATE_VNODE),
/* harmony export */   "FRAGMENT": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.FRAGMENT),
/* harmony export */   "GUARD_REACTIVE_PROPS": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.GUARD_REACTIVE_PROPS),
/* harmony export */   "IS_MEMO_SAME": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.IS_MEMO_SAME),
/* harmony export */   "IS_REF": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.IS_REF),
/* harmony export */   "KEEP_ALIVE": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.KEEP_ALIVE),
/* harmony export */   "MERGE_PROPS": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.MERGE_PROPS),
/* harmony export */   "NORMALIZE_CLASS": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.NORMALIZE_CLASS),
/* harmony export */   "NORMALIZE_PROPS": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.NORMALIZE_PROPS),
/* harmony export */   "NORMALIZE_STYLE": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.NORMALIZE_STYLE),
/* harmony export */   "OPEN_BLOCK": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.OPEN_BLOCK),
/* harmony export */   "POP_SCOPE_ID": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.POP_SCOPE_ID),
/* harmony export */   "PUSH_SCOPE_ID": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.PUSH_SCOPE_ID),
/* harmony export */   "RENDER_LIST": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.RENDER_LIST),
/* harmony export */   "RENDER_SLOT": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.RENDER_SLOT),
/* harmony export */   "RESOLVE_COMPONENT": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.RESOLVE_COMPONENT),
/* harmony export */   "RESOLVE_DIRECTIVE": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.RESOLVE_DIRECTIVE),
/* harmony export */   "RESOLVE_DYNAMIC_COMPONENT": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.RESOLVE_DYNAMIC_COMPONENT),
/* harmony export */   "RESOLVE_FILTER": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.RESOLVE_FILTER),
/* harmony export */   "SET_BLOCK_TRACKING": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.SET_BLOCK_TRACKING),
/* harmony export */   "SUSPENSE": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.SUSPENSE),
/* harmony export */   "TELEPORT": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.TELEPORT),
/* harmony export */   "TO_DISPLAY_STRING": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.TO_DISPLAY_STRING),
/* harmony export */   "TO_HANDLERS": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.TO_HANDLERS),
/* harmony export */   "TO_HANDLER_KEY": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.TO_HANDLER_KEY),
/* harmony export */   "UNREF": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.UNREF),
/* harmony export */   "WITH_CTX": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.WITH_CTX),
/* harmony export */   "WITH_DIRECTIVES": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.WITH_DIRECTIVES),
/* harmony export */   "WITH_MEMO": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.WITH_MEMO),
/* harmony export */   "advancePositionWithClone": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.advancePositionWithClone),
/* harmony export */   "advancePositionWithMutation": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.advancePositionWithMutation),
/* harmony export */   "assert": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.assert),
/* harmony export */   "baseCompile": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.baseCompile),
/* harmony export */   "baseParse": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.baseParse),
/* harmony export */   "buildDirectiveArgs": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.buildDirectiveArgs),
/* harmony export */   "buildProps": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.buildProps),
/* harmony export */   "buildSlots": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.buildSlots),
/* harmony export */   "checkCompatEnabled": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.checkCompatEnabled),
/* harmony export */   "createArrayExpression": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createArrayExpression),
/* harmony export */   "createAssignmentExpression": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createAssignmentExpression),
/* harmony export */   "createBlockStatement": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createBlockStatement),
/* harmony export */   "createCacheExpression": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCacheExpression),
/* harmony export */   "createCallExpression": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCallExpression),
/* harmony export */   "createCompilerError": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCompilerError),
/* harmony export */   "createCompoundExpression": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCompoundExpression),
/* harmony export */   "createConditionalExpression": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createConditionalExpression),
/* harmony export */   "createForLoopParams": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createForLoopParams),
/* harmony export */   "createFunctionExpression": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createFunctionExpression),
/* harmony export */   "createIfStatement": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createIfStatement),
/* harmony export */   "createInterpolation": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createInterpolation),
/* harmony export */   "createObjectExpression": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createObjectExpression),
/* harmony export */   "createObjectProperty": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createObjectProperty),
/* harmony export */   "createReturnStatement": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createReturnStatement),
/* harmony export */   "createRoot": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createRoot),
/* harmony export */   "createSequenceExpression": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSequenceExpression),
/* harmony export */   "createSimpleExpression": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSimpleExpression),
/* harmony export */   "createStructuralDirectiveTransform": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createStructuralDirectiveTransform),
/* harmony export */   "createTemplateLiteral": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createTemplateLiteral),
/* harmony export */   "createTransformContext": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createTransformContext),
/* harmony export */   "createVNodeCall": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createVNodeCall),
/* harmony export */   "extractIdentifiers": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.extractIdentifiers),
/* harmony export */   "findDir": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.findDir),
/* harmony export */   "findProp": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.findProp),
/* harmony export */   "generate": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.generate),
/* harmony export */   "generateCodeFrame": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.generateCodeFrame),
/* harmony export */   "getBaseTransformPreset": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.getBaseTransformPreset),
/* harmony export */   "getInnerRange": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.getInnerRange),
/* harmony export */   "getMemoedVNodeCall": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.getMemoedVNodeCall),
/* harmony export */   "getVNodeBlockHelper": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.getVNodeBlockHelper),
/* harmony export */   "getVNodeHelper": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.getVNodeHelper),
/* harmony export */   "hasDynamicKeyVBind": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.hasDynamicKeyVBind),
/* harmony export */   "hasScopeRef": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.hasScopeRef),
/* harmony export */   "helperNameMap": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.helperNameMap),
/* harmony export */   "injectProp": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.injectProp),
/* harmony export */   "isBuiltInType": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isBuiltInType),
/* harmony export */   "isCoreComponent": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isCoreComponent),
/* harmony export */   "isFunctionType": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isFunctionType),
/* harmony export */   "isInDestructureAssignment": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isInDestructureAssignment),
/* harmony export */   "isMemberExpression": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isMemberExpression),
/* harmony export */   "isMemberExpressionBrowser": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isMemberExpressionBrowser),
/* harmony export */   "isMemberExpressionNode": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isMemberExpressionNode),
/* harmony export */   "isReferencedIdentifier": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isReferencedIdentifier),
/* harmony export */   "isSimpleIdentifier": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isSimpleIdentifier),
/* harmony export */   "isSlotOutlet": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isSlotOutlet),
/* harmony export */   "isStaticArgOf": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isStaticArgOf),
/* harmony export */   "isStaticExp": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isStaticExp),
/* harmony export */   "isStaticProperty": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isStaticProperty),
/* harmony export */   "isStaticPropertyKey": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isStaticPropertyKey),
/* harmony export */   "isTemplateNode": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isTemplateNode),
/* harmony export */   "isText": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isText),
/* harmony export */   "isVSlot": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isVSlot),
/* harmony export */   "locStub": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.locStub),
/* harmony export */   "makeBlock": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.makeBlock),
/* harmony export */   "noopDirectiveTransform": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.noopDirectiveTransform),
/* harmony export */   "processExpression": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.processExpression),
/* harmony export */   "processFor": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.processFor),
/* harmony export */   "processIf": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.processIf),
/* harmony export */   "processSlotOutlet": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.processSlotOutlet),
/* harmony export */   "registerRuntimeHelpers": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.registerRuntimeHelpers),
/* harmony export */   "resolveComponentType": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.resolveComponentType),
/* harmony export */   "toValidAssetId": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.toValidAssetId),
/* harmony export */   "trackSlotScopes": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.trackSlotScopes),
/* harmony export */   "trackVForSlotScopes": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.trackVForSlotScopes),
/* harmony export */   "transform": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.transform),
/* harmony export */   "transformBind": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.transformBind),
/* harmony export */   "transformElement": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.transformElement),
/* harmony export */   "transformExpression": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.transformExpression),
/* harmony export */   "transformModel": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.transformModel),
/* harmony export */   "transformOn": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.transformOn),
/* harmony export */   "traverseNode": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.traverseNode),
/* harmony export */   "walkBlockDeclarations": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.walkBlockDeclarations),
/* harmony export */   "walkFunctionParams": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.walkFunctionParams),
/* harmony export */   "walkIdentifiers": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.walkIdentifiers),
/* harmony export */   "warnDeprecation": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.warnDeprecation),
/* harmony export */   "DOMDirectiveTransforms": () => (/* binding */ DOMDirectiveTransforms),
/* harmony export */   "DOMNodeTransforms": () => (/* binding */ DOMNodeTransforms),
/* harmony export */   "TRANSITION": () => (/* binding */ TRANSITION),
/* harmony export */   "TRANSITION_GROUP": () => (/* binding */ TRANSITION_GROUP),
/* harmony export */   "V_MODEL_CHECKBOX": () => (/* binding */ V_MODEL_CHECKBOX),
/* harmony export */   "V_MODEL_DYNAMIC": () => (/* binding */ V_MODEL_DYNAMIC),
/* harmony export */   "V_MODEL_RADIO": () => (/* binding */ V_MODEL_RADIO),
/* harmony export */   "V_MODEL_SELECT": () => (/* binding */ V_MODEL_SELECT),
/* harmony export */   "V_MODEL_TEXT": () => (/* binding */ V_MODEL_TEXT),
/* harmony export */   "V_ON_WITH_KEYS": () => (/* binding */ V_ON_WITH_KEYS),
/* harmony export */   "V_ON_WITH_MODIFIERS": () => (/* binding */ V_ON_WITH_MODIFIERS),
/* harmony export */   "V_SHOW": () => (/* binding */ V_SHOW),
/* harmony export */   "compile": () => (/* binding */ compile),
/* harmony export */   "createDOMCompilerError": () => (/* binding */ createDOMCompilerError),
/* harmony export */   "parse": () => (/* binding */ parse),
/* harmony export */   "parserOptions": () => (/* binding */ parserOptions),
/* harmony export */   "transformStyle": () => (/* binding */ transformStyle)
/* harmony export */ });
/* harmony import */ var _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vue/compiler-core */ "./node_modules/@vue/compiler-core/dist/compiler-core.esm-bundler.js");
/* harmony import */ var _vue_shared__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @vue/shared */ "./node_modules/@vue/compiler-dom/node_modules/@vue/shared/dist/shared.esm-bundler.js");




const V_MODEL_RADIO = Symbol(( true) ? `vModelRadio` : 0);
const V_MODEL_CHECKBOX = Symbol(( true) ? `vModelCheckbox` : 0);
const V_MODEL_TEXT = Symbol(( true) ? `vModelText` : 0);
const V_MODEL_SELECT = Symbol(( true) ? `vModelSelect` : 0);
const V_MODEL_DYNAMIC = Symbol(( true) ? `vModelDynamic` : 0);
const V_ON_WITH_MODIFIERS = Symbol(( true) ? `vOnModifiersGuard` : 0);
const V_ON_WITH_KEYS = Symbol(( true) ? `vOnKeysGuard` : 0);
const V_SHOW = Symbol(( true) ? `vShow` : 0);
const TRANSITION = Symbol(( true) ? `Transition` : 0);
const TRANSITION_GROUP = Symbol(( true) ? `TransitionGroup` : 0);
(0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.registerRuntimeHelpers)({
    [V_MODEL_RADIO]: `vModelRadio`,
    [V_MODEL_CHECKBOX]: `vModelCheckbox`,
    [V_MODEL_TEXT]: `vModelText`,
    [V_MODEL_SELECT]: `vModelSelect`,
    [V_MODEL_DYNAMIC]: `vModelDynamic`,
    [V_ON_WITH_MODIFIERS]: `withModifiers`,
    [V_ON_WITH_KEYS]: `withKeys`,
    [V_SHOW]: `vShow`,
    [TRANSITION]: `Transition`,
    [TRANSITION_GROUP]: `TransitionGroup`
});

/* eslint-disable no-restricted-globals */
let decoder;
function decodeHtmlBrowser(raw, asAttr = false) {
    if (!decoder) {
        decoder = document.createElement('div');
    }
    if (asAttr) {
        decoder.innerHTML = `<div foo="${raw.replace(/"/g, '&quot;')}">`;
        return decoder.children[0].getAttribute('foo');
    }
    else {
        decoder.innerHTML = raw;
        return decoder.textContent;
    }
}

const isRawTextContainer = /*#__PURE__*/ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.makeMap)('style,iframe,script,noscript', true);
const parserOptions = {
    isVoidTag: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isVoidTag,
    isNativeTag: tag => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isHTMLTag)(tag) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSVGTag)(tag),
    isPreTag: tag => tag === 'pre',
    decodeEntities: decodeHtmlBrowser ,
    isBuiltInComponent: (tag) => {
        if ((0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isBuiltInType)(tag, `Transition`)) {
            return TRANSITION;
        }
        else if ((0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isBuiltInType)(tag, `TransitionGroup`)) {
            return TRANSITION_GROUP;
        }
    },
    // https://html.spec.whatwg.org/multipage/parsing.html#tree-construction-dispatcher
    getNamespace(tag, parent) {
        let ns = parent ? parent.ns : 0 /* HTML */;
        if (parent && ns === 2 /* MATH_ML */) {
            if (parent.tag === 'annotation-xml') {
                if (tag === 'svg') {
                    return 1 /* SVG */;
                }
                if (parent.props.some(a => a.type === 6 /* ATTRIBUTE */ &&
                    a.name === 'encoding' &&
                    a.value != null &&
                    (a.value.content === 'text/html' ||
                        a.value.content === 'application/xhtml+xml'))) {
                    ns = 0 /* HTML */;
                }
            }
            else if (/^m(?:[ions]|text)$/.test(parent.tag) &&
                tag !== 'mglyph' &&
                tag !== 'malignmark') {
                ns = 0 /* HTML */;
            }
        }
        else if (parent && ns === 1 /* SVG */) {
            if (parent.tag === 'foreignObject' ||
                parent.tag === 'desc' ||
                parent.tag === 'title') {
                ns = 0 /* HTML */;
            }
        }
        if (ns === 0 /* HTML */) {
            if (tag === 'svg') {
                return 1 /* SVG */;
            }
            if (tag === 'math') {
                return 2 /* MATH_ML */;
            }
        }
        return ns;
    },
    // https://html.spec.whatwg.org/multipage/parsing.html#parsing-html-fragments
    getTextMode({ tag, ns }) {
        if (ns === 0 /* HTML */) {
            if (tag === 'textarea' || tag === 'title') {
                return 1 /* RCDATA */;
            }
            if (isRawTextContainer(tag)) {
                return 2 /* RAWTEXT */;
            }
        }
        return 0 /* DATA */;
    }
};

// Parse inline CSS strings for static style attributes into an object.
// This is a NodeTransform since it works on the static `style` attribute and
// converts it into a dynamic equivalent:
// style="color: red" -> :style='{ "color": "red" }'
// It is then processed by `transformElement` and included in the generated
// props.
const transformStyle = node => {
    if (node.type === 1 /* ELEMENT */) {
        node.props.forEach((p, i) => {
            if (p.type === 6 /* ATTRIBUTE */ && p.name === 'style' && p.value) {
                // replace p with an expression node
                node.props[i] = {
                    type: 7 /* DIRECTIVE */,
                    name: `bind`,
                    arg: (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSimpleExpression)(`style`, true, p.loc),
                    exp: parseInlineCSS(p.value.content, p.loc),
                    modifiers: [],
                    loc: p.loc
                };
            }
        });
    }
};
const parseInlineCSS = (cssText, loc) => {
    const normalized = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.parseStringStyle)(cssText);
    return (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSimpleExpression)(JSON.stringify(normalized), false, loc, 3 /* CAN_STRINGIFY */);
};

function createDOMCompilerError(code, loc) {
    return (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCompilerError)(code, loc,  true ? DOMErrorMessages : 0);
}
const DOMErrorMessages = {
    [50 /* X_V_HTML_NO_EXPRESSION */]: `v-html is missing expression.`,
    [51 /* X_V_HTML_WITH_CHILDREN */]: `v-html will override element children.`,
    [52 /* X_V_TEXT_NO_EXPRESSION */]: `v-text is missing expression.`,
    [53 /* X_V_TEXT_WITH_CHILDREN */]: `v-text will override element children.`,
    [54 /* X_V_MODEL_ON_INVALID_ELEMENT */]: `v-model can only be used on <input>, <textarea> and <select> elements.`,
    [55 /* X_V_MODEL_ARG_ON_ELEMENT */]: `v-model argument is not supported on plain elements.`,
    [56 /* X_V_MODEL_ON_FILE_INPUT_ELEMENT */]: `v-model cannot be used on file inputs since they are read-only. Use a v-on:change listener instead.`,
    [57 /* X_V_MODEL_UNNECESSARY_VALUE */]: `Unnecessary value binding used alongside v-model. It will interfere with v-model's behavior.`,
    [58 /* X_V_SHOW_NO_EXPRESSION */]: `v-show is missing expression.`,
    [59 /* X_TRANSITION_INVALID_CHILDREN */]: `<Transition> expects exactly one child element or component.`,
    [60 /* X_IGNORED_SIDE_EFFECT_TAG */]: `Tags with side effect (<script> and <style>) are ignored in client component templates.`
};

const transformVHtml = (dir, node, context) => {
    const { exp, loc } = dir;
    if (!exp) {
        context.onError(createDOMCompilerError(50 /* X_V_HTML_NO_EXPRESSION */, loc));
    }
    if (node.children.length) {
        context.onError(createDOMCompilerError(51 /* X_V_HTML_WITH_CHILDREN */, loc));
        node.children.length = 0;
    }
    return {
        props: [
            (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createObjectProperty)((0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSimpleExpression)(`innerHTML`, true, loc), exp || (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSimpleExpression)('', true))
        ]
    };
};

const transformVText = (dir, node, context) => {
    const { exp, loc } = dir;
    if (!exp) {
        context.onError(createDOMCompilerError(52 /* X_V_TEXT_NO_EXPRESSION */, loc));
    }
    if (node.children.length) {
        context.onError(createDOMCompilerError(53 /* X_V_TEXT_WITH_CHILDREN */, loc));
        node.children.length = 0;
    }
    return {
        props: [
            (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createObjectProperty)((0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSimpleExpression)(`textContent`, true), exp
                ? (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCallExpression)(context.helperString(_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.TO_DISPLAY_STRING), [exp], loc)
                : (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSimpleExpression)('', true))
        ]
    };
};

const transformModel = (dir, node, context) => {
    const baseResult = (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.transformModel)(dir, node, context);
    // base transform has errors OR component v-model (only need props)
    if (!baseResult.props.length || node.tagType === 1 /* COMPONENT */) {
        return baseResult;
    }
    if (dir.arg) {
        context.onError(createDOMCompilerError(55 /* X_V_MODEL_ARG_ON_ELEMENT */, dir.arg.loc));
    }
    function checkDuplicatedValue() {
        const value = (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.findProp)(node, 'value');
        if (value) {
            context.onError(createDOMCompilerError(57 /* X_V_MODEL_UNNECESSARY_VALUE */, value.loc));
        }
    }
    const { tag } = node;
    const isCustomElement = context.isCustomElement(tag);
    if (tag === 'input' ||
        tag === 'textarea' ||
        tag === 'select' ||
        isCustomElement) {
        let directiveToUse = V_MODEL_TEXT;
        let isInvalidType = false;
        if (tag === 'input' || isCustomElement) {
            const type = (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.findProp)(node, `type`);
            if (type) {
                if (type.type === 7 /* DIRECTIVE */) {
                    // :type="foo"
                    directiveToUse = V_MODEL_DYNAMIC;
                }
                else if (type.value) {
                    switch (type.value.content) {
                        case 'radio':
                            directiveToUse = V_MODEL_RADIO;
                            break;
                        case 'checkbox':
                            directiveToUse = V_MODEL_CHECKBOX;
                            break;
                        case 'file':
                            isInvalidType = true;
                            context.onError(createDOMCompilerError(56 /* X_V_MODEL_ON_FILE_INPUT_ELEMENT */, dir.loc));
                            break;
                        default:
                            // text type
                            ( true) && checkDuplicatedValue();
                            break;
                    }
                }
            }
            else if ((0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.hasDynamicKeyVBind)(node)) {
                // element has bindings with dynamic keys, which can possibly contain
                // "type".
                directiveToUse = V_MODEL_DYNAMIC;
            }
            else {
                // text type
                ( true) && checkDuplicatedValue();
            }
        }
        else if (tag === 'select') {
            directiveToUse = V_MODEL_SELECT;
        }
        else {
            // textarea
            ( true) && checkDuplicatedValue();
        }
        // inject runtime directive
        // by returning the helper symbol via needRuntime
        // the import will replaced a resolveDirective call.
        if (!isInvalidType) {
            baseResult.needRuntime = context.helper(directiveToUse);
        }
    }
    else {
        context.onError(createDOMCompilerError(54 /* X_V_MODEL_ON_INVALID_ELEMENT */, dir.loc));
    }
    // native vmodel doesn't need the `modelValue` props since they are also
    // passed to the runtime as `binding.value`. removing it reduces code size.
    baseResult.props = baseResult.props.filter(p => !(p.key.type === 4 /* SIMPLE_EXPRESSION */ &&
        p.key.content === 'modelValue'));
    return baseResult;
};

const isEventOptionModifier = /*#__PURE__*/ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.makeMap)(`passive,once,capture`);
const isNonKeyModifier = /*#__PURE__*/ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.makeMap)(
// event propagation management
`stop,prevent,self,` +
    // system modifiers + exact
    `ctrl,shift,alt,meta,exact,` +
    // mouse
    `middle`);
// left & right could be mouse or key modifiers based on event type
const maybeKeyModifier = /*#__PURE__*/ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.makeMap)('left,right');
const isKeyboardEvent = /*#__PURE__*/ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.makeMap)(`onkeyup,onkeydown,onkeypress`, true);
const resolveModifiers = (key, modifiers, context, loc) => {
    const keyModifiers = [];
    const nonKeyModifiers = [];
    const eventOptionModifiers = [];
    for (let i = 0; i < modifiers.length; i++) {
        const modifier = modifiers[i];
        if (modifier === 'native' &&
            (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.checkCompatEnabled)("COMPILER_V_ON_NATIVE" /* COMPILER_V_ON_NATIVE */, context, loc)) {
            eventOptionModifiers.push(modifier);
        }
        else if (isEventOptionModifier(modifier)) {
            // eventOptionModifiers: modifiers for addEventListener() options,
            // e.g. .passive & .capture
            eventOptionModifiers.push(modifier);
        }
        else {
            // runtimeModifiers: modifiers that needs runtime guards
            if (maybeKeyModifier(modifier)) {
                if ((0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isStaticExp)(key)) {
                    if (isKeyboardEvent(key.content)) {
                        keyModifiers.push(modifier);
                    }
                    else {
                        nonKeyModifiers.push(modifier);
                    }
                }
                else {
                    keyModifiers.push(modifier);
                    nonKeyModifiers.push(modifier);
                }
            }
            else {
                if (isNonKeyModifier(modifier)) {
                    nonKeyModifiers.push(modifier);
                }
                else {
                    keyModifiers.push(modifier);
                }
            }
        }
    }
    return {
        keyModifiers,
        nonKeyModifiers,
        eventOptionModifiers
    };
};
const transformClick = (key, event) => {
    const isStaticClick = (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isStaticExp)(key) && key.content.toLowerCase() === 'onclick';
    return isStaticClick
        ? (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSimpleExpression)(event, true)
        : key.type !== 4 /* SIMPLE_EXPRESSION */
            ? (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCompoundExpression)([
                `(`,
                key,
                `) === "onClick" ? "${event}" : (`,
                key,
                `)`
            ])
            : key;
};
const transformOn = (dir, node, context) => {
    return (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.transformOn)(dir, node, context, baseResult => {
        const { modifiers } = dir;
        if (!modifiers.length)
            return baseResult;
        let { key, value: handlerExp } = baseResult.props[0];
        const { keyModifiers, nonKeyModifiers, eventOptionModifiers } = resolveModifiers(key, modifiers, context, dir.loc);
        // normalize click.right and click.middle since they don't actually fire
        if (nonKeyModifiers.includes('right')) {
            key = transformClick(key, `onContextmenu`);
        }
        if (nonKeyModifiers.includes('middle')) {
            key = transformClick(key, `onMouseup`);
        }
        if (nonKeyModifiers.length) {
            handlerExp = (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCallExpression)(context.helper(V_ON_WITH_MODIFIERS), [
                handlerExp,
                JSON.stringify(nonKeyModifiers)
            ]);
        }
        if (keyModifiers.length &&
            // if event name is dynamic, always wrap with keys guard
            (!(0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isStaticExp)(key) || isKeyboardEvent(key.content))) {
            handlerExp = (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCallExpression)(context.helper(V_ON_WITH_KEYS), [
                handlerExp,
                JSON.stringify(keyModifiers)
            ]);
        }
        if (eventOptionModifiers.length) {
            const modifierPostfix = eventOptionModifiers.map(_vue_shared__WEBPACK_IMPORTED_MODULE_1__.capitalize).join('');
            key = (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isStaticExp)(key)
                ? (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSimpleExpression)(`${key.content}${modifierPostfix}`, true)
                : (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCompoundExpression)([`(`, key, `) + "${modifierPostfix}"`]);
        }
        return {
            props: [(0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createObjectProperty)(key, handlerExp)]
        };
    });
};

const transformShow = (dir, node, context) => {
    const { exp, loc } = dir;
    if (!exp) {
        context.onError(createDOMCompilerError(58 /* X_V_SHOW_NO_EXPRESSION */, loc));
    }
    return {
        props: [],
        needRuntime: context.helper(V_SHOW)
    };
};

const warnTransitionChildren = (node, context) => {
    if (node.type === 1 /* ELEMENT */ &&
        node.tagType === 1 /* COMPONENT */) {
        const component = context.isBuiltInComponent(node.tag);
        if (component === TRANSITION) {
            return () => {
                if (node.children.length && hasMultipleChildren(node)) {
                    context.onError(createDOMCompilerError(59 /* X_TRANSITION_INVALID_CHILDREN */, {
                        start: node.children[0].loc.start,
                        end: node.children[node.children.length - 1].loc.end,
                        source: ''
                    }));
                }
            };
        }
    }
};
function hasMultipleChildren(node) {
    // #1352 filter out potential comment nodes.
    const children = (node.children = node.children.filter(c => c.type !== 3 /* COMMENT */ &&
        !(c.type === 2 /* TEXT */ && !c.content.trim())));
    const child = children[0];
    return (children.length !== 1 ||
        child.type === 11 /* FOR */ ||
        (child.type === 9 /* IF */ && child.branches.some(hasMultipleChildren)));
}

const ignoreSideEffectTags = (node, context) => {
    if (node.type === 1 /* ELEMENT */ &&
        node.tagType === 0 /* ELEMENT */ &&
        (node.tag === 'script' || node.tag === 'style')) {
        context.onError(createDOMCompilerError(60 /* X_IGNORED_SIDE_EFFECT_TAG */, node.loc));
        context.removeNode();
    }
};

const DOMNodeTransforms = [
    transformStyle,
    ...(( true) ? [warnTransitionChildren] : 0)
];
const DOMDirectiveTransforms = {
    cloak: _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.noopDirectiveTransform,
    html: transformVHtml,
    text: transformVText,
    model: transformModel,
    on: transformOn,
    show: transformShow
};
function compile(template, options = {}) {
    return (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.baseCompile)(template, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, parserOptions, options, {
        nodeTransforms: [
            // ignore <script> and <tag>
            // this is not put inside DOMNodeTransforms because that list is used
            // by compiler-ssr to generate vnode fallback branches
            ignoreSideEffectTags,
            ...DOMNodeTransforms,
            ...(options.nodeTransforms || [])
        ],
        directiveTransforms: (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, DOMDirectiveTransforms, options.directiveTransforms || {}),
        transformHoist: null 
    }));
}
function parse(template, options = {}) {
    return (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.baseParse)(template, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, parserOptions, options));
}




/***/ }),

/***/ "./node_modules/@vue/compiler-dom/node_modules/@vue/shared/dist/shared.esm-bundler.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@vue/compiler-dom/node_modules/@vue/shared/dist/shared.esm-bundler.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EMPTY_ARR": () => (/* binding */ EMPTY_ARR),
/* harmony export */   "EMPTY_OBJ": () => (/* binding */ EMPTY_OBJ),
/* harmony export */   "NO": () => (/* binding */ NO),
/* harmony export */   "NOOP": () => (/* binding */ NOOP),
/* harmony export */   "PatchFlagNames": () => (/* binding */ PatchFlagNames),
/* harmony export */   "camelize": () => (/* binding */ camelize),
/* harmony export */   "capitalize": () => (/* binding */ capitalize),
/* harmony export */   "def": () => (/* binding */ def),
/* harmony export */   "escapeHtml": () => (/* binding */ escapeHtml),
/* harmony export */   "escapeHtmlComment": () => (/* binding */ escapeHtmlComment),
/* harmony export */   "extend": () => (/* binding */ extend),
/* harmony export */   "generateCodeFrame": () => (/* binding */ generateCodeFrame),
/* harmony export */   "getGlobalThis": () => (/* binding */ getGlobalThis),
/* harmony export */   "hasChanged": () => (/* binding */ hasChanged),
/* harmony export */   "hasOwn": () => (/* binding */ hasOwn),
/* harmony export */   "hyphenate": () => (/* binding */ hyphenate),
/* harmony export */   "includeBooleanAttr": () => (/* binding */ includeBooleanAttr),
/* harmony export */   "invokeArrayFns": () => (/* binding */ invokeArrayFns),
/* harmony export */   "isArray": () => (/* binding */ isArray),
/* harmony export */   "isBooleanAttr": () => (/* binding */ isBooleanAttr),
/* harmony export */   "isBuiltInDirective": () => (/* binding */ isBuiltInDirective),
/* harmony export */   "isDate": () => (/* binding */ isDate),
/* harmony export */   "isFunction": () => (/* binding */ isFunction),
/* harmony export */   "isGloballyWhitelisted": () => (/* binding */ isGloballyWhitelisted),
/* harmony export */   "isHTMLTag": () => (/* binding */ isHTMLTag),
/* harmony export */   "isIntegerKey": () => (/* binding */ isIntegerKey),
/* harmony export */   "isKnownHtmlAttr": () => (/* binding */ isKnownHtmlAttr),
/* harmony export */   "isKnownSvgAttr": () => (/* binding */ isKnownSvgAttr),
/* harmony export */   "isMap": () => (/* binding */ isMap),
/* harmony export */   "isModelListener": () => (/* binding */ isModelListener),
/* harmony export */   "isNoUnitNumericStyleProp": () => (/* binding */ isNoUnitNumericStyleProp),
/* harmony export */   "isObject": () => (/* binding */ isObject),
/* harmony export */   "isOn": () => (/* binding */ isOn),
/* harmony export */   "isPlainObject": () => (/* binding */ isPlainObject),
/* harmony export */   "isPromise": () => (/* binding */ isPromise),
/* harmony export */   "isReservedProp": () => (/* binding */ isReservedProp),
/* harmony export */   "isSSRSafeAttrName": () => (/* binding */ isSSRSafeAttrName),
/* harmony export */   "isSVGTag": () => (/* binding */ isSVGTag),
/* harmony export */   "isSet": () => (/* binding */ isSet),
/* harmony export */   "isSpecialBooleanAttr": () => (/* binding */ isSpecialBooleanAttr),
/* harmony export */   "isString": () => (/* binding */ isString),
/* harmony export */   "isSymbol": () => (/* binding */ isSymbol),
/* harmony export */   "isVoidTag": () => (/* binding */ isVoidTag),
/* harmony export */   "looseEqual": () => (/* binding */ looseEqual),
/* harmony export */   "looseIndexOf": () => (/* binding */ looseIndexOf),
/* harmony export */   "makeMap": () => (/* binding */ makeMap),
/* harmony export */   "normalizeClass": () => (/* binding */ normalizeClass),
/* harmony export */   "normalizeProps": () => (/* binding */ normalizeProps),
/* harmony export */   "normalizeStyle": () => (/* binding */ normalizeStyle),
/* harmony export */   "objectToString": () => (/* binding */ objectToString),
/* harmony export */   "parseStringStyle": () => (/* binding */ parseStringStyle),
/* harmony export */   "propsToAttrMap": () => (/* binding */ propsToAttrMap),
/* harmony export */   "remove": () => (/* binding */ remove),
/* harmony export */   "slotFlagsText": () => (/* binding */ slotFlagsText),
/* harmony export */   "stringifyStyle": () => (/* binding */ stringifyStyle),
/* harmony export */   "toDisplayString": () => (/* binding */ toDisplayString),
/* harmony export */   "toHandlerKey": () => (/* binding */ toHandlerKey),
/* harmony export */   "toNumber": () => (/* binding */ toNumber),
/* harmony export */   "toRawType": () => (/* binding */ toRawType),
/* harmony export */   "toTypeString": () => (/* binding */ toTypeString)
/* harmony export */ });
/**
 * Make a map and return a function for checking if a key
 * is in that map.
 * IMPORTANT: all calls of this function must be prefixed with
 * \/\*#\_\_PURE\_\_\*\/
 * So that rollup can tree-shake them if necessary.
 */
function makeMap(str, expectsLowerCase) {
    const map = Object.create(null);
    const list = str.split(',');
    for (let i = 0; i < list.length; i++) {
        map[list[i]] = true;
    }
    return expectsLowerCase ? val => !!map[val.toLowerCase()] : val => !!map[val];
}

/**
 * dev only flag -> name mapping
 */
const PatchFlagNames = {
    [1 /* TEXT */]: `TEXT`,
    [2 /* CLASS */]: `CLASS`,
    [4 /* STYLE */]: `STYLE`,
    [8 /* PROPS */]: `PROPS`,
    [16 /* FULL_PROPS */]: `FULL_PROPS`,
    [32 /* HYDRATE_EVENTS */]: `HYDRATE_EVENTS`,
    [64 /* STABLE_FRAGMENT */]: `STABLE_FRAGMENT`,
    [128 /* KEYED_FRAGMENT */]: `KEYED_FRAGMENT`,
    [256 /* UNKEYED_FRAGMENT */]: `UNKEYED_FRAGMENT`,
    [512 /* NEED_PATCH */]: `NEED_PATCH`,
    [1024 /* DYNAMIC_SLOTS */]: `DYNAMIC_SLOTS`,
    [2048 /* DEV_ROOT_FRAGMENT */]: `DEV_ROOT_FRAGMENT`,
    [-1 /* HOISTED */]: `HOISTED`,
    [-2 /* BAIL */]: `BAIL`
};

/**
 * Dev only
 */
const slotFlagsText = {
    [1 /* STABLE */]: 'STABLE',
    [2 /* DYNAMIC */]: 'DYNAMIC',
    [3 /* FORWARDED */]: 'FORWARDED'
};

const GLOBALS_WHITE_LISTED = 'Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,' +
    'decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,' +
    'Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt';
const isGloballyWhitelisted = /*#__PURE__*/ makeMap(GLOBALS_WHITE_LISTED);

const range = 2;
function generateCodeFrame(source, start = 0, end = source.length) {
    // Split the content into individual lines but capture the newline sequence
    // that separated each line. This is important because the actual sequence is
    // needed to properly take into account the full line length for offset
    // comparison
    let lines = source.split(/(\r?\n)/);
    // Separate the lines and newline sequences into separate arrays for easier referencing
    const newlineSequences = lines.filter((_, idx) => idx % 2 === 1);
    lines = lines.filter((_, idx) => idx % 2 === 0);
    let count = 0;
    const res = [];
    for (let i = 0; i < lines.length; i++) {
        count +=
            lines[i].length +
                ((newlineSequences[i] && newlineSequences[i].length) || 0);
        if (count >= start) {
            for (let j = i - range; j <= i + range || end > count; j++) {
                if (j < 0 || j >= lines.length)
                    continue;
                const line = j + 1;
                res.push(`${line}${' '.repeat(Math.max(3 - String(line).length, 0))}|  ${lines[j]}`);
                const lineLength = lines[j].length;
                const newLineSeqLength = (newlineSequences[j] && newlineSequences[j].length) || 0;
                if (j === i) {
                    // push underline
                    const pad = start - (count - (lineLength + newLineSeqLength));
                    const length = Math.max(1, end > count ? lineLength - pad : end - start);
                    res.push(`   |  ` + ' '.repeat(pad) + '^'.repeat(length));
                }
                else if (j > i) {
                    if (end > count) {
                        const length = Math.max(Math.min(end - count, lineLength), 1);
                        res.push(`   |  ` + '^'.repeat(length));
                    }
                    count += lineLength + newLineSeqLength;
                }
            }
            break;
        }
    }
    return res.join('\n');
}

/**
 * On the client we only need to offer special cases for boolean attributes that
 * have different names from their corresponding dom properties:
 * - itemscope -> N/A
 * - allowfullscreen -> allowFullscreen
 * - formnovalidate -> formNoValidate
 * - ismap -> isMap
 * - nomodule -> noModule
 * - novalidate -> noValidate
 * - readonly -> readOnly
 */
const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
const isSpecialBooleanAttr = /*#__PURE__*/ makeMap(specialBooleanAttrs);
/**
 * The full list is needed during SSR to produce the correct initial markup.
 */
const isBooleanAttr = /*#__PURE__*/ makeMap(specialBooleanAttrs +
    `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,` +
    `loop,open,required,reversed,scoped,seamless,` +
    `checked,muted,multiple,selected`);
/**
 * Boolean attributes should be included if the value is truthy or ''.
 * e.g. `<select multiple>` compiles to `{ multiple: '' }`
 */
function includeBooleanAttr(value) {
    return !!value || value === '';
}
const unsafeAttrCharRE = /[>/="'\u0009\u000a\u000c\u0020]/;
const attrValidationCache = {};
function isSSRSafeAttrName(name) {
    if (attrValidationCache.hasOwnProperty(name)) {
        return attrValidationCache[name];
    }
    const isUnsafe = unsafeAttrCharRE.test(name);
    if (isUnsafe) {
        console.error(`unsafe attribute name: ${name}`);
    }
    return (attrValidationCache[name] = !isUnsafe);
}
const propsToAttrMap = {
    acceptCharset: 'accept-charset',
    className: 'class',
    htmlFor: 'for',
    httpEquiv: 'http-equiv'
};
/**
 * CSS properties that accept plain numbers
 */
const isNoUnitNumericStyleProp = /*#__PURE__*/ makeMap(`animation-iteration-count,border-image-outset,border-image-slice,` +
    `border-image-width,box-flex,box-flex-group,box-ordinal-group,column-count,` +
    `columns,flex,flex-grow,flex-positive,flex-shrink,flex-negative,flex-order,` +
    `grid-row,grid-row-end,grid-row-span,grid-row-start,grid-column,` +
    `grid-column-end,grid-column-span,grid-column-start,font-weight,line-clamp,` +
    `line-height,opacity,order,orphans,tab-size,widows,z-index,zoom,` +
    // SVG
    `fill-opacity,flood-opacity,stop-opacity,stroke-dasharray,stroke-dashoffset,` +
    `stroke-miterlimit,stroke-opacity,stroke-width`);
/**
 * Known attributes, this is used for stringification of runtime static nodes
 * so that we don't stringify bindings that cannot be set from HTML.
 * Don't also forget to allow `data-*` and `aria-*`!
 * Generated from https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes
 */
const isKnownHtmlAttr = /*#__PURE__*/ makeMap(`accept,accept-charset,accesskey,action,align,allow,alt,async,` +
    `autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,` +
    `border,buffered,capture,challenge,charset,checked,cite,class,code,` +
    `codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,` +
    `coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,` +
    `disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,` +
    `formaction,formenctype,formmethod,formnovalidate,formtarget,headers,` +
    `height,hidden,high,href,hreflang,http-equiv,icon,id,importance,integrity,` +
    `ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,` +
    `manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,` +
    `open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,` +
    `referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,` +
    `selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,` +
    `start,step,style,summary,tabindex,target,title,translate,type,usemap,` +
    `value,width,wrap`);
/**
 * Generated from https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute
 */
const isKnownSvgAttr = /*#__PURE__*/ makeMap(`xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,` +
    `arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,` +
    `baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,` +
    `clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,` +
    `color-interpolation-filters,color-profile,color-rendering,` +
    `contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,` +
    `descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,` +
    `dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,` +
    `fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,` +
    `font-family,font-size,font-size-adjust,font-stretch,font-style,` +
    `font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,` +
    `glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,` +
    `gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,` +
    `horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,` +
    `k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,` +
    `lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,` +
    `marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,` +
    `mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,` +
    `name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,` +
    `overflow,overline-position,overline-thickness,panose-1,paint-order,path,` +
    `pathLength,patternContentUnits,patternTransform,patternUnits,ping,` +
    `pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,` +
    `preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,` +
    `rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,` +
    `restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,` +
    `specularConstant,specularExponent,speed,spreadMethod,startOffset,` +
    `stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,` +
    `strikethrough-position,strikethrough-thickness,string,stroke,` +
    `stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,` +
    `stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,` +
    `systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,` +
    `text-decoration,text-rendering,textLength,to,transform,transform-origin,` +
    `type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,` +
    `unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,` +
    `v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,` +
    `vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,` +
    `writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,` +
    `xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xml:base,xml:lang,` +
    `xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan`);

function normalizeStyle(value) {
    if (isArray(value)) {
        const res = {};
        for (let i = 0; i < value.length; i++) {
            const item = value[i];
            const normalized = isString(item)
                ? parseStringStyle(item)
                : normalizeStyle(item);
            if (normalized) {
                for (const key in normalized) {
                    res[key] = normalized[key];
                }
            }
        }
        return res;
    }
    else if (isString(value)) {
        return value;
    }
    else if (isObject(value)) {
        return value;
    }
}
const listDelimiterRE = /;(?![^(]*\))/g;
const propertyDelimiterRE = /:(.+)/;
function parseStringStyle(cssText) {
    const ret = {};
    cssText.split(listDelimiterRE).forEach(item => {
        if (item) {
            const tmp = item.split(propertyDelimiterRE);
            tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
        }
    });
    return ret;
}
function stringifyStyle(styles) {
    let ret = '';
    if (!styles || isString(styles)) {
        return ret;
    }
    for (const key in styles) {
        const value = styles[key];
        const normalizedKey = key.startsWith(`--`) ? key : hyphenate(key);
        if (isString(value) ||
            (typeof value === 'number' && isNoUnitNumericStyleProp(normalizedKey))) {
            // only render valid values
            ret += `${normalizedKey}:${value};`;
        }
    }
    return ret;
}
function normalizeClass(value) {
    let res = '';
    if (isString(value)) {
        res = value;
    }
    else if (isArray(value)) {
        for (let i = 0; i < value.length; i++) {
            const normalized = normalizeClass(value[i]);
            if (normalized) {
                res += normalized + ' ';
            }
        }
    }
    else if (isObject(value)) {
        for (const name in value) {
            if (value[name]) {
                res += name + ' ';
            }
        }
    }
    return res.trim();
}
function normalizeProps(props) {
    if (!props)
        return null;
    let { class: klass, style } = props;
    if (klass && !isString(klass)) {
        props.class = normalizeClass(klass);
    }
    if (style) {
        props.style = normalizeStyle(style);
    }
    return props;
}

// These tag configs are shared between compiler-dom and runtime-dom, so they
// https://developer.mozilla.org/en-US/docs/Web/HTML/Element
const HTML_TAGS = 'html,body,base,head,link,meta,style,title,address,article,aside,footer,' +
    'header,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,' +
    'figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,' +
    'data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,' +
    'time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,' +
    'canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,' +
    'th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,' +
    'option,output,progress,select,textarea,details,dialog,menu,' +
    'summary,template,blockquote,iframe,tfoot';
// https://developer.mozilla.org/en-US/docs/Web/SVG/Element
const SVG_TAGS = 'svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,' +
    'defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,' +
    'feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,' +
    'feDistanceLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,' +
    'feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,' +
    'fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,' +
    'foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,' +
    'mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,' +
    'polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,' +
    'text,textPath,title,tspan,unknown,use,view';
const VOID_TAGS = 'area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr';
/**
 * Compiler only.
 * Do NOT use in runtime code paths unless behind `(process.env.NODE_ENV !== 'production')` flag.
 */
const isHTMLTag = /*#__PURE__*/ makeMap(HTML_TAGS);
/**
 * Compiler only.
 * Do NOT use in runtime code paths unless behind `(process.env.NODE_ENV !== 'production')` flag.
 */
const isSVGTag = /*#__PURE__*/ makeMap(SVG_TAGS);
/**
 * Compiler only.
 * Do NOT use in runtime code paths unless behind `(process.env.NODE_ENV !== 'production')` flag.
 */
const isVoidTag = /*#__PURE__*/ makeMap(VOID_TAGS);

const escapeRE = /["'&<>]/;
function escapeHtml(string) {
    const str = '' + string;
    const match = escapeRE.exec(str);
    if (!match) {
        return str;
    }
    let html = '';
    let escaped;
    let index;
    let lastIndex = 0;
    for (index = match.index; index < str.length; index++) {
        switch (str.charCodeAt(index)) {
            case 34: // "
                escaped = '&quot;';
                break;
            case 38: // &
                escaped = '&amp;';
                break;
            case 39: // '
                escaped = '&#39;';
                break;
            case 60: // <
                escaped = '&lt;';
                break;
            case 62: // >
                escaped = '&gt;';
                break;
            default:
                continue;
        }
        if (lastIndex !== index) {
            html += str.slice(lastIndex, index);
        }
        lastIndex = index + 1;
        html += escaped;
    }
    return lastIndex !== index ? html + str.slice(lastIndex, index) : html;
}
// https://www.w3.org/TR/html52/syntax.html#comments
const commentStripRE = /^-?>|<!--|-->|--!>|<!-$/g;
function escapeHtmlComment(src) {
    return src.replace(commentStripRE, '');
}

function looseCompareArrays(a, b) {
    if (a.length !== b.length)
        return false;
    let equal = true;
    for (let i = 0; equal && i < a.length; i++) {
        equal = looseEqual(a[i], b[i]);
    }
    return equal;
}
function looseEqual(a, b) {
    if (a === b)
        return true;
    let aValidType = isDate(a);
    let bValidType = isDate(b);
    if (aValidType || bValidType) {
        return aValidType && bValidType ? a.getTime() === b.getTime() : false;
    }
    aValidType = isArray(a);
    bValidType = isArray(b);
    if (aValidType || bValidType) {
        return aValidType && bValidType ? looseCompareArrays(a, b) : false;
    }
    aValidType = isObject(a);
    bValidType = isObject(b);
    if (aValidType || bValidType) {
        /* istanbul ignore if: this if will probably never be called */
        if (!aValidType || !bValidType) {
            return false;
        }
        const aKeysCount = Object.keys(a).length;
        const bKeysCount = Object.keys(b).length;
        if (aKeysCount !== bKeysCount) {
            return false;
        }
        for (const key in a) {
            const aHasKey = a.hasOwnProperty(key);
            const bHasKey = b.hasOwnProperty(key);
            if ((aHasKey && !bHasKey) ||
                (!aHasKey && bHasKey) ||
                !looseEqual(a[key], b[key])) {
                return false;
            }
        }
    }
    return String(a) === String(b);
}
function looseIndexOf(arr, val) {
    return arr.findIndex(item => looseEqual(item, val));
}

/**
 * For converting {{ interpolation }} values to displayed strings.
 * @private
 */
const toDisplayString = (val) => {
    return isString(val)
        ? val
        : val == null
            ? ''
            : isArray(val) ||
                (isObject(val) &&
                    (val.toString === objectToString || !isFunction(val.toString)))
                ? JSON.stringify(val, replacer, 2)
                : String(val);
};
const replacer = (_key, val) => {
    // can't use isRef here since @vue/shared has no deps
    if (val && val.__v_isRef) {
        return replacer(_key, val.value);
    }
    else if (isMap(val)) {
        return {
            [`Map(${val.size})`]: [...val.entries()].reduce((entries, [key, val]) => {
                entries[`${key} =>`] = val;
                return entries;
            }, {})
        };
    }
    else if (isSet(val)) {
        return {
            [`Set(${val.size})`]: [...val.values()]
        };
    }
    else if (isObject(val) && !isArray(val) && !isPlainObject(val)) {
        return String(val);
    }
    return val;
};

const EMPTY_OBJ = ( true)
    ? Object.freeze({})
    : 0;
const EMPTY_ARR = ( true) ? Object.freeze([]) : 0;
const NOOP = () => { };
/**
 * Always return false.
 */
const NO = () => false;
const onRE = /^on[^a-z]/;
const isOn = (key) => onRE.test(key);
const isModelListener = (key) => key.startsWith('onUpdate:');
const extend = Object.assign;
const remove = (arr, el) => {
    const i = arr.indexOf(el);
    if (i > -1) {
        arr.splice(i, 1);
    }
};
const hasOwnProperty = Object.prototype.hasOwnProperty;
const hasOwn = (val, key) => hasOwnProperty.call(val, key);
const isArray = Array.isArray;
const isMap = (val) => toTypeString(val) === '[object Map]';
const isSet = (val) => toTypeString(val) === '[object Set]';
const isDate = (val) => val instanceof Date;
const isFunction = (val) => typeof val === 'function';
const isString = (val) => typeof val === 'string';
const isSymbol = (val) => typeof val === 'symbol';
const isObject = (val) => val !== null && typeof val === 'object';
const isPromise = (val) => {
    return isObject(val) && isFunction(val.then) && isFunction(val.catch);
};
const objectToString = Object.prototype.toString;
const toTypeString = (value) => objectToString.call(value);
const toRawType = (value) => {
    // extract "RawType" from strings like "[object RawType]"
    return toTypeString(value).slice(8, -1);
};
const isPlainObject = (val) => toTypeString(val) === '[object Object]';
const isIntegerKey = (key) => isString(key) &&
    key !== 'NaN' &&
    key[0] !== '-' &&
    '' + parseInt(key, 10) === key;
const isReservedProp = /*#__PURE__*/ makeMap(
// the leading comma is intentional so empty string "" is also included
',key,ref,ref_for,ref_key,' +
    'onVnodeBeforeMount,onVnodeMounted,' +
    'onVnodeBeforeUpdate,onVnodeUpdated,' +
    'onVnodeBeforeUnmount,onVnodeUnmounted');
const isBuiltInDirective = /*#__PURE__*/ makeMap('bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo');
const cacheStringFunction = (fn) => {
    const cache = Object.create(null);
    return ((str) => {
        const hit = cache[str];
        return hit || (cache[str] = fn(str));
    });
};
const camelizeRE = /-(\w)/g;
/**
 * @private
 */
const camelize = cacheStringFunction((str) => {
    return str.replace(camelizeRE, (_, c) => (c ? c.toUpperCase() : ''));
});
const hyphenateRE = /\B([A-Z])/g;
/**
 * @private
 */
const hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, '-$1').toLowerCase());
/**
 * @private
 */
const capitalize = cacheStringFunction((str) => str.charAt(0).toUpperCase() + str.slice(1));
/**
 * @private
 */
const toHandlerKey = cacheStringFunction((str) => str ? `on${capitalize(str)}` : ``);
// compare whether a value has changed, accounting for NaN.
const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
const invokeArrayFns = (fns, arg) => {
    for (let i = 0; i < fns.length; i++) {
        fns[i](arg);
    }
};
const def = (obj, key, value) => {
    Object.defineProperty(obj, key, {
        configurable: true,
        enumerable: false,
        value
    });
};
const toNumber = (val) => {
    const n = parseFloat(val);
    return isNaN(n) ? val : n;
};
let _globalThis;
const getGlobalThis = () => {
    return (_globalThis ||
        (_globalThis =
            typeof globalThis !== 'undefined'
                ? globalThis
                : typeof self !== 'undefined'
                    ? self
                    : typeof window !== 'undefined'
                        ? window
                        : typeof __webpack_require__.g !== 'undefined'
                            ? __webpack_require__.g
                            : {}));
};




/***/ }),

/***/ "./node_modules/@vue/runtime-core/dist/runtime-core.esm-bundler.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@vue/runtime-core/dist/runtime-core.esm-bundler.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EffectScope": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.EffectScope),
/* harmony export */   "ReactiveEffect": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ReactiveEffect),
/* harmony export */   "customRef": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.customRef),
/* harmony export */   "effect": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.effect),
/* harmony export */   "effectScope": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.effectScope),
/* harmony export */   "getCurrentScope": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.getCurrentScope),
/* harmony export */   "isProxy": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isProxy),
/* harmony export */   "isReactive": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReactive),
/* harmony export */   "isReadonly": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReadonly),
/* harmony export */   "isRef": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef),
/* harmony export */   "isShallow": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isShallow),
/* harmony export */   "markRaw": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.markRaw),
/* harmony export */   "onScopeDispose": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.onScopeDispose),
/* harmony export */   "proxyRefs": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.proxyRefs),
/* harmony export */   "reactive": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.reactive),
/* harmony export */   "readonly": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.readonly),
/* harmony export */   "ref": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ref),
/* harmony export */   "shallowReactive": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReactive),
/* harmony export */   "shallowReadonly": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly),
/* harmony export */   "shallowRef": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowRef),
/* harmony export */   "stop": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.stop),
/* harmony export */   "toRaw": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw),
/* harmony export */   "toRef": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRef),
/* harmony export */   "toRefs": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRefs),
/* harmony export */   "triggerRef": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.triggerRef),
/* harmony export */   "unref": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.unref),
/* harmony export */   "camelize": () => (/* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize),
/* harmony export */   "capitalize": () => (/* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_1__.capitalize),
/* harmony export */   "normalizeClass": () => (/* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_1__.normalizeClass),
/* harmony export */   "normalizeProps": () => (/* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_1__.normalizeProps),
/* harmony export */   "normalizeStyle": () => (/* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_1__.normalizeStyle),
/* harmony export */   "toDisplayString": () => (/* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_1__.toDisplayString),
/* harmony export */   "toHandlerKey": () => (/* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey),
/* harmony export */   "BaseTransition": () => (/* binding */ BaseTransition),
/* harmony export */   "Comment": () => (/* binding */ Comment),
/* harmony export */   "Fragment": () => (/* binding */ Fragment),
/* harmony export */   "KeepAlive": () => (/* binding */ KeepAlive),
/* harmony export */   "Static": () => (/* binding */ Static),
/* harmony export */   "Suspense": () => (/* binding */ Suspense),
/* harmony export */   "Teleport": () => (/* binding */ Teleport),
/* harmony export */   "Text": () => (/* binding */ Text),
/* harmony export */   "callWithAsyncErrorHandling": () => (/* binding */ callWithAsyncErrorHandling),
/* harmony export */   "callWithErrorHandling": () => (/* binding */ callWithErrorHandling),
/* harmony export */   "cloneVNode": () => (/* binding */ cloneVNode),
/* harmony export */   "compatUtils": () => (/* binding */ compatUtils),
/* harmony export */   "computed": () => (/* binding */ computed),
/* harmony export */   "createBlock": () => (/* binding */ createBlock),
/* harmony export */   "createCommentVNode": () => (/* binding */ createCommentVNode),
/* harmony export */   "createElementBlock": () => (/* binding */ createElementBlock),
/* harmony export */   "createElementVNode": () => (/* binding */ createBaseVNode),
/* harmony export */   "createHydrationRenderer": () => (/* binding */ createHydrationRenderer),
/* harmony export */   "createPropsRestProxy": () => (/* binding */ createPropsRestProxy),
/* harmony export */   "createRenderer": () => (/* binding */ createRenderer),
/* harmony export */   "createSlots": () => (/* binding */ createSlots),
/* harmony export */   "createStaticVNode": () => (/* binding */ createStaticVNode),
/* harmony export */   "createTextVNode": () => (/* binding */ createTextVNode),
/* harmony export */   "createVNode": () => (/* binding */ createVNode),
/* harmony export */   "defineAsyncComponent": () => (/* binding */ defineAsyncComponent),
/* harmony export */   "defineComponent": () => (/* binding */ defineComponent),
/* harmony export */   "defineEmits": () => (/* binding */ defineEmits),
/* harmony export */   "defineExpose": () => (/* binding */ defineExpose),
/* harmony export */   "defineProps": () => (/* binding */ defineProps),
/* harmony export */   "devtools": () => (/* binding */ devtools),
/* harmony export */   "getCurrentInstance": () => (/* binding */ getCurrentInstance),
/* harmony export */   "getTransitionRawChildren": () => (/* binding */ getTransitionRawChildren),
/* harmony export */   "guardReactiveProps": () => (/* binding */ guardReactiveProps),
/* harmony export */   "h": () => (/* binding */ h),
/* harmony export */   "handleError": () => (/* binding */ handleError),
/* harmony export */   "initCustomFormatter": () => (/* binding */ initCustomFormatter),
/* harmony export */   "inject": () => (/* binding */ inject),
/* harmony export */   "isMemoSame": () => (/* binding */ isMemoSame),
/* harmony export */   "isRuntimeOnly": () => (/* binding */ isRuntimeOnly),
/* harmony export */   "isVNode": () => (/* binding */ isVNode),
/* harmony export */   "mergeDefaults": () => (/* binding */ mergeDefaults),
/* harmony export */   "mergeProps": () => (/* binding */ mergeProps),
/* harmony export */   "nextTick": () => (/* binding */ nextTick),
/* harmony export */   "onActivated": () => (/* binding */ onActivated),
/* harmony export */   "onBeforeMount": () => (/* binding */ onBeforeMount),
/* harmony export */   "onBeforeUnmount": () => (/* binding */ onBeforeUnmount),
/* harmony export */   "onBeforeUpdate": () => (/* binding */ onBeforeUpdate),
/* harmony export */   "onDeactivated": () => (/* binding */ onDeactivated),
/* harmony export */   "onErrorCaptured": () => (/* binding */ onErrorCaptured),
/* harmony export */   "onMounted": () => (/* binding */ onMounted),
/* harmony export */   "onRenderTracked": () => (/* binding */ onRenderTracked),
/* harmony export */   "onRenderTriggered": () => (/* binding */ onRenderTriggered),
/* harmony export */   "onServerPrefetch": () => (/* binding */ onServerPrefetch),
/* harmony export */   "onUnmounted": () => (/* binding */ onUnmounted),
/* harmony export */   "onUpdated": () => (/* binding */ onUpdated),
/* harmony export */   "openBlock": () => (/* binding */ openBlock),
/* harmony export */   "popScopeId": () => (/* binding */ popScopeId),
/* harmony export */   "provide": () => (/* binding */ provide),
/* harmony export */   "pushScopeId": () => (/* binding */ pushScopeId),
/* harmony export */   "queuePostFlushCb": () => (/* binding */ queuePostFlushCb),
/* harmony export */   "registerRuntimeCompiler": () => (/* binding */ registerRuntimeCompiler),
/* harmony export */   "renderList": () => (/* binding */ renderList),
/* harmony export */   "renderSlot": () => (/* binding */ renderSlot),
/* harmony export */   "resolveComponent": () => (/* binding */ resolveComponent),
/* harmony export */   "resolveDirective": () => (/* binding */ resolveDirective),
/* harmony export */   "resolveDynamicComponent": () => (/* binding */ resolveDynamicComponent),
/* harmony export */   "resolveFilter": () => (/* binding */ resolveFilter),
/* harmony export */   "resolveTransitionHooks": () => (/* binding */ resolveTransitionHooks),
/* harmony export */   "setBlockTracking": () => (/* binding */ setBlockTracking),
/* harmony export */   "setDevtoolsHook": () => (/* binding */ setDevtoolsHook),
/* harmony export */   "setTransitionHooks": () => (/* binding */ setTransitionHooks),
/* harmony export */   "ssrContextKey": () => (/* binding */ ssrContextKey),
/* harmony export */   "ssrUtils": () => (/* binding */ ssrUtils),
/* harmony export */   "toHandlers": () => (/* binding */ toHandlers),
/* harmony export */   "transformVNodeArgs": () => (/* binding */ transformVNodeArgs),
/* harmony export */   "useAttrs": () => (/* binding */ useAttrs),
/* harmony export */   "useSSRContext": () => (/* binding */ useSSRContext),
/* harmony export */   "useSlots": () => (/* binding */ useSlots),
/* harmony export */   "useTransitionState": () => (/* binding */ useTransitionState),
/* harmony export */   "version": () => (/* binding */ version),
/* harmony export */   "warn": () => (/* binding */ warn),
/* harmony export */   "watch": () => (/* binding */ watch),
/* harmony export */   "watchEffect": () => (/* binding */ watchEffect),
/* harmony export */   "watchPostEffect": () => (/* binding */ watchPostEffect),
/* harmony export */   "watchSyncEffect": () => (/* binding */ watchSyncEffect),
/* harmony export */   "withAsyncContext": () => (/* binding */ withAsyncContext),
/* harmony export */   "withCtx": () => (/* binding */ withCtx),
/* harmony export */   "withDefaults": () => (/* binding */ withDefaults),
/* harmony export */   "withDirectives": () => (/* binding */ withDirectives),
/* harmony export */   "withMemo": () => (/* binding */ withMemo),
/* harmony export */   "withScopeId": () => (/* binding */ withScopeId)
/* harmony export */ });
/* harmony import */ var _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vue/reactivity */ "./node_modules/@vue/runtime-core/node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js");
/* harmony import */ var _vue_shared__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @vue/shared */ "./node_modules/@vue/runtime-core/node_modules/@vue/shared/dist/shared.esm-bundler.js");





const stack = [];
function pushWarningContext(vnode) {
    stack.push(vnode);
}
function popWarningContext() {
    stack.pop();
}
function warn(msg, ...args) {
    // avoid props formatting or warn handler tracking deps that might be mutated
    // during patch, leading to infinite recursion.
    (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.pauseTracking)();
    const instance = stack.length ? stack[stack.length - 1].component : null;
    const appWarnHandler = instance && instance.appContext.config.warnHandler;
    const trace = getComponentTrace();
    if (appWarnHandler) {
        callWithErrorHandling(appWarnHandler, instance, 11 /* APP_WARN_HANDLER */, [
            msg + args.join(''),
            instance && instance.proxy,
            trace
                .map(({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`)
                .join('\n'),
            trace
        ]);
    }
    else {
        const warnArgs = [`[Vue warn]: ${msg}`, ...args];
        /* istanbul ignore if */
        if (trace.length &&
            // avoid spamming console during tests
            !false) {
            warnArgs.push(`\n`, ...formatTrace(trace));
        }
        console.warn(...warnArgs);
    }
    (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.resetTracking)();
}
function getComponentTrace() {
    let currentVNode = stack[stack.length - 1];
    if (!currentVNode) {
        return [];
    }
    // we can't just use the stack because it will be incomplete during updates
    // that did not start from the root. Re-construct the parent chain using
    // instance parent pointers.
    const normalizedStack = [];
    while (currentVNode) {
        const last = normalizedStack[0];
        if (last && last.vnode === currentVNode) {
            last.recurseCount++;
        }
        else {
            normalizedStack.push({
                vnode: currentVNode,
                recurseCount: 0
            });
        }
        const parentInstance = currentVNode.component && currentVNode.component.parent;
        currentVNode = parentInstance && parentInstance.vnode;
    }
    return normalizedStack;
}
/* istanbul ignore next */
function formatTrace(trace) {
    const logs = [];
    trace.forEach((entry, i) => {
        logs.push(...(i === 0 ? [] : [`\n`]), ...formatTraceEntry(entry));
    });
    return logs;
}
function formatTraceEntry({ vnode, recurseCount }) {
    const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
    const isRoot = vnode.component ? vnode.component.parent == null : false;
    const open = ` at <${formatComponentName(vnode.component, vnode.type, isRoot)}`;
    const close = `>` + postfix;
    return vnode.props
        ? [open, ...formatProps(vnode.props), close]
        : [open + close];
}
/* istanbul ignore next */
function formatProps(props) {
    const res = [];
    const keys = Object.keys(props);
    keys.slice(0, 3).forEach(key => {
        res.push(...formatProp(key, props[key]));
    });
    if (keys.length > 3) {
        res.push(` ...`);
    }
    return res;
}
/* istanbul ignore next */
function formatProp(key, value, raw) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(value)) {
        value = JSON.stringify(value);
        return raw ? value : [`${key}=${value}`];
    }
    else if (typeof value === 'number' ||
        typeof value === 'boolean' ||
        value == null) {
        return raw ? value : [`${key}=${value}`];
    }
    else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(value)) {
        value = formatProp(key, (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(value.value), true);
        return raw ? value : [`${key}=Ref<`, value, `>`];
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(value)) {
        return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];
    }
    else {
        value = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(value);
        return raw ? value : [`${key}=`, value];
    }
}

const ErrorTypeStrings = {
    ["sp" /* SERVER_PREFETCH */]: 'serverPrefetch hook',
    ["bc" /* BEFORE_CREATE */]: 'beforeCreate hook',
    ["c" /* CREATED */]: 'created hook',
    ["bm" /* BEFORE_MOUNT */]: 'beforeMount hook',
    ["m" /* MOUNTED */]: 'mounted hook',
    ["bu" /* BEFORE_UPDATE */]: 'beforeUpdate hook',
    ["u" /* UPDATED */]: 'updated',
    ["bum" /* BEFORE_UNMOUNT */]: 'beforeUnmount hook',
    ["um" /* UNMOUNTED */]: 'unmounted hook',
    ["a" /* ACTIVATED */]: 'activated hook',
    ["da" /* DEACTIVATED */]: 'deactivated hook',
    ["ec" /* ERROR_CAPTURED */]: 'errorCaptured hook',
    ["rtc" /* RENDER_TRACKED */]: 'renderTracked hook',
    ["rtg" /* RENDER_TRIGGERED */]: 'renderTriggered hook',
    [0 /* SETUP_FUNCTION */]: 'setup function',
    [1 /* RENDER_FUNCTION */]: 'render function',
    [2 /* WATCH_GETTER */]: 'watcher getter',
    [3 /* WATCH_CALLBACK */]: 'watcher callback',
    [4 /* WATCH_CLEANUP */]: 'watcher cleanup function',
    [5 /* NATIVE_EVENT_HANDLER */]: 'native event handler',
    [6 /* COMPONENT_EVENT_HANDLER */]: 'component event handler',
    [7 /* VNODE_HOOK */]: 'vnode hook',
    [8 /* DIRECTIVE_HOOK */]: 'directive hook',
    [9 /* TRANSITION_HOOK */]: 'transition hook',
    [10 /* APP_ERROR_HANDLER */]: 'app errorHandler',
    [11 /* APP_WARN_HANDLER */]: 'app warnHandler',
    [12 /* FUNCTION_REF */]: 'ref function',
    [13 /* ASYNC_COMPONENT_LOADER */]: 'async component loader',
    [14 /* SCHEDULER */]: 'scheduler flush. This is likely a Vue internals bug. ' +
        'Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/core'
};
function callWithErrorHandling(fn, instance, type, args) {
    let res;
    try {
        res = args ? fn(...args) : fn();
    }
    catch (err) {
        handleError(err, instance, type);
    }
    return res;
}
function callWithAsyncErrorHandling(fn, instance, type, args) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(fn)) {
        const res = callWithErrorHandling(fn, instance, type, args);
        if (res && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isPromise)(res)) {
            res.catch(err => {
                handleError(err, instance, type);
            });
        }
        return res;
    }
    const values = [];
    for (let i = 0; i < fn.length; i++) {
        values.push(callWithAsyncErrorHandling(fn[i], instance, type, args));
    }
    return values;
}
function handleError(err, instance, type, throwInDev = true) {
    const contextVNode = instance ? instance.vnode : null;
    if (instance) {
        let cur = instance.parent;
        // the exposed instance is the render proxy to keep it consistent with 2.x
        const exposedInstance = instance.proxy;
        // in production the hook receives only the error code
        const errorInfo = ( true) ? ErrorTypeStrings[type] : 0;
        while (cur) {
            const errorCapturedHooks = cur.ec;
            if (errorCapturedHooks) {
                for (let i = 0; i < errorCapturedHooks.length; i++) {
                    if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {
                        return;
                    }
                }
            }
            cur = cur.parent;
        }
        // app-level handling
        const appErrorHandler = instance.appContext.config.errorHandler;
        if (appErrorHandler) {
            callWithErrorHandling(appErrorHandler, null, 10 /* APP_ERROR_HANDLER */, [err, exposedInstance, errorInfo]);
            return;
        }
    }
    logError(err, type, contextVNode, throwInDev);
}
function logError(err, type, contextVNode, throwInDev = true) {
    if ((true)) {
        const info = ErrorTypeStrings[type];
        if (contextVNode) {
            pushWarningContext(contextVNode);
        }
        warn(`Unhandled error${info ? ` during execution of ${info}` : ``}`);
        if (contextVNode) {
            popWarningContext();
        }
        // crash in dev by default so it's more noticeable
        if (throwInDev) {
            throw err;
        }
        else {
            console.error(err);
        }
    }
    else {}
}

let isFlushing = false;
let isFlushPending = false;
const queue = [];
let flushIndex = 0;
const pendingPreFlushCbs = [];
let activePreFlushCbs = null;
let preFlushIndex = 0;
const pendingPostFlushCbs = [];
let activePostFlushCbs = null;
let postFlushIndex = 0;
const resolvedPromise = Promise.resolve();
let currentFlushPromise = null;
let currentPreFlushParentJob = null;
const RECURSION_LIMIT = 100;
function nextTick(fn) {
    const p = currentFlushPromise || resolvedPromise;
    return fn ? p.then(this ? fn.bind(this) : fn) : p;
}
// #2768
// Use binary-search to find a suitable position in the queue,
// so that the queue maintains the increasing order of job's id,
// which can prevent the job from being skipped and also can avoid repeated patching.
function findInsertionIndex(id) {
    // the start index should be `flushIndex + 1`
    let start = flushIndex + 1;
    let end = queue.length;
    while (start < end) {
        const middle = (start + end) >>> 1;
        const middleJobId = getId(queue[middle]);
        middleJobId < id ? (start = middle + 1) : (end = middle);
    }
    return start;
}
function queueJob(job) {
    // the dedupe search uses the startIndex argument of Array.includes()
    // by default the search index includes the current job that is being run
    // so it cannot recursively trigger itself again.
    // if the job is a watch() callback, the search will start with a +1 index to
    // allow it recursively trigger itself - it is the user's responsibility to
    // ensure it doesn't end up in an infinite loop.
    if ((!queue.length ||
        !queue.includes(job, isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex)) &&
        job !== currentPreFlushParentJob) {
        if (job.id == null) {
            queue.push(job);
        }
        else {
            queue.splice(findInsertionIndex(job.id), 0, job);
        }
        queueFlush();
    }
}
function queueFlush() {
    if (!isFlushing && !isFlushPending) {
        isFlushPending = true;
        currentFlushPromise = resolvedPromise.then(flushJobs);
    }
}
function invalidateJob(job) {
    const i = queue.indexOf(job);
    if (i > flushIndex) {
        queue.splice(i, 1);
    }
}
function queueCb(cb, activeQueue, pendingQueue, index) {
    if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(cb)) {
        if (!activeQueue ||
            !activeQueue.includes(cb, cb.allowRecurse ? index + 1 : index)) {
            pendingQueue.push(cb);
        }
    }
    else {
        // if cb is an array, it is a component lifecycle hook which can only be
        // triggered by a job, which is already deduped in the main queue, so
        // we can skip duplicate check here to improve perf
        pendingQueue.push(...cb);
    }
    queueFlush();
}
function queuePreFlushCb(cb) {
    queueCb(cb, activePreFlushCbs, pendingPreFlushCbs, preFlushIndex);
}
function queuePostFlushCb(cb) {
    queueCb(cb, activePostFlushCbs, pendingPostFlushCbs, postFlushIndex);
}
function flushPreFlushCbs(seen, parentJob = null) {
    if (pendingPreFlushCbs.length) {
        currentPreFlushParentJob = parentJob;
        activePreFlushCbs = [...new Set(pendingPreFlushCbs)];
        pendingPreFlushCbs.length = 0;
        if ((true)) {
            seen = seen || new Map();
        }
        for (preFlushIndex = 0; preFlushIndex < activePreFlushCbs.length; preFlushIndex++) {
            if (( true) &&
                checkRecursiveUpdates(seen, activePreFlushCbs[preFlushIndex])) {
                continue;
            }
            activePreFlushCbs[preFlushIndex]();
        }
        activePreFlushCbs = null;
        preFlushIndex = 0;
        currentPreFlushParentJob = null;
        // recursively flush until it drains
        flushPreFlushCbs(seen, parentJob);
    }
}
function flushPostFlushCbs(seen) {
    if (pendingPostFlushCbs.length) {
        const deduped = [...new Set(pendingPostFlushCbs)];
        pendingPostFlushCbs.length = 0;
        // #1947 already has active queue, nested flushPostFlushCbs call
        if (activePostFlushCbs) {
            activePostFlushCbs.push(...deduped);
            return;
        }
        activePostFlushCbs = deduped;
        if ((true)) {
            seen = seen || new Map();
        }
        activePostFlushCbs.sort((a, b) => getId(a) - getId(b));
        for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
            if (( true) &&
                checkRecursiveUpdates(seen, activePostFlushCbs[postFlushIndex])) {
                continue;
            }
            activePostFlushCbs[postFlushIndex]();
        }
        activePostFlushCbs = null;
        postFlushIndex = 0;
    }
}
const getId = (job) => job.id == null ? Infinity : job.id;
function flushJobs(seen) {
    isFlushPending = false;
    isFlushing = true;
    if ((true)) {
        seen = seen || new Map();
    }
    flushPreFlushCbs(seen);
    // Sort queue before flush.
    // This ensures that:
    // 1. Components are updated from parent to child. (because parent is always
    //    created before the child so its render effect will have smaller
    //    priority number)
    // 2. If a component is unmounted during a parent component's update,
    //    its update can be skipped.
    queue.sort((a, b) => getId(a) - getId(b));
    // conditional usage of checkRecursiveUpdate must be determined out of
    // try ... catch block since Rollup by default de-optimizes treeshaking
    // inside try-catch. This can leave all warning code unshaked. Although
    // they would get eventually shaken by a minifier like terser, some minifiers
    // would fail to do that (e.g. https://github.com/evanw/esbuild/issues/1610)
    const check = ( true)
        ? (job) => checkRecursiveUpdates(seen, job)
        : 0;
    try {
        for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
            const job = queue[flushIndex];
            if (job && job.active !== false) {
                if (( true) && check(job)) {
                    continue;
                }
                // console.log(`running:`, job.id)
                callWithErrorHandling(job, null, 14 /* SCHEDULER */);
            }
        }
    }
    finally {
        flushIndex = 0;
        queue.length = 0;
        flushPostFlushCbs(seen);
        isFlushing = false;
        currentFlushPromise = null;
        // some postFlushCb queued jobs!
        // keep flushing until it drains.
        if (queue.length ||
            pendingPreFlushCbs.length ||
            pendingPostFlushCbs.length) {
            flushJobs(seen);
        }
    }
}
function checkRecursiveUpdates(seen, fn) {
    if (!seen.has(fn)) {
        seen.set(fn, 1);
    }
    else {
        const count = seen.get(fn);
        if (count > RECURSION_LIMIT) {
            const instance = fn.ownerInstance;
            const componentName = instance && getComponentName(instance.type);
            warn(`Maximum recursive updates exceeded${componentName ? ` in component <${componentName}>` : ``}. ` +
                `This means you have a reactive effect that is mutating its own ` +
                `dependencies and thus recursively triggering itself. Possible sources ` +
                `include component template, render function, updated hook or ` +
                `watcher source function.`);
            return true;
        }
        else {
            seen.set(fn, count + 1);
        }
    }
}

/* eslint-disable no-restricted-globals */
let isHmrUpdating = false;
const hmrDirtyComponents = new Set();
// Expose the HMR runtime on the global object
// This makes it entirely tree-shakable without polluting the exports and makes
// it easier to be used in toolings like vue-loader
// Note: for a component to be eligible for HMR it also needs the __hmrId option
// to be set so that its instances can be registered / removed.
if ((true)) {
    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.getGlobalThis)().__VUE_HMR_RUNTIME__ = {
        createRecord: tryWrap(createRecord),
        rerender: tryWrap(rerender),
        reload: tryWrap(reload)
    };
}
const map = new Map();
function registerHMR(instance) {
    const id = instance.type.__hmrId;
    let record = map.get(id);
    if (!record) {
        createRecord(id, instance.type);
        record = map.get(id);
    }
    record.instances.add(instance);
}
function unregisterHMR(instance) {
    map.get(instance.type.__hmrId).instances.delete(instance);
}
function createRecord(id, initialDef) {
    if (map.has(id)) {
        return false;
    }
    map.set(id, {
        initialDef: normalizeClassComponent(initialDef),
        instances: new Set()
    });
    return true;
}
function normalizeClassComponent(component) {
    return isClassComponent(component) ? component.__vccOpts : component;
}
function rerender(id, newRender) {
    const record = map.get(id);
    if (!record) {
        return;
    }
    // update initial record (for not-yet-rendered component)
    record.initialDef.render = newRender;
    [...record.instances].forEach(instance => {
        if (newRender) {
            instance.render = newRender;
            normalizeClassComponent(instance.type).render = newRender;
        }
        instance.renderCache = [];
        // this flag forces child components with slot content to update
        isHmrUpdating = true;
        instance.update();
        isHmrUpdating = false;
    });
}
function reload(id, newComp) {
    const record = map.get(id);
    if (!record)
        return;
    newComp = normalizeClassComponent(newComp);
    // update initial def (for not-yet-rendered components)
    updateComponentDef(record.initialDef, newComp);
    // create a snapshot which avoids the set being mutated during updates
    const instances = [...record.instances];
    for (const instance of instances) {
        const oldComp = normalizeClassComponent(instance.type);
        if (!hmrDirtyComponents.has(oldComp)) {
            // 1. Update existing comp definition to match new one
            if (oldComp !== record.initialDef) {
                updateComponentDef(oldComp, newComp);
            }
            // 2. mark definition dirty. This forces the renderer to replace the
            // component on patch.
            hmrDirtyComponents.add(oldComp);
        }
        // 3. invalidate options resolution cache
        instance.appContext.optionsCache.delete(instance.type);
        // 4. actually update
        if (instance.ceReload) {
            // custom element
            hmrDirtyComponents.add(oldComp);
            instance.ceReload(newComp.styles);
            hmrDirtyComponents.delete(oldComp);
        }
        else if (instance.parent) {
            // 4. Force the parent instance to re-render. This will cause all updated
            // components to be unmounted and re-mounted. Queue the update so that we
            // don't end up forcing the same parent to re-render multiple times.
            queueJob(instance.parent.update);
            // instance is the inner component of an async custom element
            // invoke to reset styles
            if (instance.parent.type.__asyncLoader &&
                instance.parent.ceReload) {
                instance.parent.ceReload(newComp.styles);
            }
        }
        else if (instance.appContext.reload) {
            // root instance mounted via createApp() has a reload method
            instance.appContext.reload();
        }
        else if (typeof window !== 'undefined') {
            // root instance inside tree created via raw render(). Force reload.
            window.location.reload();
        }
        else {
            console.warn('[HMR] Root or manually mounted instance modified. Full reload required.');
        }
    }
    // 5. make sure to cleanup dirty hmr components after update
    queuePostFlushCb(() => {
        for (const instance of instances) {
            hmrDirtyComponents.delete(normalizeClassComponent(instance.type));
        }
    });
}
function updateComponentDef(oldComp, newComp) {
    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(oldComp, newComp);
    for (const key in oldComp) {
        if (key !== '__file' && !(key in newComp)) {
            delete oldComp[key];
        }
    }
}
function tryWrap(fn) {
    return (id, arg) => {
        try {
            return fn(id, arg);
        }
        catch (e) {
            console.error(e);
            console.warn(`[HMR] Something went wrong during Vue component hot-reload. ` +
                `Full reload required.`);
        }
    };
}

let devtools;
let buffer = [];
let devtoolsNotInstalled = false;
function emit(event, ...args) {
    if (devtools) {
        devtools.emit(event, ...args);
    }
    else if (!devtoolsNotInstalled) {
        buffer.push({ event, args });
    }
}
function setDevtoolsHook(hook, target) {
    var _a, _b;
    devtools = hook;
    if (devtools) {
        devtools.enabled = true;
        buffer.forEach(({ event, args }) => devtools.emit(event, ...args));
        buffer = [];
    }
    else if (
    // handle late devtools injection - only do this if we are in an actual
    // browser environment to avoid the timer handle stalling test runner exit
    // (#4815)
    // eslint-disable-next-line no-restricted-globals
    typeof window !== 'undefined' &&
        // some envs mock window but not fully
        window.HTMLElement &&
        // also exclude jsdom
        !((_b = (_a = window.navigator) === null || _a === void 0 ? void 0 : _a.userAgent) === null || _b === void 0 ? void 0 : _b.includes('jsdom'))) {
        const replay = (target.__VUE_DEVTOOLS_HOOK_REPLAY__ =
            target.__VUE_DEVTOOLS_HOOK_REPLAY__ || []);
        replay.push((newHook) => {
            setDevtoolsHook(newHook, target);
        });
        // clear buffer after 3s - the user probably doesn't have devtools installed
        // at all, and keeping the buffer will cause memory leaks (#4738)
        setTimeout(() => {
            if (!devtools) {
                target.__VUE_DEVTOOLS_HOOK_REPLAY__ = null;
                devtoolsNotInstalled = true;
                buffer = [];
            }
        }, 3000);
    }
    else {
        // non-browser env, assume not installed
        devtoolsNotInstalled = true;
        buffer = [];
    }
}
function devtoolsInitApp(app, version) {
    emit("app:init" /* APP_INIT */, app, version, {
        Fragment,
        Text,
        Comment,
        Static
    });
}
function devtoolsUnmountApp(app) {
    emit("app:unmount" /* APP_UNMOUNT */, app);
}
const devtoolsComponentAdded = /*#__PURE__*/ createDevtoolsComponentHook("component:added" /* COMPONENT_ADDED */);
const devtoolsComponentUpdated = 
/*#__PURE__*/ createDevtoolsComponentHook("component:updated" /* COMPONENT_UPDATED */);
const devtoolsComponentRemoved = 
/*#__PURE__*/ createDevtoolsComponentHook("component:removed" /* COMPONENT_REMOVED */);
function createDevtoolsComponentHook(hook) {
    return (component) => {
        emit(hook, component.appContext.app, component.uid, component.parent ? component.parent.uid : undefined, component);
    };
}
const devtoolsPerfStart = /*#__PURE__*/ createDevtoolsPerformanceHook("perf:start" /* PERFORMANCE_START */);
const devtoolsPerfEnd = /*#__PURE__*/ createDevtoolsPerformanceHook("perf:end" /* PERFORMANCE_END */);
function createDevtoolsPerformanceHook(hook) {
    return (component, type, time) => {
        emit(hook, component.appContext.app, component.uid, component, type, time);
    };
}
function devtoolsComponentEmit(component, event, params) {
    emit("component:emit" /* COMPONENT_EMIT */, component.appContext.app, component, event, params);
}

function emit$1(instance, event, ...rawArgs) {
    const props = instance.vnode.props || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
    if ((true)) {
        const { emitsOptions, propsOptions: [propsOptions] } = instance;
        if (emitsOptions) {
            if (!(event in emitsOptions) &&
                !(false )) {
                if (!propsOptions || !((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)(event) in propsOptions)) {
                    warn(`Component emitted event "${event}" but it is neither declared in ` +
                        `the emits option nor as an "${(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)(event)}" prop.`);
                }
            }
            else {
                const validator = emitsOptions[event];
                if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(validator)) {
                    const isValid = validator(...rawArgs);
                    if (!isValid) {
                        warn(`Invalid event arguments: event validation failed for event "${event}".`);
                    }
                }
            }
        }
    }
    let args = rawArgs;
    const isModelListener = event.startsWith('update:');
    // for v-model update:xxx events, apply modifiers on args
    const modelArg = isModelListener && event.slice(7);
    if (modelArg && modelArg in props) {
        const modifiersKey = `${modelArg === 'modelValue' ? 'model' : modelArg}Modifiers`;
        const { number, trim } = props[modifiersKey] || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
        if (trim) {
            args = rawArgs.map(a => a.trim());
        }
        else if (number) {
            args = rawArgs.map(_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toNumber);
        }
    }
    if (true) {
        devtoolsComponentEmit(instance, event, args);
    }
    if ((true)) {
        const lowerCaseEvent = event.toLowerCase();
        if (lowerCaseEvent !== event && props[(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)(lowerCaseEvent)]) {
            warn(`Event "${lowerCaseEvent}" is emitted in component ` +
                `${formatComponentName(instance, instance.type)} but the handler is registered for "${event}". ` +
                `Note that HTML attributes are case-insensitive and you cannot use ` +
                `v-on to listen to camelCase events when using in-DOM templates. ` +
                `You should probably use "${(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(event)}" instead of "${event}".`);
        }
    }
    let handlerName;
    let handler = props[(handlerName = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)(event))] ||
        // also try camelCase event handler (#2249)
        props[(handlerName = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(event)))];
    // for v-model update:xxx events, also trigger kebab-case equivalent
    // for props passed via kebab-case
    if (!handler && isModelListener) {
        handler = props[(handlerName = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(event)))];
    }
    if (handler) {
        callWithAsyncErrorHandling(handler, instance, 6 /* COMPONENT_EVENT_HANDLER */, args);
    }
    const onceHandler = props[handlerName + `Once`];
    if (onceHandler) {
        if (!instance.emitted) {
            instance.emitted = {};
        }
        else if (instance.emitted[handlerName]) {
            return;
        }
        instance.emitted[handlerName] = true;
        callWithAsyncErrorHandling(onceHandler, instance, 6 /* COMPONENT_EVENT_HANDLER */, args);
    }
}
function normalizeEmitsOptions(comp, appContext, asMixin = false) {
    const cache = appContext.emitsCache;
    const cached = cache.get(comp);
    if (cached !== undefined) {
        return cached;
    }
    const raw = comp.emits;
    let normalized = {};
    // apply mixin/extends props
    let hasExtends = false;
    if ( true && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(comp)) {
        const extendEmits = (raw) => {
            const normalizedFromExtend = normalizeEmitsOptions(raw, appContext, true);
            if (normalizedFromExtend) {
                hasExtends = true;
                (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(normalized, normalizedFromExtend);
            }
        };
        if (!asMixin && appContext.mixins.length) {
            appContext.mixins.forEach(extendEmits);
        }
        if (comp.extends) {
            extendEmits(comp.extends);
        }
        if (comp.mixins) {
            comp.mixins.forEach(extendEmits);
        }
    }
    if (!raw && !hasExtends) {
        cache.set(comp, null);
        return null;
    }
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(raw)) {
        raw.forEach(key => (normalized[key] = null));
    }
    else {
        (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(normalized, raw);
    }
    cache.set(comp, normalized);
    return normalized;
}
// Check if an incoming prop key is a declared emit event listener.
// e.g. With `emits: { click: null }`, props named `onClick` and `onclick` are
// both considered matched listeners.
function isEmitListener(options, key) {
    if (!options || !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isOn)(key)) {
        return false;
    }
    key = key.slice(2).replace(/Once$/, '');
    return ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(options, key[0].toLowerCase() + key.slice(1)) ||
        (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(options, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(key)) ||
        (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(options, key));
}

/**
 * mark the current rendering instance for asset resolution (e.g.
 * resolveComponent, resolveDirective) during render
 */
let currentRenderingInstance = null;
let currentScopeId = null;
/**
 * Note: rendering calls maybe nested. The function returns the parent rendering
 * instance if present, which should be restored after the render is done:
 *
 * ```js
 * const prev = setCurrentRenderingInstance(i)
 * // ...render
 * setCurrentRenderingInstance(prev)
 * ```
 */
function setCurrentRenderingInstance(instance) {
    const prev = currentRenderingInstance;
    currentRenderingInstance = instance;
    currentScopeId = (instance && instance.type.__scopeId) || null;
    return prev;
}
/**
 * Set scope id when creating hoisted vnodes.
 * @private compiler helper
 */
function pushScopeId(id) {
    currentScopeId = id;
}
/**
 * Technically we no longer need this after 3.0.8 but we need to keep the same
 * API for backwards compat w/ code generated by compilers.
 * @private
 */
function popScopeId() {
    currentScopeId = null;
}
/**
 * Only for backwards compat
 * @private
 */
const withScopeId = (_id) => withCtx;
/**
 * Wrap a slot function to memoize current rendering instance
 * @private compiler helper
 */
function withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot // false only
) {
    if (!ctx)
        return fn;
    // already normalized
    if (fn._n) {
        return fn;
    }
    const renderFnWithContext = (...args) => {
        // If a user calls a compiled slot inside a template expression (#1745), it
        // can mess up block tracking, so by default we disable block tracking and
        // force bail out when invoking a compiled slot (indicated by the ._d flag).
        // This isn't necessary if rendering a compiled `<slot>`, so we flip the
        // ._d flag off when invoking the wrapped fn inside `renderSlot`.
        if (renderFnWithContext._d) {
            setBlockTracking(-1);
        }
        const prevInstance = setCurrentRenderingInstance(ctx);
        const res = fn(...args);
        setCurrentRenderingInstance(prevInstance);
        if (renderFnWithContext._d) {
            setBlockTracking(1);
        }
        if (true) {
            devtoolsComponentUpdated(ctx);
        }
        return res;
    };
    // mark normalized to avoid duplicated wrapping
    renderFnWithContext._n = true;
    // mark this as compiled by default
    // this is used in vnode.ts -> normalizeChildren() to set the slot
    // rendering flag.
    renderFnWithContext._c = true;
    // disable block tracking by default
    renderFnWithContext._d = true;
    return renderFnWithContext;
}

/**
 * dev only flag to track whether $attrs was used during render.
 * If $attrs was used during render then the warning for failed attrs
 * fallthrough can be suppressed.
 */
let accessedAttrs = false;
function markAttrsAccessed() {
    accessedAttrs = true;
}
function renderComponentRoot(instance) {
    const { type: Component, vnode, proxy, withProxy, props, propsOptions: [propsOptions], slots, attrs, emit, render, renderCache, data, setupState, ctx, inheritAttrs } = instance;
    let result;
    let fallthroughAttrs;
    const prev = setCurrentRenderingInstance(instance);
    if ((true)) {
        accessedAttrs = false;
    }
    try {
        if (vnode.shapeFlag & 4 /* STATEFUL_COMPONENT */) {
            // withProxy is a proxy with a different `has` trap only for
            // runtime-compiled render functions using `with` block.
            const proxyToUse = withProxy || proxy;
            result = normalizeVNode(render.call(proxyToUse, proxyToUse, renderCache, props, setupState, data, ctx));
            fallthroughAttrs = attrs;
        }
        else {
            // functional
            const render = Component;
            // in dev, mark attrs accessed if optional props (attrs === props)
            if (( true) && attrs === props) {
                markAttrsAccessed();
            }
            result = normalizeVNode(render.length > 1
                ? render(props, ( true)
                    ? {
                        get attrs() {
                            markAttrsAccessed();
                            return attrs;
                        },
                        slots,
                        emit
                    }
                    : 0)
                : render(props, null /* we know it doesn't need it */));
            fallthroughAttrs = Component.props
                ? attrs
                : getFunctionalFallthrough(attrs);
        }
    }
    catch (err) {
        blockStack.length = 0;
        handleError(err, instance, 1 /* RENDER_FUNCTION */);
        result = createVNode(Comment);
    }
    // attr merging
    // in dev mode, comments are preserved, and it's possible for a template
    // to have comments along side the root element which makes it a fragment
    let root = result;
    let setRoot = undefined;
    if (( true) &&
        result.patchFlag > 0 &&
        result.patchFlag & 2048 /* DEV_ROOT_FRAGMENT */) {
        [root, setRoot] = getChildRoot(result);
    }
    if (fallthroughAttrs && inheritAttrs !== false) {
        const keys = Object.keys(fallthroughAttrs);
        const { shapeFlag } = root;
        if (keys.length) {
            if (shapeFlag & (1 /* ELEMENT */ | 6 /* COMPONENT */)) {
                if (propsOptions && keys.some(_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isModelListener)) {
                    // If a v-model listener (onUpdate:xxx) has a corresponding declared
                    // prop, it indicates this component expects to handle v-model and
                    // it should not fallthrough.
                    // related: #1543, #1643, #1989
                    fallthroughAttrs = filterModelListeners(fallthroughAttrs, propsOptions);
                }
                root = cloneVNode(root, fallthroughAttrs);
            }
            else if (( true) && !accessedAttrs && root.type !== Comment) {
                const allAttrs = Object.keys(attrs);
                const eventAttrs = [];
                const extraAttrs = [];
                for (let i = 0, l = allAttrs.length; i < l; i++) {
                    const key = allAttrs[i];
                    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isOn)(key)) {
                        // ignore v-model handlers when they fail to fallthrough
                        if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isModelListener)(key)) {
                            // remove `on`, lowercase first letter to reflect event casing
                            // accurately
                            eventAttrs.push(key[2].toLowerCase() + key.slice(3));
                        }
                    }
                    else {
                        extraAttrs.push(key);
                    }
                }
                if (extraAttrs.length) {
                    warn(`Extraneous non-props attributes (` +
                        `${extraAttrs.join(', ')}) ` +
                        `were passed to component but could not be automatically inherited ` +
                        `because component renders fragment or text root nodes.`);
                }
                if (eventAttrs.length) {
                    warn(`Extraneous non-emits event listeners (` +
                        `${eventAttrs.join(', ')}) ` +
                        `were passed to component but could not be automatically inherited ` +
                        `because component renders fragment or text root nodes. ` +
                        `If the listener is intended to be a component custom event listener only, ` +
                        `declare it using the "emits" option.`);
                }
            }
        }
    }
    // inherit directives
    if (vnode.dirs) {
        if (( true) && !isElementRoot(root)) {
            warn(`Runtime directive used on component with non-element root node. ` +
                `The directives will not function as intended.`);
        }
        root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;
    }
    // inherit transition data
    if (vnode.transition) {
        if (( true) && !isElementRoot(root)) {
            warn(`Component inside <Transition> renders non-element root node ` +
                `that cannot be animated.`);
        }
        root.transition = vnode.transition;
    }
    if (( true) && setRoot) {
        setRoot(root);
    }
    else {
        result = root;
    }
    setCurrentRenderingInstance(prev);
    return result;
}
/**
 * dev only
 * In dev mode, template root level comments are rendered, which turns the
 * template into a fragment root, but we need to locate the single element
 * root for attrs and scope id processing.
 */
const getChildRoot = (vnode) => {
    const rawChildren = vnode.children;
    const dynamicChildren = vnode.dynamicChildren;
    const childRoot = filterSingleRoot(rawChildren);
    if (!childRoot) {
        return [vnode, undefined];
    }
    const index = rawChildren.indexOf(childRoot);
    const dynamicIndex = dynamicChildren ? dynamicChildren.indexOf(childRoot) : -1;
    const setRoot = (updatedRoot) => {
        rawChildren[index] = updatedRoot;
        if (dynamicChildren) {
            if (dynamicIndex > -1) {
                dynamicChildren[dynamicIndex] = updatedRoot;
            }
            else if (updatedRoot.patchFlag > 0) {
                vnode.dynamicChildren = [...dynamicChildren, updatedRoot];
            }
        }
    };
    return [normalizeVNode(childRoot), setRoot];
};
function filterSingleRoot(children) {
    let singleRoot;
    for (let i = 0; i < children.length; i++) {
        const child = children[i];
        if (isVNode(child)) {
            // ignore user comment
            if (child.type !== Comment || child.children === 'v-if') {
                if (singleRoot) {
                    // has more than 1 non-comment child, return now
                    return;
                }
                else {
                    singleRoot = child;
                }
            }
        }
        else {
            return;
        }
    }
    return singleRoot;
}
const getFunctionalFallthrough = (attrs) => {
    let res;
    for (const key in attrs) {
        if (key === 'class' || key === 'style' || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isOn)(key)) {
            (res || (res = {}))[key] = attrs[key];
        }
    }
    return res;
};
const filterModelListeners = (attrs, props) => {
    const res = {};
    for (const key in attrs) {
        if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isModelListener)(key) || !(key.slice(9) in props)) {
            res[key] = attrs[key];
        }
    }
    return res;
};
const isElementRoot = (vnode) => {
    return (vnode.shapeFlag & (6 /* COMPONENT */ | 1 /* ELEMENT */) ||
        vnode.type === Comment // potential v-if branch switch
    );
};
function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
    const { props: prevProps, children: prevChildren, component } = prevVNode;
    const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
    const emits = component.emitsOptions;
    // Parent component's render function was hot-updated. Since this may have
    // caused the child component's slots content to have changed, we need to
    // force the child to update as well.
    if (( true) && (prevChildren || nextChildren) && isHmrUpdating) {
        return true;
    }
    // force child update for runtime directive or transition on component vnode.
    if (nextVNode.dirs || nextVNode.transition) {
        return true;
    }
    if (optimized && patchFlag >= 0) {
        if (patchFlag & 1024 /* DYNAMIC_SLOTS */) {
            // slot content that references values that might have changed,
            // e.g. in a v-for
            return true;
        }
        if (patchFlag & 16 /* FULL_PROPS */) {
            if (!prevProps) {
                return !!nextProps;
            }
            // presence of this flag indicates props are always non-null
            return hasPropsChanged(prevProps, nextProps, emits);
        }
        else if (patchFlag & 8 /* PROPS */) {
            const dynamicProps = nextVNode.dynamicProps;
            for (let i = 0; i < dynamicProps.length; i++) {
                const key = dynamicProps[i];
                if (nextProps[key] !== prevProps[key] &&
                    !isEmitListener(emits, key)) {
                    return true;
                }
            }
        }
    }
    else {
        // this path is only taken by manually written render functions
        // so presence of any children leads to a forced update
        if (prevChildren || nextChildren) {
            if (!nextChildren || !nextChildren.$stable) {
                return true;
            }
        }
        if (prevProps === nextProps) {
            return false;
        }
        if (!prevProps) {
            return !!nextProps;
        }
        if (!nextProps) {
            return true;
        }
        return hasPropsChanged(prevProps, nextProps, emits);
    }
    return false;
}
function hasPropsChanged(prevProps, nextProps, emitsOptions) {
    const nextKeys = Object.keys(nextProps);
    if (nextKeys.length !== Object.keys(prevProps).length) {
        return true;
    }
    for (let i = 0; i < nextKeys.length; i++) {
        const key = nextKeys[i];
        if (nextProps[key] !== prevProps[key] &&
            !isEmitListener(emitsOptions, key)) {
            return true;
        }
    }
    return false;
}
function updateHOCHostEl({ vnode, parent }, el // HostNode
) {
    while (parent && parent.subTree === vnode) {
        (vnode = parent.vnode).el = el;
        parent = parent.parent;
    }
}

const isSuspense = (type) => type.__isSuspense;
// Suspense exposes a component-like API, and is treated like a component
// in the compiler, but internally it's a special built-in type that hooks
// directly into the renderer.
const SuspenseImpl = {
    name: 'Suspense',
    // In order to make Suspense tree-shakable, we need to avoid importing it
    // directly in the renderer. The renderer checks for the __isSuspense flag
    // on a vnode's type and calls the `process` method, passing in renderer
    // internals.
    __isSuspense: true,
    process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, 
    // platform-specific impl passed from renderer
    rendererInternals) {
        if (n1 == null) {
            mountSuspense(n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals);
        }
        else {
            patchSuspense(n1, n2, container, anchor, parentComponent, isSVG, slotScopeIds, optimized, rendererInternals);
        }
    },
    hydrate: hydrateSuspense,
    create: createSuspenseBoundary,
    normalize: normalizeSuspenseChildren
};
// Force-casted public typing for h and TSX props inference
const Suspense = (SuspenseImpl );
function triggerEvent(vnode, name) {
    const eventListener = vnode.props && vnode.props[name];
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(eventListener)) {
        eventListener();
    }
}
function mountSuspense(vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals) {
    const { p: patch, o: { createElement } } = rendererInternals;
    const hiddenContainer = createElement('div');
    const suspense = (vnode.suspense = createSuspenseBoundary(vnode, parentSuspense, parentComponent, container, hiddenContainer, anchor, isSVG, slotScopeIds, optimized, rendererInternals));
    // start mounting the content subtree in an off-dom container
    patch(null, (suspense.pendingBranch = vnode.ssContent), hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds);
    // now check if we have encountered any async deps
    if (suspense.deps > 0) {
        // has async
        // invoke @fallback event
        triggerEvent(vnode, 'onPending');
        triggerEvent(vnode, 'onFallback');
        // mount the fallback tree
        patch(null, vnode.ssFallback, container, anchor, parentComponent, null, // fallback tree will not have suspense context
        isSVG, slotScopeIds);
        setActiveBranch(suspense, vnode.ssFallback);
    }
    else {
        // Suspense has no async deps. Just resolve.
        suspense.resolve();
    }
}
function patchSuspense(n1, n2, container, anchor, parentComponent, isSVG, slotScopeIds, optimized, { p: patch, um: unmount, o: { createElement } }) {
    const suspense = (n2.suspense = n1.suspense);
    suspense.vnode = n2;
    n2.el = n1.el;
    const newBranch = n2.ssContent;
    const newFallback = n2.ssFallback;
    const { activeBranch, pendingBranch, isInFallback, isHydrating } = suspense;
    if (pendingBranch) {
        suspense.pendingBranch = newBranch;
        if (isSameVNodeType(newBranch, pendingBranch)) {
            // same root type but content may have changed.
            patch(pendingBranch, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);
            if (suspense.deps <= 0) {
                suspense.resolve();
            }
            else if (isInFallback) {
                patch(activeBranch, newFallback, container, anchor, parentComponent, null, // fallback tree will not have suspense context
                isSVG, slotScopeIds, optimized);
                setActiveBranch(suspense, newFallback);
            }
        }
        else {
            // toggled before pending tree is resolved
            suspense.pendingId++;
            if (isHydrating) {
                // if toggled before hydration is finished, the current DOM tree is
                // no longer valid. set it as the active branch so it will be unmounted
                // when resolved
                suspense.isHydrating = false;
                suspense.activeBranch = pendingBranch;
            }
            else {
                unmount(pendingBranch, parentComponent, suspense);
            }
            // increment pending ID. this is used to invalidate async callbacks
            // reset suspense state
            suspense.deps = 0;
            // discard effects from pending branch
            suspense.effects.length = 0;
            // discard previous container
            suspense.hiddenContainer = createElement('div');
            if (isInFallback) {
                // already in fallback state
                patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);
                if (suspense.deps <= 0) {
                    suspense.resolve();
                }
                else {
                    patch(activeBranch, newFallback, container, anchor, parentComponent, null, // fallback tree will not have suspense context
                    isSVG, slotScopeIds, optimized);
                    setActiveBranch(suspense, newFallback);
                }
            }
            else if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
                // toggled "back" to current active branch
                patch(activeBranch, newBranch, container, anchor, parentComponent, suspense, isSVG, slotScopeIds, optimized);
                // force resolve
                suspense.resolve(true);
            }
            else {
                // switched to a 3rd branch
                patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);
                if (suspense.deps <= 0) {
                    suspense.resolve();
                }
            }
        }
    }
    else {
        if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
            // root did not change, just normal patch
            patch(activeBranch, newBranch, container, anchor, parentComponent, suspense, isSVG, slotScopeIds, optimized);
            setActiveBranch(suspense, newBranch);
        }
        else {
            // root node toggled
            // invoke @pending event
            triggerEvent(n2, 'onPending');
            // mount pending branch in off-dom container
            suspense.pendingBranch = newBranch;
            suspense.pendingId++;
            patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);
            if (suspense.deps <= 0) {
                // incoming branch has no async deps, resolve now.
                suspense.resolve();
            }
            else {
                const { timeout, pendingId } = suspense;
                if (timeout > 0) {
                    setTimeout(() => {
                        if (suspense.pendingId === pendingId) {
                            suspense.fallback(newFallback);
                        }
                    }, timeout);
                }
                else if (timeout === 0) {
                    suspense.fallback(newFallback);
                }
            }
        }
    }
}
let hasWarned = false;
function createSuspenseBoundary(vnode, parent, parentComponent, container, hiddenContainer, anchor, isSVG, slotScopeIds, optimized, rendererInternals, isHydrating = false) {
    /* istanbul ignore if */
    if ( true && !hasWarned) {
        hasWarned = true;
        // @ts-ignore `console.info` cannot be null error
        console[console.info ? 'info' : 'log'](`<Suspense> is an experimental feature and its API will likely change.`);
    }
    const { p: patch, m: move, um: unmount, n: next, o: { parentNode, remove } } = rendererInternals;
    const timeout = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toNumber)(vnode.props && vnode.props.timeout);
    const suspense = {
        vnode,
        parent,
        parentComponent,
        isSVG,
        container,
        hiddenContainer,
        anchor,
        deps: 0,
        pendingId: 0,
        timeout: typeof timeout === 'number' ? timeout : -1,
        activeBranch: null,
        pendingBranch: null,
        isInFallback: true,
        isHydrating,
        isUnmounted: false,
        effects: [],
        resolve(resume = false) {
            if ((true)) {
                if (!resume && !suspense.pendingBranch) {
                    throw new Error(`suspense.resolve() is called without a pending branch.`);
                }
                if (suspense.isUnmounted) {
                    throw new Error(`suspense.resolve() is called on an already unmounted suspense boundary.`);
                }
            }
            const { vnode, activeBranch, pendingBranch, pendingId, effects, parentComponent, container } = suspense;
            if (suspense.isHydrating) {
                suspense.isHydrating = false;
            }
            else if (!resume) {
                const delayEnter = activeBranch &&
                    pendingBranch.transition &&
                    pendingBranch.transition.mode === 'out-in';
                if (delayEnter) {
                    activeBranch.transition.afterLeave = () => {
                        if (pendingId === suspense.pendingId) {
                            move(pendingBranch, container, anchor, 0 /* ENTER */);
                        }
                    };
                }
                // this is initial anchor on mount
                let { anchor } = suspense;
                // unmount current active tree
                if (activeBranch) {
                    // if the fallback tree was mounted, it may have been moved
                    // as part of a parent suspense. get the latest anchor for insertion
                    anchor = next(activeBranch);
                    unmount(activeBranch, parentComponent, suspense, true);
                }
                if (!delayEnter) {
                    // move content from off-dom container to actual container
                    move(pendingBranch, container, anchor, 0 /* ENTER */);
                }
            }
            setActiveBranch(suspense, pendingBranch);
            suspense.pendingBranch = null;
            suspense.isInFallback = false;
            // flush buffered effects
            // check if there is a pending parent suspense
            let parent = suspense.parent;
            let hasUnresolvedAncestor = false;
            while (parent) {
                if (parent.pendingBranch) {
                    // found a pending parent suspense, merge buffered post jobs
                    // into that parent
                    parent.effects.push(...effects);
                    hasUnresolvedAncestor = true;
                    break;
                }
                parent = parent.parent;
            }
            // no pending parent suspense, flush all jobs
            if (!hasUnresolvedAncestor) {
                queuePostFlushCb(effects);
            }
            suspense.effects = [];
            // invoke @resolve event
            triggerEvent(vnode, 'onResolve');
        },
        fallback(fallbackVNode) {
            if (!suspense.pendingBranch) {
                return;
            }
            const { vnode, activeBranch, parentComponent, container, isSVG } = suspense;
            // invoke @fallback event
            triggerEvent(vnode, 'onFallback');
            const anchor = next(activeBranch);
            const mountFallback = () => {
                if (!suspense.isInFallback) {
                    return;
                }
                // mount the fallback tree
                patch(null, fallbackVNode, container, anchor, parentComponent, null, // fallback tree will not have suspense context
                isSVG, slotScopeIds, optimized);
                setActiveBranch(suspense, fallbackVNode);
            };
            const delayEnter = fallbackVNode.transition && fallbackVNode.transition.mode === 'out-in';
            if (delayEnter) {
                activeBranch.transition.afterLeave = mountFallback;
            }
            suspense.isInFallback = true;
            // unmount current active branch
            unmount(activeBranch, parentComponent, null, // no suspense so unmount hooks fire now
            true // shouldRemove
            );
            if (!delayEnter) {
                mountFallback();
            }
        },
        move(container, anchor, type) {
            suspense.activeBranch &&
                move(suspense.activeBranch, container, anchor, type);
            suspense.container = container;
        },
        next() {
            return suspense.activeBranch && next(suspense.activeBranch);
        },
        registerDep(instance, setupRenderEffect) {
            const isInPendingSuspense = !!suspense.pendingBranch;
            if (isInPendingSuspense) {
                suspense.deps++;
            }
            const hydratedEl = instance.vnode.el;
            instance
                .asyncDep.catch(err => {
                handleError(err, instance, 0 /* SETUP_FUNCTION */);
            })
                .then(asyncSetupResult => {
                // retry when the setup() promise resolves.
                // component may have been unmounted before resolve.
                if (instance.isUnmounted ||
                    suspense.isUnmounted ||
                    suspense.pendingId !== instance.suspenseId) {
                    return;
                }
                // retry from this component
                instance.asyncResolved = true;
                const { vnode } = instance;
                if ((true)) {
                    pushWarningContext(vnode);
                }
                handleSetupResult(instance, asyncSetupResult, false);
                if (hydratedEl) {
                    // vnode may have been replaced if an update happened before the
                    // async dep is resolved.
                    vnode.el = hydratedEl;
                }
                const placeholder = !hydratedEl && instance.subTree.el;
                setupRenderEffect(instance, vnode, 
                // component may have been moved before resolve.
                // if this is not a hydration, instance.subTree will be the comment
                // placeholder.
                parentNode(hydratedEl || instance.subTree.el), 
                // anchor will not be used if this is hydration, so only need to
                // consider the comment placeholder case.
                hydratedEl ? null : next(instance.subTree), suspense, isSVG, optimized);
                if (placeholder) {
                    remove(placeholder);
                }
                updateHOCHostEl(instance, vnode.el);
                if ((true)) {
                    popWarningContext();
                }
                // only decrease deps count if suspense is not already resolved
                if (isInPendingSuspense && --suspense.deps === 0) {
                    suspense.resolve();
                }
            });
        },
        unmount(parentSuspense, doRemove) {
            suspense.isUnmounted = true;
            if (suspense.activeBranch) {
                unmount(suspense.activeBranch, parentComponent, parentSuspense, doRemove);
            }
            if (suspense.pendingBranch) {
                unmount(suspense.pendingBranch, parentComponent, parentSuspense, doRemove);
            }
        }
    };
    return suspense;
}
function hydrateSuspense(node, vnode, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals, hydrateNode) {
    /* eslint-disable no-restricted-globals */
    const suspense = (vnode.suspense = createSuspenseBoundary(vnode, parentSuspense, parentComponent, node.parentNode, document.createElement('div'), null, isSVG, slotScopeIds, optimized, rendererInternals, true /* hydrating */));
    // there are two possible scenarios for server-rendered suspense:
    // - success: ssr content should be fully resolved
    // - failure: ssr content should be the fallback branch.
    // however, on the client we don't really know if it has failed or not
    // attempt to hydrate the DOM assuming it has succeeded, but we still
    // need to construct a suspense boundary first
    const result = hydrateNode(node, (suspense.pendingBranch = vnode.ssContent), parentComponent, suspense, slotScopeIds, optimized);
    if (suspense.deps === 0) {
        suspense.resolve();
    }
    return result;
    /* eslint-enable no-restricted-globals */
}
function normalizeSuspenseChildren(vnode) {
    const { shapeFlag, children } = vnode;
    const isSlotChildren = shapeFlag & 32 /* SLOTS_CHILDREN */;
    vnode.ssContent = normalizeSuspenseSlot(isSlotChildren ? children.default : children);
    vnode.ssFallback = isSlotChildren
        ? normalizeSuspenseSlot(children.fallback)
        : createVNode(Comment);
}
function normalizeSuspenseSlot(s) {
    let block;
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(s)) {
        const trackBlock = isBlockTreeEnabled && s._c;
        if (trackBlock) {
            // disableTracking: false
            // allow block tracking for compiled slots
            // (see ./componentRenderContext.ts)
            s._d = false;
            openBlock();
        }
        s = s();
        if (trackBlock) {
            s._d = true;
            block = currentBlock;
            closeBlock();
        }
    }
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(s)) {
        const singleChild = filterSingleRoot(s);
        if (( true) && !singleChild) {
            warn(`<Suspense> slots expect a single root node.`);
        }
        s = singleChild;
    }
    s = normalizeVNode(s);
    if (block && !s.dynamicChildren) {
        s.dynamicChildren = block.filter(c => c !== s);
    }
    return s;
}
function queueEffectWithSuspense(fn, suspense) {
    if (suspense && suspense.pendingBranch) {
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(fn)) {
            suspense.effects.push(...fn);
        }
        else {
            suspense.effects.push(fn);
        }
    }
    else {
        queuePostFlushCb(fn);
    }
}
function setActiveBranch(suspense, branch) {
    suspense.activeBranch = branch;
    const { vnode, parentComponent } = suspense;
    const el = (vnode.el = branch.el);
    // in case suspense is the root node of a component,
    // recursively update the HOC el
    if (parentComponent && parentComponent.subTree === vnode) {
        parentComponent.vnode.el = el;
        updateHOCHostEl(parentComponent, el);
    }
}

function provide(key, value) {
    if (!currentInstance) {
        if ((true)) {
            warn(`provide() can only be used inside setup().`);
        }
    }
    else {
        let provides = currentInstance.provides;
        // by default an instance inherits its parent's provides object
        // but when it needs to provide values of its own, it creates its
        // own provides object using parent provides object as prototype.
        // this way in `inject` we can simply look up injections from direct
        // parent and let the prototype chain do the work.
        const parentProvides = currentInstance.parent && currentInstance.parent.provides;
        if (parentProvides === provides) {
            provides = currentInstance.provides = Object.create(parentProvides);
        }
        // TS doesn't allow symbol as index type
        provides[key] = value;
    }
}
function inject(key, defaultValue, treatDefaultAsFactory = false) {
    // fallback to `currentRenderingInstance` so that this can be called in
    // a functional component
    const instance = currentInstance || currentRenderingInstance;
    if (instance) {
        // #2400
        // to support `app.use` plugins,
        // fallback to appContext's `provides` if the instance is at root
        const provides = instance.parent == null
            ? instance.vnode.appContext && instance.vnode.appContext.provides
            : instance.parent.provides;
        if (provides && key in provides) {
            // TS doesn't allow symbol as index type
            return provides[key];
        }
        else if (arguments.length > 1) {
            return treatDefaultAsFactory && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(defaultValue)
                ? defaultValue.call(instance.proxy)
                : defaultValue;
        }
        else if ((true)) {
            warn(`injection "${String(key)}" not found.`);
        }
    }
    else if ((true)) {
        warn(`inject() can only be used inside setup() or functional components.`);
    }
}

// Simple effect.
function watchEffect(effect, options) {
    return doWatch(effect, null, options);
}
function watchPostEffect(effect, options) {
    return doWatch(effect, null, (( true)
        ? Object.assign(options || {}, { flush: 'post' })
        : 0));
}
function watchSyncEffect(effect, options) {
    return doWatch(effect, null, (( true)
        ? Object.assign(options || {}, { flush: 'sync' })
        : 0));
}
// initial value for watchers to trigger on undefined initial values
const INITIAL_WATCHER_VALUE = {};
// implementation
function watch(source, cb, options) {
    if (( true) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(cb)) {
        warn(`\`watch(fn, options?)\` signature has been moved to a separate API. ` +
            `Use \`watchEffect(fn, options?)\` instead. \`watch\` now only ` +
            `supports \`watch(source, cb, options?) signature.`);
    }
    return doWatch(source, cb, options);
}
function doWatch(source, cb, { immediate, deep, flush, onTrack, onTrigger } = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ) {
    if (( true) && !cb) {
        if (immediate !== undefined) {
            warn(`watch() "immediate" option is only respected when using the ` +
                `watch(source, callback, options?) signature.`);
        }
        if (deep !== undefined) {
            warn(`watch() "deep" option is only respected when using the ` +
                `watch(source, callback, options?) signature.`);
        }
    }
    const warnInvalidSource = (s) => {
        warn(`Invalid watch source: `, s, `A watch source can only be a getter/effect function, a ref, ` +
            `a reactive object, or an array of these types.`);
    };
    const instance = currentInstance;
    let getter;
    let forceTrigger = false;
    let isMultiSource = false;
    if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(source)) {
        getter = () => source.value;
        forceTrigger = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isShallow)(source);
    }
    else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReactive)(source)) {
        getter = () => source;
        deep = true;
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(source)) {
        isMultiSource = true;
        forceTrigger = source.some(_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReactive);
        getter = () => source.map(s => {
            if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(s)) {
                return s.value;
            }
            else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReactive)(s)) {
                return traverse(s);
            }
            else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(s)) {
                return callWithErrorHandling(s, instance, 2 /* WATCH_GETTER */);
            }
            else {
                ( true) && warnInvalidSource(s);
            }
        });
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(source)) {
        if (cb) {
            // getter with cb
            getter = () => callWithErrorHandling(source, instance, 2 /* WATCH_GETTER */);
        }
        else {
            // no cb -> simple effect
            getter = () => {
                if (instance && instance.isUnmounted) {
                    return;
                }
                if (cleanup) {
                    cleanup();
                }
                return callWithAsyncErrorHandling(source, instance, 3 /* WATCH_CALLBACK */, [onCleanup]);
            };
        }
    }
    else {
        getter = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP;
        ( true) && warnInvalidSource(source);
    }
    if (cb && deep) {
        const baseGetter = getter;
        getter = () => traverse(baseGetter());
    }
    let cleanup;
    let onCleanup = (fn) => {
        cleanup = effect.onStop = () => {
            callWithErrorHandling(fn, instance, 4 /* WATCH_CLEANUP */);
        };
    };
    // in SSR there is no need to setup an actual effect, and it should be noop
    // unless it's eager
    if (isInSSRComponentSetup) {
        // we will also not call the invalidate callback (+ runner is not set up)
        onCleanup = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP;
        if (!cb) {
            getter();
        }
        else if (immediate) {
            callWithAsyncErrorHandling(cb, instance, 3 /* WATCH_CALLBACK */, [
                getter(),
                isMultiSource ? [] : undefined,
                onCleanup
            ]);
        }
        return _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP;
    }
    let oldValue = isMultiSource ? [] : INITIAL_WATCHER_VALUE;
    const job = () => {
        if (!effect.active) {
            return;
        }
        if (cb) {
            // watch(source, cb)
            const newValue = effect.run();
            if (deep ||
                forceTrigger ||
                (isMultiSource
                    ? newValue.some((v, i) => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasChanged)(v, oldValue[i]))
                    : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasChanged)(newValue, oldValue)) ||
                (false  )) {
                // cleanup before running cb again
                if (cleanup) {
                    cleanup();
                }
                callWithAsyncErrorHandling(cb, instance, 3 /* WATCH_CALLBACK */, [
                    newValue,
                    // pass undefined as the old value when it's changed for the first time
                    oldValue === INITIAL_WATCHER_VALUE ? undefined : oldValue,
                    onCleanup
                ]);
                oldValue = newValue;
            }
        }
        else {
            // watchEffect
            effect.run();
        }
    };
    // important: mark the job as a watcher callback so that scheduler knows
    // it is allowed to self-trigger (#1727)
    job.allowRecurse = !!cb;
    let scheduler;
    if (flush === 'sync') {
        scheduler = job; // the scheduler function gets called directly
    }
    else if (flush === 'post') {
        scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);
    }
    else {
        // default: 'pre'
        scheduler = () => {
            if (!instance || instance.isMounted) {
                queuePreFlushCb(job);
            }
            else {
                // with 'pre' option, the first call must happen before
                // the component is mounted so it is called synchronously.
                job();
            }
        };
    }
    const effect = new _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ReactiveEffect(getter, scheduler);
    if ((true)) {
        effect.onTrack = onTrack;
        effect.onTrigger = onTrigger;
    }
    // initial run
    if (cb) {
        if (immediate) {
            job();
        }
        else {
            oldValue = effect.run();
        }
    }
    else if (flush === 'post') {
        queuePostRenderEffect(effect.run.bind(effect), instance && instance.suspense);
    }
    else {
        effect.run();
    }
    return () => {
        effect.stop();
        if (instance && instance.scope) {
            (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.remove)(instance.scope.effects, effect);
        }
    };
}
// this.$watch
function instanceWatch(source, value, options) {
    const publicThis = this.proxy;
    const getter = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(source)
        ? source.includes('.')
            ? createPathGetter(publicThis, source)
            : () => publicThis[source]
        : source.bind(publicThis, publicThis);
    let cb;
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(value)) {
        cb = value;
    }
    else {
        cb = value.handler;
        options = value;
    }
    const cur = currentInstance;
    setCurrentInstance(this);
    const res = doWatch(getter, cb.bind(publicThis), options);
    if (cur) {
        setCurrentInstance(cur);
    }
    else {
        unsetCurrentInstance();
    }
    return res;
}
function createPathGetter(ctx, path) {
    const segments = path.split('.');
    return () => {
        let cur = ctx;
        for (let i = 0; i < segments.length && cur; i++) {
            cur = cur[segments[i]];
        }
        return cur;
    };
}
function traverse(value, seen) {
    if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(value) || value["__v_skip" /* SKIP */]) {
        return value;
    }
    seen = seen || new Set();
    if (seen.has(value)) {
        return value;
    }
    seen.add(value);
    if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(value)) {
        traverse(value.value, seen);
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value)) {
        for (let i = 0; i < value.length; i++) {
            traverse(value[i], seen);
        }
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSet)(value) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isMap)(value)) {
        value.forEach((v) => {
            traverse(v, seen);
        });
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isPlainObject)(value)) {
        for (const key in value) {
            traverse(value[key], seen);
        }
    }
    return value;
}

function useTransitionState() {
    const state = {
        isMounted: false,
        isLeaving: false,
        isUnmounting: false,
        leavingVNodes: new Map()
    };
    onMounted(() => {
        state.isMounted = true;
    });
    onBeforeUnmount(() => {
        state.isUnmounting = true;
    });
    return state;
}
const TransitionHookValidator = [Function, Array];
const BaseTransitionImpl = {
    name: `BaseTransition`,
    props: {
        mode: String,
        appear: Boolean,
        persisted: Boolean,
        // enter
        onBeforeEnter: TransitionHookValidator,
        onEnter: TransitionHookValidator,
        onAfterEnter: TransitionHookValidator,
        onEnterCancelled: TransitionHookValidator,
        // leave
        onBeforeLeave: TransitionHookValidator,
        onLeave: TransitionHookValidator,
        onAfterLeave: TransitionHookValidator,
        onLeaveCancelled: TransitionHookValidator,
        // appear
        onBeforeAppear: TransitionHookValidator,
        onAppear: TransitionHookValidator,
        onAfterAppear: TransitionHookValidator,
        onAppearCancelled: TransitionHookValidator
    },
    setup(props, { slots }) {
        const instance = getCurrentInstance();
        const state = useTransitionState();
        let prevTransitionKey;
        return () => {
            const children = slots.default && getTransitionRawChildren(slots.default(), true);
            if (!children || !children.length) {
                return;
            }
            // warn multiple elements
            if (( true) && children.length > 1) {
                warn('<transition> can only be used on a single element or component. Use ' +
                    '<transition-group> for lists.');
            }
            // there's no need to track reactivity for these props so use the raw
            // props for a bit better perf
            const rawProps = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(props);
            const { mode } = rawProps;
            // check mode
            if (( true) &&
                mode &&
                mode !== 'in-out' && mode !== 'out-in' && mode !== 'default') {
                warn(`invalid <transition> mode: ${mode}`);
            }
            // at this point children has a guaranteed length of 1.
            const child = children[0];
            if (state.isLeaving) {
                return emptyPlaceholder(child);
            }
            // in the case of <transition><keep-alive/></transition>, we need to
            // compare the type of the kept-alive children.
            const innerChild = getKeepAliveChild(child);
            if (!innerChild) {
                return emptyPlaceholder(child);
            }
            const enterHooks = resolveTransitionHooks(innerChild, rawProps, state, instance);
            setTransitionHooks(innerChild, enterHooks);
            const oldChild = instance.subTree;
            const oldInnerChild = oldChild && getKeepAliveChild(oldChild);
            let transitionKeyChanged = false;
            const { getTransitionKey } = innerChild.type;
            if (getTransitionKey) {
                const key = getTransitionKey();
                if (prevTransitionKey === undefined) {
                    prevTransitionKey = key;
                }
                else if (key !== prevTransitionKey) {
                    prevTransitionKey = key;
                    transitionKeyChanged = true;
                }
            }
            // handle mode
            if (oldInnerChild &&
                oldInnerChild.type !== Comment &&
                (!isSameVNodeType(innerChild, oldInnerChild) || transitionKeyChanged)) {
                const leavingHooks = resolveTransitionHooks(oldInnerChild, rawProps, state, instance);
                // update old tree's hooks in case of dynamic transition
                setTransitionHooks(oldInnerChild, leavingHooks);
                // switching between different views
                if (mode === 'out-in') {
                    state.isLeaving = true;
                    // return placeholder node and queue update when leave finishes
                    leavingHooks.afterLeave = () => {
                        state.isLeaving = false;
                        instance.update();
                    };
                    return emptyPlaceholder(child);
                }
                else if (mode === 'in-out' && innerChild.type !== Comment) {
                    leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {
                        const leavingVNodesCache = getLeavingNodesForType(state, oldInnerChild);
                        leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
                        // early removal callback
                        el._leaveCb = () => {
                            earlyRemove();
                            el._leaveCb = undefined;
                            delete enterHooks.delayedLeave;
                        };
                        enterHooks.delayedLeave = delayedLeave;
                    };
                }
            }
            return child;
        };
    }
};
// export the public type for h/tsx inference
// also to avoid inline import() in generated d.ts files
const BaseTransition = BaseTransitionImpl;
function getLeavingNodesForType(state, vnode) {
    const { leavingVNodes } = state;
    let leavingVNodesCache = leavingVNodes.get(vnode.type);
    if (!leavingVNodesCache) {
        leavingVNodesCache = Object.create(null);
        leavingVNodes.set(vnode.type, leavingVNodesCache);
    }
    return leavingVNodesCache;
}
// The transition hooks are attached to the vnode as vnode.transition
// and will be called at appropriate timing in the renderer.
function resolveTransitionHooks(vnode, props, state, instance) {
    const { appear, mode, persisted = false, onBeforeEnter, onEnter, onAfterEnter, onEnterCancelled, onBeforeLeave, onLeave, onAfterLeave, onLeaveCancelled, onBeforeAppear, onAppear, onAfterAppear, onAppearCancelled } = props;
    const key = String(vnode.key);
    const leavingVNodesCache = getLeavingNodesForType(state, vnode);
    const callHook = (hook, args) => {
        hook &&
            callWithAsyncErrorHandling(hook, instance, 9 /* TRANSITION_HOOK */, args);
    };
    const hooks = {
        mode,
        persisted,
        beforeEnter(el) {
            let hook = onBeforeEnter;
            if (!state.isMounted) {
                if (appear) {
                    hook = onBeforeAppear || onBeforeEnter;
                }
                else {
                    return;
                }
            }
            // for same element (v-show)
            if (el._leaveCb) {
                el._leaveCb(true /* cancelled */);
            }
            // for toggled element with same key (v-if)
            const leavingVNode = leavingVNodesCache[key];
            if (leavingVNode &&
                isSameVNodeType(vnode, leavingVNode) &&
                leavingVNode.el._leaveCb) {
                // force early removal (not cancelled)
                leavingVNode.el._leaveCb();
            }
            callHook(hook, [el]);
        },
        enter(el) {
            let hook = onEnter;
            let afterHook = onAfterEnter;
            let cancelHook = onEnterCancelled;
            if (!state.isMounted) {
                if (appear) {
                    hook = onAppear || onEnter;
                    afterHook = onAfterAppear || onAfterEnter;
                    cancelHook = onAppearCancelled || onEnterCancelled;
                }
                else {
                    return;
                }
            }
            let called = false;
            const done = (el._enterCb = (cancelled) => {
                if (called)
                    return;
                called = true;
                if (cancelled) {
                    callHook(cancelHook, [el]);
                }
                else {
                    callHook(afterHook, [el]);
                }
                if (hooks.delayedLeave) {
                    hooks.delayedLeave();
                }
                el._enterCb = undefined;
            });
            if (hook) {
                hook(el, done);
                if (hook.length <= 1) {
                    done();
                }
            }
            else {
                done();
            }
        },
        leave(el, remove) {
            const key = String(vnode.key);
            if (el._enterCb) {
                el._enterCb(true /* cancelled */);
            }
            if (state.isUnmounting) {
                return remove();
            }
            callHook(onBeforeLeave, [el]);
            let called = false;
            const done = (el._leaveCb = (cancelled) => {
                if (called)
                    return;
                called = true;
                remove();
                if (cancelled) {
                    callHook(onLeaveCancelled, [el]);
                }
                else {
                    callHook(onAfterLeave, [el]);
                }
                el._leaveCb = undefined;
                if (leavingVNodesCache[key] === vnode) {
                    delete leavingVNodesCache[key];
                }
            });
            leavingVNodesCache[key] = vnode;
            if (onLeave) {
                onLeave(el, done);
                if (onLeave.length <= 1) {
                    done();
                }
            }
            else {
                done();
            }
        },
        clone(vnode) {
            return resolveTransitionHooks(vnode, props, state, instance);
        }
    };
    return hooks;
}
// the placeholder really only handles one special case: KeepAlive
// in the case of a KeepAlive in a leave phase we need to return a KeepAlive
// placeholder with empty content to avoid the KeepAlive instance from being
// unmounted.
function emptyPlaceholder(vnode) {
    if (isKeepAlive(vnode)) {
        vnode = cloneVNode(vnode);
        vnode.children = null;
        return vnode;
    }
}
function getKeepAliveChild(vnode) {
    return isKeepAlive(vnode)
        ? vnode.children
            ? vnode.children[0]
            : undefined
        : vnode;
}
function setTransitionHooks(vnode, hooks) {
    if (vnode.shapeFlag & 6 /* COMPONENT */ && vnode.component) {
        setTransitionHooks(vnode.component.subTree, hooks);
    }
    else if (vnode.shapeFlag & 128 /* SUSPENSE */) {
        vnode.ssContent.transition = hooks.clone(vnode.ssContent);
        vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
    }
    else {
        vnode.transition = hooks;
    }
}
function getTransitionRawChildren(children, keepComment = false) {
    let ret = [];
    let keyedFragmentCount = 0;
    for (let i = 0; i < children.length; i++) {
        const child = children[i];
        // handle fragment children case, e.g. v-for
        if (child.type === Fragment) {
            if (child.patchFlag & 128 /* KEYED_FRAGMENT */)
                keyedFragmentCount++;
            ret = ret.concat(getTransitionRawChildren(child.children, keepComment));
        }
        // comment placeholders should be skipped, e.g. v-if
        else if (keepComment || child.type !== Comment) {
            ret.push(child);
        }
    }
    // #1126 if a transition children list contains multiple sub fragments, these
    // fragments will be merged into a flat children array. Since each v-for
    // fragment may contain different static bindings inside, we need to de-op
    // these children to force full diffs to ensure correct behavior.
    if (keyedFragmentCount > 1) {
        for (let i = 0; i < ret.length; i++) {
            ret[i].patchFlag = -2 /* BAIL */;
        }
    }
    return ret;
}

// implementation, close to no-op
function defineComponent(options) {
    return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(options) ? { setup: options, name: options.name } : options;
}

const isAsyncWrapper = (i) => !!i.type.__asyncLoader;
function defineAsyncComponent(source) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(source)) {
        source = { loader: source };
    }
    const { loader, loadingComponent, errorComponent, delay = 200, timeout, // undefined = never times out
    suspensible = true, onError: userOnError } = source;
    let pendingRequest = null;
    let resolvedComp;
    let retries = 0;
    const retry = () => {
        retries++;
        pendingRequest = null;
        return load();
    };
    const load = () => {
        let thisRequest;
        return (pendingRequest ||
            (thisRequest = pendingRequest =
                loader()
                    .catch(err => {
                    err = err instanceof Error ? err : new Error(String(err));
                    if (userOnError) {
                        return new Promise((resolve, reject) => {
                            const userRetry = () => resolve(retry());
                            const userFail = () => reject(err);
                            userOnError(err, userRetry, userFail, retries + 1);
                        });
                    }
                    else {
                        throw err;
                    }
                })
                    .then((comp) => {
                    if (thisRequest !== pendingRequest && pendingRequest) {
                        return pendingRequest;
                    }
                    if (( true) && !comp) {
                        warn(`Async component loader resolved to undefined. ` +
                            `If you are using retry(), make sure to return its return value.`);
                    }
                    // interop module default
                    if (comp &&
                        (comp.__esModule || comp[Symbol.toStringTag] === 'Module')) {
                        comp = comp.default;
                    }
                    if (( true) && comp && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(comp) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(comp)) {
                        throw new Error(`Invalid async component load result: ${comp}`);
                    }
                    resolvedComp = comp;
                    return comp;
                })));
    };
    return defineComponent({
        name: 'AsyncComponentWrapper',
        __asyncLoader: load,
        get __asyncResolved() {
            return resolvedComp;
        },
        setup() {
            const instance = currentInstance;
            // already resolved
            if (resolvedComp) {
                return () => createInnerComp(resolvedComp, instance);
            }
            const onError = (err) => {
                pendingRequest = null;
                handleError(err, instance, 13 /* ASYNC_COMPONENT_LOADER */, !errorComponent /* do not throw in dev if user provided error component */);
            };
            // suspense-controlled or SSR.
            if ((suspensible && instance.suspense) ||
                (isInSSRComponentSetup)) {
                return load()
                    .then(comp => {
                    return () => createInnerComp(comp, instance);
                })
                    .catch(err => {
                    onError(err);
                    return () => errorComponent
                        ? createVNode(errorComponent, {
                            error: err
                        })
                        : null;
                });
            }
            const loaded = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ref)(false);
            const error = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ref)();
            const delayed = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ref)(!!delay);
            if (delay) {
                setTimeout(() => {
                    delayed.value = false;
                }, delay);
            }
            if (timeout != null) {
                setTimeout(() => {
                    if (!loaded.value && !error.value) {
                        const err = new Error(`Async component timed out after ${timeout}ms.`);
                        onError(err);
                        error.value = err;
                    }
                }, timeout);
            }
            load()
                .then(() => {
                loaded.value = true;
                if (instance.parent && isKeepAlive(instance.parent.vnode)) {
                    // parent is keep-alive, force update so the loaded component's
                    // name is taken into account
                    queueJob(instance.parent.update);
                }
            })
                .catch(err => {
                onError(err);
                error.value = err;
            });
            return () => {
                if (loaded.value && resolvedComp) {
                    return createInnerComp(resolvedComp, instance);
                }
                else if (error.value && errorComponent) {
                    return createVNode(errorComponent, {
                        error: error.value
                    });
                }
                else if (loadingComponent && !delayed.value) {
                    return createVNode(loadingComponent);
                }
            };
        }
    });
}
function createInnerComp(comp, { vnode: { ref, props, children } }) {
    const vnode = createVNode(comp, props, children);
    // ensure inner component inherits the async wrapper's ref owner
    vnode.ref = ref;
    return vnode;
}

const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
const KeepAliveImpl = {
    name: `KeepAlive`,
    // Marker for special handling inside the renderer. We are not using a ===
    // check directly on KeepAlive in the renderer, because importing it directly
    // would prevent it from being tree-shaken.
    __isKeepAlive: true,
    props: {
        include: [String, RegExp, Array],
        exclude: [String, RegExp, Array],
        max: [String, Number]
    },
    setup(props, { slots }) {
        const instance = getCurrentInstance();
        // KeepAlive communicates with the instantiated renderer via the
        // ctx where the renderer passes in its internals,
        // and the KeepAlive instance exposes activate/deactivate implementations.
        // The whole point of this is to avoid importing KeepAlive directly in the
        // renderer to facilitate tree-shaking.
        const sharedContext = instance.ctx;
        // if the internal renderer is not registered, it indicates that this is server-side rendering,
        // for KeepAlive, we just need to render its children
        if (!sharedContext.renderer) {
            return slots.default;
        }
        const cache = new Map();
        const keys = new Set();
        let current = null;
        if (true) {
            instance.__v_cache = cache;
        }
        const parentSuspense = instance.suspense;
        const { renderer: { p: patch, m: move, um: _unmount, o: { createElement } } } = sharedContext;
        const storageContainer = createElement('div');
        sharedContext.activate = (vnode, container, anchor, isSVG, optimized) => {
            const instance = vnode.component;
            move(vnode, container, anchor, 0 /* ENTER */, parentSuspense);
            // in case props have changed
            patch(instance.vnode, vnode, container, anchor, instance, parentSuspense, isSVG, vnode.slotScopeIds, optimized);
            queuePostRenderEffect(() => {
                instance.isDeactivated = false;
                if (instance.a) {
                    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(instance.a);
                }
                const vnodeHook = vnode.props && vnode.props.onVnodeMounted;
                if (vnodeHook) {
                    invokeVNodeHook(vnodeHook, instance.parent, vnode);
                }
            }, parentSuspense);
            if (true) {
                // Update components tree
                devtoolsComponentAdded(instance);
            }
        };
        sharedContext.deactivate = (vnode) => {
            const instance = vnode.component;
            move(vnode, storageContainer, null, 1 /* LEAVE */, parentSuspense);
            queuePostRenderEffect(() => {
                if (instance.da) {
                    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(instance.da);
                }
                const vnodeHook = vnode.props && vnode.props.onVnodeUnmounted;
                if (vnodeHook) {
                    invokeVNodeHook(vnodeHook, instance.parent, vnode);
                }
                instance.isDeactivated = true;
            }, parentSuspense);
            if (true) {
                // Update components tree
                devtoolsComponentAdded(instance);
            }
        };
        function unmount(vnode) {
            // reset the shapeFlag so it can be properly unmounted
            resetShapeFlag(vnode);
            _unmount(vnode, instance, parentSuspense, true);
        }
        function pruneCache(filter) {
            cache.forEach((vnode, key) => {
                const name = getComponentName(vnode.type);
                if (name && (!filter || !filter(name))) {
                    pruneCacheEntry(key);
                }
            });
        }
        function pruneCacheEntry(key) {
            const cached = cache.get(key);
            if (!current || cached.type !== current.type) {
                unmount(cached);
            }
            else if (current) {
                // current active instance should no longer be kept-alive.
                // we can't unmount it now but it might be later, so reset its flag now.
                resetShapeFlag(current);
            }
            cache.delete(key);
            keys.delete(key);
        }
        // prune cache on include/exclude prop change
        watch(() => [props.include, props.exclude], ([include, exclude]) => {
            include && pruneCache(name => matches(include, name));
            exclude && pruneCache(name => !matches(exclude, name));
        }, 
        // prune post-render after `current` has been updated
        { flush: 'post', deep: true });
        // cache sub tree after render
        let pendingCacheKey = null;
        const cacheSubtree = () => {
            // fix #1621, the pendingCacheKey could be 0
            if (pendingCacheKey != null) {
                cache.set(pendingCacheKey, getInnerChild(instance.subTree));
            }
        };
        onMounted(cacheSubtree);
        onUpdated(cacheSubtree);
        onBeforeUnmount(() => {
            cache.forEach(cached => {
                const { subTree, suspense } = instance;
                const vnode = getInnerChild(subTree);
                if (cached.type === vnode.type) {
                    // current instance will be unmounted as part of keep-alive's unmount
                    resetShapeFlag(vnode);
                    // but invoke its deactivated hook here
                    const da = vnode.component.da;
                    da && queuePostRenderEffect(da, suspense);
                    return;
                }
                unmount(cached);
            });
        });
        return () => {
            pendingCacheKey = null;
            if (!slots.default) {
                return null;
            }
            const children = slots.default();
            const rawVNode = children[0];
            if (children.length > 1) {
                if ((true)) {
                    warn(`KeepAlive should contain exactly one component child.`);
                }
                current = null;
                return children;
            }
            else if (!isVNode(rawVNode) ||
                (!(rawVNode.shapeFlag & 4 /* STATEFUL_COMPONENT */) &&
                    !(rawVNode.shapeFlag & 128 /* SUSPENSE */))) {
                current = null;
                return rawVNode;
            }
            let vnode = getInnerChild(rawVNode);
            const comp = vnode.type;
            // for async components, name check should be based in its loaded
            // inner component if available
            const name = getComponentName(isAsyncWrapper(vnode)
                ? vnode.type.__asyncResolved || {}
                : comp);
            const { include, exclude, max } = props;
            if ((include && (!name || !matches(include, name))) ||
                (exclude && name && matches(exclude, name))) {
                current = vnode;
                return rawVNode;
            }
            const key = vnode.key == null ? comp : vnode.key;
            const cachedVNode = cache.get(key);
            // clone vnode if it's reused because we are going to mutate it
            if (vnode.el) {
                vnode = cloneVNode(vnode);
                if (rawVNode.shapeFlag & 128 /* SUSPENSE */) {
                    rawVNode.ssContent = vnode;
                }
            }
            // #1513 it's possible for the returned vnode to be cloned due to attr
            // fallthrough or scopeId, so the vnode here may not be the final vnode
            // that is mounted. Instead of caching it directly, we store the pending
            // key and cache `instance.subTree` (the normalized vnode) in
            // beforeMount/beforeUpdate hooks.
            pendingCacheKey = key;
            if (cachedVNode) {
                // copy over mounted state
                vnode.el = cachedVNode.el;
                vnode.component = cachedVNode.component;
                if (vnode.transition) {
                    // recursively update transition hooks on subTree
                    setTransitionHooks(vnode, vnode.transition);
                }
                // avoid vnode being mounted as fresh
                vnode.shapeFlag |= 512 /* COMPONENT_KEPT_ALIVE */;
                // make this key the freshest
                keys.delete(key);
                keys.add(key);
            }
            else {
                keys.add(key);
                // prune oldest entry
                if (max && keys.size > parseInt(max, 10)) {
                    pruneCacheEntry(keys.values().next().value);
                }
            }
            // avoid vnode being unmounted
            vnode.shapeFlag |= 256 /* COMPONENT_SHOULD_KEEP_ALIVE */;
            current = vnode;
            return rawVNode;
        };
    }
};
// export the public type for h/tsx inference
// also to avoid inline import() in generated d.ts files
const KeepAlive = KeepAliveImpl;
function matches(pattern, name) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(pattern)) {
        return pattern.some((p) => matches(p, name));
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(pattern)) {
        return pattern.split(',').includes(name);
    }
    else if (pattern.test) {
        return pattern.test(name);
    }
    /* istanbul ignore next */
    return false;
}
function onActivated(hook, target) {
    registerKeepAliveHook(hook, "a" /* ACTIVATED */, target);
}
function onDeactivated(hook, target) {
    registerKeepAliveHook(hook, "da" /* DEACTIVATED */, target);
}
function registerKeepAliveHook(hook, type, target = currentInstance) {
    // cache the deactivate branch check wrapper for injected hooks so the same
    // hook can be properly deduped by the scheduler. "__wdc" stands for "with
    // deactivation check".
    const wrappedHook = hook.__wdc ||
        (hook.__wdc = () => {
            // only fire the hook if the target instance is NOT in a deactivated branch.
            let current = target;
            while (current) {
                if (current.isDeactivated) {
                    return;
                }
                current = current.parent;
            }
            return hook();
        });
    injectHook(type, wrappedHook, target);
    // In addition to registering it on the target instance, we walk up the parent
    // chain and register it on all ancestor instances that are keep-alive roots.
    // This avoids the need to walk the entire component tree when invoking these
    // hooks, and more importantly, avoids the need to track child components in
    // arrays.
    if (target) {
        let current = target.parent;
        while (current && current.parent) {
            if (isKeepAlive(current.parent.vnode)) {
                injectToKeepAliveRoot(wrappedHook, type, target, current);
            }
            current = current.parent;
        }
    }
}
function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
    // injectHook wraps the original for error handling, so make sure to remove
    // the wrapped version.
    const injected = injectHook(type, hook, keepAliveRoot, true /* prepend */);
    onUnmounted(() => {
        (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.remove)(keepAliveRoot[type], injected);
    }, target);
}
function resetShapeFlag(vnode) {
    let shapeFlag = vnode.shapeFlag;
    if (shapeFlag & 256 /* COMPONENT_SHOULD_KEEP_ALIVE */) {
        shapeFlag -= 256 /* COMPONENT_SHOULD_KEEP_ALIVE */;
    }
    if (shapeFlag & 512 /* COMPONENT_KEPT_ALIVE */) {
        shapeFlag -= 512 /* COMPONENT_KEPT_ALIVE */;
    }
    vnode.shapeFlag = shapeFlag;
}
function getInnerChild(vnode) {
    return vnode.shapeFlag & 128 /* SUSPENSE */ ? vnode.ssContent : vnode;
}

function injectHook(type, hook, target = currentInstance, prepend = false) {
    if (target) {
        const hooks = target[type] || (target[type] = []);
        // cache the error handling wrapper for injected hooks so the same hook
        // can be properly deduped by the scheduler. "__weh" stands for "with error
        // handling".
        const wrappedHook = hook.__weh ||
            (hook.__weh = (...args) => {
                if (target.isUnmounted) {
                    return;
                }
                // disable tracking inside all lifecycle hooks
                // since they can potentially be called inside effects.
                (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.pauseTracking)();
                // Set currentInstance during hook invocation.
                // This assumes the hook does not synchronously trigger other hooks, which
                // can only be false when the user does something really funky.
                setCurrentInstance(target);
                const res = callWithAsyncErrorHandling(hook, target, type, args);
                unsetCurrentInstance();
                (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.resetTracking)();
                return res;
            });
        if (prepend) {
            hooks.unshift(wrappedHook);
        }
        else {
            hooks.push(wrappedHook);
        }
        return wrappedHook;
    }
    else if ((true)) {
        const apiName = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)(ErrorTypeStrings[type].replace(/ hook$/, ''));
        warn(`${apiName} is called when there is no active component instance to be ` +
            `associated with. ` +
            `Lifecycle injection APIs can only be used during execution of setup().` +
            (` If you are using async setup(), make sure to register lifecycle ` +
                    `hooks before the first await statement.`
                ));
    }
}
const createHook = (lifecycle) => (hook, target = currentInstance) => 
// post-create lifecycle registrations are noops during SSR (except for serverPrefetch)
(!isInSSRComponentSetup || lifecycle === "sp" /* SERVER_PREFETCH */) &&
    injectHook(lifecycle, hook, target);
const onBeforeMount = createHook("bm" /* BEFORE_MOUNT */);
const onMounted = createHook("m" /* MOUNTED */);
const onBeforeUpdate = createHook("bu" /* BEFORE_UPDATE */);
const onUpdated = createHook("u" /* UPDATED */);
const onBeforeUnmount = createHook("bum" /* BEFORE_UNMOUNT */);
const onUnmounted = createHook("um" /* UNMOUNTED */);
const onServerPrefetch = createHook("sp" /* SERVER_PREFETCH */);
const onRenderTriggered = createHook("rtg" /* RENDER_TRIGGERED */);
const onRenderTracked = createHook("rtc" /* RENDER_TRACKED */);
function onErrorCaptured(hook, target = currentInstance) {
    injectHook("ec" /* ERROR_CAPTURED */, hook, target);
}

function createDuplicateChecker() {
    const cache = Object.create(null);
    return (type, key) => {
        if (cache[key]) {
            warn(`${type} property "${key}" is already defined in ${cache[key]}.`);
        }
        else {
            cache[key] = type;
        }
    };
}
let shouldCacheAccess = true;
function applyOptions(instance) {
    const options = resolveMergedOptions(instance);
    const publicThis = instance.proxy;
    const ctx = instance.ctx;
    // do not cache property access on public proxy during state initialization
    shouldCacheAccess = false;
    // call beforeCreate first before accessing other options since
    // the hook may mutate resolved options (#2791)
    if (options.beforeCreate) {
        callHook(options.beforeCreate, instance, "bc" /* BEFORE_CREATE */);
    }
    const { 
    // state
    data: dataOptions, computed: computedOptions, methods, watch: watchOptions, provide: provideOptions, inject: injectOptions, 
    // lifecycle
    created, beforeMount, mounted, beforeUpdate, updated, activated, deactivated, beforeDestroy, beforeUnmount, destroyed, unmounted, render, renderTracked, renderTriggered, errorCaptured, serverPrefetch, 
    // public API
    expose, inheritAttrs, 
    // assets
    components, directives, filters } = options;
    const checkDuplicateProperties = ( true) ? createDuplicateChecker() : 0;
    if ((true)) {
        const [propsOptions] = instance.propsOptions;
        if (propsOptions) {
            for (const key in propsOptions) {
                checkDuplicateProperties("Props" /* PROPS */, key);
            }
        }
    }
    // options initialization order (to be consistent with Vue 2):
    // - props (already done outside of this function)
    // - inject
    // - methods
    // - data (deferred since it relies on `this` access)
    // - computed
    // - watch (deferred since it relies on `this` access)
    if (injectOptions) {
        resolveInjections(injectOptions, ctx, checkDuplicateProperties, instance.appContext.config.unwrapInjectedRef);
    }
    if (methods) {
        for (const key in methods) {
            const methodHandler = methods[key];
            if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(methodHandler)) {
                // In dev mode, we use the `createRenderContext` function to define
                // methods to the proxy target, and those are read-only but
                // reconfigurable, so it needs to be redefined here
                if ((true)) {
                    Object.defineProperty(ctx, key, {
                        value: methodHandler.bind(publicThis),
                        configurable: true,
                        enumerable: true,
                        writable: true
                    });
                }
                else {}
                if ((true)) {
                    checkDuplicateProperties("Methods" /* METHODS */, key);
                }
            }
            else if ((true)) {
                warn(`Method "${key}" has type "${typeof methodHandler}" in the component definition. ` +
                    `Did you reference the function correctly?`);
            }
        }
    }
    if (dataOptions) {
        if (( true) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(dataOptions)) {
            warn(`The data option must be a function. ` +
                `Plain object usage is no longer supported.`);
        }
        const data = dataOptions.call(publicThis, publicThis);
        if (( true) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isPromise)(data)) {
            warn(`data() returned a Promise - note data() cannot be async; If you ` +
                `intend to perform data fetching before component renders, use ` +
                `async setup() + <Suspense>.`);
        }
        if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(data)) {
            ( true) && warn(`data() should return an object.`);
        }
        else {
            instance.data = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.reactive)(data);
            if ((true)) {
                for (const key in data) {
                    checkDuplicateProperties("Data" /* DATA */, key);
                    // expose data on ctx during dev
                    if (key[0] !== '$' && key[0] !== '_') {
                        Object.defineProperty(ctx, key, {
                            configurable: true,
                            enumerable: true,
                            get: () => data[key],
                            set: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP
                        });
                    }
                }
            }
        }
    }
    // state initialization complete at this point - start caching access
    shouldCacheAccess = true;
    if (computedOptions) {
        for (const key in computedOptions) {
            const opt = computedOptions[key];
            const get = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(opt)
                ? opt.bind(publicThis, publicThis)
                : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(opt.get)
                    ? opt.get.bind(publicThis, publicThis)
                    : _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP;
            if (( true) && get === _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP) {
                warn(`Computed property "${key}" has no getter.`);
            }
            const set = !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(opt) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(opt.set)
                ? opt.set.bind(publicThis)
                : ( true)
                    ? () => {
                        warn(`Write operation failed: computed property "${key}" is readonly.`);
                    }
                    : 0;
            const c = computed({
                get,
                set
            });
            Object.defineProperty(ctx, key, {
                enumerable: true,
                configurable: true,
                get: () => c.value,
                set: v => (c.value = v)
            });
            if ((true)) {
                checkDuplicateProperties("Computed" /* COMPUTED */, key);
            }
        }
    }
    if (watchOptions) {
        for (const key in watchOptions) {
            createWatcher(watchOptions[key], ctx, publicThis, key);
        }
    }
    if (provideOptions) {
        const provides = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(provideOptions)
            ? provideOptions.call(publicThis)
            : provideOptions;
        Reflect.ownKeys(provides).forEach(key => {
            provide(key, provides[key]);
        });
    }
    if (created) {
        callHook(created, instance, "c" /* CREATED */);
    }
    function registerLifecycleHook(register, hook) {
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(hook)) {
            hook.forEach(_hook => register(_hook.bind(publicThis)));
        }
        else if (hook) {
            register(hook.bind(publicThis));
        }
    }
    registerLifecycleHook(onBeforeMount, beforeMount);
    registerLifecycleHook(onMounted, mounted);
    registerLifecycleHook(onBeforeUpdate, beforeUpdate);
    registerLifecycleHook(onUpdated, updated);
    registerLifecycleHook(onActivated, activated);
    registerLifecycleHook(onDeactivated, deactivated);
    registerLifecycleHook(onErrorCaptured, errorCaptured);
    registerLifecycleHook(onRenderTracked, renderTracked);
    registerLifecycleHook(onRenderTriggered, renderTriggered);
    registerLifecycleHook(onBeforeUnmount, beforeUnmount);
    registerLifecycleHook(onUnmounted, unmounted);
    registerLifecycleHook(onServerPrefetch, serverPrefetch);
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(expose)) {
        if (expose.length) {
            const exposed = instance.exposed || (instance.exposed = {});
            expose.forEach(key => {
                Object.defineProperty(exposed, key, {
                    get: () => publicThis[key],
                    set: val => (publicThis[key] = val)
                });
            });
        }
        else if (!instance.exposed) {
            instance.exposed = {};
        }
    }
    // options that are handled when creating the instance but also need to be
    // applied from mixins
    if (render && instance.render === _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP) {
        instance.render = render;
    }
    if (inheritAttrs != null) {
        instance.inheritAttrs = inheritAttrs;
    }
    // asset options.
    if (components)
        instance.components = components;
    if (directives)
        instance.directives = directives;
}
function resolveInjections(injectOptions, ctx, checkDuplicateProperties = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP, unwrapRef = false) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(injectOptions)) {
        injectOptions = normalizeInject(injectOptions);
    }
    for (const key in injectOptions) {
        const opt = injectOptions[key];
        let injected;
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(opt)) {
            if ('default' in opt) {
                injected = inject(opt.from || key, opt.default, true /* treat default function as factory */);
            }
            else {
                injected = inject(opt.from || key);
            }
        }
        else {
            injected = inject(opt);
        }
        if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(injected)) {
            // TODO remove the check in 3.3
            if (unwrapRef) {
                Object.defineProperty(ctx, key, {
                    enumerable: true,
                    configurable: true,
                    get: () => injected.value,
                    set: v => (injected.value = v)
                });
            }
            else {
                if ((true)) {
                    warn(`injected property "${key}" is a ref and will be auto-unwrapped ` +
                        `and no longer needs \`.value\` in the next minor release. ` +
                        `To opt-in to the new behavior now, ` +
                        `set \`app.config.unwrapInjectedRef = true\` (this config is ` +
                        `temporary and will not be needed in the future.)`);
                }
                ctx[key] = injected;
            }
        }
        else {
            ctx[key] = injected;
        }
        if ((true)) {
            checkDuplicateProperties("Inject" /* INJECT */, key);
        }
    }
}
function callHook(hook, instance, type) {
    callWithAsyncErrorHandling((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(hook)
        ? hook.map(h => h.bind(instance.proxy))
        : hook.bind(instance.proxy), instance, type);
}
function createWatcher(raw, ctx, publicThis, key) {
    const getter = key.includes('.')
        ? createPathGetter(publicThis, key)
        : () => publicThis[key];
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(raw)) {
        const handler = ctx[raw];
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(handler)) {
            watch(getter, handler);
        }
        else if ((true)) {
            warn(`Invalid watch handler specified by key "${raw}"`, handler);
        }
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(raw)) {
        watch(getter, raw.bind(publicThis));
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(raw)) {
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(raw)) {
            raw.forEach(r => createWatcher(r, ctx, publicThis, key));
        }
        else {
            const handler = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(raw.handler)
                ? raw.handler.bind(publicThis)
                : ctx[raw.handler];
            if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(handler)) {
                watch(getter, handler, raw);
            }
            else if ((true)) {
                warn(`Invalid watch handler specified by key "${raw.handler}"`, handler);
            }
        }
    }
    else if ((true)) {
        warn(`Invalid watch option: "${key}"`, raw);
    }
}
/**
 * Resolve merged options and cache it on the component.
 * This is done only once per-component since the merging does not involve
 * instances.
 */
function resolveMergedOptions(instance) {
    const base = instance.type;
    const { mixins, extends: extendsOptions } = base;
    const { mixins: globalMixins, optionsCache: cache, config: { optionMergeStrategies } } = instance.appContext;
    const cached = cache.get(base);
    let resolved;
    if (cached) {
        resolved = cached;
    }
    else if (!globalMixins.length && !mixins && !extendsOptions) {
        {
            resolved = base;
        }
    }
    else {
        resolved = {};
        if (globalMixins.length) {
            globalMixins.forEach(m => mergeOptions(resolved, m, optionMergeStrategies, true));
        }
        mergeOptions(resolved, base, optionMergeStrategies);
    }
    cache.set(base, resolved);
    return resolved;
}
function mergeOptions(to, from, strats, asMixin = false) {
    const { mixins, extends: extendsOptions } = from;
    if (extendsOptions) {
        mergeOptions(to, extendsOptions, strats, true);
    }
    if (mixins) {
        mixins.forEach((m) => mergeOptions(to, m, strats, true));
    }
    for (const key in from) {
        if (asMixin && key === 'expose') {
            ( true) &&
                warn(`"expose" option is ignored when declared in mixins or extends. ` +
                    `It should only be declared in the base component itself.`);
        }
        else {
            const strat = internalOptionMergeStrats[key] || (strats && strats[key]);
            to[key] = strat ? strat(to[key], from[key]) : from[key];
        }
    }
    return to;
}
const internalOptionMergeStrats = {
    data: mergeDataFn,
    props: mergeObjectOptions,
    emits: mergeObjectOptions,
    // objects
    methods: mergeObjectOptions,
    computed: mergeObjectOptions,
    // lifecycle
    beforeCreate: mergeAsArray,
    created: mergeAsArray,
    beforeMount: mergeAsArray,
    mounted: mergeAsArray,
    beforeUpdate: mergeAsArray,
    updated: mergeAsArray,
    beforeDestroy: mergeAsArray,
    beforeUnmount: mergeAsArray,
    destroyed: mergeAsArray,
    unmounted: mergeAsArray,
    activated: mergeAsArray,
    deactivated: mergeAsArray,
    errorCaptured: mergeAsArray,
    serverPrefetch: mergeAsArray,
    // assets
    components: mergeObjectOptions,
    directives: mergeObjectOptions,
    // watch
    watch: mergeWatchOptions,
    // provide / inject
    provide: mergeDataFn,
    inject: mergeInject
};
function mergeDataFn(to, from) {
    if (!from) {
        return to;
    }
    if (!to) {
        return from;
    }
    return function mergedDataFn() {
        return ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend))((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(to) ? to.call(this, this) : to, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(from) ? from.call(this, this) : from);
    };
}
function mergeInject(to, from) {
    return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
}
function normalizeInject(raw) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(raw)) {
        const res = {};
        for (let i = 0; i < raw.length; i++) {
            res[raw[i]] = raw[i];
        }
        return res;
    }
    return raw;
}
function mergeAsArray(to, from) {
    return to ? [...new Set([].concat(to, from))] : from;
}
function mergeObjectOptions(to, from) {
    return to ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(Object.create(null), to), from) : from;
}
function mergeWatchOptions(to, from) {
    if (!to)
        return from;
    if (!from)
        return to;
    const merged = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(Object.create(null), to);
    for (const key in from) {
        merged[key] = mergeAsArray(to[key], from[key]);
    }
    return merged;
}

function initProps(instance, rawProps, isStateful, // result of bitwise flag comparison
isSSR = false) {
    const props = {};
    const attrs = {};
    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.def)(attrs, InternalObjectKey, 1);
    instance.propsDefaults = Object.create(null);
    setFullProps(instance, rawProps, props, attrs);
    // ensure all declared prop keys are present
    for (const key in instance.propsOptions[0]) {
        if (!(key in props)) {
            props[key] = undefined;
        }
    }
    // validation
    if ((true)) {
        validateProps(rawProps || {}, props, instance);
    }
    if (isStateful) {
        // stateful
        instance.props = isSSR ? props : (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReactive)(props);
    }
    else {
        if (!instance.type.props) {
            // functional w/ optional props, props === attrs
            instance.props = attrs;
        }
        else {
            // functional w/ declared props
            instance.props = props;
        }
    }
    instance.attrs = attrs;
}
function updateProps(instance, rawProps, rawPrevProps, optimized) {
    const { props, attrs, vnode: { patchFlag } } = instance;
    const rawCurrentProps = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(props);
    const [options] = instance.propsOptions;
    let hasAttrsChanged = false;
    if (
    // always force full diff in dev
    // - #1942 if hmr is enabled with sfc component
    // - vite#872 non-sfc component used by sfc component
    !(( true) &&
        (instance.type.__hmrId ||
            (instance.parent && instance.parent.type.__hmrId))) &&
        (optimized || patchFlag > 0) &&
        !(patchFlag & 16 /* FULL_PROPS */)) {
        if (patchFlag & 8 /* PROPS */) {
            // Compiler-generated props & no keys change, just set the updated
            // the props.
            const propsToUpdate = instance.vnode.dynamicProps;
            for (let i = 0; i < propsToUpdate.length; i++) {
                let key = propsToUpdate[i];
                // PROPS flag guarantees rawProps to be non-null
                const value = rawProps[key];
                if (options) {
                    // attr / props separation was done on init and will be consistent
                    // in this code path, so just check if attrs have it.
                    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(attrs, key)) {
                        if (value !== attrs[key]) {
                            attrs[key] = value;
                            hasAttrsChanged = true;
                        }
                    }
                    else {
                        const camelizedKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(key);
                        props[camelizedKey] = resolvePropValue(options, rawCurrentProps, camelizedKey, value, instance, false /* isAbsent */);
                    }
                }
                else {
                    if (value !== attrs[key]) {
                        attrs[key] = value;
                        hasAttrsChanged = true;
                    }
                }
            }
        }
    }
    else {
        // full props update.
        if (setFullProps(instance, rawProps, props, attrs)) {
            hasAttrsChanged = true;
        }
        // in case of dynamic props, check if we need to delete keys from
        // the props object
        let kebabKey;
        for (const key in rawCurrentProps) {
            if (!rawProps ||
                // for camelCase
                (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(rawProps, key) &&
                    // it's possible the original props was passed in as kebab-case
                    // and converted to camelCase (#955)
                    ((kebabKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(key)) === key || !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(rawProps, kebabKey)))) {
                if (options) {
                    if (rawPrevProps &&
                        // for camelCase
                        (rawPrevProps[key] !== undefined ||
                            // for kebab-case
                            rawPrevProps[kebabKey] !== undefined)) {
                        props[key] = resolvePropValue(options, rawCurrentProps, key, undefined, instance, true /* isAbsent */);
                    }
                }
                else {
                    delete props[key];
                }
            }
        }
        // in the case of functional component w/o props declaration, props and
        // attrs point to the same object so it should already have been updated.
        if (attrs !== rawCurrentProps) {
            for (const key in attrs) {
                if (!rawProps ||
                    (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(rawProps, key) &&
                        (!false ))) {
                    delete attrs[key];
                    hasAttrsChanged = true;
                }
            }
        }
    }
    // trigger updates for $attrs in case it's used in component slots
    if (hasAttrsChanged) {
        (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.trigger)(instance, "set" /* SET */, '$attrs');
    }
    if ((true)) {
        validateProps(rawProps || {}, props, instance);
    }
}
function setFullProps(instance, rawProps, props, attrs) {
    const [options, needCastKeys] = instance.propsOptions;
    let hasAttrsChanged = false;
    let rawCastValues;
    if (rawProps) {
        for (let key in rawProps) {
            // key, ref are reserved and never passed down
            if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isReservedProp)(key)) {
                continue;
            }
            const value = rawProps[key];
            // prop option names are camelized during normalization, so to support
            // kebab -> camel conversion here we need to camelize the key.
            let camelKey;
            if (options && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(options, (camelKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(key)))) {
                if (!needCastKeys || !needCastKeys.includes(camelKey)) {
                    props[camelKey] = value;
                }
                else {
                    (rawCastValues || (rawCastValues = {}))[camelKey] = value;
                }
            }
            else if (!isEmitListener(instance.emitsOptions, key)) {
                if (!(key in attrs) || value !== attrs[key]) {
                    attrs[key] = value;
                    hasAttrsChanged = true;
                }
            }
        }
    }
    if (needCastKeys) {
        const rawCurrentProps = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(props);
        const castValues = rawCastValues || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
        for (let i = 0; i < needCastKeys.length; i++) {
            const key = needCastKeys[i];
            props[key] = resolvePropValue(options, rawCurrentProps, key, castValues[key], instance, !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(castValues, key));
        }
    }
    return hasAttrsChanged;
}
function resolvePropValue(options, props, key, value, instance, isAbsent) {
    const opt = options[key];
    if (opt != null) {
        const hasDefault = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(opt, 'default');
        // default values
        if (hasDefault && value === undefined) {
            const defaultValue = opt.default;
            if (opt.type !== Function && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(defaultValue)) {
                const { propsDefaults } = instance;
                if (key in propsDefaults) {
                    value = propsDefaults[key];
                }
                else {
                    setCurrentInstance(instance);
                    value = propsDefaults[key] = defaultValue.call(null, props);
                    unsetCurrentInstance();
                }
            }
            else {
                value = defaultValue;
            }
        }
        // boolean casting
        if (opt[0 /* shouldCast */]) {
            if (isAbsent && !hasDefault) {
                value = false;
            }
            else if (opt[1 /* shouldCastTrue */] &&
                (value === '' || value === (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(key))) {
                value = true;
            }
        }
    }
    return value;
}
function normalizePropsOptions(comp, appContext, asMixin = false) {
    const cache = appContext.propsCache;
    const cached = cache.get(comp);
    if (cached) {
        return cached;
    }
    const raw = comp.props;
    const normalized = {};
    const needCastKeys = [];
    // apply mixin/extends props
    let hasExtends = false;
    if ( true && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(comp)) {
        const extendProps = (raw) => {
            hasExtends = true;
            const [props, keys] = normalizePropsOptions(raw, appContext, true);
            (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(normalized, props);
            if (keys)
                needCastKeys.push(...keys);
        };
        if (!asMixin && appContext.mixins.length) {
            appContext.mixins.forEach(extendProps);
        }
        if (comp.extends) {
            extendProps(comp.extends);
        }
        if (comp.mixins) {
            comp.mixins.forEach(extendProps);
        }
    }
    if (!raw && !hasExtends) {
        cache.set(comp, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARR);
        return _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARR;
    }
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(raw)) {
        for (let i = 0; i < raw.length; i++) {
            if (( true) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(raw[i])) {
                warn(`props must be strings when using array syntax.`, raw[i]);
            }
            const normalizedKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(raw[i]);
            if (validatePropName(normalizedKey)) {
                normalized[normalizedKey] = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
            }
        }
    }
    else if (raw) {
        if (( true) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(raw)) {
            warn(`invalid props options`, raw);
        }
        for (const key in raw) {
            const normalizedKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(key);
            if (validatePropName(normalizedKey)) {
                const opt = raw[key];
                const prop = (normalized[normalizedKey] =
                    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(opt) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(opt) ? { type: opt } : opt);
                if (prop) {
                    const booleanIndex = getTypeIndex(Boolean, prop.type);
                    const stringIndex = getTypeIndex(String, prop.type);
                    prop[0 /* shouldCast */] = booleanIndex > -1;
                    prop[1 /* shouldCastTrue */] =
                        stringIndex < 0 || booleanIndex < stringIndex;
                    // if the prop needs boolean casting or default value
                    if (booleanIndex > -1 || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(prop, 'default')) {
                        needCastKeys.push(normalizedKey);
                    }
                }
            }
        }
    }
    const res = [normalized, needCastKeys];
    cache.set(comp, res);
    return res;
}
function validatePropName(key) {
    if (key[0] !== '$') {
        return true;
    }
    else if ((true)) {
        warn(`Invalid prop name: "${key}" is a reserved property.`);
    }
    return false;
}
// use function string name to check type constructors
// so that it works across vms / iframes.
function getType(ctor) {
    const match = ctor && ctor.toString().match(/^\s*function (\w+)/);
    return match ? match[1] : ctor === null ? 'null' : '';
}
function isSameType(a, b) {
    return getType(a) === getType(b);
}
function getTypeIndex(type, expectedTypes) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(expectedTypes)) {
        return expectedTypes.findIndex(t => isSameType(t, type));
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(expectedTypes)) {
        return isSameType(expectedTypes, type) ? 0 : -1;
    }
    return -1;
}
/**
 * dev only
 */
function validateProps(rawProps, props, instance) {
    const resolvedValues = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(props);
    const options = instance.propsOptions[0];
    for (const key in options) {
        let opt = options[key];
        if (opt == null)
            continue;
        validateProp(key, resolvedValues[key], opt, !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(rawProps, key) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(rawProps, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(key)));
    }
}
/**
 * dev only
 */
function validateProp(name, value, prop, isAbsent) {
    const { type, required, validator } = prop;
    // required!
    if (required && isAbsent) {
        warn('Missing required prop: "' + name + '"');
        return;
    }
    // missing but optional
    if (value == null && !prop.required) {
        return;
    }
    // type check
    if (type != null && type !== true) {
        let isValid = false;
        const types = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(type) ? type : [type];
        const expectedTypes = [];
        // value is valid as long as one of the specified types match
        for (let i = 0; i < types.length && !isValid; i++) {
            const { valid, expectedType } = assertType(value, types[i]);
            expectedTypes.push(expectedType || '');
            isValid = valid;
        }
        if (!isValid) {
            warn(getInvalidTypeMessage(name, value, expectedTypes));
            return;
        }
    }
    // custom validator
    if (validator && !validator(value)) {
        warn('Invalid prop: custom validator check failed for prop "' + name + '".');
    }
}
const isSimpleType = /*#__PURE__*/ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.makeMap)('String,Number,Boolean,Function,Symbol,BigInt');
/**
 * dev only
 */
function assertType(value, type) {
    let valid;
    const expectedType = getType(type);
    if (isSimpleType(expectedType)) {
        const t = typeof value;
        valid = t === expectedType.toLowerCase();
        // for primitive wrapper objects
        if (!valid && t === 'object') {
            valid = value instanceof type;
        }
    }
    else if (expectedType === 'Object') {
        valid = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(value);
    }
    else if (expectedType === 'Array') {
        valid = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value);
    }
    else if (expectedType === 'null') {
        valid = value === null;
    }
    else {
        valid = value instanceof type;
    }
    return {
        valid,
        expectedType
    };
}
/**
 * dev only
 */
function getInvalidTypeMessage(name, value, expectedTypes) {
    let message = `Invalid prop: type check failed for prop "${name}".` +
        ` Expected ${expectedTypes.map(_vue_shared__WEBPACK_IMPORTED_MODULE_1__.capitalize).join(' | ')}`;
    const expectedType = expectedTypes[0];
    const receivedType = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toRawType)(value);
    const expectedValue = styleValue(value, expectedType);
    const receivedValue = styleValue(value, receivedType);
    // check if we need to specify expected value
    if (expectedTypes.length === 1 &&
        isExplicable(expectedType) &&
        !isBoolean(expectedType, receivedType)) {
        message += ` with value ${expectedValue}`;
    }
    message += `, got ${receivedType} `;
    // check if we need to specify received value
    if (isExplicable(receivedType)) {
        message += `with value ${receivedValue}.`;
    }
    return message;
}
/**
 * dev only
 */
function styleValue(value, type) {
    if (type === 'String') {
        return `"${value}"`;
    }
    else if (type === 'Number') {
        return `${Number(value)}`;
    }
    else {
        return `${value}`;
    }
}
/**
 * dev only
 */
function isExplicable(type) {
    const explicitTypes = ['string', 'number', 'boolean'];
    return explicitTypes.some(elem => type.toLowerCase() === elem);
}
/**
 * dev only
 */
function isBoolean(...args) {
    return args.some(elem => elem.toLowerCase() === 'boolean');
}

const isInternalKey = (key) => key[0] === '_' || key === '$stable';
const normalizeSlotValue = (value) => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value)
    ? value.map(normalizeVNode)
    : [normalizeVNode(value)];
const normalizeSlot = (key, rawSlot, ctx) => {
    const normalized = withCtx((...args) => {
        if (( true) && currentInstance) {
            warn(`Slot "${key}" invoked outside of the render function: ` +
                `this will not track dependencies used in the slot. ` +
                `Invoke the slot function inside the render function instead.`);
        }
        return normalizeSlotValue(rawSlot(...args));
    }, ctx);
    normalized._c = false;
    return normalized;
};
const normalizeObjectSlots = (rawSlots, slots, instance) => {
    const ctx = rawSlots._ctx;
    for (const key in rawSlots) {
        if (isInternalKey(key))
            continue;
        const value = rawSlots[key];
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(value)) {
            slots[key] = normalizeSlot(key, value, ctx);
        }
        else if (value != null) {
            if (true) {
                warn(`Non-function value encountered for slot "${key}". ` +
                    `Prefer function slots for better performance.`);
            }
            const normalized = normalizeSlotValue(value);
            slots[key] = () => normalized;
        }
    }
};
const normalizeVNodeSlots = (instance, children) => {
    if (( true) &&
        !isKeepAlive(instance.vnode) &&
        !(false )) {
        warn(`Non-function value encountered for default slot. ` +
            `Prefer function slots for better performance.`);
    }
    const normalized = normalizeSlotValue(children);
    instance.slots.default = () => normalized;
};
const initSlots = (instance, children) => {
    if (instance.vnode.shapeFlag & 32 /* SLOTS_CHILDREN */) {
        const type = children._;
        if (type) {
            // users can get the shallow readonly version of the slots object through `this.$slots`,
            // we should avoid the proxy object polluting the slots of the internal instance
            instance.slots = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(children);
            // make compiler marker non-enumerable
            (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.def)(children, '_', type);
        }
        else {
            normalizeObjectSlots(children, (instance.slots = {}));
        }
    }
    else {
        instance.slots = {};
        if (children) {
            normalizeVNodeSlots(instance, children);
        }
    }
    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.def)(instance.slots, InternalObjectKey, 1);
};
const updateSlots = (instance, children, optimized) => {
    const { vnode, slots } = instance;
    let needDeletionCheck = true;
    let deletionComparisonTarget = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
    if (vnode.shapeFlag & 32 /* SLOTS_CHILDREN */) {
        const type = children._;
        if (type) {
            // compiled slots.
            if (( true) && isHmrUpdating) {
                // Parent was HMR updated so slot content may have changed.
                // force update slots and mark instance for hmr as well
                (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(slots, children);
            }
            else if (optimized && type === 1 /* STABLE */) {
                // compiled AND stable.
                // no need to update, and skip stale slots removal.
                needDeletionCheck = false;
            }
            else {
                // compiled but dynamic (v-if/v-for on slots) - update slots, but skip
                // normalization.
                (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(slots, children);
                // #2893
                // when rendering the optimized slots by manually written render function,
                // we need to delete the `slots._` flag if necessary to make subsequent updates reliable,
                // i.e. let the `renderSlot` create the bailed Fragment
                if (!optimized && type === 1 /* STABLE */) {
                    delete slots._;
                }
            }
        }
        else {
            needDeletionCheck = !children.$stable;
            normalizeObjectSlots(children, slots);
        }
        deletionComparisonTarget = children;
    }
    else if (children) {
        // non slot object children (direct value) passed to a component
        normalizeVNodeSlots(instance, children);
        deletionComparisonTarget = { default: 1 };
    }
    // delete stale slots
    if (needDeletionCheck) {
        for (const key in slots) {
            if (!isInternalKey(key) && !(key in deletionComparisonTarget)) {
                delete slots[key];
            }
        }
    }
};

/**
Runtime helper for applying directives to a vnode. Example usage:

const comp = resolveComponent('comp')
const foo = resolveDirective('foo')
const bar = resolveDirective('bar')

return withDirectives(h(comp), [
  [foo, this.x],
  [bar, this.y]
])
*/
function validateDirectiveName(name) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isBuiltInDirective)(name)) {
        warn('Do not use built-in directive ids as custom directive id: ' + name);
    }
}
/**
 * Adds directives to a VNode.
 */
function withDirectives(vnode, directives) {
    const internalInstance = currentRenderingInstance;
    if (internalInstance === null) {
        ( true) && warn(`withDirectives can only be used inside render functions.`);
        return vnode;
    }
    const instance = internalInstance.proxy;
    const bindings = vnode.dirs || (vnode.dirs = []);
    for (let i = 0; i < directives.length; i++) {
        let [dir, value, arg, modifiers = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ] = directives[i];
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(dir)) {
            dir = {
                mounted: dir,
                updated: dir
            };
        }
        if (dir.deep) {
            traverse(value);
        }
        bindings.push({
            dir,
            instance,
            value,
            oldValue: void 0,
            arg,
            modifiers
        });
    }
    return vnode;
}
function invokeDirectiveHook(vnode, prevVNode, instance, name) {
    const bindings = vnode.dirs;
    const oldBindings = prevVNode && prevVNode.dirs;
    for (let i = 0; i < bindings.length; i++) {
        const binding = bindings[i];
        if (oldBindings) {
            binding.oldValue = oldBindings[i].value;
        }
        let hook = binding.dir[name];
        if (hook) {
            // disable tracking inside all lifecycle hooks
            // since they can potentially be called inside effects.
            (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.pauseTracking)();
            callWithAsyncErrorHandling(hook, instance, 8 /* DIRECTIVE_HOOK */, [
                vnode.el,
                binding,
                vnode,
                prevVNode
            ]);
            (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.resetTracking)();
        }
    }
}

function createAppContext() {
    return {
        app: null,
        config: {
            isNativeTag: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NO,
            performance: false,
            globalProperties: {},
            optionMergeStrategies: {},
            errorHandler: undefined,
            warnHandler: undefined,
            compilerOptions: {}
        },
        mixins: [],
        components: {},
        directives: {},
        provides: Object.create(null),
        optionsCache: new WeakMap(),
        propsCache: new WeakMap(),
        emitsCache: new WeakMap()
    };
}
let uid = 0;
function createAppAPI(render, hydrate) {
    return function createApp(rootComponent, rootProps = null) {
        if (rootProps != null && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(rootProps)) {
            ( true) && warn(`root props passed to app.mount() must be an object.`);
            rootProps = null;
        }
        const context = createAppContext();
        const installedPlugins = new Set();
        let isMounted = false;
        const app = (context.app = {
            _uid: uid++,
            _component: rootComponent,
            _props: rootProps,
            _container: null,
            _context: context,
            _instance: null,
            version,
            get config() {
                return context.config;
            },
            set config(v) {
                if ((true)) {
                    warn(`app.config cannot be replaced. Modify individual options instead.`);
                }
            },
            use(plugin, ...options) {
                if (installedPlugins.has(plugin)) {
                    ( true) && warn(`Plugin has already been applied to target app.`);
                }
                else if (plugin && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(plugin.install)) {
                    installedPlugins.add(plugin);
                    plugin.install(app, ...options);
                }
                else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(plugin)) {
                    installedPlugins.add(plugin);
                    plugin(app, ...options);
                }
                else if ((true)) {
                    warn(`A plugin must either be a function or an object with an "install" ` +
                        `function.`);
                }
                return app;
            },
            mixin(mixin) {
                if (true) {
                    if (!context.mixins.includes(mixin)) {
                        context.mixins.push(mixin);
                    }
                    else if ((true)) {
                        warn('Mixin has already been applied to target app' +
                            (mixin.name ? `: ${mixin.name}` : ''));
                    }
                }
                else {}
                return app;
            },
            component(name, component) {
                if ((true)) {
                    validateComponentName(name, context.config);
                }
                if (!component) {
                    return context.components[name];
                }
                if (( true) && context.components[name]) {
                    warn(`Component "${name}" has already been registered in target app.`);
                }
                context.components[name] = component;
                return app;
            },
            directive(name, directive) {
                if ((true)) {
                    validateDirectiveName(name);
                }
                if (!directive) {
                    return context.directives[name];
                }
                if (( true) && context.directives[name]) {
                    warn(`Directive "${name}" has already been registered in target app.`);
                }
                context.directives[name] = directive;
                return app;
            },
            mount(rootContainer, isHydrate, isSVG) {
                if (!isMounted) {
                    const vnode = createVNode(rootComponent, rootProps);
                    // store app context on the root VNode.
                    // this will be set on the root instance on initial mount.
                    vnode.appContext = context;
                    // HMR root reload
                    if ((true)) {
                        context.reload = () => {
                            render(cloneVNode(vnode), rootContainer, isSVG);
                        };
                    }
                    if (isHydrate && hydrate) {
                        hydrate(vnode, rootContainer);
                    }
                    else {
                        render(vnode, rootContainer, isSVG);
                    }
                    isMounted = true;
                    app._container = rootContainer;
                    rootContainer.__vue_app__ = app;
                    if (true) {
                        app._instance = vnode.component;
                        devtoolsInitApp(app, version);
                    }
                    return getExposeProxy(vnode.component) || vnode.component.proxy;
                }
                else if ((true)) {
                    warn(`App has already been mounted.\n` +
                        `If you want to remount the same app, move your app creation logic ` +
                        `into a factory function and create fresh app instances for each ` +
                        `mount - e.g. \`const createMyApp = () => createApp(App)\``);
                }
            },
            unmount() {
                if (isMounted) {
                    render(null, app._container);
                    if (true) {
                        app._instance = null;
                        devtoolsUnmountApp(app);
                    }
                    delete app._container.__vue_app__;
                }
                else if ((true)) {
                    warn(`Cannot unmount an app that is not mounted.`);
                }
            },
            provide(key, value) {
                if (( true) && key in context.provides) {
                    warn(`App already provides property with key "${String(key)}". ` +
                        `It will be overwritten with the new value.`);
                }
                // TypeScript doesn't allow symbols as index type
                // https://github.com/Microsoft/TypeScript/issues/24587
                context.provides[key] = value;
                return app;
            }
        });
        return app;
    };
}

/**
 * Function for handling a template ref
 */
function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(rawRef)) {
        rawRef.forEach((r, i) => setRef(r, oldRawRef && ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(oldRawRef) ? oldRawRef[i] : oldRawRef), parentSuspense, vnode, isUnmount));
        return;
    }
    if (isAsyncWrapper(vnode) && !isUnmount) {
        // when mounting async components, nothing needs to be done,
        // because the template ref is forwarded to inner component
        return;
    }
    const refValue = vnode.shapeFlag & 4 /* STATEFUL_COMPONENT */
        ? getExposeProxy(vnode.component) || vnode.component.proxy
        : vnode.el;
    const value = isUnmount ? null : refValue;
    const { i: owner, r: ref } = rawRef;
    if (( true) && !owner) {
        warn(`Missing ref owner context. ref cannot be used on hoisted vnodes. ` +
            `A vnode with ref must be created inside the render function.`);
        return;
    }
    const oldRef = oldRawRef && oldRawRef.r;
    const refs = owner.refs === _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ ? (owner.refs = {}) : owner.refs;
    const setupState = owner.setupState;
    // dynamic ref changed. unset old ref
    if (oldRef != null && oldRef !== ref) {
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(oldRef)) {
            refs[oldRef] = null;
            if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(setupState, oldRef)) {
                setupState[oldRef] = null;
            }
        }
        else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(oldRef)) {
            oldRef.value = null;
        }
    }
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(ref)) {
        callWithErrorHandling(ref, owner, 12 /* FUNCTION_REF */, [value, refs]);
    }
    else {
        const _isString = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(ref);
        const _isRef = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(ref);
        if (_isString || _isRef) {
            const doSet = () => {
                if (rawRef.f) {
                    const existing = _isString ? refs[ref] : ref.value;
                    if (isUnmount) {
                        (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(existing) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.remove)(existing, refValue);
                    }
                    else {
                        if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(existing)) {
                            if (_isString) {
                                refs[ref] = [refValue];
                            }
                            else {
                                ref.value = [refValue];
                                if (rawRef.k)
                                    refs[rawRef.k] = ref.value;
                            }
                        }
                        else if (!existing.includes(refValue)) {
                            existing.push(refValue);
                        }
                    }
                }
                else if (_isString) {
                    refs[ref] = value;
                    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(setupState, ref)) {
                        setupState[ref] = value;
                    }
                }
                else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(ref)) {
                    ref.value = value;
                    if (rawRef.k)
                        refs[rawRef.k] = value;
                }
                else if ((true)) {
                    warn('Invalid template ref type:', ref, `(${typeof ref})`);
                }
            };
            if (value) {
                doSet.id = -1;
                queuePostRenderEffect(doSet, parentSuspense);
            }
            else {
                doSet();
            }
        }
        else if ((true)) {
            warn('Invalid template ref type:', ref, `(${typeof ref})`);
        }
    }
}

let hasMismatch = false;
const isSVGContainer = (container) => /svg/.test(container.namespaceURI) && container.tagName !== 'foreignObject';
const isComment = (node) => node.nodeType === 8 /* COMMENT */;
// Note: hydration is DOM-specific
// But we have to place it in core due to tight coupling with core - splitting
// it out creates a ton of unnecessary complexity.
// Hydration also depends on some renderer internal logic which needs to be
// passed in via arguments.
function createHydrationFunctions(rendererInternals) {
    const { mt: mountComponent, p: patch, o: { patchProp, nextSibling, parentNode, remove, insert, createComment } } = rendererInternals;
    const hydrate = (vnode, container) => {
        if (!container.hasChildNodes()) {
            ( true) &&
                warn(`Attempting to hydrate existing markup but container is empty. ` +
                    `Performing full mount instead.`);
            patch(null, vnode, container);
            flushPostFlushCbs();
            return;
        }
        hasMismatch = false;
        hydrateNode(container.firstChild, vnode, null, null, null);
        flushPostFlushCbs();
        if (hasMismatch && !false) {
            // this error should show up in production
            console.error(`Hydration completed but contains mismatches.`);
        }
    };
    const hydrateNode = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized = false) => {
        const isFragmentStart = isComment(node) && node.data === '[';
        const onMismatch = () => handleMismatch(node, vnode, parentComponent, parentSuspense, slotScopeIds, isFragmentStart);
        const { type, ref, shapeFlag } = vnode;
        const domType = node.nodeType;
        vnode.el = node;
        let nextNode = null;
        switch (type) {
            case Text:
                if (domType !== 3 /* TEXT */) {
                    nextNode = onMismatch();
                }
                else {
                    if (node.data !== vnode.children) {
                        hasMismatch = true;
                        ( true) &&
                            warn(`Hydration text mismatch:` +
                                `\n- Client: ${JSON.stringify(node.data)}` +
                                `\n- Server: ${JSON.stringify(vnode.children)}`);
                        node.data = vnode.children;
                    }
                    nextNode = nextSibling(node);
                }
                break;
            case Comment:
                if (domType !== 8 /* COMMENT */ || isFragmentStart) {
                    nextNode = onMismatch();
                }
                else {
                    nextNode = nextSibling(node);
                }
                break;
            case Static:
                if (domType !== 1 /* ELEMENT */) {
                    nextNode = onMismatch();
                }
                else {
                    // determine anchor, adopt content
                    nextNode = node;
                    // if the static vnode has its content stripped during build,
                    // adopt it from the server-rendered HTML.
                    const needToAdoptContent = !vnode.children.length;
                    for (let i = 0; i < vnode.staticCount; i++) {
                        if (needToAdoptContent)
                            vnode.children += nextNode.outerHTML;
                        if (i === vnode.staticCount - 1) {
                            vnode.anchor = nextNode;
                        }
                        nextNode = nextSibling(nextNode);
                    }
                    return nextNode;
                }
                break;
            case Fragment:
                if (!isFragmentStart) {
                    nextNode = onMismatch();
                }
                else {
                    nextNode = hydrateFragment(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);
                }
                break;
            default:
                if (shapeFlag & 1 /* ELEMENT */) {
                    if (domType !== 1 /* ELEMENT */ ||
                        vnode.type.toLowerCase() !==
                            node.tagName.toLowerCase()) {
                        nextNode = onMismatch();
                    }
                    else {
                        nextNode = hydrateElement(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);
                    }
                }
                else if (shapeFlag & 6 /* COMPONENT */) {
                    // when setting up the render effect, if the initial vnode already
                    // has .el set, the component will perform hydration instead of mount
                    // on its sub-tree.
                    vnode.slotScopeIds = slotScopeIds;
                    const container = parentNode(node);
                    mountComponent(vnode, container, null, parentComponent, parentSuspense, isSVGContainer(container), optimized);
                    // component may be async, so in the case of fragments we cannot rely
                    // on component's rendered output to determine the end of the fragment
                    // instead, we do a lookahead to find the end anchor node.
                    nextNode = isFragmentStart
                        ? locateClosingAsyncAnchor(node)
                        : nextSibling(node);
                    // #3787
                    // if component is async, it may get moved / unmounted before its
                    // inner component is loaded, so we need to give it a placeholder
                    // vnode that matches its adopted DOM.
                    if (isAsyncWrapper(vnode)) {
                        let subTree;
                        if (isFragmentStart) {
                            subTree = createVNode(Fragment);
                            subTree.anchor = nextNode
                                ? nextNode.previousSibling
                                : container.lastChild;
                        }
                        else {
                            subTree =
                                node.nodeType === 3 ? createTextVNode('') : createVNode('div');
                        }
                        subTree.el = node;
                        vnode.component.subTree = subTree;
                    }
                }
                else if (shapeFlag & 64 /* TELEPORT */) {
                    if (domType !== 8 /* COMMENT */) {
                        nextNode = onMismatch();
                    }
                    else {
                        nextNode = vnode.type.hydrate(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, rendererInternals, hydrateChildren);
                    }
                }
                else if (shapeFlag & 128 /* SUSPENSE */) {
                    nextNode = vnode.type.hydrate(node, vnode, parentComponent, parentSuspense, isSVGContainer(parentNode(node)), slotScopeIds, optimized, rendererInternals, hydrateNode);
                }
                else if ((true)) {
                    warn('Invalid HostVNode type:', type, `(${typeof type})`);
                }
        }
        if (ref != null) {
            setRef(ref, null, parentSuspense, vnode);
        }
        return nextNode;
    };
    const hydrateElement = (el, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {
        optimized = optimized || !!vnode.dynamicChildren;
        const { type, props, patchFlag, shapeFlag, dirs } = vnode;
        // #4006 for form elements with non-string v-model value bindings
        // e.g. <option :value="obj">, <input type="checkbox" :true-value="1">
        const forcePatchValue = (type === 'input' && dirs) || type === 'option';
        // skip props & children if this is hoisted static nodes
        // #5405 in dev, always hydrate children for HMR
        if (true /* HOISTED */) {
            if (dirs) {
                invokeDirectiveHook(vnode, null, parentComponent, 'created');
            }
            // props
            if (props) {
                if (forcePatchValue ||
                    !optimized ||
                    patchFlag & (16 /* FULL_PROPS */ | 32 /* HYDRATE_EVENTS */)) {
                    for (const key in props) {
                        if ((forcePatchValue && key.endsWith('value')) ||
                            ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isOn)(key) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isReservedProp)(key))) {
                            patchProp(el, key, null, props[key], false, undefined, parentComponent);
                        }
                    }
                }
                else if (props.onClick) {
                    // Fast path for click listeners (which is most often) to avoid
                    // iterating through props.
                    patchProp(el, 'onClick', null, props.onClick, false, undefined, parentComponent);
                }
            }
            // vnode / directive hooks
            let vnodeHooks;
            if ((vnodeHooks = props && props.onVnodeBeforeMount)) {
                invokeVNodeHook(vnodeHooks, parentComponent, vnode);
            }
            if (dirs) {
                invokeDirectiveHook(vnode, null, parentComponent, 'beforeMount');
            }
            if ((vnodeHooks = props && props.onVnodeMounted) || dirs) {
                queueEffectWithSuspense(() => {
                    vnodeHooks && invokeVNodeHook(vnodeHooks, parentComponent, vnode);
                    dirs && invokeDirectiveHook(vnode, null, parentComponent, 'mounted');
                }, parentSuspense);
            }
            // children
            if (shapeFlag & 16 /* ARRAY_CHILDREN */ &&
                // skip if element has innerHTML / textContent
                !(props && (props.innerHTML || props.textContent))) {
                let next = hydrateChildren(el.firstChild, vnode, el, parentComponent, parentSuspense, slotScopeIds, optimized);
                let hasWarned = false;
                while (next) {
                    hasMismatch = true;
                    if (( true) && !hasWarned) {
                        warn(`Hydration children mismatch in <${vnode.type}>: ` +
                            `server rendered element contains more child nodes than client vdom.`);
                        hasWarned = true;
                    }
                    // The SSRed DOM contains more nodes than it should. Remove them.
                    const cur = next;
                    next = next.nextSibling;
                    remove(cur);
                }
            }
            else if (shapeFlag & 8 /* TEXT_CHILDREN */) {
                if (el.textContent !== vnode.children) {
                    hasMismatch = true;
                    ( true) &&
                        warn(`Hydration text content mismatch in <${vnode.type}>:\n` +
                            `- Client: ${el.textContent}\n` +
                            `- Server: ${vnode.children}`);
                    el.textContent = vnode.children;
                }
            }
        }
        return el.nextSibling;
    };
    const hydrateChildren = (node, parentVNode, container, parentComponent, parentSuspense, slotScopeIds, optimized) => {
        optimized = optimized || !!parentVNode.dynamicChildren;
        const children = parentVNode.children;
        const l = children.length;
        let hasWarned = false;
        for (let i = 0; i < l; i++) {
            const vnode = optimized
                ? children[i]
                : (children[i] = normalizeVNode(children[i]));
            if (node) {
                node = hydrateNode(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);
            }
            else if (vnode.type === Text && !vnode.children) {
                continue;
            }
            else {
                hasMismatch = true;
                if (( true) && !hasWarned) {
                    warn(`Hydration children mismatch in <${container.tagName.toLowerCase()}>: ` +
                        `server rendered element contains fewer child nodes than client vdom.`);
                    hasWarned = true;
                }
                // the SSRed DOM didn't contain enough nodes. Mount the missing ones.
                patch(null, vnode, container, null, parentComponent, parentSuspense, isSVGContainer(container), slotScopeIds);
            }
        }
        return node;
    };
    const hydrateFragment = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {
        const { slotScopeIds: fragmentSlotScopeIds } = vnode;
        if (fragmentSlotScopeIds) {
            slotScopeIds = slotScopeIds
                ? slotScopeIds.concat(fragmentSlotScopeIds)
                : fragmentSlotScopeIds;
        }
        const container = parentNode(node);
        const next = hydrateChildren(nextSibling(node), vnode, container, parentComponent, parentSuspense, slotScopeIds, optimized);
        if (next && isComment(next) && next.data === ']') {
            return nextSibling((vnode.anchor = next));
        }
        else {
            // fragment didn't hydrate successfully, since we didn't get a end anchor
            // back. This should have led to node/children mismatch warnings.
            hasMismatch = true;
            // since the anchor is missing, we need to create one and insert it
            insert((vnode.anchor = createComment(`]`)), container, next);
            return next;
        }
    };
    const handleMismatch = (node, vnode, parentComponent, parentSuspense, slotScopeIds, isFragment) => {
        hasMismatch = true;
        ( true) &&
            warn(`Hydration node mismatch:\n- Client vnode:`, vnode.type, `\n- Server rendered DOM:`, node, node.nodeType === 3 /* TEXT */
                ? `(text)`
                : isComment(node) && node.data === '['
                    ? `(start of fragment)`
                    : ``);
        vnode.el = null;
        if (isFragment) {
            // remove excessive fragment nodes
            const end = locateClosingAsyncAnchor(node);
            while (true) {
                const next = nextSibling(node);
                if (next && next !== end) {
                    remove(next);
                }
                else {
                    break;
                }
            }
        }
        const next = nextSibling(node);
        const container = parentNode(node);
        remove(node);
        patch(null, vnode, container, next, parentComponent, parentSuspense, isSVGContainer(container), slotScopeIds);
        return next;
    };
    const locateClosingAsyncAnchor = (node) => {
        let match = 0;
        while (node) {
            node = nextSibling(node);
            if (node && isComment(node)) {
                if (node.data === '[')
                    match++;
                if (node.data === ']') {
                    if (match === 0) {
                        return nextSibling(node);
                    }
                    else {
                        match--;
                    }
                }
            }
        }
        return node;
    };
    return [hydrate, hydrateNode];
}

/* eslint-disable no-restricted-globals */
let supported;
let perf;
function startMeasure(instance, type) {
    if (instance.appContext.config.performance && isSupported()) {
        perf.mark(`vue-${type}-${instance.uid}`);
    }
    if (true) {
        devtoolsPerfStart(instance, type, supported ? perf.now() : Date.now());
    }
}
function endMeasure(instance, type) {
    if (instance.appContext.config.performance && isSupported()) {
        const startTag = `vue-${type}-${instance.uid}`;
        const endTag = startTag + `:end`;
        perf.mark(endTag);
        perf.measure(`<${formatComponentName(instance, instance.type)}> ${type}`, startTag, endTag);
        perf.clearMarks(startTag);
        perf.clearMarks(endTag);
    }
    if (true) {
        devtoolsPerfEnd(instance, type, supported ? perf.now() : Date.now());
    }
}
function isSupported() {
    if (supported !== undefined) {
        return supported;
    }
    if (typeof window !== 'undefined' && window.performance) {
        supported = true;
        perf = window.performance;
    }
    else {
        supported = false;
    }
    return supported;
}

/**
 * This is only called in esm-bundler builds.
 * It is called when a renderer is created, in `baseCreateRenderer` so that
 * importing runtime-core is side-effects free.
 *
 * istanbul-ignore-next
 */
function initFeatureFlags() {
    const needWarn = [];
    if (false) {}
    if (false) {}
    if (( true) && needWarn.length) {
        const multi = needWarn.length > 1;
        console.warn(`Feature flag${multi ? `s` : ``} ${needWarn.join(', ')} ${multi ? `are` : `is`} not explicitly defined. You are running the esm-bundler build of Vue, ` +
            `which expects these compile-time feature flags to be globally injected ` +
            `via the bundler config in order to get better tree-shaking in the ` +
            `production bundle.\n\n` +
            `For more details, see https://link.vuejs.org/feature-flags.`);
    }
}

const queuePostRenderEffect = queueEffectWithSuspense
    ;
/**
 * The createRenderer function accepts two generic arguments:
 * HostNode and HostElement, corresponding to Node and Element types in the
 * host environment. For example, for runtime-dom, HostNode would be the DOM
 * `Node` interface and HostElement would be the DOM `Element` interface.
 *
 * Custom renderers can pass in the platform specific types like this:
 *
 * ``` js
 * const { render, createApp } = createRenderer<Node, Element>({
 *   patchProp,
 *   ...nodeOps
 * })
 * ```
 */
function createRenderer(options) {
    return baseCreateRenderer(options);
}
// Separate API for creating hydration-enabled renderer.
// Hydration logic is only used when calling this function, making it
// tree-shakable.
function createHydrationRenderer(options) {
    return baseCreateRenderer(options, createHydrationFunctions);
}
// implementation
function baseCreateRenderer(options, createHydrationFns) {
    // compile-time feature flags check
    {
        initFeatureFlags();
    }
    const target = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.getGlobalThis)();
    target.__VUE__ = true;
    if (true) {
        setDevtoolsHook(target.__VUE_DEVTOOLS_GLOBAL_HOOK__, target);
    }
    const { insert: hostInsert, remove: hostRemove, patchProp: hostPatchProp, createElement: hostCreateElement, createText: hostCreateText, createComment: hostCreateComment, setText: hostSetText, setElementText: hostSetElementText, parentNode: hostParentNode, nextSibling: hostNextSibling, setScopeId: hostSetScopeId = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP, cloneNode: hostCloneNode, insertStaticContent: hostInsertStaticContent } = options;
    // Note: functions inside this closure should use `const xxx = () => {}`
    // style in order to prevent being inlined by minifiers.
    const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, isSVG = false, slotScopeIds = null, optimized = ( true) && isHmrUpdating ? false : !!n2.dynamicChildren) => {
        if (n1 === n2) {
            return;
        }
        // patching & not same type, unmount old tree
        if (n1 && !isSameVNodeType(n1, n2)) {
            anchor = getNextHostNode(n1);
            unmount(n1, parentComponent, parentSuspense, true);
            n1 = null;
        }
        if (n2.patchFlag === -2 /* BAIL */) {
            optimized = false;
            n2.dynamicChildren = null;
        }
        const { type, ref, shapeFlag } = n2;
        switch (type) {
            case Text:
                processText(n1, n2, container, anchor);
                break;
            case Comment:
                processCommentNode(n1, n2, container, anchor);
                break;
            case Static:
                if (n1 == null) {
                    mountStaticNode(n2, container, anchor, isSVG);
                }
                else if ((true)) {
                    patchStaticNode(n1, n2, container, isSVG);
                }
                break;
            case Fragment:
                processFragment(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                break;
            default:
                if (shapeFlag & 1 /* ELEMENT */) {
                    processElement(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                }
                else if (shapeFlag & 6 /* COMPONENT */) {
                    processComponent(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                }
                else if (shapeFlag & 64 /* TELEPORT */) {
                    type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);
                }
                else if (shapeFlag & 128 /* SUSPENSE */) {
                    type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);
                }
                else if ((true)) {
                    warn('Invalid VNode type:', type, `(${typeof type})`);
                }
        }
        // set ref
        if (ref != null && parentComponent) {
            setRef(ref, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
        }
    };
    const processText = (n1, n2, container, anchor) => {
        if (n1 == null) {
            hostInsert((n2.el = hostCreateText(n2.children)), container, anchor);
        }
        else {
            const el = (n2.el = n1.el);
            if (n2.children !== n1.children) {
                hostSetText(el, n2.children);
            }
        }
    };
    const processCommentNode = (n1, n2, container, anchor) => {
        if (n1 == null) {
            hostInsert((n2.el = hostCreateComment(n2.children || '')), container, anchor);
        }
        else {
            // there's no support for dynamic comments
            n2.el = n1.el;
        }
    };
    const mountStaticNode = (n2, container, anchor, isSVG) => {
        [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, isSVG, n2.el, n2.anchor);
    };
    /**
     * Dev / HMR only
     */
    const patchStaticNode = (n1, n2, container, isSVG) => {
        // static nodes are only patched during dev for HMR
        if (n2.children !== n1.children) {
            const anchor = hostNextSibling(n1.anchor);
            // remove existing
            removeStaticNode(n1);
            [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, isSVG);
        }
        else {
            n2.el = n1.el;
            n2.anchor = n1.anchor;
        }
    };
    const moveStaticNode = ({ el, anchor }, container, nextSibling) => {
        let next;
        while (el && el !== anchor) {
            next = hostNextSibling(el);
            hostInsert(el, container, nextSibling);
            el = next;
        }
        hostInsert(anchor, container, nextSibling);
    };
    const removeStaticNode = ({ el, anchor }) => {
        let next;
        while (el && el !== anchor) {
            next = hostNextSibling(el);
            hostRemove(el);
            el = next;
        }
        hostRemove(anchor);
    };
    const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
        isSVG = isSVG || n2.type === 'svg';
        if (n1 == null) {
            mountElement(n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        }
        else {
            patchElement(n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        }
    };
    const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
        let el;
        let vnodeHook;
        const { type, props, shapeFlag, transition, patchFlag, dirs } = vnode;
        if (false /* HOISTED */) {}
        else {
            el = vnode.el = hostCreateElement(vnode.type, isSVG, props && props.is, props);
            // mount children first, since some props may rely on child content
            // being already rendered, e.g. `<select value>`
            if (shapeFlag & 8 /* TEXT_CHILDREN */) {
                hostSetElementText(el, vnode.children);
            }
            else if (shapeFlag & 16 /* ARRAY_CHILDREN */) {
                mountChildren(vnode.children, el, null, parentComponent, parentSuspense, isSVG && type !== 'foreignObject', slotScopeIds, optimized);
            }
            if (dirs) {
                invokeDirectiveHook(vnode, null, parentComponent, 'created');
            }
            // props
            if (props) {
                for (const key in props) {
                    if (key !== 'value' && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isReservedProp)(key)) {
                        hostPatchProp(el, key, null, props[key], isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
                    }
                }
                /**
                 * Special case for setting value on DOM elements:
                 * - it can be order-sensitive (e.g. should be set *after* min/max, #2325, #4024)
                 * - it needs to be forced (#1471)
                 * #2353 proposes adding another renderer option to configure this, but
                 * the properties affects are so finite it is worth special casing it
                 * here to reduce the complexity. (Special casing it also should not
                 * affect non-DOM renderers)
                 */
                if ('value' in props) {
                    hostPatchProp(el, 'value', null, props.value);
                }
                if ((vnodeHook = props.onVnodeBeforeMount)) {
                    invokeVNodeHook(vnodeHook, parentComponent, vnode);
                }
            }
            // scopeId
            setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
        }
        if (true) {
            Object.defineProperty(el, '__vnode', {
                value: vnode,
                enumerable: false
            });
            Object.defineProperty(el, '__vueParentComponent', {
                value: parentComponent,
                enumerable: false
            });
        }
        if (dirs) {
            invokeDirectiveHook(vnode, null, parentComponent, 'beforeMount');
        }
        // #1583 For inside suspense + suspense not resolved case, enter hook should call when suspense resolved
        // #1689 For inside suspense + suspense resolved case, just call it
        const needCallTransitionHooks = (!parentSuspense || (parentSuspense && !parentSuspense.pendingBranch)) &&
            transition &&
            !transition.persisted;
        if (needCallTransitionHooks) {
            transition.beforeEnter(el);
        }
        hostInsert(el, container, anchor);
        if ((vnodeHook = props && props.onVnodeMounted) ||
            needCallTransitionHooks ||
            dirs) {
            queuePostRenderEffect(() => {
                vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
                needCallTransitionHooks && transition.enter(el);
                dirs && invokeDirectiveHook(vnode, null, parentComponent, 'mounted');
            }, parentSuspense);
        }
    };
    const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
        if (scopeId) {
            hostSetScopeId(el, scopeId);
        }
        if (slotScopeIds) {
            for (let i = 0; i < slotScopeIds.length; i++) {
                hostSetScopeId(el, slotScopeIds[i]);
            }
        }
        if (parentComponent) {
            let subTree = parentComponent.subTree;
            if (( true) &&
                subTree.patchFlag > 0 &&
                subTree.patchFlag & 2048 /* DEV_ROOT_FRAGMENT */) {
                subTree =
                    filterSingleRoot(subTree.children) || subTree;
            }
            if (vnode === subTree) {
                const parentVNode = parentComponent.vnode;
                setScopeId(el, parentVNode, parentVNode.scopeId, parentVNode.slotScopeIds, parentComponent.parent);
            }
        }
    };
    const mountChildren = (children, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, start = 0) => {
        for (let i = start; i < children.length; i++) {
            const child = (children[i] = optimized
                ? cloneIfMounted(children[i])
                : normalizeVNode(children[i]));
            patch(null, child, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        }
    };
    const patchElement = (n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
        const el = (n2.el = n1.el);
        let { patchFlag, dynamicChildren, dirs } = n2;
        // #1426 take the old vnode's patch flag into account since user may clone a
        // compiler-generated vnode, which de-opts to FULL_PROPS
        patchFlag |= n1.patchFlag & 16 /* FULL_PROPS */;
        const oldProps = n1.props || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
        const newProps = n2.props || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
        let vnodeHook;
        // disable recurse in beforeUpdate hooks
        parentComponent && toggleRecurse(parentComponent, false);
        if ((vnodeHook = newProps.onVnodeBeforeUpdate)) {
            invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
        }
        if (dirs) {
            invokeDirectiveHook(n2, n1, parentComponent, 'beforeUpdate');
        }
        parentComponent && toggleRecurse(parentComponent, true);
        if (( true) && isHmrUpdating) {
            // HMR updated, force full diff
            patchFlag = 0;
            optimized = false;
            dynamicChildren = null;
        }
        const areChildrenSVG = isSVG && n2.type !== 'foreignObject';
        if (dynamicChildren) {
            patchBlockChildren(n1.dynamicChildren, dynamicChildren, el, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds);
            if (( true) && parentComponent && parentComponent.type.__hmrId) {
                traverseStaticChildren(n1, n2);
            }
        }
        else if (!optimized) {
            // full diff
            patchChildren(n1, n2, el, null, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds, false);
        }
        if (patchFlag > 0) {
            // the presence of a patchFlag means this element's render code was
            // generated by the compiler and can take the fast path.
            // in this path old node and new node are guaranteed to have the same shape
            // (i.e. at the exact same position in the source template)
            if (patchFlag & 16 /* FULL_PROPS */) {
                // element props contain dynamic keys, full diff needed
                patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);
            }
            else {
                // class
                // this flag is matched when the element has dynamic class bindings.
                if (patchFlag & 2 /* CLASS */) {
                    if (oldProps.class !== newProps.class) {
                        hostPatchProp(el, 'class', null, newProps.class, isSVG);
                    }
                }
                // style
                // this flag is matched when the element has dynamic style bindings
                if (patchFlag & 4 /* STYLE */) {
                    hostPatchProp(el, 'style', oldProps.style, newProps.style, isSVG);
                }
                // props
                // This flag is matched when the element has dynamic prop/attr bindings
                // other than class and style. The keys of dynamic prop/attrs are saved for
                // faster iteration.
                // Note dynamic keys like :[foo]="bar" will cause this optimization to
                // bail out and go through a full diff because we need to unset the old key
                if (patchFlag & 8 /* PROPS */) {
                    // if the flag is present then dynamicProps must be non-null
                    const propsToUpdate = n2.dynamicProps;
                    for (let i = 0; i < propsToUpdate.length; i++) {
                        const key = propsToUpdate[i];
                        const prev = oldProps[key];
                        const next = newProps[key];
                        // #1471 force patch value
                        if (next !== prev || key === 'value') {
                            hostPatchProp(el, key, prev, next, isSVG, n1.children, parentComponent, parentSuspense, unmountChildren);
                        }
                    }
                }
            }
            // text
            // This flag is matched when the element has only dynamic text children.
            if (patchFlag & 1 /* TEXT */) {
                if (n1.children !== n2.children) {
                    hostSetElementText(el, n2.children);
                }
            }
        }
        else if (!optimized && dynamicChildren == null) {
            // unoptimized, full diff
            patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);
        }
        if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
            queuePostRenderEffect(() => {
                vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
                dirs && invokeDirectiveHook(n2, n1, parentComponent, 'updated');
            }, parentSuspense);
        }
    };
    // The fast path for blocks.
    const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, isSVG, slotScopeIds) => {
        for (let i = 0; i < newChildren.length; i++) {
            const oldVNode = oldChildren[i];
            const newVNode = newChildren[i];
            // Determine the container (parent element) for the patch.
            const container = 
            // oldVNode may be an errored async setup() component inside Suspense
            // which will not have a mounted element
            oldVNode.el &&
                // - In the case of a Fragment, we need to provide the actual parent
                // of the Fragment itself so it can move its children.
                (oldVNode.type === Fragment ||
                    // - In the case of different nodes, there is going to be a replacement
                    // which also requires the correct parent container
                    !isSameVNodeType(oldVNode, newVNode) ||
                    // - In the case of a component, it could contain anything.
                    oldVNode.shapeFlag & (6 /* COMPONENT */ | 64 /* TELEPORT */))
                ? hostParentNode(oldVNode.el)
                : // In other cases, the parent container is not actually used so we
                    // just pass the block element here to avoid a DOM parentNode call.
                    fallbackContainer;
            patch(oldVNode, newVNode, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, true);
        }
    };
    const patchProps = (el, vnode, oldProps, newProps, parentComponent, parentSuspense, isSVG) => {
        if (oldProps !== newProps) {
            for (const key in newProps) {
                // empty string is not valid prop
                if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isReservedProp)(key))
                    continue;
                const next = newProps[key];
                const prev = oldProps[key];
                // defer patching value
                if (next !== prev && key !== 'value') {
                    hostPatchProp(el, key, prev, next, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
                }
            }
            if (oldProps !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ) {
                for (const key in oldProps) {
                    if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isReservedProp)(key) && !(key in newProps)) {
                        hostPatchProp(el, key, oldProps[key], null, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
                    }
                }
            }
            if ('value' in newProps) {
                hostPatchProp(el, 'value', oldProps.value, newProps.value);
            }
        }
    };
    const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
        const fragmentStartAnchor = (n2.el = n1 ? n1.el : hostCreateText(''));
        const fragmentEndAnchor = (n2.anchor = n1 ? n1.anchor : hostCreateText(''));
        let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
        if (( true) && isHmrUpdating) {
            // HMR updated, force full diff
            patchFlag = 0;
            optimized = false;
            dynamicChildren = null;
        }
        // check if this is a slot fragment with :slotted scope ids
        if (fragmentSlotScopeIds) {
            slotScopeIds = slotScopeIds
                ? slotScopeIds.concat(fragmentSlotScopeIds)
                : fragmentSlotScopeIds;
        }
        if (n1 == null) {
            hostInsert(fragmentStartAnchor, container, anchor);
            hostInsert(fragmentEndAnchor, container, anchor);
            // a fragment can only have array children
            // since they are either generated by the compiler, or implicitly created
            // from arrays.
            mountChildren(n2.children, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        }
        else {
            if (patchFlag > 0 &&
                patchFlag & 64 /* STABLE_FRAGMENT */ &&
                dynamicChildren &&
                // #2715 the previous fragment could've been a BAILed one as a result
                // of renderSlot() with no valid children
                n1.dynamicChildren) {
                // a stable fragment (template root or <template v-for>) doesn't need to
                // patch children order, but it may contain dynamicChildren.
                patchBlockChildren(n1.dynamicChildren, dynamicChildren, container, parentComponent, parentSuspense, isSVG, slotScopeIds);
                if (( true) && parentComponent && parentComponent.type.__hmrId) {
                    traverseStaticChildren(n1, n2);
                }
                else if (
                // #2080 if the stable fragment has a key, it's a <template v-for> that may
                //  get moved around. Make sure all root level vnodes inherit el.
                // #2134 or if it's a component root, it may also get moved around
                // as the component is being moved.
                n2.key != null ||
                    (parentComponent && n2 === parentComponent.subTree)) {
                    traverseStaticChildren(n1, n2, true /* shallow */);
                }
            }
            else {
                // keyed / unkeyed, or manual fragments.
                // for keyed & unkeyed, since they are compiler generated from v-for,
                // each child is guaranteed to be a block so the fragment will never
                // have dynamicChildren.
                patchChildren(n1, n2, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
            }
        }
    };
    const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
        n2.slotScopeIds = slotScopeIds;
        if (n1 == null) {
            if (n2.shapeFlag & 512 /* COMPONENT_KEPT_ALIVE */) {
                parentComponent.ctx.activate(n2, container, anchor, isSVG, optimized);
            }
            else {
                mountComponent(n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);
            }
        }
        else {
            updateComponent(n1, n2, optimized);
        }
    };
    const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {
        const instance = (initialVNode.component = createComponentInstance(initialVNode, parentComponent, parentSuspense));
        if (( true) && instance.type.__hmrId) {
            registerHMR(instance);
        }
        if ((true)) {
            pushWarningContext(initialVNode);
            startMeasure(instance, `mount`);
        }
        // inject renderer internals for keepAlive
        if (isKeepAlive(initialVNode)) {
            instance.ctx.renderer = internals;
        }
        // resolve props and slots for setup context
        {
            if ((true)) {
                startMeasure(instance, `init`);
            }
            setupComponent(instance);
            if ((true)) {
                endMeasure(instance, `init`);
            }
        }
        // setup() is async. This component relies on async logic to be resolved
        // before proceeding
        if (instance.asyncDep) {
            parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect);
            // Give it a placeholder if this is not hydration
            // TODO handle self-defined fallback
            if (!initialVNode.el) {
                const placeholder = (instance.subTree = createVNode(Comment));
                processCommentNode(null, placeholder, container, anchor);
            }
            return;
        }
        setupRenderEffect(instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized);
        if ((true)) {
            popWarningContext();
            endMeasure(instance, `mount`);
        }
    };
    const updateComponent = (n1, n2, optimized) => {
        const instance = (n2.component = n1.component);
        if (shouldUpdateComponent(n1, n2, optimized)) {
            if (instance.asyncDep &&
                !instance.asyncResolved) {
                // async & still pending - just update props and slots
                // since the component's reactive effect for render isn't set-up yet
                if ((true)) {
                    pushWarningContext(n2);
                }
                updateComponentPreRender(instance, n2, optimized);
                if ((true)) {
                    popWarningContext();
                }
                return;
            }
            else {
                // normal update
                instance.next = n2;
                // in case the child component is also queued, remove it to avoid
                // double updating the same child component in the same flush.
                invalidateJob(instance.update);
                // instance.update is the reactive effect.
                instance.update();
            }
        }
        else {
            // no update needed. just copy over properties
            n2.component = n1.component;
            n2.el = n1.el;
            instance.vnode = n2;
        }
    };
    const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized) => {
        const componentUpdateFn = () => {
            if (!instance.isMounted) {
                let vnodeHook;
                const { el, props } = initialVNode;
                const { bm, m, parent } = instance;
                const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
                toggleRecurse(instance, false);
                // beforeMount hook
                if (bm) {
                    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(bm);
                }
                // onVnodeBeforeMount
                if (!isAsyncWrapperVNode &&
                    (vnodeHook = props && props.onVnodeBeforeMount)) {
                    invokeVNodeHook(vnodeHook, parent, initialVNode);
                }
                toggleRecurse(instance, true);
                if (el && hydrateNode) {
                    // vnode has adopted host node - perform hydration instead of mount.
                    const hydrateSubTree = () => {
                        if ((true)) {
                            startMeasure(instance, `render`);
                        }
                        instance.subTree = renderComponentRoot(instance);
                        if ((true)) {
                            endMeasure(instance, `render`);
                        }
                        if ((true)) {
                            startMeasure(instance, `hydrate`);
                        }
                        hydrateNode(el, instance.subTree, instance, parentSuspense, null);
                        if ((true)) {
                            endMeasure(instance, `hydrate`);
                        }
                    };
                    if (isAsyncWrapperVNode) {
                        initialVNode.type.__asyncLoader().then(
                        // note: we are moving the render call into an async callback,
                        // which means it won't track dependencies - but it's ok because
                        // a server-rendered async wrapper is already in resolved state
                        // and it will never need to change.
                        () => !instance.isUnmounted && hydrateSubTree());
                    }
                    else {
                        hydrateSubTree();
                    }
                }
                else {
                    if ((true)) {
                        startMeasure(instance, `render`);
                    }
                    const subTree = (instance.subTree = renderComponentRoot(instance));
                    if ((true)) {
                        endMeasure(instance, `render`);
                    }
                    if ((true)) {
                        startMeasure(instance, `patch`);
                    }
                    patch(null, subTree, container, anchor, instance, parentSuspense, isSVG);
                    if ((true)) {
                        endMeasure(instance, `patch`);
                    }
                    initialVNode.el = subTree.el;
                }
                // mounted hook
                if (m) {
                    queuePostRenderEffect(m, parentSuspense);
                }
                // onVnodeMounted
                if (!isAsyncWrapperVNode &&
                    (vnodeHook = props && props.onVnodeMounted)) {
                    const scopedInitialVNode = initialVNode;
                    queuePostRenderEffect(() => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode), parentSuspense);
                }
                // activated hook for keep-alive roots.
                // #1742 activated hook must be accessed after first render
                // since the hook may be injected by a child keep-alive
                if (initialVNode.shapeFlag & 256 /* COMPONENT_SHOULD_KEEP_ALIVE */) {
                    instance.a && queuePostRenderEffect(instance.a, parentSuspense);
                }
                instance.isMounted = true;
                if (true) {
                    devtoolsComponentAdded(instance);
                }
                // #2458: deference mount-only object parameters to prevent memleaks
                initialVNode = container = anchor = null;
            }
            else {
                // updateComponent
                // This is triggered by mutation of component's own state (next: null)
                // OR parent calling processComponent (next: VNode)
                let { next, bu, u, parent, vnode } = instance;
                let originNext = next;
                let vnodeHook;
                if ((true)) {
                    pushWarningContext(next || instance.vnode);
                }
                // Disallow component effect recursion during pre-lifecycle hooks.
                toggleRecurse(instance, false);
                if (next) {
                    next.el = vnode.el;
                    updateComponentPreRender(instance, next, optimized);
                }
                else {
                    next = vnode;
                }
                // beforeUpdate hook
                if (bu) {
                    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(bu);
                }
                // onVnodeBeforeUpdate
                if ((vnodeHook = next.props && next.props.onVnodeBeforeUpdate)) {
                    invokeVNodeHook(vnodeHook, parent, next, vnode);
                }
                toggleRecurse(instance, true);
                // render
                if ((true)) {
                    startMeasure(instance, `render`);
                }
                const nextTree = renderComponentRoot(instance);
                if ((true)) {
                    endMeasure(instance, `render`);
                }
                const prevTree = instance.subTree;
                instance.subTree = nextTree;
                if ((true)) {
                    startMeasure(instance, `patch`);
                }
                patch(prevTree, nextTree, 
                // parent may have changed if it's in a teleport
                hostParentNode(prevTree.el), 
                // anchor may have changed if it's in a fragment
                getNextHostNode(prevTree), instance, parentSuspense, isSVG);
                if ((true)) {
                    endMeasure(instance, `patch`);
                }
                next.el = nextTree.el;
                if (originNext === null) {
                    // self-triggered update. In case of HOC, update parent component
                    // vnode el. HOC is indicated by parent instance's subTree pointing
                    // to child component's vnode
                    updateHOCHostEl(instance, nextTree.el);
                }
                // updated hook
                if (u) {
                    queuePostRenderEffect(u, parentSuspense);
                }
                // onVnodeUpdated
                if ((vnodeHook = next.props && next.props.onVnodeUpdated)) {
                    queuePostRenderEffect(() => invokeVNodeHook(vnodeHook, parent, next, vnode), parentSuspense);
                }
                if (true) {
                    devtoolsComponentUpdated(instance);
                }
                if ((true)) {
                    popWarningContext();
                }
            }
        };
        // create reactive effect for rendering
        const effect = (instance.effect = new _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ReactiveEffect(componentUpdateFn, () => queueJob(instance.update), instance.scope // track it in component's effect scope
        ));
        const update = (instance.update = effect.run.bind(effect));
        update.id = instance.uid;
        // allowRecurse
        // #1801, #2043 component render effects should allow recursive updates
        toggleRecurse(instance, true);
        if ((true)) {
            effect.onTrack = instance.rtc
                ? e => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(instance.rtc, e)
                : void 0;
            effect.onTrigger = instance.rtg
                ? e => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(instance.rtg, e)
                : void 0;
            // @ts-ignore (for scheduler)
            update.ownerInstance = instance;
        }
        update();
    };
    const updateComponentPreRender = (instance, nextVNode, optimized) => {
        nextVNode.component = instance;
        const prevProps = instance.vnode.props;
        instance.vnode = nextVNode;
        instance.next = null;
        updateProps(instance, nextVNode.props, prevProps, optimized);
        updateSlots(instance, nextVNode.children, optimized);
        (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.pauseTracking)();
        // props update may have triggered pre-flush watchers.
        // flush them before the render update.
        flushPreFlushCbs(undefined, instance.update);
        (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.resetTracking)();
    };
    const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized = false) => {
        const c1 = n1 && n1.children;
        const prevShapeFlag = n1 ? n1.shapeFlag : 0;
        const c2 = n2.children;
        const { patchFlag, shapeFlag } = n2;
        // fast path
        if (patchFlag > 0) {
            if (patchFlag & 128 /* KEYED_FRAGMENT */) {
                // this could be either fully-keyed or mixed (some keyed some not)
                // presence of patchFlag means children are guaranteed to be arrays
                patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                return;
            }
            else if (patchFlag & 256 /* UNKEYED_FRAGMENT */) {
                // unkeyed
                patchUnkeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                return;
            }
        }
        // children has 3 possibilities: text, array or no children.
        if (shapeFlag & 8 /* TEXT_CHILDREN */) {
            // text children fast path
            if (prevShapeFlag & 16 /* ARRAY_CHILDREN */) {
                unmountChildren(c1, parentComponent, parentSuspense);
            }
            if (c2 !== c1) {
                hostSetElementText(container, c2);
            }
        }
        else {
            if (prevShapeFlag & 16 /* ARRAY_CHILDREN */) {
                // prev children was array
                if (shapeFlag & 16 /* ARRAY_CHILDREN */) {
                    // two arrays, cannot assume anything, do full diff
                    patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                }
                else {
                    // no new children, just unmount old
                    unmountChildren(c1, parentComponent, parentSuspense, true);
                }
            }
            else {
                // prev children was text OR null
                // new children is array OR null
                if (prevShapeFlag & 8 /* TEXT_CHILDREN */) {
                    hostSetElementText(container, '');
                }
                // mount new if array
                if (shapeFlag & 16 /* ARRAY_CHILDREN */) {
                    mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                }
            }
        }
    };
    const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
        c1 = c1 || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARR;
        c2 = c2 || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARR;
        const oldLength = c1.length;
        const newLength = c2.length;
        const commonLength = Math.min(oldLength, newLength);
        let i;
        for (i = 0; i < commonLength; i++) {
            const nextChild = (c2[i] = optimized
                ? cloneIfMounted(c2[i])
                : normalizeVNode(c2[i]));
            patch(c1[i], nextChild, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        }
        if (oldLength > newLength) {
            // remove old
            unmountChildren(c1, parentComponent, parentSuspense, true, false, commonLength);
        }
        else {
            // mount new
            mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, commonLength);
        }
    };
    // can be all-keyed or mixed
    const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
        let i = 0;
        const l2 = c2.length;
        let e1 = c1.length - 1; // prev ending index
        let e2 = l2 - 1; // next ending index
        // 1. sync from start
        // (a b) c
        // (a b) d e
        while (i <= e1 && i <= e2) {
            const n1 = c1[i];
            const n2 = (c2[i] = optimized
                ? cloneIfMounted(c2[i])
                : normalizeVNode(c2[i]));
            if (isSameVNodeType(n1, n2)) {
                patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
            }
            else {
                break;
            }
            i++;
        }
        // 2. sync from end
        // a (b c)
        // d e (b c)
        while (i <= e1 && i <= e2) {
            const n1 = c1[e1];
            const n2 = (c2[e2] = optimized
                ? cloneIfMounted(c2[e2])
                : normalizeVNode(c2[e2]));
            if (isSameVNodeType(n1, n2)) {
                patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
            }
            else {
                break;
            }
            e1--;
            e2--;
        }
        // 3. common sequence + mount
        // (a b)
        // (a b) c
        // i = 2, e1 = 1, e2 = 2
        // (a b)
        // c (a b)
        // i = 0, e1 = -1, e2 = 0
        if (i > e1) {
            if (i <= e2) {
                const nextPos = e2 + 1;
                const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
                while (i <= e2) {
                    patch(null, (c2[i] = optimized
                        ? cloneIfMounted(c2[i])
                        : normalizeVNode(c2[i])), container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                    i++;
                }
            }
        }
        // 4. common sequence + unmount
        // (a b) c
        // (a b)
        // i = 2, e1 = 2, e2 = 1
        // a (b c)
        // (b c)
        // i = 0, e1 = 0, e2 = -1
        else if (i > e2) {
            while (i <= e1) {
                unmount(c1[i], parentComponent, parentSuspense, true);
                i++;
            }
        }
        // 5. unknown sequence
        // [i ... e1 + 1]: a b [c d e] f g
        // [i ... e2 + 1]: a b [e d c h] f g
        // i = 2, e1 = 4, e2 = 5
        else {
            const s1 = i; // prev starting index
            const s2 = i; // next starting index
            // 5.1 build key:index map for newChildren
            const keyToNewIndexMap = new Map();
            for (i = s2; i <= e2; i++) {
                const nextChild = (c2[i] = optimized
                    ? cloneIfMounted(c2[i])
                    : normalizeVNode(c2[i]));
                if (nextChild.key != null) {
                    if (( true) && keyToNewIndexMap.has(nextChild.key)) {
                        warn(`Duplicate keys found during update:`, JSON.stringify(nextChild.key), `Make sure keys are unique.`);
                    }
                    keyToNewIndexMap.set(nextChild.key, i);
                }
            }
            // 5.2 loop through old children left to be patched and try to patch
            // matching nodes & remove nodes that are no longer present
            let j;
            let patched = 0;
            const toBePatched = e2 - s2 + 1;
            let moved = false;
            // used to track whether any node has moved
            let maxNewIndexSoFar = 0;
            // works as Map<newIndex, oldIndex>
            // Note that oldIndex is offset by +1
            // and oldIndex = 0 is a special value indicating the new node has
            // no corresponding old node.
            // used for determining longest stable subsequence
            const newIndexToOldIndexMap = new Array(toBePatched);
            for (i = 0; i < toBePatched; i++)
                newIndexToOldIndexMap[i] = 0;
            for (i = s1; i <= e1; i++) {
                const prevChild = c1[i];
                if (patched >= toBePatched) {
                    // all new children have been patched so this can only be a removal
                    unmount(prevChild, parentComponent, parentSuspense, true);
                    continue;
                }
                let newIndex;
                if (prevChild.key != null) {
                    newIndex = keyToNewIndexMap.get(prevChild.key);
                }
                else {
                    // key-less node, try to locate a key-less node of the same type
                    for (j = s2; j <= e2; j++) {
                        if (newIndexToOldIndexMap[j - s2] === 0 &&
                            isSameVNodeType(prevChild, c2[j])) {
                            newIndex = j;
                            break;
                        }
                    }
                }
                if (newIndex === undefined) {
                    unmount(prevChild, parentComponent, parentSuspense, true);
                }
                else {
                    newIndexToOldIndexMap[newIndex - s2] = i + 1;
                    if (newIndex >= maxNewIndexSoFar) {
                        maxNewIndexSoFar = newIndex;
                    }
                    else {
                        moved = true;
                    }
                    patch(prevChild, c2[newIndex], container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                    patched++;
                }
            }
            // 5.3 move and mount
            // generate longest stable subsequence only when nodes have moved
            const increasingNewIndexSequence = moved
                ? getSequence(newIndexToOldIndexMap)
                : _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARR;
            j = increasingNewIndexSequence.length - 1;
            // looping backwards so that we can use last patched node as anchor
            for (i = toBePatched - 1; i >= 0; i--) {
                const nextIndex = s2 + i;
                const nextChild = c2[nextIndex];
                const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
                if (newIndexToOldIndexMap[i] === 0) {
                    // mount new
                    patch(null, nextChild, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                }
                else if (moved) {
                    // move if:
                    // There is no stable subsequence (e.g. a reverse)
                    // OR current node is not among the stable sequence
                    if (j < 0 || i !== increasingNewIndexSequence[j]) {
                        move(nextChild, container, anchor, 2 /* REORDER */);
                    }
                    else {
                        j--;
                    }
                }
            }
        }
    };
    const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
        const { el, type, transition, children, shapeFlag } = vnode;
        if (shapeFlag & 6 /* COMPONENT */) {
            move(vnode.component.subTree, container, anchor, moveType);
            return;
        }
        if (shapeFlag & 128 /* SUSPENSE */) {
            vnode.suspense.move(container, anchor, moveType);
            return;
        }
        if (shapeFlag & 64 /* TELEPORT */) {
            type.move(vnode, container, anchor, internals);
            return;
        }
        if (type === Fragment) {
            hostInsert(el, container, anchor);
            for (let i = 0; i < children.length; i++) {
                move(children[i], container, anchor, moveType);
            }
            hostInsert(vnode.anchor, container, anchor);
            return;
        }
        if (type === Static) {
            moveStaticNode(vnode, container, anchor);
            return;
        }
        // single nodes
        const needTransition = moveType !== 2 /* REORDER */ &&
            shapeFlag & 1 /* ELEMENT */ &&
            transition;
        if (needTransition) {
            if (moveType === 0 /* ENTER */) {
                transition.beforeEnter(el);
                hostInsert(el, container, anchor);
                queuePostRenderEffect(() => transition.enter(el), parentSuspense);
            }
            else {
                const { leave, delayLeave, afterLeave } = transition;
                const remove = () => hostInsert(el, container, anchor);
                const performLeave = () => {
                    leave(el, () => {
                        remove();
                        afterLeave && afterLeave();
                    });
                };
                if (delayLeave) {
                    delayLeave(el, remove, performLeave);
                }
                else {
                    performLeave();
                }
            }
        }
        else {
            hostInsert(el, container, anchor);
        }
    };
    const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
        const { type, props, ref, children, dynamicChildren, shapeFlag, patchFlag, dirs } = vnode;
        // unset ref
        if (ref != null) {
            setRef(ref, null, parentSuspense, vnode, true);
        }
        if (shapeFlag & 256 /* COMPONENT_SHOULD_KEEP_ALIVE */) {
            parentComponent.ctx.deactivate(vnode);
            return;
        }
        const shouldInvokeDirs = shapeFlag & 1 /* ELEMENT */ && dirs;
        const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
        let vnodeHook;
        if (shouldInvokeVnodeHook &&
            (vnodeHook = props && props.onVnodeBeforeUnmount)) {
            invokeVNodeHook(vnodeHook, parentComponent, vnode);
        }
        if (shapeFlag & 6 /* COMPONENT */) {
            unmountComponent(vnode.component, parentSuspense, doRemove);
        }
        else {
            if (shapeFlag & 128 /* SUSPENSE */) {
                vnode.suspense.unmount(parentSuspense, doRemove);
                return;
            }
            if (shouldInvokeDirs) {
                invokeDirectiveHook(vnode, null, parentComponent, 'beforeUnmount');
            }
            if (shapeFlag & 64 /* TELEPORT */) {
                vnode.type.remove(vnode, parentComponent, parentSuspense, optimized, internals, doRemove);
            }
            else if (dynamicChildren &&
                // #1153: fast path should not be taken for non-stable (v-for) fragments
                (type !== Fragment ||
                    (patchFlag > 0 && patchFlag & 64 /* STABLE_FRAGMENT */))) {
                // fast path for block nodes: only need to unmount dynamic children.
                unmountChildren(dynamicChildren, parentComponent, parentSuspense, false, true);
            }
            else if ((type === Fragment &&
                patchFlag &
                    (128 /* KEYED_FRAGMENT */ | 256 /* UNKEYED_FRAGMENT */)) ||
                (!optimized && shapeFlag & 16 /* ARRAY_CHILDREN */)) {
                unmountChildren(children, parentComponent, parentSuspense);
            }
            if (doRemove) {
                remove(vnode);
            }
        }
        if ((shouldInvokeVnodeHook &&
            (vnodeHook = props && props.onVnodeUnmounted)) ||
            shouldInvokeDirs) {
            queuePostRenderEffect(() => {
                vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
                shouldInvokeDirs &&
                    invokeDirectiveHook(vnode, null, parentComponent, 'unmounted');
            }, parentSuspense);
        }
    };
    const remove = vnode => {
        const { type, el, anchor, transition } = vnode;
        if (type === Fragment) {
            removeFragment(el, anchor);
            return;
        }
        if (type === Static) {
            removeStaticNode(vnode);
            return;
        }
        const performRemove = () => {
            hostRemove(el);
            if (transition && !transition.persisted && transition.afterLeave) {
                transition.afterLeave();
            }
        };
        if (vnode.shapeFlag & 1 /* ELEMENT */ &&
            transition &&
            !transition.persisted) {
            const { leave, delayLeave } = transition;
            const performLeave = () => leave(el, performRemove);
            if (delayLeave) {
                delayLeave(vnode.el, performRemove, performLeave);
            }
            else {
                performLeave();
            }
        }
        else {
            performRemove();
        }
    };
    const removeFragment = (cur, end) => {
        // For fragments, directly remove all contained DOM nodes.
        // (fragment child nodes cannot have transition)
        let next;
        while (cur !== end) {
            next = hostNextSibling(cur);
            hostRemove(cur);
            cur = next;
        }
        hostRemove(end);
    };
    const unmountComponent = (instance, parentSuspense, doRemove) => {
        if (( true) && instance.type.__hmrId) {
            unregisterHMR(instance);
        }
        const { bum, scope, update, subTree, um } = instance;
        // beforeUnmount hook
        if (bum) {
            (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(bum);
        }
        // stop effects in component scope
        scope.stop();
        // update may be null if a component is unmounted before its async
        // setup has resolved.
        if (update) {
            // so that scheduler will no longer invoke it
            update.active = false;
            unmount(subTree, instance, parentSuspense, doRemove);
        }
        // unmounted hook
        if (um) {
            queuePostRenderEffect(um, parentSuspense);
        }
        queuePostRenderEffect(() => {
            instance.isUnmounted = true;
        }, parentSuspense);
        // A component with async dep inside a pending suspense is unmounted before
        // its async dep resolves. This should remove the dep from the suspense, and
        // cause the suspense to resolve immediately if that was the last dep.
        if (parentSuspense &&
            parentSuspense.pendingBranch &&
            !parentSuspense.isUnmounted &&
            instance.asyncDep &&
            !instance.asyncResolved &&
            instance.suspenseId === parentSuspense.pendingId) {
            parentSuspense.deps--;
            if (parentSuspense.deps === 0) {
                parentSuspense.resolve();
            }
        }
        if (true) {
            devtoolsComponentRemoved(instance);
        }
    };
    const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {
        for (let i = start; i < children.length; i++) {
            unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);
        }
    };
    const getNextHostNode = vnode => {
        if (vnode.shapeFlag & 6 /* COMPONENT */) {
            return getNextHostNode(vnode.component.subTree);
        }
        if (vnode.shapeFlag & 128 /* SUSPENSE */) {
            return vnode.suspense.next();
        }
        return hostNextSibling((vnode.anchor || vnode.el));
    };
    const render = (vnode, container, isSVG) => {
        if (vnode == null) {
            if (container._vnode) {
                unmount(container._vnode, null, null, true);
            }
        }
        else {
            patch(container._vnode || null, vnode, container, null, null, null, isSVG);
        }
        flushPostFlushCbs();
        container._vnode = vnode;
    };
    const internals = {
        p: patch,
        um: unmount,
        m: move,
        r: remove,
        mt: mountComponent,
        mc: mountChildren,
        pc: patchChildren,
        pbc: patchBlockChildren,
        n: getNextHostNode,
        o: options
    };
    let hydrate;
    let hydrateNode;
    if (createHydrationFns) {
        [hydrate, hydrateNode] = createHydrationFns(internals);
    }
    return {
        render,
        hydrate,
        createApp: createAppAPI(render, hydrate)
    };
}
function toggleRecurse({ effect, update }, allowed) {
    effect.allowRecurse = update.allowRecurse = allowed;
}
/**
 * #1156
 * When a component is HMR-enabled, we need to make sure that all static nodes
 * inside a block also inherit the DOM element from the previous tree so that
 * HMR updates (which are full updates) can retrieve the element for patching.
 *
 * #2080
 * Inside keyed `template` fragment static children, if a fragment is moved,
 * the children will always be moved. Therefore, in order to ensure correct move
 * position, el should be inherited from previous nodes.
 */
function traverseStaticChildren(n1, n2, shallow = false) {
    const ch1 = n1.children;
    const ch2 = n2.children;
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(ch1) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(ch2)) {
        for (let i = 0; i < ch1.length; i++) {
            // this is only called in the optimized path so array children are
            // guaranteed to be vnodes
            const c1 = ch1[i];
            let c2 = ch2[i];
            if (c2.shapeFlag & 1 /* ELEMENT */ && !c2.dynamicChildren) {
                if (c2.patchFlag <= 0 || c2.patchFlag === 32 /* HYDRATE_EVENTS */) {
                    c2 = ch2[i] = cloneIfMounted(ch2[i]);
                    c2.el = c1.el;
                }
                if (!shallow)
                    traverseStaticChildren(c1, c2);
            }
            // also inherit for comment nodes, but not placeholders (e.g. v-if which
            // would have received .el during block patch)
            if (( true) && c2.type === Comment && !c2.el) {
                c2.el = c1.el;
            }
        }
    }
}
// https://en.wikipedia.org/wiki/Longest_increasing_subsequence
function getSequence(arr) {
    const p = arr.slice();
    const result = [0];
    let i, j, u, v, c;
    const len = arr.length;
    for (i = 0; i < len; i++) {
        const arrI = arr[i];
        if (arrI !== 0) {
            j = result[result.length - 1];
            if (arr[j] < arrI) {
                p[i] = j;
                result.push(i);
                continue;
            }
            u = 0;
            v = result.length - 1;
            while (u < v) {
                c = (u + v) >> 1;
                if (arr[result[c]] < arrI) {
                    u = c + 1;
                }
                else {
                    v = c;
                }
            }
            if (arrI < arr[result[u]]) {
                if (u > 0) {
                    p[i] = result[u - 1];
                }
                result[u] = i;
            }
        }
    }
    u = result.length;
    v = result[u - 1];
    while (u-- > 0) {
        result[u] = v;
        v = p[v];
    }
    return result;
}

const isTeleport = (type) => type.__isTeleport;
const isTeleportDisabled = (props) => props && (props.disabled || props.disabled === '');
const isTargetSVG = (target) => typeof SVGElement !== 'undefined' && target instanceof SVGElement;
const resolveTarget = (props, select) => {
    const targetSelector = props && props.to;
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(targetSelector)) {
        if (!select) {
            ( true) &&
                warn(`Current renderer does not support string target for Teleports. ` +
                    `(missing querySelector renderer option)`);
            return null;
        }
        else {
            const target = select(targetSelector);
            if (!target) {
                ( true) &&
                    warn(`Failed to locate Teleport target with selector "${targetSelector}". ` +
                        `Note the target element must exist before the component is mounted - ` +
                        `i.e. the target cannot be rendered by the component itself, and ` +
                        `ideally should be outside of the entire Vue component tree.`);
            }
            return target;
        }
    }
    else {
        if (( true) && !targetSelector && !isTeleportDisabled(props)) {
            warn(`Invalid Teleport target: ${targetSelector}`);
        }
        return targetSelector;
    }
};
const TeleportImpl = {
    __isTeleport: true,
    process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals) {
        const { mc: mountChildren, pc: patchChildren, pbc: patchBlockChildren, o: { insert, querySelector, createText, createComment } } = internals;
        const disabled = isTeleportDisabled(n2.props);
        let { shapeFlag, children, dynamicChildren } = n2;
        // #3302
        // HMR updated, force full diff
        if (( true) && isHmrUpdating) {
            optimized = false;
            dynamicChildren = null;
        }
        if (n1 == null) {
            // insert anchors in the main view
            const placeholder = (n2.el = ( true)
                ? createComment('teleport start')
                : 0);
            const mainAnchor = (n2.anchor = ( true)
                ? createComment('teleport end')
                : 0);
            insert(placeholder, container, anchor);
            insert(mainAnchor, container, anchor);
            const target = (n2.target = resolveTarget(n2.props, querySelector));
            const targetAnchor = (n2.targetAnchor = createText(''));
            if (target) {
                insert(targetAnchor, target);
                // #2652 we could be teleporting from a non-SVG tree into an SVG tree
                isSVG = isSVG || isTargetSVG(target);
            }
            else if (( true) && !disabled) {
                warn('Invalid Teleport target on mount:', target, `(${typeof target})`);
            }
            const mount = (container, anchor) => {
                // Teleport *always* has Array children. This is enforced in both the
                // compiler and vnode children normalization.
                if (shapeFlag & 16 /* ARRAY_CHILDREN */) {
                    mountChildren(children, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                }
            };
            if (disabled) {
                mount(container, mainAnchor);
            }
            else if (target) {
                mount(target, targetAnchor);
            }
        }
        else {
            // update content
            n2.el = n1.el;
            const mainAnchor = (n2.anchor = n1.anchor);
            const target = (n2.target = n1.target);
            const targetAnchor = (n2.targetAnchor = n1.targetAnchor);
            const wasDisabled = isTeleportDisabled(n1.props);
            const currentContainer = wasDisabled ? container : target;
            const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;
            isSVG = isSVG || isTargetSVG(target);
            if (dynamicChildren) {
                // fast path when the teleport happens to be a block root
                patchBlockChildren(n1.dynamicChildren, dynamicChildren, currentContainer, parentComponent, parentSuspense, isSVG, slotScopeIds);
                // even in block tree mode we need to make sure all root-level nodes
                // in the teleport inherit previous DOM references so that they can
                // be moved in future patches.
                traverseStaticChildren(n1, n2, true);
            }
            else if (!optimized) {
                patchChildren(n1, n2, currentContainer, currentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, false);
            }
            if (disabled) {
                if (!wasDisabled) {
                    // enabled -> disabled
                    // move into main container
                    moveTeleport(n2, container, mainAnchor, internals, 1 /* TOGGLE */);
                }
            }
            else {
                // target changed
                if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {
                    const nextTarget = (n2.target = resolveTarget(n2.props, querySelector));
                    if (nextTarget) {
                        moveTeleport(n2, nextTarget, null, internals, 0 /* TARGET_CHANGE */);
                    }
                    else if ((true)) {
                        warn('Invalid Teleport target on update:', target, `(${typeof target})`);
                    }
                }
                else if (wasDisabled) {
                    // disabled -> enabled
                    // move into teleport target
                    moveTeleport(n2, target, targetAnchor, internals, 1 /* TOGGLE */);
                }
            }
        }
    },
    remove(vnode, parentComponent, parentSuspense, optimized, { um: unmount, o: { remove: hostRemove } }, doRemove) {
        const { shapeFlag, children, anchor, targetAnchor, target, props } = vnode;
        if (target) {
            hostRemove(targetAnchor);
        }
        // an unmounted teleport should always remove its children if not disabled
        if (doRemove || !isTeleportDisabled(props)) {
            hostRemove(anchor);
            if (shapeFlag & 16 /* ARRAY_CHILDREN */) {
                for (let i = 0; i < children.length; i++) {
                    const child = children[i];
                    unmount(child, parentComponent, parentSuspense, true, !!child.dynamicChildren);
                }
            }
        }
    },
    move: moveTeleport,
    hydrate: hydrateTeleport
};
function moveTeleport(vnode, container, parentAnchor, { o: { insert }, m: move }, moveType = 2 /* REORDER */) {
    // move target anchor if this is a target change.
    if (moveType === 0 /* TARGET_CHANGE */) {
        insert(vnode.targetAnchor, container, parentAnchor);
    }
    const { el, anchor, shapeFlag, children, props } = vnode;
    const isReorder = moveType === 2 /* REORDER */;
    // move main view anchor if this is a re-order.
    if (isReorder) {
        insert(el, container, parentAnchor);
    }
    // if this is a re-order and teleport is enabled (content is in target)
    // do not move children. So the opposite is: only move children if this
    // is not a reorder, or the teleport is disabled
    if (!isReorder || isTeleportDisabled(props)) {
        // Teleport has either Array children or no children.
        if (shapeFlag & 16 /* ARRAY_CHILDREN */) {
            for (let i = 0; i < children.length; i++) {
                move(children[i], container, parentAnchor, 2 /* REORDER */);
            }
        }
    }
    // move main view anchor if this is a re-order.
    if (isReorder) {
        insert(anchor, container, parentAnchor);
    }
}
function hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, { o: { nextSibling, parentNode, querySelector } }, hydrateChildren) {
    const target = (vnode.target = resolveTarget(vnode.props, querySelector));
    if (target) {
        // if multiple teleports rendered to the same target element, we need to
        // pick up from where the last teleport finished instead of the first node
        const targetNode = target._lpa || target.firstChild;
        if (vnode.shapeFlag & 16 /* ARRAY_CHILDREN */) {
            if (isTeleportDisabled(vnode.props)) {
                vnode.anchor = hydrateChildren(nextSibling(node), vnode, parentNode(node), parentComponent, parentSuspense, slotScopeIds, optimized);
                vnode.targetAnchor = targetNode;
            }
            else {
                vnode.anchor = nextSibling(node);
                vnode.targetAnchor = hydrateChildren(targetNode, vnode, target, parentComponent, parentSuspense, slotScopeIds, optimized);
            }
            target._lpa =
                vnode.targetAnchor && nextSibling(vnode.targetAnchor);
        }
    }
    return vnode.anchor && nextSibling(vnode.anchor);
}
// Force-casted public typing for h and TSX props inference
const Teleport = TeleportImpl;

const COMPONENTS = 'components';
const DIRECTIVES = 'directives';
/**
 * @private
 */
function resolveComponent(name, maybeSelfReference) {
    return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;
}
const NULL_DYNAMIC_COMPONENT = Symbol();
/**
 * @private
 */
function resolveDynamicComponent(component) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(component)) {
        return resolveAsset(COMPONENTS, component, false) || component;
    }
    else {
        // invalid types will fallthrough to createVNode and raise warning
        return (component || NULL_DYNAMIC_COMPONENT);
    }
}
/**
 * @private
 */
function resolveDirective(name) {
    return resolveAsset(DIRECTIVES, name);
}
// implementation
function resolveAsset(type, name, warnMissing = true, maybeSelfReference = false) {
    const instance = currentRenderingInstance || currentInstance;
    if (instance) {
        const Component = instance.type;
        // explicit self name has highest priority
        if (type === COMPONENTS) {
            const selfName = getComponentName(Component);
            if (selfName &&
                (selfName === name ||
                    selfName === (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(name) ||
                    selfName === (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.capitalize)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(name)))) {
                return Component;
            }
        }
        const res = 
        // local registration
        // check instance[type] first which is resolved for options API
        resolve(instance[type] || Component[type], name) ||
            // global registration
            resolve(instance.appContext[type], name);
        if (!res && maybeSelfReference) {
            // fallback to implicit self-reference
            return Component;
        }
        if (( true) && warnMissing && !res) {
            const extra = type === COMPONENTS
                ? `\nIf this is a native custom element, make sure to exclude it from ` +
                    `component resolution via compilerOptions.isCustomElement.`
                : ``;
            warn(`Failed to resolve ${type.slice(0, -1)}: ${name}${extra}`);
        }
        return res;
    }
    else if ((true)) {
        warn(`resolve${(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.capitalize)(type.slice(0, -1))} ` +
            `can only be used in render() or setup().`);
    }
}
function resolve(registry, name) {
    return (registry &&
        (registry[name] ||
            registry[(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(name)] ||
            registry[(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.capitalize)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(name))]));
}

const Fragment = Symbol(( true) ? 'Fragment' : 0);
const Text = Symbol(( true) ? 'Text' : 0);
const Comment = Symbol(( true) ? 'Comment' : 0);
const Static = Symbol(( true) ? 'Static' : 0);
// Since v-if and v-for are the two possible ways node structure can dynamically
// change, once we consider v-if branches and each v-for fragment a block, we
// can divide a template into nested blocks, and within each block the node
// structure would be stable. This allows us to skip most children diffing
// and only worry about the dynamic nodes (indicated by patch flags).
const blockStack = [];
let currentBlock = null;
/**
 * Open a block.
 * This must be called before `createBlock`. It cannot be part of `createBlock`
 * because the children of the block are evaluated before `createBlock` itself
 * is called. The generated code typically looks like this:
 *
 * ```js
 * function render() {
 *   return (openBlock(),createBlock('div', null, [...]))
 * }
 * ```
 * disableTracking is true when creating a v-for fragment block, since a v-for
 * fragment always diffs its children.
 *
 * @private
 */
function openBlock(disableTracking = false) {
    blockStack.push((currentBlock = disableTracking ? null : []));
}
function closeBlock() {
    blockStack.pop();
    currentBlock = blockStack[blockStack.length - 1] || null;
}
// Whether we should be tracking dynamic child nodes inside a block.
// Only tracks when this value is > 0
// We are not using a simple boolean because this value may need to be
// incremented/decremented by nested usage of v-once (see below)
let isBlockTreeEnabled = 1;
/**
 * Block tracking sometimes needs to be disabled, for example during the
 * creation of a tree that needs to be cached by v-once. The compiler generates
 * code like this:
 *
 * ``` js
 * _cache[1] || (
 *   setBlockTracking(-1),
 *   _cache[1] = createVNode(...),
 *   setBlockTracking(1),
 *   _cache[1]
 * )
 * ```
 *
 * @private
 */
function setBlockTracking(value) {
    isBlockTreeEnabled += value;
}
function setupBlock(vnode) {
    // save current block children on the block vnode
    vnode.dynamicChildren =
        isBlockTreeEnabled > 0 ? currentBlock || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARR : null;
    // close block
    closeBlock();
    // a block is always going to be patched, so track it as a child of its
    // parent block
    if (isBlockTreeEnabled > 0 && currentBlock) {
        currentBlock.push(vnode);
    }
    return vnode;
}
/**
 * @private
 */
function createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {
    return setupBlock(createBaseVNode(type, props, children, patchFlag, dynamicProps, shapeFlag, true /* isBlock */));
}
/**
 * Create a block root vnode. Takes the same exact arguments as `createVNode`.
 * A block root keeps track of dynamic nodes within the block in the
 * `dynamicChildren` array.
 *
 * @private
 */
function createBlock(type, props, children, patchFlag, dynamicProps) {
    return setupBlock(createVNode(type, props, children, patchFlag, dynamicProps, true /* isBlock: prevent a block from tracking itself */));
}
function isVNode(value) {
    return value ? value.__v_isVNode === true : false;
}
function isSameVNodeType(n1, n2) {
    if (( true) &&
        n2.shapeFlag & 6 /* COMPONENT */ &&
        hmrDirtyComponents.has(n2.type)) {
        // HMR only: if the component has been hot-updated, force a reload.
        return false;
    }
    return n1.type === n2.type && n1.key === n2.key;
}
let vnodeArgsTransformer;
/**
 * Internal API for registering an arguments transform for createVNode
 * used for creating stubs in the test-utils
 * It is *internal* but needs to be exposed for test-utils to pick up proper
 * typings
 */
function transformVNodeArgs(transformer) {
    vnodeArgsTransformer = transformer;
}
const createVNodeWithArgsTransform = (...args) => {
    return _createVNode(...(vnodeArgsTransformer
        ? vnodeArgsTransformer(args, currentRenderingInstance)
        : args));
};
const InternalObjectKey = `__vInternal`;
const normalizeKey = ({ key }) => key != null ? key : null;
const normalizeRef = ({ ref, ref_key, ref_for }) => {
    return (ref != null
        ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(ref) || (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(ref) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(ref)
            ? { i: currentRenderingInstance, r: ref, k: ref_key, f: !!ref_for }
            : ref
        : null);
};
function createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1 /* ELEMENT */, isBlockNode = false, needFullChildrenNormalization = false) {
    const vnode = {
        __v_isVNode: true,
        __v_skip: true,
        type,
        props,
        key: props && normalizeKey(props),
        ref: props && normalizeRef(props),
        scopeId: currentScopeId,
        slotScopeIds: null,
        children,
        component: null,
        suspense: null,
        ssContent: null,
        ssFallback: null,
        dirs: null,
        transition: null,
        el: null,
        anchor: null,
        target: null,
        targetAnchor: null,
        staticCount: 0,
        shapeFlag,
        patchFlag,
        dynamicProps,
        dynamicChildren: null,
        appContext: null
    };
    if (needFullChildrenNormalization) {
        normalizeChildren(vnode, children);
        // normalize suspense children
        if (shapeFlag & 128 /* SUSPENSE */) {
            type.normalize(vnode);
        }
    }
    else if (children) {
        // compiled element vnode - if children is passed, only possible types are
        // string or Array.
        vnode.shapeFlag |= (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(children)
            ? 8 /* TEXT_CHILDREN */
            : 16 /* ARRAY_CHILDREN */;
    }
    // validate key
    if (( true) && vnode.key !== vnode.key) {
        warn(`VNode created with invalid key (NaN). VNode type:`, vnode.type);
    }
    // track vnode for block tree
    if (isBlockTreeEnabled > 0 &&
        // avoid a block node from tracking itself
        !isBlockNode &&
        // has current parent block
        currentBlock &&
        // presence of a patch flag indicates this node needs patching on updates.
        // component nodes also should always be patched, because even if the
        // component doesn't need to update, it needs to persist the instance on to
        // the next vnode so that it can be properly unmounted later.
        (vnode.patchFlag > 0 || shapeFlag & 6 /* COMPONENT */) &&
        // the EVENTS flag is only for hydration and if it is the only flag, the
        // vnode should not be considered dynamic due to handler caching.
        vnode.patchFlag !== 32 /* HYDRATE_EVENTS */) {
        currentBlock.push(vnode);
    }
    return vnode;
}
const createVNode = (( true) ? createVNodeWithArgsTransform : 0);
function _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
    if (!type || type === NULL_DYNAMIC_COMPONENT) {
        if (( true) && !type) {
            warn(`Invalid vnode type when creating vnode: ${type}.`);
        }
        type = Comment;
    }
    if (isVNode(type)) {
        // createVNode receiving an existing vnode. This happens in cases like
        // <component :is="vnode"/>
        // #2078 make sure to merge refs during the clone instead of overwriting it
        const cloned = cloneVNode(type, props, true /* mergeRef: true */);
        if (children) {
            normalizeChildren(cloned, children);
        }
        return cloned;
    }
    // class component normalization.
    if (isClassComponent(type)) {
        type = type.__vccOpts;
    }
    // class & style normalization.
    if (props) {
        // for reactive or proxy objects, we need to clone it to enable mutation.
        props = guardReactiveProps(props);
        let { class: klass, style } = props;
        if (klass && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(klass)) {
            props.class = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.normalizeClass)(klass);
        }
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(style)) {
            // reactive state objects need to be cloned since they are likely to be
            // mutated
            if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isProxy)(style) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(style)) {
                style = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, style);
            }
            props.style = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.normalizeStyle)(style);
        }
    }
    // encode the vnode type information into a bitmap
    const shapeFlag = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(type)
        ? 1 /* ELEMENT */
        : isSuspense(type)
            ? 128 /* SUSPENSE */
            : isTeleport(type)
                ? 64 /* TELEPORT */
                : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(type)
                    ? 4 /* STATEFUL_COMPONENT */
                    : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(type)
                        ? 2 /* FUNCTIONAL_COMPONENT */
                        : 0;
    if (( true) && shapeFlag & 4 /* STATEFUL_COMPONENT */ && (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isProxy)(type)) {
        type = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(type);
        warn(`Vue received a Component which was made a reactive object. This can ` +
            `lead to unnecessary performance overhead, and should be avoided by ` +
            `marking the component with \`markRaw\` or using \`shallowRef\` ` +
            `instead of \`ref\`.`, `\nComponent that was made reactive: `, type);
    }
    return createBaseVNode(type, props, children, patchFlag, dynamicProps, shapeFlag, isBlockNode, true);
}
function guardReactiveProps(props) {
    if (!props)
        return null;
    return (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isProxy)(props) || InternalObjectKey in props
        ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, props)
        : props;
}
function cloneVNode(vnode, extraProps, mergeRef = false) {
    // This is intentionally NOT using spread or extend to avoid the runtime
    // key enumeration cost.
    const { props, ref, patchFlag, children } = vnode;
    const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
    const cloned = {
        __v_isVNode: true,
        __v_skip: true,
        type: vnode.type,
        props: mergedProps,
        key: mergedProps && normalizeKey(mergedProps),
        ref: extraProps && extraProps.ref
            ? // #2078 in the case of <component :is="vnode" ref="extra"/>
                // if the vnode itself already has a ref, cloneVNode will need to merge
                // the refs so the single vnode can be set on multiple refs
                mergeRef && ref
                    ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(ref)
                        ? ref.concat(normalizeRef(extraProps))
                        : [ref, normalizeRef(extraProps)]
                    : normalizeRef(extraProps)
            : ref,
        scopeId: vnode.scopeId,
        slotScopeIds: vnode.slotScopeIds,
        children: ( true) && patchFlag === -1 /* HOISTED */ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(children)
            ? children.map(deepCloneVNode)
            : children,
        target: vnode.target,
        targetAnchor: vnode.targetAnchor,
        staticCount: vnode.staticCount,
        shapeFlag: vnode.shapeFlag,
        // if the vnode is cloned with extra props, we can no longer assume its
        // existing patch flag to be reliable and need to add the FULL_PROPS flag.
        // note: preserve flag for fragments since they use the flag for children
        // fast paths only.
        patchFlag: extraProps && vnode.type !== Fragment
            ? patchFlag === -1 // hoisted node
                ? 16 /* FULL_PROPS */
                : patchFlag | 16 /* FULL_PROPS */
            : patchFlag,
        dynamicProps: vnode.dynamicProps,
        dynamicChildren: vnode.dynamicChildren,
        appContext: vnode.appContext,
        dirs: vnode.dirs,
        transition: vnode.transition,
        // These should technically only be non-null on mounted VNodes. However,
        // they *should* be copied for kept-alive vnodes. So we just always copy
        // them since them being non-null during a mount doesn't affect the logic as
        // they will simply be overwritten.
        component: vnode.component,
        suspense: vnode.suspense,
        ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
        ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
        el: vnode.el,
        anchor: vnode.anchor
    };
    return cloned;
}
/**
 * Dev only, for HMR of hoisted vnodes reused in v-for
 * https://github.com/vitejs/vite/issues/2022
 */
function deepCloneVNode(vnode) {
    const cloned = cloneVNode(vnode);
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(vnode.children)) {
        cloned.children = vnode.children.map(deepCloneVNode);
    }
    return cloned;
}
/**
 * @private
 */
function createTextVNode(text = ' ', flag = 0) {
    return createVNode(Text, null, text, flag);
}
/**
 * @private
 */
function createStaticVNode(content, numberOfNodes) {
    // A static vnode can contain multiple stringified elements, and the number
    // of elements is necessary for hydration.
    const vnode = createVNode(Static, null, content);
    vnode.staticCount = numberOfNodes;
    return vnode;
}
/**
 * @private
 */
function createCommentVNode(text = '', 
// when used as the v-else branch, the comment node must be created as a
// block to ensure correct updates.
asBlock = false) {
    return asBlock
        ? (openBlock(), createBlock(Comment, null, text))
        : createVNode(Comment, null, text);
}
function normalizeVNode(child) {
    if (child == null || typeof child === 'boolean') {
        // empty placeholder
        return createVNode(Comment);
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(child)) {
        // fragment
        return createVNode(Fragment, null, 
        // #3666, avoid reference pollution when reusing vnode
        child.slice());
    }
    else if (typeof child === 'object') {
        // already vnode, this should be the most common since compiled templates
        // always produce all-vnode children arrays
        return cloneIfMounted(child);
    }
    else {
        // strings and numbers
        return createVNode(Text, null, String(child));
    }
}
// optimized normalization for template-compiled render fns
function cloneIfMounted(child) {
    return child.el === null || child.memo ? child : cloneVNode(child);
}
function normalizeChildren(vnode, children) {
    let type = 0;
    const { shapeFlag } = vnode;
    if (children == null) {
        children = null;
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(children)) {
        type = 16 /* ARRAY_CHILDREN */;
    }
    else if (typeof children === 'object') {
        if (shapeFlag & (1 /* ELEMENT */ | 64 /* TELEPORT */)) {
            // Normalize slot to plain children for plain element and Teleport
            const slot = children.default;
            if (slot) {
                // _c marker is added by withCtx() indicating this is a compiled slot
                slot._c && (slot._d = false);
                normalizeChildren(vnode, slot());
                slot._c && (slot._d = true);
            }
            return;
        }
        else {
            type = 32 /* SLOTS_CHILDREN */;
            const slotFlag = children._;
            if (!slotFlag && !(InternalObjectKey in children)) {
                children._ctx = currentRenderingInstance;
            }
            else if (slotFlag === 3 /* FORWARDED */ && currentRenderingInstance) {
                // a child component receives forwarded slots from the parent.
                // its slot type is determined by its parent's slot type.
                if (currentRenderingInstance.slots._ === 1 /* STABLE */) {
                    children._ = 1 /* STABLE */;
                }
                else {
                    children._ = 2 /* DYNAMIC */;
                    vnode.patchFlag |= 1024 /* DYNAMIC_SLOTS */;
                }
            }
        }
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(children)) {
        children = { default: children, _ctx: currentRenderingInstance };
        type = 32 /* SLOTS_CHILDREN */;
    }
    else {
        children = String(children);
        // force teleport children to array so it can be moved around
        if (shapeFlag & 64 /* TELEPORT */) {
            type = 16 /* ARRAY_CHILDREN */;
            children = [createTextVNode(children)];
        }
        else {
            type = 8 /* TEXT_CHILDREN */;
        }
    }
    vnode.children = children;
    vnode.shapeFlag |= type;
}
function mergeProps(...args) {
    const ret = {};
    for (let i = 0; i < args.length; i++) {
        const toMerge = args[i];
        for (const key in toMerge) {
            if (key === 'class') {
                if (ret.class !== toMerge.class) {
                    ret.class = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.normalizeClass)([ret.class, toMerge.class]);
                }
            }
            else if (key === 'style') {
                ret.style = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.normalizeStyle)([ret.style, toMerge.style]);
            }
            else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isOn)(key)) {
                const existing = ret[key];
                const incoming = toMerge[key];
                if (incoming &&
                    existing !== incoming &&
                    !((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(existing) && existing.includes(incoming))) {
                    ret[key] = existing
                        ? [].concat(existing, incoming)
                        : incoming;
                }
            }
            else if (key !== '') {
                ret[key] = toMerge[key];
            }
        }
    }
    return ret;
}
function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
    callWithAsyncErrorHandling(hook, instance, 7 /* VNODE_HOOK */, [
        vnode,
        prevVNode
    ]);
}

/**
 * Actual implementation
 */
function renderList(source, renderItem, cache, index) {
    let ret;
    const cached = (cache && cache[index]);
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(source) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(source)) {
        ret = new Array(source.length);
        for (let i = 0, l = source.length; i < l; i++) {
            ret[i] = renderItem(source[i], i, undefined, cached && cached[i]);
        }
    }
    else if (typeof source === 'number') {
        if (( true) && !Number.isInteger(source)) {
            warn(`The v-for range expect an integer value but got ${source}.`);
            return [];
        }
        ret = new Array(source);
        for (let i = 0; i < source; i++) {
            ret[i] = renderItem(i + 1, i, undefined, cached && cached[i]);
        }
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(source)) {
        if (source[Symbol.iterator]) {
            ret = Array.from(source, (item, i) => renderItem(item, i, undefined, cached && cached[i]));
        }
        else {
            const keys = Object.keys(source);
            ret = new Array(keys.length);
            for (let i = 0, l = keys.length; i < l; i++) {
                const key = keys[i];
                ret[i] = renderItem(source[key], key, i, cached && cached[i]);
            }
        }
    }
    else {
        ret = [];
    }
    if (cache) {
        cache[index] = ret;
    }
    return ret;
}

/**
 * Compiler runtime helper for creating dynamic slots object
 * @private
 */
function createSlots(slots, dynamicSlots) {
    for (let i = 0; i < dynamicSlots.length; i++) {
        const slot = dynamicSlots[i];
        // array of dynamic slot generated by <template v-for="..." #[...]>
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(slot)) {
            for (let j = 0; j < slot.length; j++) {
                slots[slot[j].name] = slot[j].fn;
            }
        }
        else if (slot) {
            // conditional single slot generated by <template v-if="..." #foo>
            slots[slot.name] = slot.fn;
        }
    }
    return slots;
}

/**
 * Compiler runtime helper for rendering `<slot/>`
 * @private
 */
function renderSlot(slots, name, props = {}, 
// this is not a user-facing function, so the fallback is always generated by
// the compiler and guaranteed to be a function returning an array
fallback, noSlotted) {
    if (currentRenderingInstance.isCE) {
        return createVNode('slot', name === 'default' ? null : { name }, fallback && fallback());
    }
    let slot = slots[name];
    if (( true) && slot && slot.length > 1) {
        warn(`SSR-optimized slot function detected in a non-SSR-optimized render ` +
            `function. You need to mark this component with $dynamic-slots in the ` +
            `parent template.`);
        slot = () => [];
    }
    // a compiled slot disables block tracking by default to avoid manual
    // invocation interfering with template-based block tracking, but in
    // `renderSlot` we can be sure that it's template-based so we can force
    // enable it.
    if (slot && slot._c) {
        slot._d = false;
    }
    openBlock();
    const validSlotContent = slot && ensureValidVNode(slot(props));
    const rendered = createBlock(Fragment, { key: props.key || `_${name}` }, validSlotContent || (fallback ? fallback() : []), validSlotContent && slots._ === 1 /* STABLE */
        ? 64 /* STABLE_FRAGMENT */
        : -2 /* BAIL */);
    if (!noSlotted && rendered.scopeId) {
        rendered.slotScopeIds = [rendered.scopeId + '-s'];
    }
    if (slot && slot._c) {
        slot._d = true;
    }
    return rendered;
}
function ensureValidVNode(vnodes) {
    return vnodes.some(child => {
        if (!isVNode(child))
            return true;
        if (child.type === Comment)
            return false;
        if (child.type === Fragment &&
            !ensureValidVNode(child.children))
            return false;
        return true;
    })
        ? vnodes
        : null;
}

/**
 * For prefixing keys in v-on="obj" with "on"
 * @private
 */
function toHandlers(obj) {
    const ret = {};
    if (( true) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(obj)) {
        warn(`v-on with no argument expects an object value.`);
        return ret;
    }
    for (const key in obj) {
        ret[(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)(key)] = obj[key];
    }
    return ret;
}

/**
 * #2437 In Vue 3, functional components do not have a public instance proxy but
 * they exist in the internal parent chain. For code that relies on traversing
 * public $parent chains, skip functional ones and go to the parent instead.
 */
const getPublicInstance = (i) => {
    if (!i)
        return null;
    if (isStatefulComponent(i))
        return getExposeProxy(i) || i.proxy;
    return getPublicInstance(i.parent);
};
const publicPropertiesMap = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(Object.create(null), {
    $: i => i,
    $el: i => i.vnode.el,
    $data: i => i.data,
    $props: i => (( true) ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly)(i.props) : 0),
    $attrs: i => (( true) ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly)(i.attrs) : 0),
    $slots: i => (( true) ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly)(i.slots) : 0),
    $refs: i => (( true) ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly)(i.refs) : 0),
    $parent: i => getPublicInstance(i.parent),
    $root: i => getPublicInstance(i.root),
    $emit: i => i.emit,
    $options: i => ( true ? resolveMergedOptions(i) : 0),
    $forceUpdate: i => () => queueJob(i.update),
    $nextTick: i => nextTick.bind(i.proxy),
    $watch: i => ( true ? instanceWatch.bind(i) : 0)
});
const PublicInstanceProxyHandlers = {
    get({ _: instance }, key) {
        const { ctx, setupState, data, props, accessCache, type, appContext } = instance;
        // for internal formatters to know that this is a Vue instance
        if (( true) && key === '__isVue') {
            return true;
        }
        // prioritize <script setup> bindings during dev.
        // this allows even properties that start with _ or $ to be used - so that
        // it aligns with the production behavior where the render fn is inlined and
        // indeed has access to all declared variables.
        if (( true) &&
            setupState !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ &&
            setupState.__isScriptSetup &&
            (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(setupState, key)) {
            return setupState[key];
        }
        // data / props / ctx
        // This getter gets called for every property access on the render context
        // during render and is a major hotspot. The most expensive part of this
        // is the multiple hasOwn() calls. It's much faster to do a simple property
        // access on a plain object, so we use an accessCache object (with null
        // prototype) to memoize what access type a key corresponds to.
        let normalizedProps;
        if (key[0] !== '$') {
            const n = accessCache[key];
            if (n !== undefined) {
                switch (n) {
                    case 1 /* SETUP */:
                        return setupState[key];
                    case 2 /* DATA */:
                        return data[key];
                    case 4 /* CONTEXT */:
                        return ctx[key];
                    case 3 /* PROPS */:
                        return props[key];
                    // default: just fallthrough
                }
            }
            else if (setupState !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(setupState, key)) {
                accessCache[key] = 1 /* SETUP */;
                return setupState[key];
            }
            else if (data !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(data, key)) {
                accessCache[key] = 2 /* DATA */;
                return data[key];
            }
            else if (
            // only cache other properties when instance has declared (thus stable)
            // props
            (normalizedProps = instance.propsOptions[0]) &&
                (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(normalizedProps, key)) {
                accessCache[key] = 3 /* PROPS */;
                return props[key];
            }
            else if (ctx !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(ctx, key)) {
                accessCache[key] = 4 /* CONTEXT */;
                return ctx[key];
            }
            else if ( false || shouldCacheAccess) {
                accessCache[key] = 0 /* OTHER */;
            }
        }
        const publicGetter = publicPropertiesMap[key];
        let cssModule, globalProperties;
        // public $xxx properties
        if (publicGetter) {
            if (key === '$attrs') {
                (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.track)(instance, "get" /* GET */, key);
                ( true) && markAttrsAccessed();
            }
            return publicGetter(instance);
        }
        else if (
        // css module (injected by vue-loader)
        (cssModule = type.__cssModules) &&
            (cssModule = cssModule[key])) {
            return cssModule;
        }
        else if (ctx !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(ctx, key)) {
            // user may set custom properties to `this` that start with `$`
            accessCache[key] = 4 /* CONTEXT */;
            return ctx[key];
        }
        else if (
        // global properties
        ((globalProperties = appContext.config.globalProperties),
            (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(globalProperties, key))) {
            {
                return globalProperties[key];
            }
        }
        else if (( true) &&
            currentRenderingInstance &&
            (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(key) ||
                // #1091 avoid internal isRef/isVNode checks on component instance leading
                // to infinite warning loop
                key.indexOf('__v') !== 0)) {
            if (data !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ &&
                (key[0] === '$' || key[0] === '_') &&
                (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(data, key)) {
                warn(`Property ${JSON.stringify(key)} must be accessed via $data because it starts with a reserved ` +
                    `character ("$" or "_") and is not proxied on the render context.`);
            }
            else if (instance === currentRenderingInstance) {
                warn(`Property ${JSON.stringify(key)} was accessed during render ` +
                    `but is not defined on instance.`);
            }
        }
    },
    set({ _: instance }, key, value) {
        const { data, setupState, ctx } = instance;
        if (setupState !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(setupState, key)) {
            setupState[key] = value;
            return true;
        }
        else if (data !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(data, key)) {
            data[key] = value;
            return true;
        }
        else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(instance.props, key)) {
            ( true) &&
                warn(`Attempting to mutate prop "${key}". Props are readonly.`, instance);
            return false;
        }
        if (key[0] === '$' && key.slice(1) in instance) {
            ( true) &&
                warn(`Attempting to mutate public property "${key}". ` +
                    `Properties starting with $ are reserved and readonly.`, instance);
            return false;
        }
        else {
            if (( true) && key in instance.appContext.config.globalProperties) {
                Object.defineProperty(ctx, key, {
                    enumerable: true,
                    configurable: true,
                    value
                });
            }
            else {
                ctx[key] = value;
            }
        }
        return true;
    },
    has({ _: { data, setupState, accessCache, ctx, appContext, propsOptions } }, key) {
        let normalizedProps;
        return (!!accessCache[key] ||
            (data !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(data, key)) ||
            (setupState !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(setupState, key)) ||
            ((normalizedProps = propsOptions[0]) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(normalizedProps, key)) ||
            (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(ctx, key) ||
            (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(publicPropertiesMap, key) ||
            (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(appContext.config.globalProperties, key));
    },
    defineProperty(target, key, descriptor) {
        if (descriptor.get != null) {
            this.set(target, key, descriptor.get(), null);
        }
        else if (descriptor.value != null) {
            this.set(target, key, descriptor.value, null);
        }
        return Reflect.defineProperty(target, key, descriptor);
    }
};
if (true) {
    PublicInstanceProxyHandlers.ownKeys = (target) => {
        warn(`Avoid app logic that relies on enumerating keys on a component instance. ` +
            `The keys will be empty in production mode to avoid performance overhead.`);
        return Reflect.ownKeys(target);
    };
}
const RuntimeCompiledPublicInstanceProxyHandlers = /*#__PURE__*/ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, PublicInstanceProxyHandlers, {
    get(target, key) {
        // fast path for unscopables when using `with` block
        if (key === Symbol.unscopables) {
            return;
        }
        return PublicInstanceProxyHandlers.get(target, key, target);
    },
    has(_, key) {
        const has = key[0] !== '_' && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isGloballyWhitelisted)(key);
        if (( true) && !has && PublicInstanceProxyHandlers.has(_, key)) {
            warn(`Property ${JSON.stringify(key)} should not start with _ which is a reserved prefix for Vue internals.`);
        }
        return has;
    }
});
// dev only
// In dev mode, the proxy target exposes the same properties as seen on `this`
// for easier console inspection. In prod mode it will be an empty object so
// these properties definitions can be skipped.
function createDevRenderContext(instance) {
    const target = {};
    // expose internal instance for proxy handlers
    Object.defineProperty(target, `_`, {
        configurable: true,
        enumerable: false,
        get: () => instance
    });
    // expose public properties
    Object.keys(publicPropertiesMap).forEach(key => {
        Object.defineProperty(target, key, {
            configurable: true,
            enumerable: false,
            get: () => publicPropertiesMap[key](instance),
            // intercepted by the proxy so no need for implementation,
            // but needed to prevent set errors
            set: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP
        });
    });
    return target;
}
// dev only
function exposePropsOnRenderContext(instance) {
    const { ctx, propsOptions: [propsOptions] } = instance;
    if (propsOptions) {
        Object.keys(propsOptions).forEach(key => {
            Object.defineProperty(ctx, key, {
                enumerable: true,
                configurable: true,
                get: () => instance.props[key],
                set: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP
            });
        });
    }
}
// dev only
function exposeSetupStateOnRenderContext(instance) {
    const { ctx, setupState } = instance;
    Object.keys((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(setupState)).forEach(key => {
        if (!setupState.__isScriptSetup) {
            if (key[0] === '$' || key[0] === '_') {
                warn(`setup() return property ${JSON.stringify(key)} should not start with "$" or "_" ` +
                    `which are reserved prefixes for Vue internals.`);
                return;
            }
            Object.defineProperty(ctx, key, {
                enumerable: true,
                configurable: true,
                get: () => setupState[key],
                set: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP
            });
        }
    });
}

const emptyAppContext = createAppContext();
let uid$1 = 0;
function createComponentInstance(vnode, parent, suspense) {
    const type = vnode.type;
    // inherit parent app context - or - if root, adopt from root vnode
    const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
    const instance = {
        uid: uid$1++,
        vnode,
        type,
        parent,
        appContext,
        root: null,
        next: null,
        subTree: null,
        effect: null,
        update: null,
        scope: new _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.EffectScope(true /* detached */),
        render: null,
        proxy: null,
        exposed: null,
        exposeProxy: null,
        withProxy: null,
        provides: parent ? parent.provides : Object.create(appContext.provides),
        accessCache: null,
        renderCache: [],
        // local resovled assets
        components: null,
        directives: null,
        // resolved props and emits options
        propsOptions: normalizePropsOptions(type, appContext),
        emitsOptions: normalizeEmitsOptions(type, appContext),
        // emit
        emit: null,
        emitted: null,
        // props default value
        propsDefaults: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
        // inheritAttrs
        inheritAttrs: type.inheritAttrs,
        // state
        ctx: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
        data: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
        props: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
        attrs: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
        slots: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
        refs: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
        setupState: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
        setupContext: null,
        // suspense related
        suspense,
        suspenseId: suspense ? suspense.pendingId : 0,
        asyncDep: null,
        asyncResolved: false,
        // lifecycle hooks
        // not using enums here because it results in computed properties
        isMounted: false,
        isUnmounted: false,
        isDeactivated: false,
        bc: null,
        c: null,
        bm: null,
        m: null,
        bu: null,
        u: null,
        um: null,
        bum: null,
        da: null,
        a: null,
        rtg: null,
        rtc: null,
        ec: null,
        sp: null
    };
    if ((true)) {
        instance.ctx = createDevRenderContext(instance);
    }
    else {}
    instance.root = parent ? parent.root : instance;
    instance.emit = emit$1.bind(null, instance);
    // apply custom element special handling
    if (vnode.ce) {
        vnode.ce(instance);
    }
    return instance;
}
let currentInstance = null;
const getCurrentInstance = () => currentInstance || currentRenderingInstance;
const setCurrentInstance = (instance) => {
    currentInstance = instance;
    instance.scope.on();
};
const unsetCurrentInstance = () => {
    currentInstance && currentInstance.scope.off();
    currentInstance = null;
};
const isBuiltInTag = /*#__PURE__*/ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.makeMap)('slot,component');
function validateComponentName(name, config) {
    const appIsNativeTag = config.isNativeTag || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NO;
    if (isBuiltInTag(name) || appIsNativeTag(name)) {
        warn('Do not use built-in or reserved HTML elements as component id: ' + name);
    }
}
function isStatefulComponent(instance) {
    return instance.vnode.shapeFlag & 4 /* STATEFUL_COMPONENT */;
}
let isInSSRComponentSetup = false;
function setupComponent(instance, isSSR = false) {
    isInSSRComponentSetup = isSSR;
    const { props, children } = instance.vnode;
    const isStateful = isStatefulComponent(instance);
    initProps(instance, props, isStateful, isSSR);
    initSlots(instance, children);
    const setupResult = isStateful
        ? setupStatefulComponent(instance, isSSR)
        : undefined;
    isInSSRComponentSetup = false;
    return setupResult;
}
function setupStatefulComponent(instance, isSSR) {
    const Component = instance.type;
    if ((true)) {
        if (Component.name) {
            validateComponentName(Component.name, instance.appContext.config);
        }
        if (Component.components) {
            const names = Object.keys(Component.components);
            for (let i = 0; i < names.length; i++) {
                validateComponentName(names[i], instance.appContext.config);
            }
        }
        if (Component.directives) {
            const names = Object.keys(Component.directives);
            for (let i = 0; i < names.length; i++) {
                validateDirectiveName(names[i]);
            }
        }
        if (Component.compilerOptions && isRuntimeOnly()) {
            warn(`"compilerOptions" is only supported when using a build of Vue that ` +
                `includes the runtime compiler. Since you are using a runtime-only ` +
                `build, the options should be passed via your build tool config instead.`);
        }
    }
    // 0. create render proxy property access cache
    instance.accessCache = Object.create(null);
    // 1. create public instance / render proxy
    // also mark it raw so it's never observed
    instance.proxy = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.markRaw)(new Proxy(instance.ctx, PublicInstanceProxyHandlers));
    if ((true)) {
        exposePropsOnRenderContext(instance);
    }
    // 2. call setup()
    const { setup } = Component;
    if (setup) {
        const setupContext = (instance.setupContext =
            setup.length > 1 ? createSetupContext(instance) : null);
        setCurrentInstance(instance);
        (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.pauseTracking)();
        const setupResult = callWithErrorHandling(setup, instance, 0 /* SETUP_FUNCTION */, [( true) ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly)(instance.props) : 0, setupContext]);
        (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.resetTracking)();
        unsetCurrentInstance();
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isPromise)(setupResult)) {
            setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
            if (isSSR) {
                // return the promise so server-renderer can wait on it
                return setupResult
                    .then((resolvedResult) => {
                    handleSetupResult(instance, resolvedResult, isSSR);
                })
                    .catch(e => {
                    handleError(e, instance, 0 /* SETUP_FUNCTION */);
                });
            }
            else {
                // async setup returned Promise.
                // bail here and wait for re-entry.
                instance.asyncDep = setupResult;
            }
        }
        else {
            handleSetupResult(instance, setupResult, isSSR);
        }
    }
    else {
        finishComponentSetup(instance, isSSR);
    }
}
function handleSetupResult(instance, setupResult, isSSR) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(setupResult)) {
        // setup returned an inline render function
        if (instance.type.__ssrInlineRender) {
            // when the function's name is `ssrRender` (compiled by SFC inline mode),
            // set it as ssrRender instead.
            instance.ssrRender = setupResult;
        }
        else {
            instance.render = setupResult;
        }
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(setupResult)) {
        if (( true) && isVNode(setupResult)) {
            warn(`setup() should not return VNodes directly - ` +
                `return a render function instead.`);
        }
        // setup returned bindings.
        // assuming a render function compiled from template is present.
        if (true) {
            instance.devtoolsRawSetupState = setupResult;
        }
        instance.setupState = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.proxyRefs)(setupResult);
        if ((true)) {
            exposeSetupStateOnRenderContext(instance);
        }
    }
    else if (( true) && setupResult !== undefined) {
        warn(`setup() should return an object. Received: ${setupResult === null ? 'null' : typeof setupResult}`);
    }
    finishComponentSetup(instance, isSSR);
}
let compile;
let installWithProxy;
/**
 * For runtime-dom to register the compiler.
 * Note the exported method uses any to avoid d.ts relying on the compiler types.
 */
function registerRuntimeCompiler(_compile) {
    compile = _compile;
    installWithProxy = i => {
        if (i.render._rc) {
            i.withProxy = new Proxy(i.ctx, RuntimeCompiledPublicInstanceProxyHandlers);
        }
    };
}
// dev only
const isRuntimeOnly = () => !compile;
function finishComponentSetup(instance, isSSR, skipOptions) {
    const Component = instance.type;
    // template / render function normalization
    // could be already set when returned from setup()
    if (!instance.render) {
        // only do on-the-fly compile if not in SSR - SSR on-the-fly compilation
        // is done by server-renderer
        if (!isSSR && compile && !Component.render) {
            const template = Component.template;
            if (template) {
                if ((true)) {
                    startMeasure(instance, `compile`);
                }
                const { isCustomElement, compilerOptions } = instance.appContext.config;
                const { delimiters, compilerOptions: componentCompilerOptions } = Component;
                const finalCompilerOptions = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({
                    isCustomElement,
                    delimiters
                }, compilerOptions), componentCompilerOptions);
                Component.render = compile(template, finalCompilerOptions);
                if ((true)) {
                    endMeasure(instance, `compile`);
                }
            }
        }
        instance.render = (Component.render || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP);
        // for runtime-compiled render functions using `with` blocks, the render
        // proxy used needs a different `has` handler which is more performant and
        // also only allows a whitelist of globals to fallthrough.
        if (installWithProxy) {
            installWithProxy(instance);
        }
    }
    // support for 2.x options
    if (true) {
        setCurrentInstance(instance);
        (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.pauseTracking)();
        applyOptions(instance);
        (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.resetTracking)();
        unsetCurrentInstance();
    }
    // warn missing template/render
    // the runtime compilation of template in SSR is done by server-render
    if (( true) && !Component.render && instance.render === _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP && !isSSR) {
        /* istanbul ignore if */
        if (!compile && Component.template) {
            warn(`Component provided template option but ` +
                `runtime compilation is not supported in this build of Vue.` +
                (` Configure your bundler to alias "vue" to "vue/dist/vue.esm-bundler.js".`
                    ) /* should not happen */);
        }
        else {
            warn(`Component is missing template or render function.`);
        }
    }
}
function createAttrsProxy(instance) {
    return new Proxy(instance.attrs, ( true)
        ? {
            get(target, key) {
                markAttrsAccessed();
                (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.track)(instance, "get" /* GET */, '$attrs');
                return target[key];
            },
            set() {
                warn(`setupContext.attrs is readonly.`);
                return false;
            },
            deleteProperty() {
                warn(`setupContext.attrs is readonly.`);
                return false;
            }
        }
        : 0);
}
function createSetupContext(instance) {
    const expose = exposed => {
        if (( true) && instance.exposed) {
            warn(`expose() should be called only once per setup().`);
        }
        instance.exposed = exposed || {};
    };
    let attrs;
    if ((true)) {
        // We use getters in dev in case libs like test-utils overwrite instance
        // properties (overwrites should not be done in prod)
        return Object.freeze({
            get attrs() {
                return attrs || (attrs = createAttrsProxy(instance));
            },
            get slots() {
                return (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly)(instance.slots);
            },
            get emit() {
                return (event, ...args) => instance.emit(event, ...args);
            },
            expose
        });
    }
    else {}
}
function getExposeProxy(instance) {
    if (instance.exposed) {
        return (instance.exposeProxy ||
            (instance.exposeProxy = new Proxy((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.proxyRefs)((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.markRaw)(instance.exposed)), {
                get(target, key) {
                    if (key in target) {
                        return target[key];
                    }
                    else if (key in publicPropertiesMap) {
                        return publicPropertiesMap[key](instance);
                    }
                }
            })));
    }
}
const classifyRE = /(?:^|[-_])(\w)/g;
const classify = (str) => str.replace(classifyRE, c => c.toUpperCase()).replace(/[-_]/g, '');
function getComponentName(Component) {
    return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(Component)
        ? Component.displayName || Component.name
        : Component.name;
}
/* istanbul ignore next */
function formatComponentName(instance, Component, isRoot = false) {
    let name = getComponentName(Component);
    if (!name && Component.__file) {
        const match = Component.__file.match(/([^/\\]+)\.\w+$/);
        if (match) {
            name = match[1];
        }
    }
    if (!name && instance && instance.parent) {
        // try to infer the name based on reverse resolution
        const inferFromRegistry = (registry) => {
            for (const key in registry) {
                if (registry[key] === Component) {
                    return key;
                }
            }
        };
        name =
            inferFromRegistry(instance.components ||
                instance.parent.type.components) || inferFromRegistry(instance.appContext.components);
    }
    return name ? classify(name) : isRoot ? `App` : `Anonymous`;
}
function isClassComponent(value) {
    return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(value) && '__vccOpts' in value;
}

const computed = ((getterOrOptions, debugOptions) => {
    // @ts-ignore
    return (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.computed)(getterOrOptions, debugOptions, isInSSRComponentSetup);
});

// dev only
const warnRuntimeUsage = (method) => warn(`${method}() is a compiler-hint helper that is only usable inside ` +
    `<script setup> of a single file component. Its arguments should be ` +
    `compiled away and passing it at runtime has no effect.`);
// implementation
function defineProps() {
    if ((true)) {
        warnRuntimeUsage(`defineProps`);
    }
    return null;
}
// implementation
function defineEmits() {
    if ((true)) {
        warnRuntimeUsage(`defineEmits`);
    }
    return null;
}
/**
 * Vue `<script setup>` compiler macro for declaring a component's exposed
 * instance properties when it is accessed by a parent component via template
 * refs.
 *
 * `<script setup>` components are closed by default - i.e. variables inside
 * the `<script setup>` scope is not exposed to parent unless explicitly exposed
 * via `defineExpose`.
 *
 * This is only usable inside `<script setup>`, is compiled away in the
 * output and should **not** be actually called at runtime.
 */
function defineExpose(exposed) {
    if ((true)) {
        warnRuntimeUsage(`defineExpose`);
    }
}
/**
 * Vue `<script setup>` compiler macro for providing props default values when
 * using type-based `defineProps` declaration.
 *
 * Example usage:
 * ```ts
 * withDefaults(defineProps<{
 *   size?: number
 *   labels?: string[]
 * }>(), {
 *   size: 3,
 *   labels: () => ['default label']
 * })
 * ```
 *
 * This is only usable inside `<script setup>`, is compiled away in the output
 * and should **not** be actually called at runtime.
 */
function withDefaults(props, defaults) {
    if ((true)) {
        warnRuntimeUsage(`withDefaults`);
    }
    return null;
}
function useSlots() {
    return getContext().slots;
}
function useAttrs() {
    return getContext().attrs;
}
function getContext() {
    const i = getCurrentInstance();
    if (( true) && !i) {
        warn(`useContext() called without active instance.`);
    }
    return i.setupContext || (i.setupContext = createSetupContext(i));
}
/**
 * Runtime helper for merging default declarations. Imported by compiled code
 * only.
 * @internal
 */
function mergeDefaults(raw, defaults) {
    const props = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(raw)
        ? raw.reduce((normalized, p) => ((normalized[p] = {}), normalized), {})
        : raw;
    for (const key in defaults) {
        const opt = props[key];
        if (opt) {
            if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(opt) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(opt)) {
                props[key] = { type: opt, default: defaults[key] };
            }
            else {
                opt.default = defaults[key];
            }
        }
        else if (opt === null) {
            props[key] = { default: defaults[key] };
        }
        else if ((true)) {
            warn(`props default key "${key}" has no corresponding declaration.`);
        }
    }
    return props;
}
/**
 * Used to create a proxy for the rest element when destructuring props with
 * defineProps().
 * @internal
 */
function createPropsRestProxy(props, excludedKeys) {
    const ret = {};
    for (const key in props) {
        if (!excludedKeys.includes(key)) {
            Object.defineProperty(ret, key, {
                enumerable: true,
                get: () => props[key]
            });
        }
    }
    return ret;
}
/**
 * `<script setup>` helper for persisting the current instance context over
 * async/await flows.
 *
 * `@vue/compiler-sfc` converts the following:
 *
 * ```ts
 * const x = await foo()
 * ```
 *
 * into:
 *
 * ```ts
 * let __temp, __restore
 * const x = (([__temp, __restore] = withAsyncContext(() => foo())),__temp=await __temp,__restore(),__temp)
 * ```
 * @internal
 */
function withAsyncContext(getAwaitable) {
    const ctx = getCurrentInstance();
    if (( true) && !ctx) {
        warn(`withAsyncContext called without active current instance. ` +
            `This is likely a bug.`);
    }
    let awaitable = getAwaitable();
    unsetCurrentInstance();
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isPromise)(awaitable)) {
        awaitable = awaitable.catch(e => {
            setCurrentInstance(ctx);
            throw e;
        });
    }
    return [awaitable, () => setCurrentInstance(ctx)];
}

// Actual implementation
function h(type, propsOrChildren, children) {
    const l = arguments.length;
    if (l === 2) {
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(propsOrChildren) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(propsOrChildren)) {
            // single vnode without props
            if (isVNode(propsOrChildren)) {
                return createVNode(type, null, [propsOrChildren]);
            }
            // props without children
            return createVNode(type, propsOrChildren);
        }
        else {
            // omit props
            return createVNode(type, null, propsOrChildren);
        }
    }
    else {
        if (l > 3) {
            children = Array.prototype.slice.call(arguments, 2);
        }
        else if (l === 3 && isVNode(children)) {
            children = [children];
        }
        return createVNode(type, propsOrChildren, children);
    }
}

const ssrContextKey = Symbol(( true) ? `ssrContext` : 0);
const useSSRContext = () => {
    {
        const ctx = inject(ssrContextKey);
        if (!ctx) {
            warn(`Server rendering context not provided. Make sure to only call ` +
                `useSSRContext() conditionally in the server build.`);
        }
        return ctx;
    }
};

function isShallow(value) {
    return !!(value && value["__v_isShallow" /* IS_SHALLOW */]);
}

function initCustomFormatter() {
    /* eslint-disable no-restricted-globals */
    if ( false || typeof window === 'undefined') {
        return;
    }
    const vueStyle = { style: 'color:#3ba776' };
    const numberStyle = { style: 'color:#0b1bc9' };
    const stringStyle = { style: 'color:#b62e24' };
    const keywordStyle = { style: 'color:#9d288c' };
    // custom formatter for Chrome
    // https://www.mattzeunert.com/2016/02/19/custom-chrome-devtools-object-formatters.html
    const formatter = {
        header(obj) {
            // TODO also format ComponentPublicInstance & ctx.slots/attrs in setup
            if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(obj)) {
                return null;
            }
            if (obj.__isVue) {
                return ['div', vueStyle, `VueInstance`];
            }
            else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(obj)) {
                return [
                    'div',
                    {},
                    ['span', vueStyle, genRefFlag(obj)],
                    '<',
                    formatValue(obj.value),
                    `>`
                ];
            }
            else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReactive)(obj)) {
                return [
                    'div',
                    {},
                    ['span', vueStyle, isShallow(obj) ? 'ShallowReactive' : 'Reactive'],
                    '<',
                    formatValue(obj),
                    `>${(0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReadonly)(obj) ? ` (readonly)` : ``}`
                ];
            }
            else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReadonly)(obj)) {
                return [
                    'div',
                    {},
                    ['span', vueStyle, isShallow(obj) ? 'ShallowReadonly' : 'Readonly'],
                    '<',
                    formatValue(obj),
                    '>'
                ];
            }
            return null;
        },
        hasBody(obj) {
            return obj && obj.__isVue;
        },
        body(obj) {
            if (obj && obj.__isVue) {
                return [
                    'div',
                    {},
                    ...formatInstance(obj.$)
                ];
            }
        }
    };
    function formatInstance(instance) {
        const blocks = [];
        if (instance.type.props && instance.props) {
            blocks.push(createInstanceBlock('props', (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(instance.props)));
        }
        if (instance.setupState !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ) {
            blocks.push(createInstanceBlock('setup', instance.setupState));
        }
        if (instance.data !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ) {
            blocks.push(createInstanceBlock('data', (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(instance.data)));
        }
        const computed = extractKeys(instance, 'computed');
        if (computed) {
            blocks.push(createInstanceBlock('computed', computed));
        }
        const injected = extractKeys(instance, 'inject');
        if (injected) {
            blocks.push(createInstanceBlock('injected', injected));
        }
        blocks.push([
            'div',
            {},
            [
                'span',
                {
                    style: keywordStyle.style + ';opacity:0.66'
                },
                '$ (internal): '
            ],
            ['object', { object: instance }]
        ]);
        return blocks;
    }
    function createInstanceBlock(type, target) {
        target = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, target);
        if (!Object.keys(target).length) {
            return ['span', {}];
        }
        return [
            'div',
            { style: 'line-height:1.25em;margin-bottom:0.6em' },
            [
                'div',
                {
                    style: 'color:#476582'
                },
                type
            ],
            [
                'div',
                {
                    style: 'padding-left:1.25em'
                },
                ...Object.keys(target).map(key => {
                    return [
                        'div',
                        {},
                        ['span', keywordStyle, key + ': '],
                        formatValue(target[key], false)
                    ];
                })
            ]
        ];
    }
    function formatValue(v, asRaw = true) {
        if (typeof v === 'number') {
            return ['span', numberStyle, v];
        }
        else if (typeof v === 'string') {
            return ['span', stringStyle, JSON.stringify(v)];
        }
        else if (typeof v === 'boolean') {
            return ['span', keywordStyle, v];
        }
        else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(v)) {
            return ['object', { object: asRaw ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(v) : v }];
        }
        else {
            return ['span', stringStyle, String(v)];
        }
    }
    function extractKeys(instance, type) {
        const Comp = instance.type;
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(Comp)) {
            return;
        }
        const extracted = {};
        for (const key in instance.ctx) {
            if (isKeyOfType(Comp, key, type)) {
                extracted[key] = instance.ctx[key];
            }
        }
        return extracted;
    }
    function isKeyOfType(Comp, key, type) {
        const opts = Comp[type];
        if (((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(opts) && opts.includes(key)) ||
            ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(opts) && key in opts)) {
            return true;
        }
        if (Comp.extends && isKeyOfType(Comp.extends, key, type)) {
            return true;
        }
        if (Comp.mixins && Comp.mixins.some(m => isKeyOfType(m, key, type))) {
            return true;
        }
    }
    function genRefFlag(v) {
        if (isShallow(v)) {
            return `ShallowRef`;
        }
        if (v.effect) {
            return `ComputedRef`;
        }
        return `Ref`;
    }
    if (window.devtoolsFormatters) {
        window.devtoolsFormatters.push(formatter);
    }
    else {
        window.devtoolsFormatters = [formatter];
    }
}

function withMemo(memo, render, cache, index) {
    const cached = cache[index];
    if (cached && isMemoSame(cached, memo)) {
        return cached;
    }
    const ret = render();
    // shallow clone
    ret.memo = memo.slice();
    return (cache[index] = ret);
}
function isMemoSame(cached, memo) {
    const prev = cached.memo;
    if (prev.length != memo.length) {
        return false;
    }
    for (let i = 0; i < prev.length; i++) {
        if (prev[i] !== memo[i]) {
            return false;
        }
    }
    // make sure to let parent block track it when returning cached
    if (isBlockTreeEnabled > 0 && currentBlock) {
        currentBlock.push(cached);
    }
    return true;
}

// Core API ------------------------------------------------------------------
const version = "3.2.31";
const _ssrUtils = {
    createComponentInstance,
    setupComponent,
    renderComponentRoot,
    setCurrentRenderingInstance,
    isVNode,
    normalizeVNode
};
/**
 * SSR utils for \@vue/server-renderer. Only exposed in cjs builds.
 * @internal
 */
const ssrUtils = (_ssrUtils );
/**
 * @internal only exposed in compat builds
 */
const resolveFilter = null;
/**
 * @internal only exposed in compat builds.
 */
const compatUtils = (null);




/***/ }),

/***/ "./node_modules/@vue/runtime-core/node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@vue/runtime-core/node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EffectScope": () => (/* binding */ EffectScope),
/* harmony export */   "ITERATE_KEY": () => (/* binding */ ITERATE_KEY),
/* harmony export */   "ReactiveEffect": () => (/* binding */ ReactiveEffect),
/* harmony export */   "computed": () => (/* binding */ computed),
/* harmony export */   "customRef": () => (/* binding */ customRef),
/* harmony export */   "deferredComputed": () => (/* binding */ deferredComputed),
/* harmony export */   "effect": () => (/* binding */ effect),
/* harmony export */   "effectScope": () => (/* binding */ effectScope),
/* harmony export */   "enableTracking": () => (/* binding */ enableTracking),
/* harmony export */   "getCurrentScope": () => (/* binding */ getCurrentScope),
/* harmony export */   "isProxy": () => (/* binding */ isProxy),
/* harmony export */   "isReactive": () => (/* binding */ isReactive),
/* harmony export */   "isReadonly": () => (/* binding */ isReadonly),
/* harmony export */   "isRef": () => (/* binding */ isRef),
/* harmony export */   "isShallow": () => (/* binding */ isShallow),
/* harmony export */   "markRaw": () => (/* binding */ markRaw),
/* harmony export */   "onScopeDispose": () => (/* binding */ onScopeDispose),
/* harmony export */   "pauseTracking": () => (/* binding */ pauseTracking),
/* harmony export */   "proxyRefs": () => (/* binding */ proxyRefs),
/* harmony export */   "reactive": () => (/* binding */ reactive),
/* harmony export */   "readonly": () => (/* binding */ readonly),
/* harmony export */   "ref": () => (/* binding */ ref),
/* harmony export */   "resetTracking": () => (/* binding */ resetTracking),
/* harmony export */   "shallowReactive": () => (/* binding */ shallowReactive),
/* harmony export */   "shallowReadonly": () => (/* binding */ shallowReadonly),
/* harmony export */   "shallowRef": () => (/* binding */ shallowRef),
/* harmony export */   "stop": () => (/* binding */ stop),
/* harmony export */   "toRaw": () => (/* binding */ toRaw),
/* harmony export */   "toRef": () => (/* binding */ toRef),
/* harmony export */   "toRefs": () => (/* binding */ toRefs),
/* harmony export */   "track": () => (/* binding */ track),
/* harmony export */   "trigger": () => (/* binding */ trigger),
/* harmony export */   "triggerRef": () => (/* binding */ triggerRef),
/* harmony export */   "unref": () => (/* binding */ unref)
/* harmony export */ });
/* harmony import */ var _vue_shared__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vue/shared */ "./node_modules/@vue/runtime-core/node_modules/@vue/shared/dist/shared.esm-bundler.js");


function warn(msg, ...args) {
    console.warn(`[Vue warn] ${msg}`, ...args);
}

let activeEffectScope;
class EffectScope {
    constructor(detached = false) {
        this.active = true;
        this.effects = [];
        this.cleanups = [];
        if (!detached && activeEffectScope) {
            this.parent = activeEffectScope;
            this.index =
                (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(this) - 1;
        }
    }
    run(fn) {
        if (this.active) {
            try {
                activeEffectScope = this;
                return fn();
            }
            finally {
                activeEffectScope = this.parent;
            }
        }
        else if ((true)) {
            warn(`cannot run an inactive effect scope.`);
        }
    }
    on() {
        activeEffectScope = this;
    }
    off() {
        activeEffectScope = this.parent;
    }
    stop(fromParent) {
        if (this.active) {
            let i, l;
            for (i = 0, l = this.effects.length; i < l; i++) {
                this.effects[i].stop();
            }
            for (i = 0, l = this.cleanups.length; i < l; i++) {
                this.cleanups[i]();
            }
            if (this.scopes) {
                for (i = 0, l = this.scopes.length; i < l; i++) {
                    this.scopes[i].stop(true);
                }
            }
            // nested scope, dereference from parent to avoid memory leaks
            if (this.parent && !fromParent) {
                // optimized O(1) removal
                const last = this.parent.scopes.pop();
                if (last && last !== this) {
                    this.parent.scopes[this.index] = last;
                    last.index = this.index;
                }
            }
            this.active = false;
        }
    }
}
function effectScope(detached) {
    return new EffectScope(detached);
}
function recordEffectScope(effect, scope = activeEffectScope) {
    if (scope && scope.active) {
        scope.effects.push(effect);
    }
}
function getCurrentScope() {
    return activeEffectScope;
}
function onScopeDispose(fn) {
    if (activeEffectScope) {
        activeEffectScope.cleanups.push(fn);
    }
    else if ((true)) {
        warn(`onScopeDispose() is called when there is no active effect scope` +
            ` to be associated with.`);
    }
}

const createDep = (effects) => {
    const dep = new Set(effects);
    dep.w = 0;
    dep.n = 0;
    return dep;
};
const wasTracked = (dep) => (dep.w & trackOpBit) > 0;
const newTracked = (dep) => (dep.n & trackOpBit) > 0;
const initDepMarkers = ({ deps }) => {
    if (deps.length) {
        for (let i = 0; i < deps.length; i++) {
            deps[i].w |= trackOpBit; // set was tracked
        }
    }
};
const finalizeDepMarkers = (effect) => {
    const { deps } = effect;
    if (deps.length) {
        let ptr = 0;
        for (let i = 0; i < deps.length; i++) {
            const dep = deps[i];
            if (wasTracked(dep) && !newTracked(dep)) {
                dep.delete(effect);
            }
            else {
                deps[ptr++] = dep;
            }
            // clear bits
            dep.w &= ~trackOpBit;
            dep.n &= ~trackOpBit;
        }
        deps.length = ptr;
    }
};

const targetMap = new WeakMap();
// The number of effects currently being tracked recursively.
let effectTrackDepth = 0;
let trackOpBit = 1;
/**
 * The bitwise track markers support at most 30 levels of recursion.
 * This value is chosen to enable modern JS engines to use a SMI on all platforms.
 * When recursion depth is greater, fall back to using a full cleanup.
 */
const maxMarkerBits = 30;
let activeEffect;
const ITERATE_KEY = Symbol(( true) ? 'iterate' : 0);
const MAP_KEY_ITERATE_KEY = Symbol(( true) ? 'Map key iterate' : 0);
class ReactiveEffect {
    constructor(fn, scheduler = null, scope) {
        this.fn = fn;
        this.scheduler = scheduler;
        this.active = true;
        this.deps = [];
        this.parent = undefined;
        recordEffectScope(this, scope);
    }
    run() {
        if (!this.active) {
            return this.fn();
        }
        let parent = activeEffect;
        let lastShouldTrack = shouldTrack;
        while (parent) {
            if (parent === this) {
                return;
            }
            parent = parent.parent;
        }
        try {
            this.parent = activeEffect;
            activeEffect = this;
            shouldTrack = true;
            trackOpBit = 1 << ++effectTrackDepth;
            if (effectTrackDepth <= maxMarkerBits) {
                initDepMarkers(this);
            }
            else {
                cleanupEffect(this);
            }
            return this.fn();
        }
        finally {
            if (effectTrackDepth <= maxMarkerBits) {
                finalizeDepMarkers(this);
            }
            trackOpBit = 1 << --effectTrackDepth;
            activeEffect = this.parent;
            shouldTrack = lastShouldTrack;
            this.parent = undefined;
        }
    }
    stop() {
        if (this.active) {
            cleanupEffect(this);
            if (this.onStop) {
                this.onStop();
            }
            this.active = false;
        }
    }
}
function cleanupEffect(effect) {
    const { deps } = effect;
    if (deps.length) {
        for (let i = 0; i < deps.length; i++) {
            deps[i].delete(effect);
        }
        deps.length = 0;
    }
}
function effect(fn, options) {
    if (fn.effect) {
        fn = fn.effect.fn;
    }
    const _effect = new ReactiveEffect(fn);
    if (options) {
        (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)(_effect, options);
        if (options.scope)
            recordEffectScope(_effect, options.scope);
    }
    if (!options || !options.lazy) {
        _effect.run();
    }
    const runner = _effect.run.bind(_effect);
    runner.effect = _effect;
    return runner;
}
function stop(runner) {
    runner.effect.stop();
}
let shouldTrack = true;
const trackStack = [];
function pauseTracking() {
    trackStack.push(shouldTrack);
    shouldTrack = false;
}
function enableTracking() {
    trackStack.push(shouldTrack);
    shouldTrack = true;
}
function resetTracking() {
    const last = trackStack.pop();
    shouldTrack = last === undefined ? true : last;
}
function track(target, type, key) {
    if (shouldTrack && activeEffect) {
        let depsMap = targetMap.get(target);
        if (!depsMap) {
            targetMap.set(target, (depsMap = new Map()));
        }
        let dep = depsMap.get(key);
        if (!dep) {
            depsMap.set(key, (dep = createDep()));
        }
        const eventInfo = ( true)
            ? { effect: activeEffect, target, type, key }
            : 0;
        trackEffects(dep, eventInfo);
    }
}
function trackEffects(dep, debuggerEventExtraInfo) {
    let shouldTrack = false;
    if (effectTrackDepth <= maxMarkerBits) {
        if (!newTracked(dep)) {
            dep.n |= trackOpBit; // set newly tracked
            shouldTrack = !wasTracked(dep);
        }
    }
    else {
        // Full cleanup mode.
        shouldTrack = !dep.has(activeEffect);
    }
    if (shouldTrack) {
        dep.add(activeEffect);
        activeEffect.deps.push(dep);
        if (( true) && activeEffect.onTrack) {
            activeEffect.onTrack(Object.assign({
                effect: activeEffect
            }, debuggerEventExtraInfo));
        }
    }
}
function trigger(target, type, key, newValue, oldValue, oldTarget) {
    const depsMap = targetMap.get(target);
    if (!depsMap) {
        // never been tracked
        return;
    }
    let deps = [];
    if (type === "clear" /* CLEAR */) {
        // collection being cleared
        // trigger all effects for target
        deps = [...depsMap.values()];
    }
    else if (key === 'length' && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target)) {
        depsMap.forEach((dep, key) => {
            if (key === 'length' || key >= newValue) {
                deps.push(dep);
            }
        });
    }
    else {
        // schedule runs for SET | ADD | DELETE
        if (key !== void 0) {
            deps.push(depsMap.get(key));
        }
        // also run for iteration key on ADD | DELETE | Map.SET
        switch (type) {
            case "add" /* ADD */:
                if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target)) {
                    deps.push(depsMap.get(ITERATE_KEY));
                    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isMap)(target)) {
                        deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
                    }
                }
                else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isIntegerKey)(key)) {
                    // new index added to array -> length changes
                    deps.push(depsMap.get('length'));
                }
                break;
            case "delete" /* DELETE */:
                if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target)) {
                    deps.push(depsMap.get(ITERATE_KEY));
                    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isMap)(target)) {
                        deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
                    }
                }
                break;
            case "set" /* SET */:
                if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isMap)(target)) {
                    deps.push(depsMap.get(ITERATE_KEY));
                }
                break;
        }
    }
    const eventInfo = ( true)
        ? { target, type, key, newValue, oldValue, oldTarget }
        : 0;
    if (deps.length === 1) {
        if (deps[0]) {
            if ((true)) {
                triggerEffects(deps[0], eventInfo);
            }
            else {}
        }
    }
    else {
        const effects = [];
        for (const dep of deps) {
            if (dep) {
                effects.push(...dep);
            }
        }
        if ((true)) {
            triggerEffects(createDep(effects), eventInfo);
        }
        else {}
    }
}
function triggerEffects(dep, debuggerEventExtraInfo) {
    // spread into array for stabilization
    for (const effect of (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(dep) ? dep : [...dep]) {
        if (effect !== activeEffect || effect.allowRecurse) {
            if (( true) && effect.onTrigger) {
                effect.onTrigger((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)({ effect }, debuggerEventExtraInfo));
            }
            if (effect.scheduler) {
                effect.scheduler();
            }
            else {
                effect.run();
            }
        }
    }
}

const isNonTrackableKeys = /*#__PURE__*/ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.makeMap)(`__proto__,__v_isRef,__isVue`);
const builtInSymbols = new Set(Object.getOwnPropertyNames(Symbol)
    .map(key => Symbol[key])
    .filter(_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isSymbol));
const get = /*#__PURE__*/ createGetter();
const shallowGet = /*#__PURE__*/ createGetter(false, true);
const readonlyGet = /*#__PURE__*/ createGetter(true);
const shallowReadonlyGet = /*#__PURE__*/ createGetter(true, true);
const arrayInstrumentations = /*#__PURE__*/ createArrayInstrumentations();
function createArrayInstrumentations() {
    const instrumentations = {};
    ['includes', 'indexOf', 'lastIndexOf'].forEach(key => {
        instrumentations[key] = function (...args) {
            const arr = toRaw(this);
            for (let i = 0, l = this.length; i < l; i++) {
                track(arr, "get" /* GET */, i + '');
            }
            // we run the method using the original args first (which may be reactive)
            const res = arr[key](...args);
            if (res === -1 || res === false) {
                // if that didn't work, run it again using raw values.
                return arr[key](...args.map(toRaw));
            }
            else {
                return res;
            }
        };
    });
    ['push', 'pop', 'shift', 'unshift', 'splice'].forEach(key => {
        instrumentations[key] = function (...args) {
            pauseTracking();
            const res = toRaw(this)[key].apply(this, args);
            resetTracking();
            return res;
        };
    });
    return instrumentations;
}
function createGetter(isReadonly = false, shallow = false) {
    return function get(target, key, receiver) {
        if (key === "__v_isReactive" /* IS_REACTIVE */) {
            return !isReadonly;
        }
        else if (key === "__v_isReadonly" /* IS_READONLY */) {
            return isReadonly;
        }
        else if (key === "__v_isShallow" /* IS_SHALLOW */) {
            return shallow;
        }
        else if (key === "__v_raw" /* RAW */ &&
            receiver ===
                (isReadonly
                    ? shallow
                        ? shallowReadonlyMap
                        : readonlyMap
                    : shallow
                        ? shallowReactiveMap
                        : reactiveMap).get(target)) {
            return target;
        }
        const targetIsArray = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target);
        if (!isReadonly && targetIsArray && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(arrayInstrumentations, key)) {
            return Reflect.get(arrayInstrumentations, key, receiver);
        }
        const res = Reflect.get(target, key, receiver);
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isSymbol)(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
            return res;
        }
        if (!isReadonly) {
            track(target, "get" /* GET */, key);
        }
        if (shallow) {
            return res;
        }
        if (isRef(res)) {
            // ref unwrapping - does not apply for Array + integer key.
            const shouldUnwrap = !targetIsArray || !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isIntegerKey)(key);
            return shouldUnwrap ? res.value : res;
        }
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(res)) {
            // Convert returned value into a proxy as well. we do the isObject check
            // here to avoid invalid value warning. Also need to lazy access readonly
            // and reactive here to avoid circular dependency.
            return isReadonly ? readonly(res) : reactive(res);
        }
        return res;
    };
}
const set = /*#__PURE__*/ createSetter();
const shallowSet = /*#__PURE__*/ createSetter(true);
function createSetter(shallow = false) {
    return function set(target, key, value, receiver) {
        let oldValue = target[key];
        if (isReadonly(oldValue) && isRef(oldValue) && !isRef(value)) {
            return false;
        }
        if (!shallow && !isReadonly(value)) {
            if (!isShallow(value)) {
                value = toRaw(value);
                oldValue = toRaw(oldValue);
            }
            if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target) && isRef(oldValue) && !isRef(value)) {
                oldValue.value = value;
                return true;
            }
        }
        const hadKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isIntegerKey)(key)
            ? Number(key) < target.length
            : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(target, key);
        const result = Reflect.set(target, key, value, receiver);
        // don't trigger if target is something up in the prototype chain of original
        if (target === toRaw(receiver)) {
            if (!hadKey) {
                trigger(target, "add" /* ADD */, key, value);
            }
            else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasChanged)(value, oldValue)) {
                trigger(target, "set" /* SET */, key, value, oldValue);
            }
        }
        return result;
    };
}
function deleteProperty(target, key) {
    const hadKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(target, key);
    const oldValue = target[key];
    const result = Reflect.deleteProperty(target, key);
    if (result && hadKey) {
        trigger(target, "delete" /* DELETE */, key, undefined, oldValue);
    }
    return result;
}
function has(target, key) {
    const result = Reflect.has(target, key);
    if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isSymbol)(key) || !builtInSymbols.has(key)) {
        track(target, "has" /* HAS */, key);
    }
    return result;
}
function ownKeys(target) {
    track(target, "iterate" /* ITERATE */, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target) ? 'length' : ITERATE_KEY);
    return Reflect.ownKeys(target);
}
const mutableHandlers = {
    get,
    set,
    deleteProperty,
    has,
    ownKeys
};
const readonlyHandlers = {
    get: readonlyGet,
    set(target, key) {
        if ((true)) {
            console.warn(`Set operation on key "${String(key)}" failed: target is readonly.`, target);
        }
        return true;
    },
    deleteProperty(target, key) {
        if ((true)) {
            console.warn(`Delete operation on key "${String(key)}" failed: target is readonly.`, target);
        }
        return true;
    }
};
const shallowReactiveHandlers = /*#__PURE__*/ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)({}, mutableHandlers, {
    get: shallowGet,
    set: shallowSet
});
// Props handlers are special in the sense that it should not unwrap top-level
// refs (in order to allow refs to be explicitly passed down), but should
// retain the reactivity of the normal readonly object.
const shallowReadonlyHandlers = /*#__PURE__*/ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)({}, readonlyHandlers, {
    get: shallowReadonlyGet
});

const toShallow = (value) => value;
const getProto = (v) => Reflect.getPrototypeOf(v);
function get$1(target, key, isReadonly = false, isShallow = false) {
    // #1772: readonly(reactive(Map)) should return readonly + reactive version
    // of the value
    target = target["__v_raw" /* RAW */];
    const rawTarget = toRaw(target);
    const rawKey = toRaw(key);
    if (key !== rawKey) {
        !isReadonly && track(rawTarget, "get" /* GET */, key);
    }
    !isReadonly && track(rawTarget, "get" /* GET */, rawKey);
    const { has } = getProto(rawTarget);
    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
    if (has.call(rawTarget, key)) {
        return wrap(target.get(key));
    }
    else if (has.call(rawTarget, rawKey)) {
        return wrap(target.get(rawKey));
    }
    else if (target !== rawTarget) {
        // #3602 readonly(reactive(Map))
        // ensure that the nested reactive `Map` can do tracking for itself
        target.get(key);
    }
}
function has$1(key, isReadonly = false) {
    const target = this["__v_raw" /* RAW */];
    const rawTarget = toRaw(target);
    const rawKey = toRaw(key);
    if (key !== rawKey) {
        !isReadonly && track(rawTarget, "has" /* HAS */, key);
    }
    !isReadonly && track(rawTarget, "has" /* HAS */, rawKey);
    return key === rawKey
        ? target.has(key)
        : target.has(key) || target.has(rawKey);
}
function size(target, isReadonly = false) {
    target = target["__v_raw" /* RAW */];
    !isReadonly && track(toRaw(target), "iterate" /* ITERATE */, ITERATE_KEY);
    return Reflect.get(target, 'size', target);
}
function add(value) {
    value = toRaw(value);
    const target = toRaw(this);
    const proto = getProto(target);
    const hadKey = proto.has.call(target, value);
    if (!hadKey) {
        target.add(value);
        trigger(target, "add" /* ADD */, value, value);
    }
    return this;
}
function set$1(key, value) {
    value = toRaw(value);
    const target = toRaw(this);
    const { has, get } = getProto(target);
    let hadKey = has.call(target, key);
    if (!hadKey) {
        key = toRaw(key);
        hadKey = has.call(target, key);
    }
    else if ((true)) {
        checkIdentityKeys(target, has, key);
    }
    const oldValue = get.call(target, key);
    target.set(key, value);
    if (!hadKey) {
        trigger(target, "add" /* ADD */, key, value);
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasChanged)(value, oldValue)) {
        trigger(target, "set" /* SET */, key, value, oldValue);
    }
    return this;
}
function deleteEntry(key) {
    const target = toRaw(this);
    const { has, get } = getProto(target);
    let hadKey = has.call(target, key);
    if (!hadKey) {
        key = toRaw(key);
        hadKey = has.call(target, key);
    }
    else if ((true)) {
        checkIdentityKeys(target, has, key);
    }
    const oldValue = get ? get.call(target, key) : undefined;
    // forward the operation before queueing reactions
    const result = target.delete(key);
    if (hadKey) {
        trigger(target, "delete" /* DELETE */, key, undefined, oldValue);
    }
    return result;
}
function clear() {
    const target = toRaw(this);
    const hadItems = target.size !== 0;
    const oldTarget = ( true)
        ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isMap)(target)
            ? new Map(target)
            : new Set(target)
        : 0;
    // forward the operation before queueing reactions
    const result = target.clear();
    if (hadItems) {
        trigger(target, "clear" /* CLEAR */, undefined, undefined, oldTarget);
    }
    return result;
}
function createForEach(isReadonly, isShallow) {
    return function forEach(callback, thisArg) {
        const observed = this;
        const target = observed["__v_raw" /* RAW */];
        const rawTarget = toRaw(target);
        const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
        !isReadonly && track(rawTarget, "iterate" /* ITERATE */, ITERATE_KEY);
        return target.forEach((value, key) => {
            // important: make sure the callback is
            // 1. invoked with the reactive map as `this` and 3rd arg
            // 2. the value received should be a corresponding reactive/readonly.
            return callback.call(thisArg, wrap(value), wrap(key), observed);
        });
    };
}
function createIterableMethod(method, isReadonly, isShallow) {
    return function (...args) {
        const target = this["__v_raw" /* RAW */];
        const rawTarget = toRaw(target);
        const targetIsMap = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isMap)(rawTarget);
        const isPair = method === 'entries' || (method === Symbol.iterator && targetIsMap);
        const isKeyOnly = method === 'keys' && targetIsMap;
        const innerIterator = target[method](...args);
        const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
        !isReadonly &&
            track(rawTarget, "iterate" /* ITERATE */, isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);
        // return a wrapped iterator which returns observed versions of the
        // values emitted from the real iterator
        return {
            // iterator protocol
            next() {
                const { value, done } = innerIterator.next();
                return done
                    ? { value, done }
                    : {
                        value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
                        done
                    };
            },
            // iterable protocol
            [Symbol.iterator]() {
                return this;
            }
        };
    };
}
function createReadonlyMethod(type) {
    return function (...args) {
        if ((true)) {
            const key = args[0] ? `on key "${args[0]}" ` : ``;
            console.warn(`${(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.capitalize)(type)} operation ${key}failed: target is readonly.`, toRaw(this));
        }
        return type === "delete" /* DELETE */ ? false : this;
    };
}
function createInstrumentations() {
    const mutableInstrumentations = {
        get(key) {
            return get$1(this, key);
        },
        get size() {
            return size(this);
        },
        has: has$1,
        add,
        set: set$1,
        delete: deleteEntry,
        clear,
        forEach: createForEach(false, false)
    };
    const shallowInstrumentations = {
        get(key) {
            return get$1(this, key, false, true);
        },
        get size() {
            return size(this);
        },
        has: has$1,
        add,
        set: set$1,
        delete: deleteEntry,
        clear,
        forEach: createForEach(false, true)
    };
    const readonlyInstrumentations = {
        get(key) {
            return get$1(this, key, true);
        },
        get size() {
            return size(this, true);
        },
        has(key) {
            return has$1.call(this, key, true);
        },
        add: createReadonlyMethod("add" /* ADD */),
        set: createReadonlyMethod("set" /* SET */),
        delete: createReadonlyMethod("delete" /* DELETE */),
        clear: createReadonlyMethod("clear" /* CLEAR */),
        forEach: createForEach(true, false)
    };
    const shallowReadonlyInstrumentations = {
        get(key) {
            return get$1(this, key, true, true);
        },
        get size() {
            return size(this, true);
        },
        has(key) {
            return has$1.call(this, key, true);
        },
        add: createReadonlyMethod("add" /* ADD */),
        set: createReadonlyMethod("set" /* SET */),
        delete: createReadonlyMethod("delete" /* DELETE */),
        clear: createReadonlyMethod("clear" /* CLEAR */),
        forEach: createForEach(true, true)
    };
    const iteratorMethods = ['keys', 'values', 'entries', Symbol.iterator];
    iteratorMethods.forEach(method => {
        mutableInstrumentations[method] = createIterableMethod(method, false, false);
        readonlyInstrumentations[method] = createIterableMethod(method, true, false);
        shallowInstrumentations[method] = createIterableMethod(method, false, true);
        shallowReadonlyInstrumentations[method] = createIterableMethod(method, true, true);
    });
    return [
        mutableInstrumentations,
        readonlyInstrumentations,
        shallowInstrumentations,
        shallowReadonlyInstrumentations
    ];
}
const [mutableInstrumentations, readonlyInstrumentations, shallowInstrumentations, shallowReadonlyInstrumentations] = /* #__PURE__*/ createInstrumentations();
function createInstrumentationGetter(isReadonly, shallow) {
    const instrumentations = shallow
        ? isReadonly
            ? shallowReadonlyInstrumentations
            : shallowInstrumentations
        : isReadonly
            ? readonlyInstrumentations
            : mutableInstrumentations;
    return (target, key, receiver) => {
        if (key === "__v_isReactive" /* IS_REACTIVE */) {
            return !isReadonly;
        }
        else if (key === "__v_isReadonly" /* IS_READONLY */) {
            return isReadonly;
        }
        else if (key === "__v_raw" /* RAW */) {
            return target;
        }
        return Reflect.get((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(instrumentations, key) && key in target
            ? instrumentations
            : target, key, receiver);
    };
}
const mutableCollectionHandlers = {
    get: /*#__PURE__*/ createInstrumentationGetter(false, false)
};
const shallowCollectionHandlers = {
    get: /*#__PURE__*/ createInstrumentationGetter(false, true)
};
const readonlyCollectionHandlers = {
    get: /*#__PURE__*/ createInstrumentationGetter(true, false)
};
const shallowReadonlyCollectionHandlers = {
    get: /*#__PURE__*/ createInstrumentationGetter(true, true)
};
function checkIdentityKeys(target, has, key) {
    const rawKey = toRaw(key);
    if (rawKey !== key && has.call(target, rawKey)) {
        const type = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.toRawType)(target);
        console.warn(`Reactive ${type} contains both the raw and reactive ` +
            `versions of the same object${type === `Map` ? ` as keys` : ``}, ` +
            `which can lead to inconsistencies. ` +
            `Avoid differentiating between the raw and reactive versions ` +
            `of an object and only use the reactive version if possible.`);
    }
}

const reactiveMap = new WeakMap();
const shallowReactiveMap = new WeakMap();
const readonlyMap = new WeakMap();
const shallowReadonlyMap = new WeakMap();
function targetTypeMap(rawType) {
    switch (rawType) {
        case 'Object':
        case 'Array':
            return 1 /* COMMON */;
        case 'Map':
        case 'Set':
        case 'WeakMap':
        case 'WeakSet':
            return 2 /* COLLECTION */;
        default:
            return 0 /* INVALID */;
    }
}
function getTargetType(value) {
    return value["__v_skip" /* SKIP */] || !Object.isExtensible(value)
        ? 0 /* INVALID */
        : targetTypeMap((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.toRawType)(value));
}
function reactive(target) {
    // if trying to observe a readonly proxy, return the readonly version.
    if (isReadonly(target)) {
        return target;
    }
    return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);
}
/**
 * Return a shallowly-reactive copy of the original object, where only the root
 * level properties are reactive. It also does not auto-unwrap refs (even at the
 * root level).
 */
function shallowReactive(target) {
    return createReactiveObject(target, false, shallowReactiveHandlers, shallowCollectionHandlers, shallowReactiveMap);
}
/**
 * Creates a readonly copy of the original object. Note the returned copy is not
 * made reactive, but `readonly` can be called on an already reactive object.
 */
function readonly(target) {
    return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);
}
/**
 * Returns a reactive-copy of the original object, where only the root level
 * properties are readonly, and does NOT unwrap refs nor recursively convert
 * returned properties.
 * This is used for creating the props proxy object for stateful components.
 */
function shallowReadonly(target) {
    return createReactiveObject(target, true, shallowReadonlyHandlers, shallowReadonlyCollectionHandlers, shallowReadonlyMap);
}
function createReactiveObject(target, isReadonly, baseHandlers, collectionHandlers, proxyMap) {
    if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(target)) {
        if ((true)) {
            console.warn(`value cannot be made reactive: ${String(target)}`);
        }
        return target;
    }
    // target is already a Proxy, return it.
    // exception: calling readonly() on a reactive object
    if (target["__v_raw" /* RAW */] &&
        !(isReadonly && target["__v_isReactive" /* IS_REACTIVE */])) {
        return target;
    }
    // target already has corresponding Proxy
    const existingProxy = proxyMap.get(target);
    if (existingProxy) {
        return existingProxy;
    }
    // only a whitelist of value types can be observed.
    const targetType = getTargetType(target);
    if (targetType === 0 /* INVALID */) {
        return target;
    }
    const proxy = new Proxy(target, targetType === 2 /* COLLECTION */ ? collectionHandlers : baseHandlers);
    proxyMap.set(target, proxy);
    return proxy;
}
function isReactive(value) {
    if (isReadonly(value)) {
        return isReactive(value["__v_raw" /* RAW */]);
    }
    return !!(value && value["__v_isReactive" /* IS_REACTIVE */]);
}
function isReadonly(value) {
    return !!(value && value["__v_isReadonly" /* IS_READONLY */]);
}
function isShallow(value) {
    return !!(value && value["__v_isShallow" /* IS_SHALLOW */]);
}
function isProxy(value) {
    return isReactive(value) || isReadonly(value);
}
function toRaw(observed) {
    const raw = observed && observed["__v_raw" /* RAW */];
    return raw ? toRaw(raw) : observed;
}
function markRaw(value) {
    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.def)(value, "__v_skip" /* SKIP */, true);
    return value;
}
const toReactive = (value) => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(value) ? reactive(value) : value;
const toReadonly = (value) => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(value) ? readonly(value) : value;

function trackRefValue(ref) {
    if (shouldTrack && activeEffect) {
        ref = toRaw(ref);
        if ((true)) {
            trackEffects(ref.dep || (ref.dep = createDep()), {
                target: ref,
                type: "get" /* GET */,
                key: 'value'
            });
        }
        else {}
    }
}
function triggerRefValue(ref, newVal) {
    ref = toRaw(ref);
    if (ref.dep) {
        if ((true)) {
            triggerEffects(ref.dep, {
                target: ref,
                type: "set" /* SET */,
                key: 'value',
                newValue: newVal
            });
        }
        else {}
    }
}
function isRef(r) {
    return !!(r && r.__v_isRef === true);
}
function ref(value) {
    return createRef(value, false);
}
function shallowRef(value) {
    return createRef(value, true);
}
function createRef(rawValue, shallow) {
    if (isRef(rawValue)) {
        return rawValue;
    }
    return new RefImpl(rawValue, shallow);
}
class RefImpl {
    constructor(value, __v_isShallow) {
        this.__v_isShallow = __v_isShallow;
        this.dep = undefined;
        this.__v_isRef = true;
        this._rawValue = __v_isShallow ? value : toRaw(value);
        this._value = __v_isShallow ? value : toReactive(value);
    }
    get value() {
        trackRefValue(this);
        return this._value;
    }
    set value(newVal) {
        newVal = this.__v_isShallow ? newVal : toRaw(newVal);
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasChanged)(newVal, this._rawValue)) {
            this._rawValue = newVal;
            this._value = this.__v_isShallow ? newVal : toReactive(newVal);
            triggerRefValue(this, newVal);
        }
    }
}
function triggerRef(ref) {
    triggerRefValue(ref, ( true) ? ref.value : 0);
}
function unref(ref) {
    return isRef(ref) ? ref.value : ref;
}
const shallowUnwrapHandlers = {
    get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),
    set: (target, key, value, receiver) => {
        const oldValue = target[key];
        if (isRef(oldValue) && !isRef(value)) {
            oldValue.value = value;
            return true;
        }
        else {
            return Reflect.set(target, key, value, receiver);
        }
    }
};
function proxyRefs(objectWithRefs) {
    return isReactive(objectWithRefs)
        ? objectWithRefs
        : new Proxy(objectWithRefs, shallowUnwrapHandlers);
}
class CustomRefImpl {
    constructor(factory) {
        this.dep = undefined;
        this.__v_isRef = true;
        const { get, set } = factory(() => trackRefValue(this), () => triggerRefValue(this));
        this._get = get;
        this._set = set;
    }
    get value() {
        return this._get();
    }
    set value(newVal) {
        this._set(newVal);
    }
}
function customRef(factory) {
    return new CustomRefImpl(factory);
}
function toRefs(object) {
    if (( true) && !isProxy(object)) {
        console.warn(`toRefs() expects a reactive object but received a plain one.`);
    }
    const ret = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(object) ? new Array(object.length) : {};
    for (const key in object) {
        ret[key] = toRef(object, key);
    }
    return ret;
}
class ObjectRefImpl {
    constructor(_object, _key, _defaultValue) {
        this._object = _object;
        this._key = _key;
        this._defaultValue = _defaultValue;
        this.__v_isRef = true;
    }
    get value() {
        const val = this._object[this._key];
        return val === undefined ? this._defaultValue : val;
    }
    set value(newVal) {
        this._object[this._key] = newVal;
    }
}
function toRef(object, key, defaultValue) {
    const val = object[key];
    return isRef(val)
        ? val
        : new ObjectRefImpl(object, key, defaultValue);
}

class ComputedRefImpl {
    constructor(getter, _setter, isReadonly, isSSR) {
        this._setter = _setter;
        this.dep = undefined;
        this.__v_isRef = true;
        this._dirty = true;
        this.effect = new ReactiveEffect(getter, () => {
            if (!this._dirty) {
                this._dirty = true;
                triggerRefValue(this);
            }
        });
        this.effect.computed = this;
        this.effect.active = this._cacheable = !isSSR;
        this["__v_isReadonly" /* IS_READONLY */] = isReadonly;
    }
    get value() {
        // the computed ref may get wrapped by other proxies e.g. readonly() #3376
        const self = toRaw(this);
        trackRefValue(self);
        if (self._dirty || !self._cacheable) {
            self._dirty = false;
            self._value = self.effect.run();
        }
        return self._value;
    }
    set value(newValue) {
        this._setter(newValue);
    }
}
function computed(getterOrOptions, debugOptions, isSSR = false) {
    let getter;
    let setter;
    const onlyGetter = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isFunction)(getterOrOptions);
    if (onlyGetter) {
        getter = getterOrOptions;
        setter = ( true)
            ? () => {
                console.warn('Write operation failed: computed value is readonly');
            }
            : 0;
    }
    else {
        getter = getterOrOptions.get;
        setter = getterOrOptions.set;
    }
    const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);
    if (( true) && debugOptions && !isSSR) {
        cRef.effect.onTrack = debugOptions.onTrack;
        cRef.effect.onTrigger = debugOptions.onTrigger;
    }
    return cRef;
}

var _a;
const tick = Promise.resolve();
const queue = [];
let queued = false;
const scheduler = (fn) => {
    queue.push(fn);
    if (!queued) {
        queued = true;
        tick.then(flush);
    }
};
const flush = () => {
    for (let i = 0; i < queue.length; i++) {
        queue[i]();
    }
    queue.length = 0;
    queued = false;
};
class DeferredComputedRefImpl {
    constructor(getter) {
        this.dep = undefined;
        this._dirty = true;
        this.__v_isRef = true;
        this[_a] = true;
        let compareTarget;
        let hasCompareTarget = false;
        let scheduled = false;
        this.effect = new ReactiveEffect(getter, (computedTrigger) => {
            if (this.dep) {
                if (computedTrigger) {
                    compareTarget = this._value;
                    hasCompareTarget = true;
                }
                else if (!scheduled) {
                    const valueToCompare = hasCompareTarget ? compareTarget : this._value;
                    scheduled = true;
                    hasCompareTarget = false;
                    scheduler(() => {
                        if (this.effect.active && this._get() !== valueToCompare) {
                            triggerRefValue(this);
                        }
                        scheduled = false;
                    });
                }
                // chained upstream computeds are notified synchronously to ensure
                // value invalidation in case of sync access; normal effects are
                // deferred to be triggered in scheduler.
                for (const e of this.dep) {
                    if (e.computed instanceof DeferredComputedRefImpl) {
                        e.scheduler(true /* computedTrigger */);
                    }
                }
            }
            this._dirty = true;
        });
        this.effect.computed = this;
    }
    _get() {
        if (this._dirty) {
            this._dirty = false;
            return (this._value = this.effect.run());
        }
        return this._value;
    }
    get value() {
        trackRefValue(this);
        // the computed ref may get wrapped by other proxies e.g. readonly() #3376
        return toRaw(this)._get();
    }
}
_a = "__v_isReadonly" /* IS_READONLY */;
function deferredComputed(getter) {
    return new DeferredComputedRefImpl(getter);
}




/***/ }),

/***/ "./node_modules/@vue/runtime-core/node_modules/@vue/shared/dist/shared.esm-bundler.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@vue/runtime-core/node_modules/@vue/shared/dist/shared.esm-bundler.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EMPTY_ARR": () => (/* binding */ EMPTY_ARR),
/* harmony export */   "EMPTY_OBJ": () => (/* binding */ EMPTY_OBJ),
/* harmony export */   "NO": () => (/* binding */ NO),
/* harmony export */   "NOOP": () => (/* binding */ NOOP),
/* harmony export */   "PatchFlagNames": () => (/* binding */ PatchFlagNames),
/* harmony export */   "camelize": () => (/* binding */ camelize),
/* harmony export */   "capitalize": () => (/* binding */ capitalize),
/* harmony export */   "def": () => (/* binding */ def),
/* harmony export */   "escapeHtml": () => (/* binding */ escapeHtml),
/* harmony export */   "escapeHtmlComment": () => (/* binding */ escapeHtmlComment),
/* harmony export */   "extend": () => (/* binding */ extend),
/* harmony export */   "generateCodeFrame": () => (/* binding */ generateCodeFrame),
/* harmony export */   "getGlobalThis": () => (/* binding */ getGlobalThis),
/* harmony export */   "hasChanged": () => (/* binding */ hasChanged),
/* harmony export */   "hasOwn": () => (/* binding */ hasOwn),
/* harmony export */   "hyphenate": () => (/* binding */ hyphenate),
/* harmony export */   "includeBooleanAttr": () => (/* binding */ includeBooleanAttr),
/* harmony export */   "invokeArrayFns": () => (/* binding */ invokeArrayFns),
/* harmony export */   "isArray": () => (/* binding */ isArray),
/* harmony export */   "isBooleanAttr": () => (/* binding */ isBooleanAttr),
/* harmony export */   "isBuiltInDirective": () => (/* binding */ isBuiltInDirective),
/* harmony export */   "isDate": () => (/* binding */ isDate),
/* harmony export */   "isFunction": () => (/* binding */ isFunction),
/* harmony export */   "isGloballyWhitelisted": () => (/* binding */ isGloballyWhitelisted),
/* harmony export */   "isHTMLTag": () => (/* binding */ isHTMLTag),
/* harmony export */   "isIntegerKey": () => (/* binding */ isIntegerKey),
/* harmony export */   "isKnownHtmlAttr": () => (/* binding */ isKnownHtmlAttr),
/* harmony export */   "isKnownSvgAttr": () => (/* binding */ isKnownSvgAttr),
/* harmony export */   "isMap": () => (/* binding */ isMap),
/* harmony export */   "isModelListener": () => (/* binding */ isModelListener),
/* harmony export */   "isNoUnitNumericStyleProp": () => (/* binding */ isNoUnitNumericStyleProp),
/* harmony export */   "isObject": () => (/* binding */ isObject),
/* harmony export */   "isOn": () => (/* binding */ isOn),
/* harmony export */   "isPlainObject": () => (/* binding */ isPlainObject),
/* harmony export */   "isPromise": () => (/* binding */ isPromise),
/* harmony export */   "isReservedProp": () => (/* binding */ isReservedProp),
/* harmony export */   "isSSRSafeAttrName": () => (/* binding */ isSSRSafeAttrName),
/* harmony export */   "isSVGTag": () => (/* binding */ isSVGTag),
/* harmony export */   "isSet": () => (/* binding */ isSet),
/* harmony export */   "isSpecialBooleanAttr": () => (/* binding */ isSpecialBooleanAttr),
/* harmony export */   "isString": () => (/* binding */ isString),
/* harmony export */   "isSymbol": () => (/* binding */ isSymbol),
/* harmony export */   "isVoidTag": () => (/* binding */ isVoidTag),
/* harmony export */   "looseEqual": () => (/* binding */ looseEqual),
/* harmony export */   "looseIndexOf": () => (/* binding */ looseIndexOf),
/* harmony export */   "makeMap": () => (/* binding */ makeMap),
/* harmony export */   "normalizeClass": () => (/* binding */ normalizeClass),
/* harmony export */   "normalizeProps": () => (/* binding */ normalizeProps),
/* harmony export */   "normalizeStyle": () => (/* binding */ normalizeStyle),
/* harmony export */   "objectToString": () => (/* binding */ objectToString),
/* harmony export */   "parseStringStyle": () => (/* binding */ parseStringStyle),
/* harmony export */   "propsToAttrMap": () => (/* binding */ propsToAttrMap),
/* harmony export */   "remove": () => (/* binding */ remove),
/* harmony export */   "slotFlagsText": () => (/* binding */ slotFlagsText),
/* harmony export */   "stringifyStyle": () => (/* binding */ stringifyStyle),
/* harmony export */   "toDisplayString": () => (/* binding */ toDisplayString),
/* harmony export */   "toHandlerKey": () => (/* binding */ toHandlerKey),
/* harmony export */   "toNumber": () => (/* binding */ toNumber),
/* harmony export */   "toRawType": () => (/* binding */ toRawType),
/* harmony export */   "toTypeString": () => (/* binding */ toTypeString)
/* harmony export */ });
/**
 * Make a map and return a function for checking if a key
 * is in that map.
 * IMPORTANT: all calls of this function must be prefixed with
 * \/\*#\_\_PURE\_\_\*\/
 * So that rollup can tree-shake them if necessary.
 */
function makeMap(str, expectsLowerCase) {
    const map = Object.create(null);
    const list = str.split(',');
    for (let i = 0; i < list.length; i++) {
        map[list[i]] = true;
    }
    return expectsLowerCase ? val => !!map[val.toLowerCase()] : val => !!map[val];
}

/**
 * dev only flag -> name mapping
 */
const PatchFlagNames = {
    [1 /* TEXT */]: `TEXT`,
    [2 /* CLASS */]: `CLASS`,
    [4 /* STYLE */]: `STYLE`,
    [8 /* PROPS */]: `PROPS`,
    [16 /* FULL_PROPS */]: `FULL_PROPS`,
    [32 /* HYDRATE_EVENTS */]: `HYDRATE_EVENTS`,
    [64 /* STABLE_FRAGMENT */]: `STABLE_FRAGMENT`,
    [128 /* KEYED_FRAGMENT */]: `KEYED_FRAGMENT`,
    [256 /* UNKEYED_FRAGMENT */]: `UNKEYED_FRAGMENT`,
    [512 /* NEED_PATCH */]: `NEED_PATCH`,
    [1024 /* DYNAMIC_SLOTS */]: `DYNAMIC_SLOTS`,
    [2048 /* DEV_ROOT_FRAGMENT */]: `DEV_ROOT_FRAGMENT`,
    [-1 /* HOISTED */]: `HOISTED`,
    [-2 /* BAIL */]: `BAIL`
};

/**
 * Dev only
 */
const slotFlagsText = {
    [1 /* STABLE */]: 'STABLE',
    [2 /* DYNAMIC */]: 'DYNAMIC',
    [3 /* FORWARDED */]: 'FORWARDED'
};

const GLOBALS_WHITE_LISTED = 'Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,' +
    'decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,' +
    'Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt';
const isGloballyWhitelisted = /*#__PURE__*/ makeMap(GLOBALS_WHITE_LISTED);

const range = 2;
function generateCodeFrame(source, start = 0, end = source.length) {
    // Split the content into individual lines but capture the newline sequence
    // that separated each line. This is important because the actual sequence is
    // needed to properly take into account the full line length for offset
    // comparison
    let lines = source.split(/(\r?\n)/);
    // Separate the lines and newline sequences into separate arrays for easier referencing
    const newlineSequences = lines.filter((_, idx) => idx % 2 === 1);
    lines = lines.filter((_, idx) => idx % 2 === 0);
    let count = 0;
    const res = [];
    for (let i = 0; i < lines.length; i++) {
        count +=
            lines[i].length +
                ((newlineSequences[i] && newlineSequences[i].length) || 0);
        if (count >= start) {
            for (let j = i - range; j <= i + range || end > count; j++) {
                if (j < 0 || j >= lines.length)
                    continue;
                const line = j + 1;
                res.push(`${line}${' '.repeat(Math.max(3 - String(line).length, 0))}|  ${lines[j]}`);
                const lineLength = lines[j].length;
                const newLineSeqLength = (newlineSequences[j] && newlineSequences[j].length) || 0;
                if (j === i) {
                    // push underline
                    const pad = start - (count - (lineLength + newLineSeqLength));
                    const length = Math.max(1, end > count ? lineLength - pad : end - start);
                    res.push(`   |  ` + ' '.repeat(pad) + '^'.repeat(length));
                }
                else if (j > i) {
                    if (end > count) {
                        const length = Math.max(Math.min(end - count, lineLength), 1);
                        res.push(`   |  ` + '^'.repeat(length));
                    }
                    count += lineLength + newLineSeqLength;
                }
            }
            break;
        }
    }
    return res.join('\n');
}

/**
 * On the client we only need to offer special cases for boolean attributes that
 * have different names from their corresponding dom properties:
 * - itemscope -> N/A
 * - allowfullscreen -> allowFullscreen
 * - formnovalidate -> formNoValidate
 * - ismap -> isMap
 * - nomodule -> noModule
 * - novalidate -> noValidate
 * - readonly -> readOnly
 */
const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
const isSpecialBooleanAttr = /*#__PURE__*/ makeMap(specialBooleanAttrs);
/**
 * The full list is needed during SSR to produce the correct initial markup.
 */
const isBooleanAttr = /*#__PURE__*/ makeMap(specialBooleanAttrs +
    `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,` +
    `loop,open,required,reversed,scoped,seamless,` +
    `checked,muted,multiple,selected`);
/**
 * Boolean attributes should be included if the value is truthy or ''.
 * e.g. `<select multiple>` compiles to `{ multiple: '' }`
 */
function includeBooleanAttr(value) {
    return !!value || value === '';
}
const unsafeAttrCharRE = /[>/="'\u0009\u000a\u000c\u0020]/;
const attrValidationCache = {};
function isSSRSafeAttrName(name) {
    if (attrValidationCache.hasOwnProperty(name)) {
        return attrValidationCache[name];
    }
    const isUnsafe = unsafeAttrCharRE.test(name);
    if (isUnsafe) {
        console.error(`unsafe attribute name: ${name}`);
    }
    return (attrValidationCache[name] = !isUnsafe);
}
const propsToAttrMap = {
    acceptCharset: 'accept-charset',
    className: 'class',
    htmlFor: 'for',
    httpEquiv: 'http-equiv'
};
/**
 * CSS properties that accept plain numbers
 */
const isNoUnitNumericStyleProp = /*#__PURE__*/ makeMap(`animation-iteration-count,border-image-outset,border-image-slice,` +
    `border-image-width,box-flex,box-flex-group,box-ordinal-group,column-count,` +
    `columns,flex,flex-grow,flex-positive,flex-shrink,flex-negative,flex-order,` +
    `grid-row,grid-row-end,grid-row-span,grid-row-start,grid-column,` +
    `grid-column-end,grid-column-span,grid-column-start,font-weight,line-clamp,` +
    `line-height,opacity,order,orphans,tab-size,widows,z-index,zoom,` +
    // SVG
    `fill-opacity,flood-opacity,stop-opacity,stroke-dasharray,stroke-dashoffset,` +
    `stroke-miterlimit,stroke-opacity,stroke-width`);
/**
 * Known attributes, this is used for stringification of runtime static nodes
 * so that we don't stringify bindings that cannot be set from HTML.
 * Don't also forget to allow `data-*` and `aria-*`!
 * Generated from https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes
 */
const isKnownHtmlAttr = /*#__PURE__*/ makeMap(`accept,accept-charset,accesskey,action,align,allow,alt,async,` +
    `autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,` +
    `border,buffered,capture,challenge,charset,checked,cite,class,code,` +
    `codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,` +
    `coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,` +
    `disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,` +
    `formaction,formenctype,formmethod,formnovalidate,formtarget,headers,` +
    `height,hidden,high,href,hreflang,http-equiv,icon,id,importance,integrity,` +
    `ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,` +
    `manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,` +
    `open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,` +
    `referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,` +
    `selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,` +
    `start,step,style,summary,tabindex,target,title,translate,type,usemap,` +
    `value,width,wrap`);
/**
 * Generated from https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute
 */
const isKnownSvgAttr = /*#__PURE__*/ makeMap(`xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,` +
    `arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,` +
    `baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,` +
    `clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,` +
    `color-interpolation-filters,color-profile,color-rendering,` +
    `contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,` +
    `descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,` +
    `dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,` +
    `fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,` +
    `font-family,font-size,font-size-adjust,font-stretch,font-style,` +
    `font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,` +
    `glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,` +
    `gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,` +
    `horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,` +
    `k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,` +
    `lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,` +
    `marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,` +
    `mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,` +
    `name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,` +
    `overflow,overline-position,overline-thickness,panose-1,paint-order,path,` +
    `pathLength,patternContentUnits,patternTransform,patternUnits,ping,` +
    `pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,` +
    `preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,` +
    `rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,` +
    `restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,` +
    `specularConstant,specularExponent,speed,spreadMethod,startOffset,` +
    `stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,` +
    `strikethrough-position,strikethrough-thickness,string,stroke,` +
    `stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,` +
    `stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,` +
    `systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,` +
    `text-decoration,text-rendering,textLength,to,transform,transform-origin,` +
    `type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,` +
    `unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,` +
    `v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,` +
    `vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,` +
    `writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,` +
    `xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xml:base,xml:lang,` +
    `xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan`);

function normalizeStyle(value) {
    if (isArray(value)) {
        const res = {};
        for (let i = 0; i < value.length; i++) {
            const item = value[i];
            const normalized = isString(item)
                ? parseStringStyle(item)
                : normalizeStyle(item);
            if (normalized) {
                for (const key in normalized) {
                    res[key] = normalized[key];
                }
            }
        }
        return res;
    }
    else if (isString(value)) {
        return value;
    }
    else if (isObject(value)) {
        return value;
    }
}
const listDelimiterRE = /;(?![^(]*\))/g;
const propertyDelimiterRE = /:(.+)/;
function parseStringStyle(cssText) {
    const ret = {};
    cssText.split(listDelimiterRE).forEach(item => {
        if (item) {
            const tmp = item.split(propertyDelimiterRE);
            tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
        }
    });
    return ret;
}
function stringifyStyle(styles) {
    let ret = '';
    if (!styles || isString(styles)) {
        return ret;
    }
    for (const key in styles) {
        const value = styles[key];
        const normalizedKey = key.startsWith(`--`) ? key : hyphenate(key);
        if (isString(value) ||
            (typeof value === 'number' && isNoUnitNumericStyleProp(normalizedKey))) {
            // only render valid values
            ret += `${normalizedKey}:${value};`;
        }
    }
    return ret;
}
function normalizeClass(value) {
    let res = '';
    if (isString(value)) {
        res = value;
    }
    else if (isArray(value)) {
        for (let i = 0; i < value.length; i++) {
            const normalized = normalizeClass(value[i]);
            if (normalized) {
                res += normalized + ' ';
            }
        }
    }
    else if (isObject(value)) {
        for (const name in value) {
            if (value[name]) {
                res += name + ' ';
            }
        }
    }
    return res.trim();
}
function normalizeProps(props) {
    if (!props)
        return null;
    let { class: klass, style } = props;
    if (klass && !isString(klass)) {
        props.class = normalizeClass(klass);
    }
    if (style) {
        props.style = normalizeStyle(style);
    }
    return props;
}

// These tag configs are shared between compiler-dom and runtime-dom, so they
// https://developer.mozilla.org/en-US/docs/Web/HTML/Element
const HTML_TAGS = 'html,body,base,head,link,meta,style,title,address,article,aside,footer,' +
    'header,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,' +
    'figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,' +
    'data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,' +
    'time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,' +
    'canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,' +
    'th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,' +
    'option,output,progress,select,textarea,details,dialog,menu,' +
    'summary,template,blockquote,iframe,tfoot';
// https://developer.mozilla.org/en-US/docs/Web/SVG/Element
const SVG_TAGS = 'svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,' +
    'defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,' +
    'feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,' +
    'feDistanceLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,' +
    'feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,' +
    'fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,' +
    'foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,' +
    'mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,' +
    'polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,' +
    'text,textPath,title,tspan,unknown,use,view';
const VOID_TAGS = 'area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr';
/**
 * Compiler only.
 * Do NOT use in runtime code paths unless behind `(process.env.NODE_ENV !== 'production')` flag.
 */
const isHTMLTag = /*#__PURE__*/ makeMap(HTML_TAGS);
/**
 * Compiler only.
 * Do NOT use in runtime code paths unless behind `(process.env.NODE_ENV !== 'production')` flag.
 */
const isSVGTag = /*#__PURE__*/ makeMap(SVG_TAGS);
/**
 * Compiler only.
 * Do NOT use in runtime code paths unless behind `(process.env.NODE_ENV !== 'production')` flag.
 */
const isVoidTag = /*#__PURE__*/ makeMap(VOID_TAGS);

const escapeRE = /["'&<>]/;
function escapeHtml(string) {
    const str = '' + string;
    const match = escapeRE.exec(str);
    if (!match) {
        return str;
    }
    let html = '';
    let escaped;
    let index;
    let lastIndex = 0;
    for (index = match.index; index < str.length; index++) {
        switch (str.charCodeAt(index)) {
            case 34: // "
                escaped = '&quot;';
                break;
            case 38: // &
                escaped = '&amp;';
                break;
            case 39: // '
                escaped = '&#39;';
                break;
            case 60: // <
                escaped = '&lt;';
                break;
            case 62: // >
                escaped = '&gt;';
                break;
            default:
                continue;
        }
        if (lastIndex !== index) {
            html += str.slice(lastIndex, index);
        }
        lastIndex = index + 1;
        html += escaped;
    }
    return lastIndex !== index ? html + str.slice(lastIndex, index) : html;
}
// https://www.w3.org/TR/html52/syntax.html#comments
const commentStripRE = /^-?>|<!--|-->|--!>|<!-$/g;
function escapeHtmlComment(src) {
    return src.replace(commentStripRE, '');
}

function looseCompareArrays(a, b) {
    if (a.length !== b.length)
        return false;
    let equal = true;
    for (let i = 0; equal && i < a.length; i++) {
        equal = looseEqual(a[i], b[i]);
    }
    return equal;
}
function looseEqual(a, b) {
    if (a === b)
        return true;
    let aValidType = isDate(a);
    let bValidType = isDate(b);
    if (aValidType || bValidType) {
        return aValidType && bValidType ? a.getTime() === b.getTime() : false;
    }
    aValidType = isArray(a);
    bValidType = isArray(b);
    if (aValidType || bValidType) {
        return aValidType && bValidType ? looseCompareArrays(a, b) : false;
    }
    aValidType = isObject(a);
    bValidType = isObject(b);
    if (aValidType || bValidType) {
        /* istanbul ignore if: this if will probably never be called */
        if (!aValidType || !bValidType) {
            return false;
        }
        const aKeysCount = Object.keys(a).length;
        const bKeysCount = Object.keys(b).length;
        if (aKeysCount !== bKeysCount) {
            return false;
        }
        for (const key in a) {
            const aHasKey = a.hasOwnProperty(key);
            const bHasKey = b.hasOwnProperty(key);
            if ((aHasKey && !bHasKey) ||
                (!aHasKey && bHasKey) ||
                !looseEqual(a[key], b[key])) {
                return false;
            }
        }
    }
    return String(a) === String(b);
}
function looseIndexOf(arr, val) {
    return arr.findIndex(item => looseEqual(item, val));
}

/**
 * For converting {{ interpolation }} values to displayed strings.
 * @private
 */
const toDisplayString = (val) => {
    return isString(val)
        ? val
        : val == null
            ? ''
            : isArray(val) ||
                (isObject(val) &&
                    (val.toString === objectToString || !isFunction(val.toString)))
                ? JSON.stringify(val, replacer, 2)
                : String(val);
};
const replacer = (_key, val) => {
    // can't use isRef here since @vue/shared has no deps
    if (val && val.__v_isRef) {
        return replacer(_key, val.value);
    }
    else if (isMap(val)) {
        return {
            [`Map(${val.size})`]: [...val.entries()].reduce((entries, [key, val]) => {
                entries[`${key} =>`] = val;
                return entries;
            }, {})
        };
    }
    else if (isSet(val)) {
        return {
            [`Set(${val.size})`]: [...val.values()]
        };
    }
    else if (isObject(val) && !isArray(val) && !isPlainObject(val)) {
        return String(val);
    }
    return val;
};

const EMPTY_OBJ = ( true)
    ? Object.freeze({})
    : 0;
const EMPTY_ARR = ( true) ? Object.freeze([]) : 0;
const NOOP = () => { };
/**
 * Always return false.
 */
const NO = () => false;
const onRE = /^on[^a-z]/;
const isOn = (key) => onRE.test(key);
const isModelListener = (key) => key.startsWith('onUpdate:');
const extend = Object.assign;
const remove = (arr, el) => {
    const i = arr.indexOf(el);
    if (i > -1) {
        arr.splice(i, 1);
    }
};
const hasOwnProperty = Object.prototype.hasOwnProperty;
const hasOwn = (val, key) => hasOwnProperty.call(val, key);
const isArray = Array.isArray;
const isMap = (val) => toTypeString(val) === '[object Map]';
const isSet = (val) => toTypeString(val) === '[object Set]';
const isDate = (val) => val instanceof Date;
const isFunction = (val) => typeof val === 'function';
const isString = (val) => typeof val === 'string';
const isSymbol = (val) => typeof val === 'symbol';
const isObject = (val) => val !== null && typeof val === 'object';
const isPromise = (val) => {
    return isObject(val) && isFunction(val.then) && isFunction(val.catch);
};
const objectToString = Object.prototype.toString;
const toTypeString = (value) => objectToString.call(value);
const toRawType = (value) => {
    // extract "RawType" from strings like "[object RawType]"
    return toTypeString(value).slice(8, -1);
};
const isPlainObject = (val) => toTypeString(val) === '[object Object]';
const isIntegerKey = (key) => isString(key) &&
    key !== 'NaN' &&
    key[0] !== '-' &&
    '' + parseInt(key, 10) === key;
const isReservedProp = /*#__PURE__*/ makeMap(
// the leading comma is intentional so empty string "" is also included
',key,ref,ref_for,ref_key,' +
    'onVnodeBeforeMount,onVnodeMounted,' +
    'onVnodeBeforeUpdate,onVnodeUpdated,' +
    'onVnodeBeforeUnmount,onVnodeUnmounted');
const isBuiltInDirective = /*#__PURE__*/ makeMap('bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo');
const cacheStringFunction = (fn) => {
    const cache = Object.create(null);
    return ((str) => {
        const hit = cache[str];
        return hit || (cache[str] = fn(str));
    });
};
const camelizeRE = /-(\w)/g;
/**
 * @private
 */
const camelize = cacheStringFunction((str) => {
    return str.replace(camelizeRE, (_, c) => (c ? c.toUpperCase() : ''));
});
const hyphenateRE = /\B([A-Z])/g;
/**
 * @private
 */
const hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, '-$1').toLowerCase());
/**
 * @private
 */
const capitalize = cacheStringFunction((str) => str.charAt(0).toUpperCase() + str.slice(1));
/**
 * @private
 */
const toHandlerKey = cacheStringFunction((str) => str ? `on${capitalize(str)}` : ``);
// compare whether a value has changed, accounting for NaN.
const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
const invokeArrayFns = (fns, arg) => {
    for (let i = 0; i < fns.length; i++) {
        fns[i](arg);
    }
};
const def = (obj, key, value) => {
    Object.defineProperty(obj, key, {
        configurable: true,
        enumerable: false,
        value
    });
};
const toNumber = (val) => {
    const n = parseFloat(val);
    return isNaN(n) ? val : n;
};
let _globalThis;
const getGlobalThis = () => {
    return (_globalThis ||
        (_globalThis =
            typeof globalThis !== 'undefined'
                ? globalThis
                : typeof self !== 'undefined'
                    ? self
                    : typeof window !== 'undefined'
                        ? window
                        : typeof __webpack_require__.g !== 'undefined'
                            ? __webpack_require__.g
                            : {}));
};




/***/ }),

/***/ "./node_modules/@vue/runtime-dom/dist/runtime-dom.esm-bundler.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@vue/runtime-dom/dist/runtime-dom.esm-bundler.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BaseTransition": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.BaseTransition),
/* harmony export */   "Comment": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Comment),
/* harmony export */   "EffectScope": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.EffectScope),
/* harmony export */   "Fragment": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Fragment),
/* harmony export */   "KeepAlive": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.KeepAlive),
/* harmony export */   "ReactiveEffect": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.ReactiveEffect),
/* harmony export */   "Static": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Static),
/* harmony export */   "Suspense": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Suspense),
/* harmony export */   "Teleport": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Teleport),
/* harmony export */   "Text": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Text),
/* harmony export */   "callWithAsyncErrorHandling": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.callWithAsyncErrorHandling),
/* harmony export */   "callWithErrorHandling": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.callWithErrorHandling),
/* harmony export */   "camelize": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.camelize),
/* harmony export */   "capitalize": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.capitalize),
/* harmony export */   "cloneVNode": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.cloneVNode),
/* harmony export */   "compatUtils": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.compatUtils),
/* harmony export */   "computed": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.computed),
/* harmony export */   "createBlock": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createBlock),
/* harmony export */   "createCommentVNode": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode),
/* harmony export */   "createElementBlock": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createElementBlock),
/* harmony export */   "createElementVNode": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createElementVNode),
/* harmony export */   "createHydrationRenderer": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createHydrationRenderer),
/* harmony export */   "createPropsRestProxy": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createPropsRestProxy),
/* harmony export */   "createRenderer": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createRenderer),
/* harmony export */   "createSlots": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createSlots),
/* harmony export */   "createStaticVNode": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createStaticVNode),
/* harmony export */   "createTextVNode": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createTextVNode),
/* harmony export */   "createVNode": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createVNode),
/* harmony export */   "customRef": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.customRef),
/* harmony export */   "defineAsyncComponent": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.defineAsyncComponent),
/* harmony export */   "defineComponent": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.defineComponent),
/* harmony export */   "defineEmits": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.defineEmits),
/* harmony export */   "defineExpose": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.defineExpose),
/* harmony export */   "defineProps": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.defineProps),
/* harmony export */   "devtools": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.devtools),
/* harmony export */   "effect": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.effect),
/* harmony export */   "effectScope": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.effectScope),
/* harmony export */   "getCurrentInstance": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getCurrentInstance),
/* harmony export */   "getCurrentScope": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getCurrentScope),
/* harmony export */   "getTransitionRawChildren": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getTransitionRawChildren),
/* harmony export */   "guardReactiveProps": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.guardReactiveProps),
/* harmony export */   "h": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.h),
/* harmony export */   "handleError": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.handleError),
/* harmony export */   "initCustomFormatter": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.initCustomFormatter),
/* harmony export */   "inject": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.inject),
/* harmony export */   "isMemoSame": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isMemoSame),
/* harmony export */   "isProxy": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isProxy),
/* harmony export */   "isReactive": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isReactive),
/* harmony export */   "isReadonly": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isReadonly),
/* harmony export */   "isRef": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isRef),
/* harmony export */   "isRuntimeOnly": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isRuntimeOnly),
/* harmony export */   "isShallow": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isShallow),
/* harmony export */   "isVNode": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isVNode),
/* harmony export */   "markRaw": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.markRaw),
/* harmony export */   "mergeDefaults": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.mergeDefaults),
/* harmony export */   "mergeProps": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.mergeProps),
/* harmony export */   "nextTick": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.nextTick),
/* harmony export */   "normalizeClass": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.normalizeClass),
/* harmony export */   "normalizeProps": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.normalizeProps),
/* harmony export */   "normalizeStyle": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.normalizeStyle),
/* harmony export */   "onActivated": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onActivated),
/* harmony export */   "onBeforeMount": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onBeforeMount),
/* harmony export */   "onBeforeUnmount": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onBeforeUnmount),
/* harmony export */   "onBeforeUpdate": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onBeforeUpdate),
/* harmony export */   "onDeactivated": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onDeactivated),
/* harmony export */   "onErrorCaptured": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onErrorCaptured),
/* harmony export */   "onMounted": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onMounted),
/* harmony export */   "onRenderTracked": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onRenderTracked),
/* harmony export */   "onRenderTriggered": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onRenderTriggered),
/* harmony export */   "onScopeDispose": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onScopeDispose),
/* harmony export */   "onServerPrefetch": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onServerPrefetch),
/* harmony export */   "onUnmounted": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onUnmounted),
/* harmony export */   "onUpdated": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onUpdated),
/* harmony export */   "openBlock": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.openBlock),
/* harmony export */   "popScopeId": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.popScopeId),
/* harmony export */   "provide": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.provide),
/* harmony export */   "proxyRefs": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.proxyRefs),
/* harmony export */   "pushScopeId": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.pushScopeId),
/* harmony export */   "queuePostFlushCb": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.queuePostFlushCb),
/* harmony export */   "reactive": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.reactive),
/* harmony export */   "readonly": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.readonly),
/* harmony export */   "ref": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.ref),
/* harmony export */   "registerRuntimeCompiler": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.registerRuntimeCompiler),
/* harmony export */   "renderList": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.renderList),
/* harmony export */   "renderSlot": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.renderSlot),
/* harmony export */   "resolveComponent": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.resolveComponent),
/* harmony export */   "resolveDirective": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.resolveDirective),
/* harmony export */   "resolveDynamicComponent": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.resolveDynamicComponent),
/* harmony export */   "resolveFilter": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.resolveFilter),
/* harmony export */   "resolveTransitionHooks": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.resolveTransitionHooks),
/* harmony export */   "setBlockTracking": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.setBlockTracking),
/* harmony export */   "setDevtoolsHook": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.setDevtoolsHook),
/* harmony export */   "setTransitionHooks": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.setTransitionHooks),
/* harmony export */   "shallowReactive": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.shallowReactive),
/* harmony export */   "shallowReadonly": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly),
/* harmony export */   "shallowRef": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.shallowRef),
/* harmony export */   "ssrContextKey": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.ssrContextKey),
/* harmony export */   "ssrUtils": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.ssrUtils),
/* harmony export */   "stop": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.stop),
/* harmony export */   "toDisplayString": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.toDisplayString),
/* harmony export */   "toHandlerKey": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.toHandlerKey),
/* harmony export */   "toHandlers": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.toHandlers),
/* harmony export */   "toRaw": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.toRaw),
/* harmony export */   "toRef": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.toRef),
/* harmony export */   "toRefs": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.toRefs),
/* harmony export */   "transformVNodeArgs": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.transformVNodeArgs),
/* harmony export */   "triggerRef": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.triggerRef),
/* harmony export */   "unref": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.unref),
/* harmony export */   "useAttrs": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.useAttrs),
/* harmony export */   "useSSRContext": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.useSSRContext),
/* harmony export */   "useSlots": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.useSlots),
/* harmony export */   "useTransitionState": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.useTransitionState),
/* harmony export */   "version": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.version),
/* harmony export */   "warn": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn),
/* harmony export */   "watch": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.watch),
/* harmony export */   "watchEffect": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.watchEffect),
/* harmony export */   "watchPostEffect": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.watchPostEffect),
/* harmony export */   "watchSyncEffect": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.watchSyncEffect),
/* harmony export */   "withAsyncContext": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.withAsyncContext),
/* harmony export */   "withCtx": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.withCtx),
/* harmony export */   "withDefaults": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.withDefaults),
/* harmony export */   "withDirectives": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.withDirectives),
/* harmony export */   "withMemo": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.withMemo),
/* harmony export */   "withScopeId": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.withScopeId),
/* harmony export */   "Transition": () => (/* binding */ Transition),
/* harmony export */   "TransitionGroup": () => (/* binding */ TransitionGroup),
/* harmony export */   "VueElement": () => (/* binding */ VueElement),
/* harmony export */   "createApp": () => (/* binding */ createApp),
/* harmony export */   "createSSRApp": () => (/* binding */ createSSRApp),
/* harmony export */   "defineCustomElement": () => (/* binding */ defineCustomElement),
/* harmony export */   "defineSSRCustomElement": () => (/* binding */ defineSSRCustomElement),
/* harmony export */   "hydrate": () => (/* binding */ hydrate),
/* harmony export */   "initDirectivesForSSR": () => (/* binding */ initDirectivesForSSR),
/* harmony export */   "render": () => (/* binding */ render),
/* harmony export */   "useCssModule": () => (/* binding */ useCssModule),
/* harmony export */   "useCssVars": () => (/* binding */ useCssVars),
/* harmony export */   "vModelCheckbox": () => (/* binding */ vModelCheckbox),
/* harmony export */   "vModelDynamic": () => (/* binding */ vModelDynamic),
/* harmony export */   "vModelRadio": () => (/* binding */ vModelRadio),
/* harmony export */   "vModelSelect": () => (/* binding */ vModelSelect),
/* harmony export */   "vModelText": () => (/* binding */ vModelText),
/* harmony export */   "vShow": () => (/* binding */ vShow),
/* harmony export */   "withKeys": () => (/* binding */ withKeys),
/* harmony export */   "withModifiers": () => (/* binding */ withModifiers)
/* harmony export */ });
/* harmony import */ var _vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @vue/runtime-core */ "./node_modules/@vue/runtime-core/node_modules/@vue/shared/dist/shared.esm-bundler.js");
/* harmony import */ var _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vue/runtime-core */ "./node_modules/@vue/runtime-core/dist/runtime-core.esm-bundler.js");
/* harmony import */ var _vue_runtime_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @vue/runtime-core */ "./node_modules/@vue/runtime-core/node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js");
/* harmony import */ var _vue_shared__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @vue/shared */ "./node_modules/@vue/runtime-dom/node_modules/@vue/shared/dist/shared.esm-bundler.js");




const svgNS = 'http://www.w3.org/2000/svg';
const doc = (typeof document !== 'undefined' ? document : null);
const templateContainer = doc && doc.createElement('template');
const nodeOps = {
    insert: (child, parent, anchor) => {
        parent.insertBefore(child, anchor || null);
    },
    remove: child => {
        const parent = child.parentNode;
        if (parent) {
            parent.removeChild(child);
        }
    },
    createElement: (tag, isSVG, is, props) => {
        const el = isSVG
            ? doc.createElementNS(svgNS, tag)
            : doc.createElement(tag, is ? { is } : undefined);
        if (tag === 'select' && props && props.multiple != null) {
            el.setAttribute('multiple', props.multiple);
        }
        return el;
    },
    createText: text => doc.createTextNode(text),
    createComment: text => doc.createComment(text),
    setText: (node, text) => {
        node.nodeValue = text;
    },
    setElementText: (el, text) => {
        el.textContent = text;
    },
    parentNode: node => node.parentNode,
    nextSibling: node => node.nextSibling,
    querySelector: selector => doc.querySelector(selector),
    setScopeId(el, id) {
        el.setAttribute(id, '');
    },
    cloneNode(el) {
        const cloned = el.cloneNode(true);
        // #3072
        // - in `patchDOMProp`, we store the actual value in the `el._value` property.
        // - normally, elements using `:value` bindings will not be hoisted, but if
        //   the bound value is a constant, e.g. `:value="true"` - they do get
        //   hoisted.
        // - in production, hoisted nodes are cloned when subsequent inserts, but
        //   cloneNode() does not copy the custom property we attached.
        // - This may need to account for other custom DOM properties we attach to
        //   elements in addition to `_value` in the future.
        if (`_value` in el) {
            cloned._value = el._value;
        }
        return cloned;
    },
    // __UNSAFE__
    // Reason: innerHTML.
    // Static content here can only come from compiled templates.
    // As long as the user only uses trusted templates, this is safe.
    insertStaticContent(content, parent, anchor, isSVG, start, end) {
        // <parent> before | first ... last | anchor </parent>
        const before = anchor ? anchor.previousSibling : parent.lastChild;
        // #5308 can only take cached path if:
        // - has a single root node
        // - nextSibling info is still available
        if (start && (start === end || start.nextSibling)) {
            // cached
            while (true) {
                parent.insertBefore(start.cloneNode(true), anchor);
                if (start === end || !(start = start.nextSibling))
                    break;
            }
        }
        else {
            // fresh insert
            templateContainer.innerHTML = isSVG ? `<svg>${content}</svg>` : content;
            const template = templateContainer.content;
            if (isSVG) {
                // remove outer svg wrapper
                const wrapper = template.firstChild;
                while (wrapper.firstChild) {
                    template.appendChild(wrapper.firstChild);
                }
                template.removeChild(wrapper);
            }
            parent.insertBefore(template, anchor);
        }
        return [
            // first
            before ? before.nextSibling : parent.firstChild,
            // last
            anchor ? anchor.previousSibling : parent.lastChild
        ];
    }
};

// compiler should normalize class + :class bindings on the same element
// into a single binding ['staticClass', dynamic]
function patchClass(el, value, isSVG) {
    // directly setting className should be faster than setAttribute in theory
    // if this is an element during a transition, take the temporary transition
    // classes into account.
    const transitionClasses = el._vtc;
    if (transitionClasses) {
        value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(' ');
    }
    if (value == null) {
        el.removeAttribute('class');
    }
    else if (isSVG) {
        el.setAttribute('class', value);
    }
    else {
        el.className = value;
    }
}

function patchStyle(el, prev, next) {
    const style = el.style;
    const isCssString = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(next);
    if (next && !isCssString) {
        for (const key in next) {
            setStyle(style, key, next[key]);
        }
        if (prev && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(prev)) {
            for (const key in prev) {
                if (next[key] == null) {
                    setStyle(style, key, '');
                }
            }
        }
    }
    else {
        const currentDisplay = style.display;
        if (isCssString) {
            if (prev !== next) {
                style.cssText = next;
            }
        }
        else if (prev) {
            el.removeAttribute('style');
        }
        // indicates that the `display` of the element is controlled by `v-show`,
        // so we always keep the current `display` value regardless of the `style`
        // value, thus handing over control to `v-show`.
        if ('_vod' in el) {
            style.display = currentDisplay;
        }
    }
}
const importantRE = /\s*!important$/;
function setStyle(style, name, val) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(val)) {
        val.forEach(v => setStyle(style, name, v));
    }
    else {
        if (name.startsWith('--')) {
            // custom property definition
            style.setProperty(name, val);
        }
        else {
            const prefixed = autoPrefix(style, name);
            if (importantRE.test(val)) {
                // !important
                style.setProperty((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(prefixed), val.replace(importantRE, ''), 'important');
            }
            else {
                style[prefixed] = val;
            }
        }
    }
}
const prefixes = ['Webkit', 'Moz', 'ms'];
const prefixCache = {};
function autoPrefix(style, rawName) {
    const cached = prefixCache[rawName];
    if (cached) {
        return cached;
    }
    let name = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__.camelize)(rawName);
    if (name !== 'filter' && name in style) {
        return (prefixCache[rawName] = name);
    }
    name = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.capitalize)(name);
    for (let i = 0; i < prefixes.length; i++) {
        const prefixed = prefixes[i] + name;
        if (prefixed in style) {
            return (prefixCache[rawName] = prefixed);
        }
    }
    return rawName;
}

const xlinkNS = 'http://www.w3.org/1999/xlink';
function patchAttr(el, key, value, isSVG, instance) {
    if (isSVG && key.startsWith('xlink:')) {
        if (value == null) {
            el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
        }
        else {
            el.setAttributeNS(xlinkNS, key, value);
        }
    }
    else {
        // note we are only checking boolean attributes that don't have a
        // corresponding dom prop of the same name here.
        const isBoolean = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSpecialBooleanAttr)(key);
        if (value == null || (isBoolean && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.includeBooleanAttr)(value))) {
            el.removeAttribute(key);
        }
        else {
            el.setAttribute(key, isBoolean ? '' : value);
        }
    }
}

// __UNSAFE__
// functions. The user is responsible for using them with only trusted content.
function patchDOMProp(el, key, value, 
// the following args are passed only due to potential innerHTML/textContent
// overriding existing VNodes, in which case the old tree must be properly
// unmounted.
prevChildren, parentComponent, parentSuspense, unmountChildren) {
    if (key === 'innerHTML' || key === 'textContent') {
        if (prevChildren) {
            unmountChildren(prevChildren, parentComponent, parentSuspense);
        }
        el[key] = value == null ? '' : value;
        return;
    }
    if (key === 'value' &&
        el.tagName !== 'PROGRESS' &&
        // custom elements may use _value internally
        !el.tagName.includes('-')) {
        // store value as _value as well since
        // non-string values will be stringified.
        el._value = value;
        const newValue = value == null ? '' : value;
        if (el.value !== newValue ||
            // #4956: always set for OPTION elements because its value falls back to
            // textContent if no value attribute is present. And setting .value for
            // OPTION has no side effect
            el.tagName === 'OPTION') {
            el.value = newValue;
        }
        if (value == null) {
            el.removeAttribute(key);
        }
        return;
    }
    if (value === '' || value == null) {
        const type = typeof el[key];
        if (type === 'boolean') {
            // e.g. <select multiple> compiles to { multiple: '' }
            el[key] = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.includeBooleanAttr)(value);
            return;
        }
        else if (value == null && type === 'string') {
            // e.g. <div :id="null">
            el[key] = '';
            el.removeAttribute(key);
            return;
        }
        else if (type === 'number') {
            // e.g. <img :width="null">
            // the value of some IDL attr must be greater than 0, e.g. input.size = 0 -> error
            try {
                el[key] = 0;
            }
            catch (_a) { }
            el.removeAttribute(key);
            return;
        }
    }
    // some properties perform value validation and throw
    try {
        el[key] = value;
    }
    catch (e) {
        if ((true)) {
            (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`Failed setting prop "${key}" on <${el.tagName.toLowerCase()}>: ` +
                `value ${value} is invalid.`, e);
        }
    }
}

// Async edge case fix requires storing an event listener's attach timestamp.
let _getNow = Date.now;
let skipTimestampCheck = false;
if (typeof window !== 'undefined') {
    // Determine what event timestamp the browser is using. Annoyingly, the
    // timestamp can either be hi-res (relative to page load) or low-res
    // (relative to UNIX epoch), so in order to compare time we have to use the
    // same timestamp type when saving the flush timestamp.
    if (_getNow() > document.createEvent('Event').timeStamp) {
        // if the low-res timestamp which is bigger than the event timestamp
        // (which is evaluated AFTER) it means the event is using a hi-res timestamp,
        // and we need to use the hi-res version for event listeners as well.
        _getNow = () => performance.now();
    }
    // #3485: Firefox <= 53 has incorrect Event.timeStamp implementation
    // and does not fire microtasks in between event propagation, so safe to exclude.
    const ffMatch = navigator.userAgent.match(/firefox\/(\d+)/i);
    skipTimestampCheck = !!(ffMatch && Number(ffMatch[1]) <= 53);
}
// To avoid the overhead of repeatedly calling performance.now(), we cache
// and use the same timestamp for all event listeners attached in the same tick.
let cachedNow = 0;
const p = Promise.resolve();
const reset = () => {
    cachedNow = 0;
};
const getNow = () => cachedNow || (p.then(reset), (cachedNow = _getNow()));
function addEventListener(el, event, handler, options) {
    el.addEventListener(event, handler, options);
}
function removeEventListener(el, event, handler, options) {
    el.removeEventListener(event, handler, options);
}
function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
    // vei = vue event invokers
    const invokers = el._vei || (el._vei = {});
    const existingInvoker = invokers[rawName];
    if (nextValue && existingInvoker) {
        // patch
        existingInvoker.value = nextValue;
    }
    else {
        const [name, options] = parseName(rawName);
        if (nextValue) {
            // add
            const invoker = (invokers[rawName] = createInvoker(nextValue, instance));
            addEventListener(el, name, invoker, options);
        }
        else if (existingInvoker) {
            // remove
            removeEventListener(el, name, existingInvoker, options);
            invokers[rawName] = undefined;
        }
    }
}
const optionsModifierRE = /(?:Once|Passive|Capture)$/;
function parseName(name) {
    let options;
    if (optionsModifierRE.test(name)) {
        options = {};
        let m;
        while ((m = name.match(optionsModifierRE))) {
            name = name.slice(0, name.length - m[0].length);
            options[m[0].toLowerCase()] = true;
        }
    }
    return [(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(name.slice(2)), options];
}
function createInvoker(initialValue, instance) {
    const invoker = (e) => {
        // async edge case #6566: inner click event triggers patch, event handler
        // attached to outer element during patch, and triggered again. This
        // happens because browsers fire microtask ticks between event propagation.
        // the solution is simple: we save the timestamp when a handler is attached,
        // and the handler would only fire if the event passed to it was fired
        // AFTER it was attached.
        const timeStamp = e.timeStamp || _getNow();
        if (skipTimestampCheck || timeStamp >= invoker.attached - 1) {
            (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.callWithAsyncErrorHandling)(patchStopImmediatePropagation(e, invoker.value), instance, 5 /* NATIVE_EVENT_HANDLER */, [e]);
        }
    };
    invoker.value = initialValue;
    invoker.attached = getNow();
    return invoker;
}
function patchStopImmediatePropagation(e, value) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value)) {
        const originalStop = e.stopImmediatePropagation;
        e.stopImmediatePropagation = () => {
            originalStop.call(e);
            e._stopped = true;
        };
        return value.map(fn => (e) => !e._stopped && fn && fn(e));
    }
    else {
        return value;
    }
}

const nativeOnRE = /^on[a-z]/;
const patchProp = (el, key, prevValue, nextValue, isSVG = false, prevChildren, parentComponent, parentSuspense, unmountChildren) => {
    if (key === 'class') {
        patchClass(el, nextValue, isSVG);
    }
    else if (key === 'style') {
        patchStyle(el, prevValue, nextValue);
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isOn)(key)) {
        // ignore v-model listeners
        if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isModelListener)(key)) {
            patchEvent(el, key, prevValue, nextValue, parentComponent);
        }
    }
    else if (key[0] === '.'
        ? ((key = key.slice(1)), true)
        : key[0] === '^'
            ? ((key = key.slice(1)), false)
            : shouldSetAsProp(el, key, nextValue, isSVG)) {
        patchDOMProp(el, key, nextValue, prevChildren, parentComponent, parentSuspense, unmountChildren);
    }
    else {
        // special case for <input v-model type="checkbox"> with
        // :true-value & :false-value
        // store value as dom properties since non-string values will be
        // stringified.
        if (key === 'true-value') {
            el._trueValue = nextValue;
        }
        else if (key === 'false-value') {
            el._falseValue = nextValue;
        }
        patchAttr(el, key, nextValue, isSVG);
    }
};
function shouldSetAsProp(el, key, value, isSVG) {
    if (isSVG) {
        // most keys must be set as attribute on svg elements to work
        // ...except innerHTML & textContent
        if (key === 'innerHTML' || key === 'textContent') {
            return true;
        }
        // or native onclick with function values
        if (key in el && nativeOnRE.test(key) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(value)) {
            return true;
        }
        return false;
    }
    // spellcheck and draggable are numerated attrs, however their
    // corresponding DOM properties are actually booleans - this leads to
    // setting it with a string "false" value leading it to be coerced to
    // `true`, so we need to always treat them as attributes.
    // Note that `contentEditable` doesn't have this problem: its DOM
    // property is also enumerated string values.
    if (key === 'spellcheck' || key === 'draggable') {
        return false;
    }
    // #1787, #2840 form property on form elements is readonly and must be set as
    // attribute.
    if (key === 'form') {
        return false;
    }
    // #1526 <input list> must be set as attribute
    if (key === 'list' && el.tagName === 'INPUT') {
        return false;
    }
    // #2766 <textarea type> must be set as attribute
    if (key === 'type' && el.tagName === 'TEXTAREA') {
        return false;
    }
    // native onclick with string value, must be set as attribute
    if (nativeOnRE.test(key) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(value)) {
        return false;
    }
    return key in el;
}

function defineCustomElement(options, hydate) {
    const Comp = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.defineComponent)(options);
    class VueCustomElement extends VueElement {
        constructor(initialProps) {
            super(Comp, initialProps, hydate);
        }
    }
    VueCustomElement.def = Comp;
    return VueCustomElement;
}
const defineSSRCustomElement = ((options) => {
    // @ts-ignore
    return defineCustomElement(options, hydrate);
});
const BaseClass = (typeof HTMLElement !== 'undefined' ? HTMLElement : class {
});
class VueElement extends BaseClass {
    constructor(_def, _props = {}, hydrate) {
        super();
        this._def = _def;
        this._props = _props;
        /**
         * @internal
         */
        this._instance = null;
        this._connected = false;
        this._resolved = false;
        this._numberProps = null;
        if (this.shadowRoot && hydrate) {
            hydrate(this._createVNode(), this.shadowRoot);
        }
        else {
            if (( true) && this.shadowRoot) {
                (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`Custom element has pre-rendered declarative shadow root but is not ` +
                    `defined as hydratable. Use \`defineSSRCustomElement\`.`);
            }
            this.attachShadow({ mode: 'open' });
        }
    }
    connectedCallback() {
        this._connected = true;
        if (!this._instance) {
            this._resolveDef();
        }
    }
    disconnectedCallback() {
        this._connected = false;
        (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.nextTick)(() => {
            if (!this._connected) {
                render(null, this.shadowRoot);
                this._instance = null;
            }
        });
    }
    /**
     * resolve inner component definition (handle possible async component)
     */
    _resolveDef() {
        if (this._resolved) {
            return;
        }
        this._resolved = true;
        // set initial attrs
        for (let i = 0; i < this.attributes.length; i++) {
            this._setAttr(this.attributes[i].name);
        }
        // watch future attr changes
        new MutationObserver(mutations => {
            for (const m of mutations) {
                this._setAttr(m.attributeName);
            }
        }).observe(this, { attributes: true });
        const resolve = (def) => {
            const { props, styles } = def;
            const hasOptions = !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(props);
            const rawKeys = props ? (hasOptions ? Object.keys(props) : props) : [];
            // cast Number-type props set before resolve
            let numberProps;
            if (hasOptions) {
                for (const key in this._props) {
                    const opt = props[key];
                    if (opt === Number || (opt && opt.type === Number)) {
                        this._props[key] = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toNumber)(this._props[key]);
                        (numberProps || (numberProps = Object.create(null)))[key] = true;
                    }
                }
            }
            this._numberProps = numberProps;
            // check if there are props set pre-upgrade or connect
            for (const key of Object.keys(this)) {
                if (key[0] !== '_') {
                    this._setProp(key, this[key], true, false);
                }
            }
            // defining getter/setters on prototype
            for (const key of rawKeys.map(_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)) {
                Object.defineProperty(this, key, {
                    get() {
                        return this._getProp(key);
                    },
                    set(val) {
                        this._setProp(key, val);
                    }
                });
            }
            // apply CSS
            this._applyStyles(styles);
            // initial render
            this._update();
        };
        const asyncDef = this._def.__asyncLoader;
        if (asyncDef) {
            asyncDef().then(resolve);
        }
        else {
            resolve(this._def);
        }
    }
    _setAttr(key) {
        let value = this.getAttribute(key);
        if (this._numberProps && this._numberProps[key]) {
            value = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toNumber)(value);
        }
        this._setProp((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(key), value, false);
    }
    /**
     * @internal
     */
    _getProp(key) {
        return this._props[key];
    }
    /**
     * @internal
     */
    _setProp(key, val, shouldReflect = true, shouldUpdate = true) {
        if (val !== this._props[key]) {
            this._props[key] = val;
            if (shouldUpdate && this._instance) {
                this._update();
            }
            // reflect
            if (shouldReflect) {
                if (val === true) {
                    this.setAttribute((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(key), '');
                }
                else if (typeof val === 'string' || typeof val === 'number') {
                    this.setAttribute((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(key), val + '');
                }
                else if (!val) {
                    this.removeAttribute((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(key));
                }
            }
        }
    }
    _update() {
        render(this._createVNode(), this.shadowRoot);
    }
    _createVNode() {
        const vnode = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createVNode)(this._def, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, this._props));
        if (!this._instance) {
            vnode.ce = instance => {
                this._instance = instance;
                instance.isCE = true;
                // HMR
                if ((true)) {
                    instance.ceReload = newStyles => {
                        // always reset styles
                        if (this._styles) {
                            this._styles.forEach(s => this.shadowRoot.removeChild(s));
                            this._styles.length = 0;
                        }
                        this._applyStyles(newStyles);
                        // if this is an async component, ceReload is called from the inner
                        // component so no need to reload the async wrapper
                        if (!this._def.__asyncLoader) {
                            // reload
                            this._instance = null;
                            this._update();
                        }
                    };
                }
                // intercept emit
                instance.emit = (event, ...args) => {
                    this.dispatchEvent(new CustomEvent(event, {
                        detail: args
                    }));
                };
                // locate nearest Vue custom element parent for provide/inject
                let parent = this;
                while ((parent =
                    parent && (parent.parentNode || parent.host))) {
                    if (parent instanceof VueElement) {
                        instance.parent = parent._instance;
                        break;
                    }
                }
            };
        }
        return vnode;
    }
    _applyStyles(styles) {
        if (styles) {
            styles.forEach(css => {
                const s = document.createElement('style');
                s.textContent = css;
                this.shadowRoot.appendChild(s);
                // record for HMR
                if ((true)) {
                    (this._styles || (this._styles = [])).push(s);
                }
            });
        }
    }
}

function useCssModule(name = '$style') {
    /* istanbul ignore else */
    {
        const instance = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getCurrentInstance)();
        if (!instance) {
            ( true) && (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`useCssModule must be called inside setup()`);
            return _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
        }
        const modules = instance.type.__cssModules;
        if (!modules) {
            ( true) && (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`Current instance does not have CSS modules injected.`);
            return _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
        }
        const mod = modules[name];
        if (!mod) {
            ( true) &&
                (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`Current instance does not have CSS module named "${name}".`);
            return _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
        }
        return mod;
    }
}

/**
 * Runtime helper for SFC's CSS variable injection feature.
 * @private
 */
function useCssVars(getter) {
    const instance = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getCurrentInstance)();
    /* istanbul ignore next */
    if (!instance) {
        ( true) &&
            (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`useCssVars is called without current active component instance.`);
        return;
    }
    const setVars = () => setVarsOnVNode(instance.subTree, getter(instance.proxy));
    (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.watchPostEffect)(setVars);
    (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onMounted)(() => {
        const ob = new MutationObserver(setVars);
        ob.observe(instance.subTree.el.parentNode, { childList: true });
        (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onUnmounted)(() => ob.disconnect());
    });
}
function setVarsOnVNode(vnode, vars) {
    if (vnode.shapeFlag & 128 /* SUSPENSE */) {
        const suspense = vnode.suspense;
        vnode = suspense.activeBranch;
        if (suspense.pendingBranch && !suspense.isHydrating) {
            suspense.effects.push(() => {
                setVarsOnVNode(suspense.activeBranch, vars);
            });
        }
    }
    // drill down HOCs until it's a non-component vnode
    while (vnode.component) {
        vnode = vnode.component.subTree;
    }
    if (vnode.shapeFlag & 1 /* ELEMENT */ && vnode.el) {
        setVarsOnNode(vnode.el, vars);
    }
    else if (vnode.type === _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Fragment) {
        vnode.children.forEach(c => setVarsOnVNode(c, vars));
    }
    else if (vnode.type === _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Static) {
        let { el, anchor } = vnode;
        while (el) {
            setVarsOnNode(el, vars);
            if (el === anchor)
                break;
            el = el.nextSibling;
        }
    }
}
function setVarsOnNode(el, vars) {
    if (el.nodeType === 1) {
        const style = el.style;
        for (const key in vars) {
            style.setProperty(`--${key}`, vars[key]);
        }
    }
}

const TRANSITION = 'transition';
const ANIMATION = 'animation';
// DOM Transition is a higher-order-component based on the platform-agnostic
// base Transition component, with DOM-specific logic.
const Transition = (props, { slots }) => (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.h)(_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.BaseTransition, resolveTransitionProps(props), slots);
Transition.displayName = 'Transition';
const DOMTransitionPropsValidators = {
    name: String,
    type: String,
    css: {
        type: Boolean,
        default: true
    },
    duration: [String, Number, Object],
    enterFromClass: String,
    enterActiveClass: String,
    enterToClass: String,
    appearFromClass: String,
    appearActiveClass: String,
    appearToClass: String,
    leaveFromClass: String,
    leaveActiveClass: String,
    leaveToClass: String
};
const TransitionPropsValidators = (Transition.props =
    /*#__PURE__*/ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.BaseTransition.props, DOMTransitionPropsValidators));
/**
 * #3227 Incoming hooks may be merged into arrays when wrapping Transition
 * with custom HOCs.
 */
const callHook = (hook, args = []) => {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(hook)) {
        hook.forEach(h => h(...args));
    }
    else if (hook) {
        hook(...args);
    }
};
/**
 * Check if a hook expects a callback (2nd arg), which means the user
 * intends to explicitly control the end of the transition.
 */
const hasExplicitCallback = (hook) => {
    return hook
        ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(hook)
            ? hook.some(h => h.length > 1)
            : hook.length > 1
        : false;
};
function resolveTransitionProps(rawProps) {
    const baseProps = {};
    for (const key in rawProps) {
        if (!(key in DOMTransitionPropsValidators)) {
            baseProps[key] = rawProps[key];
        }
    }
    if (rawProps.css === false) {
        return baseProps;
    }
    const { name = 'v', type, duration, enterFromClass = `${name}-enter-from`, enterActiveClass = `${name}-enter-active`, enterToClass = `${name}-enter-to`, appearFromClass = enterFromClass, appearActiveClass = enterActiveClass, appearToClass = enterToClass, leaveFromClass = `${name}-leave-from`, leaveActiveClass = `${name}-leave-active`, leaveToClass = `${name}-leave-to` } = rawProps;
    const durations = normalizeDuration(duration);
    const enterDuration = durations && durations[0];
    const leaveDuration = durations && durations[1];
    const { onBeforeEnter, onEnter, onEnterCancelled, onLeave, onLeaveCancelled, onBeforeAppear = onBeforeEnter, onAppear = onEnter, onAppearCancelled = onEnterCancelled } = baseProps;
    const finishEnter = (el, isAppear, done) => {
        removeTransitionClass(el, isAppear ? appearToClass : enterToClass);
        removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);
        done && done();
    };
    const finishLeave = (el, done) => {
        removeTransitionClass(el, leaveToClass);
        removeTransitionClass(el, leaveActiveClass);
        done && done();
    };
    const makeEnterHook = (isAppear) => {
        return (el, done) => {
            const hook = isAppear ? onAppear : onEnter;
            const resolve = () => finishEnter(el, isAppear, done);
            callHook(hook, [el, resolve]);
            nextFrame(() => {
                removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);
                addTransitionClass(el, isAppear ? appearToClass : enterToClass);
                if (!hasExplicitCallback(hook)) {
                    whenTransitionEnds(el, type, enterDuration, resolve);
                }
            });
        };
    };
    return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(baseProps, {
        onBeforeEnter(el) {
            callHook(onBeforeEnter, [el]);
            addTransitionClass(el, enterFromClass);
            addTransitionClass(el, enterActiveClass);
        },
        onBeforeAppear(el) {
            callHook(onBeforeAppear, [el]);
            addTransitionClass(el, appearFromClass);
            addTransitionClass(el, appearActiveClass);
        },
        onEnter: makeEnterHook(false),
        onAppear: makeEnterHook(true),
        onLeave(el, done) {
            const resolve = () => finishLeave(el, done);
            addTransitionClass(el, leaveFromClass);
            // force reflow so *-leave-from classes immediately take effect (#2593)
            forceReflow();
            addTransitionClass(el, leaveActiveClass);
            nextFrame(() => {
                removeTransitionClass(el, leaveFromClass);
                addTransitionClass(el, leaveToClass);
                if (!hasExplicitCallback(onLeave)) {
                    whenTransitionEnds(el, type, leaveDuration, resolve);
                }
            });
            callHook(onLeave, [el, resolve]);
        },
        onEnterCancelled(el) {
            finishEnter(el, false);
            callHook(onEnterCancelled, [el]);
        },
        onAppearCancelled(el) {
            finishEnter(el, true);
            callHook(onAppearCancelled, [el]);
        },
        onLeaveCancelled(el) {
            finishLeave(el);
            callHook(onLeaveCancelled, [el]);
        }
    });
}
function normalizeDuration(duration) {
    if (duration == null) {
        return null;
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(duration)) {
        return [NumberOf(duration.enter), NumberOf(duration.leave)];
    }
    else {
        const n = NumberOf(duration);
        return [n, n];
    }
}
function NumberOf(val) {
    const res = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toNumber)(val);
    if ((true))
        validateDuration(res);
    return res;
}
function validateDuration(val) {
    if (typeof val !== 'number') {
        (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`<transition> explicit duration is not a valid number - ` +
            `got ${JSON.stringify(val)}.`);
    }
    else if (isNaN(val)) {
        (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`<transition> explicit duration is NaN - ` +
            'the duration expression might be incorrect.');
    }
}
function addTransitionClass(el, cls) {
    cls.split(/\s+/).forEach(c => c && el.classList.add(c));
    (el._vtc ||
        (el._vtc = new Set())).add(cls);
}
function removeTransitionClass(el, cls) {
    cls.split(/\s+/).forEach(c => c && el.classList.remove(c));
    const { _vtc } = el;
    if (_vtc) {
        _vtc.delete(cls);
        if (!_vtc.size) {
            el._vtc = undefined;
        }
    }
}
function nextFrame(cb) {
    requestAnimationFrame(() => {
        requestAnimationFrame(cb);
    });
}
let endId = 0;
function whenTransitionEnds(el, expectedType, explicitTimeout, resolve) {
    const id = (el._endId = ++endId);
    const resolveIfNotStale = () => {
        if (id === el._endId) {
            resolve();
        }
    };
    if (explicitTimeout) {
        return setTimeout(resolveIfNotStale, explicitTimeout);
    }
    const { type, timeout, propCount } = getTransitionInfo(el, expectedType);
    if (!type) {
        return resolve();
    }
    const endEvent = type + 'end';
    let ended = 0;
    const end = () => {
        el.removeEventListener(endEvent, onEnd);
        resolveIfNotStale();
    };
    const onEnd = (e) => {
        if (e.target === el && ++ended >= propCount) {
            end();
        }
    };
    setTimeout(() => {
        if (ended < propCount) {
            end();
        }
    }, timeout + 1);
    el.addEventListener(endEvent, onEnd);
}
function getTransitionInfo(el, expectedType) {
    const styles = window.getComputedStyle(el);
    // JSDOM may return undefined for transition properties
    const getStyleProperties = (key) => (styles[key] || '').split(', ');
    const transitionDelays = getStyleProperties(TRANSITION + 'Delay');
    const transitionDurations = getStyleProperties(TRANSITION + 'Duration');
    const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
    const animationDelays = getStyleProperties(ANIMATION + 'Delay');
    const animationDurations = getStyleProperties(ANIMATION + 'Duration');
    const animationTimeout = getTimeout(animationDelays, animationDurations);
    let type = null;
    let timeout = 0;
    let propCount = 0;
    /* istanbul ignore if */
    if (expectedType === TRANSITION) {
        if (transitionTimeout > 0) {
            type = TRANSITION;
            timeout = transitionTimeout;
            propCount = transitionDurations.length;
        }
    }
    else if (expectedType === ANIMATION) {
        if (animationTimeout > 0) {
            type = ANIMATION;
            timeout = animationTimeout;
            propCount = animationDurations.length;
        }
    }
    else {
        timeout = Math.max(transitionTimeout, animationTimeout);
        type =
            timeout > 0
                ? transitionTimeout > animationTimeout
                    ? TRANSITION
                    : ANIMATION
                : null;
        propCount = type
            ? type === TRANSITION
                ? transitionDurations.length
                : animationDurations.length
            : 0;
    }
    const hasTransform = type === TRANSITION &&
        /\b(transform|all)(,|$)/.test(styles[TRANSITION + 'Property']);
    return {
        type,
        timeout,
        propCount,
        hasTransform
    };
}
function getTimeout(delays, durations) {
    while (delays.length < durations.length) {
        delays = delays.concat(delays);
    }
    return Math.max(...durations.map((d, i) => toMs(d) + toMs(delays[i])));
}
// Old versions of Chromium (below 61.0.3163.100) formats floating pointer
// numbers in a locale-dependent way, using a comma instead of a dot.
// If comma is not replaced with a dot, the input will be rounded down
// (i.e. acting as a floor function) causing unexpected behaviors
function toMs(s) {
    return Number(s.slice(0, -1).replace(',', '.')) * 1000;
}
// synchronously force layout to put elements into a certain state
function forceReflow() {
    return document.body.offsetHeight;
}

const positionMap = new WeakMap();
const newPositionMap = new WeakMap();
const TransitionGroupImpl = {
    name: 'TransitionGroup',
    props: /*#__PURE__*/ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, TransitionPropsValidators, {
        tag: String,
        moveClass: String
    }),
    setup(props, { slots }) {
        const instance = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getCurrentInstance)();
        const state = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.useTransitionState)();
        let prevChildren;
        let children;
        (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onUpdated)(() => {
            // children is guaranteed to exist after initial render
            if (!prevChildren.length) {
                return;
            }
            const moveClass = props.moveClass || `${props.name || 'v'}-move`;
            if (!hasCSSTransform(prevChildren[0].el, instance.vnode.el, moveClass)) {
                return;
            }
            // we divide the work into three loops to avoid mixing DOM reads and writes
            // in each iteration - which helps prevent layout thrashing.
            prevChildren.forEach(callPendingCbs);
            prevChildren.forEach(recordPosition);
            const movedChildren = prevChildren.filter(applyTranslation);
            // force reflow to put everything in position
            forceReflow();
            movedChildren.forEach(c => {
                const el = c.el;
                const style = el.style;
                addTransitionClass(el, moveClass);
                style.transform = style.webkitTransform = style.transitionDuration = '';
                const cb = (el._moveCb = (e) => {
                    if (e && e.target !== el) {
                        return;
                    }
                    if (!e || /transform$/.test(e.propertyName)) {
                        el.removeEventListener('transitionend', cb);
                        el._moveCb = null;
                        removeTransitionClass(el, moveClass);
                    }
                });
                el.addEventListener('transitionend', cb);
            });
        });
        return () => {
            const rawProps = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_3__.toRaw)(props);
            const cssTransitionProps = resolveTransitionProps(rawProps);
            let tag = rawProps.tag || _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Fragment;
            prevChildren = children;
            children = slots.default ? (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getTransitionRawChildren)(slots.default()) : [];
            for (let i = 0; i < children.length; i++) {
                const child = children[i];
                if (child.key != null) {
                    (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.setTransitionHooks)(child, (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.resolveTransitionHooks)(child, cssTransitionProps, state, instance));
                }
                else if ((true)) {
                    (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`<TransitionGroup> children must be keyed.`);
                }
            }
            if (prevChildren) {
                for (let i = 0; i < prevChildren.length; i++) {
                    const child = prevChildren[i];
                    (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.setTransitionHooks)(child, (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.resolveTransitionHooks)(child, cssTransitionProps, state, instance));
                    positionMap.set(child, child.el.getBoundingClientRect());
                }
            }
            return (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createVNode)(tag, null, children);
        };
    }
};
const TransitionGroup = TransitionGroupImpl;
function callPendingCbs(c) {
    const el = c.el;
    if (el._moveCb) {
        el._moveCb();
    }
    if (el._enterCb) {
        el._enterCb();
    }
}
function recordPosition(c) {
    newPositionMap.set(c, c.el.getBoundingClientRect());
}
function applyTranslation(c) {
    const oldPos = positionMap.get(c);
    const newPos = newPositionMap.get(c);
    const dx = oldPos.left - newPos.left;
    const dy = oldPos.top - newPos.top;
    if (dx || dy) {
        const s = c.el.style;
        s.transform = s.webkitTransform = `translate(${dx}px,${dy}px)`;
        s.transitionDuration = '0s';
        return c;
    }
}
function hasCSSTransform(el, root, moveClass) {
    // Detect whether an element with the move class applied has
    // CSS transitions. Since the element may be inside an entering
    // transition at this very moment, we make a clone of it and remove
    // all other transition classes applied to ensure only the move class
    // is applied.
    const clone = el.cloneNode();
    if (el._vtc) {
        el._vtc.forEach(cls => {
            cls.split(/\s+/).forEach(c => c && clone.classList.remove(c));
        });
    }
    moveClass.split(/\s+/).forEach(c => c && clone.classList.add(c));
    clone.style.display = 'none';
    const container = (root.nodeType === 1 ? root : root.parentNode);
    container.appendChild(clone);
    const { hasTransform } = getTransitionInfo(clone);
    container.removeChild(clone);
    return hasTransform;
}

const getModelAssigner = (vnode) => {
    const fn = vnode.props['onUpdate:modelValue'];
    return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(fn) ? value => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(fn, value) : fn;
};
function onCompositionStart(e) {
    e.target.composing = true;
}
function onCompositionEnd(e) {
    const target = e.target;
    if (target.composing) {
        target.composing = false;
        trigger(target, 'input');
    }
}
function trigger(el, type) {
    const e = document.createEvent('HTMLEvents');
    e.initEvent(type, true, true);
    el.dispatchEvent(e);
}
// We are exporting the v-model runtime directly as vnode hooks so that it can
// be tree-shaken in case v-model is never used.
const vModelText = {
    created(el, { modifiers: { lazy, trim, number } }, vnode) {
        el._assign = getModelAssigner(vnode);
        const castToNumber = number || (vnode.props && vnode.props.type === 'number');
        addEventListener(el, lazy ? 'change' : 'input', e => {
            if (e.target.composing)
                return;
            let domValue = el.value;
            if (trim) {
                domValue = domValue.trim();
            }
            else if (castToNumber) {
                domValue = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toNumber)(domValue);
            }
            el._assign(domValue);
        });
        if (trim) {
            addEventListener(el, 'change', () => {
                el.value = el.value.trim();
            });
        }
        if (!lazy) {
            addEventListener(el, 'compositionstart', onCompositionStart);
            addEventListener(el, 'compositionend', onCompositionEnd);
            // Safari < 10.2 & UIWebView doesn't fire compositionend when
            // switching focus before confirming composition choice
            // this also fixes the issue where some browsers e.g. iOS Chrome
            // fires "change" instead of "input" on autocomplete.
            addEventListener(el, 'change', onCompositionEnd);
        }
    },
    // set value on mounted so it's after min/max for type="range"
    mounted(el, { value }) {
        el.value = value == null ? '' : value;
    },
    beforeUpdate(el, { value, modifiers: { lazy, trim, number } }, vnode) {
        el._assign = getModelAssigner(vnode);
        // avoid clearing unresolved text. #2302
        if (el.composing)
            return;
        if (document.activeElement === el) {
            if (lazy) {
                return;
            }
            if (trim && el.value.trim() === value) {
                return;
            }
            if ((number || el.type === 'number') && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toNumber)(el.value) === value) {
                return;
            }
        }
        const newValue = value == null ? '' : value;
        if (el.value !== newValue) {
            el.value = newValue;
        }
    }
};
const vModelCheckbox = {
    // #4096 array checkboxes need to be deep traversed
    deep: true,
    created(el, _, vnode) {
        el._assign = getModelAssigner(vnode);
        addEventListener(el, 'change', () => {
            const modelValue = el._modelValue;
            const elementValue = getValue(el);
            const checked = el.checked;
            const assign = el._assign;
            if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(modelValue)) {
                const index = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseIndexOf)(modelValue, elementValue);
                const found = index !== -1;
                if (checked && !found) {
                    assign(modelValue.concat(elementValue));
                }
                else if (!checked && found) {
                    const filtered = [...modelValue];
                    filtered.splice(index, 1);
                    assign(filtered);
                }
            }
            else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSet)(modelValue)) {
                const cloned = new Set(modelValue);
                if (checked) {
                    cloned.add(elementValue);
                }
                else {
                    cloned.delete(elementValue);
                }
                assign(cloned);
            }
            else {
                assign(getCheckboxValue(el, checked));
            }
        });
    },
    // set initial checked on mount to wait for true-value/false-value
    mounted: setChecked,
    beforeUpdate(el, binding, vnode) {
        el._assign = getModelAssigner(vnode);
        setChecked(el, binding, vnode);
    }
};
function setChecked(el, { value, oldValue }, vnode) {
    el._modelValue = value;
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value)) {
        el.checked = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseIndexOf)(value, vnode.props.value) > -1;
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSet)(value)) {
        el.checked = value.has(vnode.props.value);
    }
    else if (value !== oldValue) {
        el.checked = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseEqual)(value, getCheckboxValue(el, true));
    }
}
const vModelRadio = {
    created(el, { value }, vnode) {
        el.checked = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseEqual)(value, vnode.props.value);
        el._assign = getModelAssigner(vnode);
        addEventListener(el, 'change', () => {
            el._assign(getValue(el));
        });
    },
    beforeUpdate(el, { value, oldValue }, vnode) {
        el._assign = getModelAssigner(vnode);
        if (value !== oldValue) {
            el.checked = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseEqual)(value, vnode.props.value);
        }
    }
};
const vModelSelect = {
    // <select multiple> value need to be deep traversed
    deep: true,
    created(el, { value, modifiers: { number } }, vnode) {
        const isSetModel = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSet)(value);
        addEventListener(el, 'change', () => {
            const selectedVal = Array.prototype.filter
                .call(el.options, (o) => o.selected)
                .map((o) => number ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toNumber)(getValue(o)) : getValue(o));
            el._assign(el.multiple
                ? isSetModel
                    ? new Set(selectedVal)
                    : selectedVal
                : selectedVal[0]);
        });
        el._assign = getModelAssigner(vnode);
    },
    // set value in mounted & updated because <select> relies on its children
    // <option>s.
    mounted(el, { value }) {
        setSelected(el, value);
    },
    beforeUpdate(el, _binding, vnode) {
        el._assign = getModelAssigner(vnode);
    },
    updated(el, { value }) {
        setSelected(el, value);
    }
};
function setSelected(el, value) {
    const isMultiple = el.multiple;
    if (isMultiple && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSet)(value)) {
        ( true) &&
            (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`<select multiple v-model> expects an Array or Set value for its binding, ` +
                `but got ${Object.prototype.toString.call(value).slice(8, -1)}.`);
        return;
    }
    for (let i = 0, l = el.options.length; i < l; i++) {
        const option = el.options[i];
        const optionValue = getValue(option);
        if (isMultiple) {
            if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value)) {
                option.selected = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseIndexOf)(value, optionValue) > -1;
            }
            else {
                option.selected = value.has(optionValue);
            }
        }
        else {
            if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseEqual)(getValue(option), value)) {
                if (el.selectedIndex !== i)
                    el.selectedIndex = i;
                return;
            }
        }
    }
    if (!isMultiple && el.selectedIndex !== -1) {
        el.selectedIndex = -1;
    }
}
// retrieve raw value set via :value bindings
function getValue(el) {
    return '_value' in el ? el._value : el.value;
}
// retrieve raw value for true-value and false-value set via :true-value or :false-value bindings
function getCheckboxValue(el, checked) {
    const key = checked ? '_trueValue' : '_falseValue';
    return key in el ? el[key] : checked;
}
const vModelDynamic = {
    created(el, binding, vnode) {
        callModelHook(el, binding, vnode, null, 'created');
    },
    mounted(el, binding, vnode) {
        callModelHook(el, binding, vnode, null, 'mounted');
    },
    beforeUpdate(el, binding, vnode, prevVNode) {
        callModelHook(el, binding, vnode, prevVNode, 'beforeUpdate');
    },
    updated(el, binding, vnode, prevVNode) {
        callModelHook(el, binding, vnode, prevVNode, 'updated');
    }
};
function callModelHook(el, binding, vnode, prevVNode, hook) {
    let modelToUse;
    switch (el.tagName) {
        case 'SELECT':
            modelToUse = vModelSelect;
            break;
        case 'TEXTAREA':
            modelToUse = vModelText;
            break;
        default:
            switch (vnode.props && vnode.props.type) {
                case 'checkbox':
                    modelToUse = vModelCheckbox;
                    break;
                case 'radio':
                    modelToUse = vModelRadio;
                    break;
                default:
                    modelToUse = vModelText;
            }
    }
    const fn = modelToUse[hook];
    fn && fn(el, binding, vnode, prevVNode);
}
// SSR vnode transforms, only used when user includes client-oriented render
// function in SSR
function initVModelForSSR() {
    vModelText.getSSRProps = ({ value }) => ({ value });
    vModelRadio.getSSRProps = ({ value }, vnode) => {
        if (vnode.props && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseEqual)(vnode.props.value, value)) {
            return { checked: true };
        }
    };
    vModelCheckbox.getSSRProps = ({ value }, vnode) => {
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value)) {
            if (vnode.props && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseIndexOf)(value, vnode.props.value) > -1) {
                return { checked: true };
            }
        }
        else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSet)(value)) {
            if (vnode.props && value.has(vnode.props.value)) {
                return { checked: true };
            }
        }
        else if (value) {
            return { checked: true };
        }
    };
}

const systemModifiers = ['ctrl', 'shift', 'alt', 'meta'];
const modifierGuards = {
    stop: e => e.stopPropagation(),
    prevent: e => e.preventDefault(),
    self: e => e.target !== e.currentTarget,
    ctrl: e => !e.ctrlKey,
    shift: e => !e.shiftKey,
    alt: e => !e.altKey,
    meta: e => !e.metaKey,
    left: e => 'button' in e && e.button !== 0,
    middle: e => 'button' in e && e.button !== 1,
    right: e => 'button' in e && e.button !== 2,
    exact: (e, modifiers) => systemModifiers.some(m => e[`${m}Key`] && !modifiers.includes(m))
};
/**
 * @private
 */
const withModifiers = (fn, modifiers) => {
    return (event, ...args) => {
        for (let i = 0; i < modifiers.length; i++) {
            const guard = modifierGuards[modifiers[i]];
            if (guard && guard(event, modifiers))
                return;
        }
        return fn(event, ...args);
    };
};
// Kept for 2.x compat.
// Note: IE11 compat for `spacebar` and `del` is removed for now.
const keyNames = {
    esc: 'escape',
    space: ' ',
    up: 'arrow-up',
    left: 'arrow-left',
    right: 'arrow-right',
    down: 'arrow-down',
    delete: 'backspace'
};
/**
 * @private
 */
const withKeys = (fn, modifiers) => {
    return (event) => {
        if (!('key' in event)) {
            return;
        }
        const eventKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(event.key);
        if (modifiers.some(k => k === eventKey || keyNames[k] === eventKey)) {
            return fn(event);
        }
    };
};

const vShow = {
    beforeMount(el, { value }, { transition }) {
        el._vod = el.style.display === 'none' ? '' : el.style.display;
        if (transition && value) {
            transition.beforeEnter(el);
        }
        else {
            setDisplay(el, value);
        }
    },
    mounted(el, { value }, { transition }) {
        if (transition && value) {
            transition.enter(el);
        }
    },
    updated(el, { value, oldValue }, { transition }) {
        if (!value === !oldValue)
            return;
        if (transition) {
            if (value) {
                transition.beforeEnter(el);
                setDisplay(el, true);
                transition.enter(el);
            }
            else {
                transition.leave(el, () => {
                    setDisplay(el, false);
                });
            }
        }
        else {
            setDisplay(el, value);
        }
    },
    beforeUnmount(el, { value }) {
        setDisplay(el, value);
    }
};
function setDisplay(el, value) {
    el.style.display = value ? el._vod : 'none';
}
// SSR vnode transforms, only used when user includes client-oriented render
// function in SSR
function initVShowForSSR() {
    vShow.getSSRProps = ({ value }) => {
        if (!value) {
            return { style: { display: 'none' } };
        }
    };
}

const rendererOptions = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({ patchProp }, nodeOps);
// lazy create the renderer - this makes core renderer logic tree-shakable
// in case the user only imports reactivity utilities from Vue.
let renderer;
let enabledHydration = false;
function ensureRenderer() {
    return (renderer ||
        (renderer = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createRenderer)(rendererOptions)));
}
function ensureHydrationRenderer() {
    renderer = enabledHydration
        ? renderer
        : (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createHydrationRenderer)(rendererOptions);
    enabledHydration = true;
    return renderer;
}
// use explicit type casts here to avoid import() calls in rolled-up d.ts
const render = ((...args) => {
    ensureRenderer().render(...args);
});
const hydrate = ((...args) => {
    ensureHydrationRenderer().hydrate(...args);
});
const createApp = ((...args) => {
    const app = ensureRenderer().createApp(...args);
    if ((true)) {
        injectNativeTagCheck(app);
        injectCompilerOptionsCheck(app);
    }
    const { mount } = app;
    app.mount = (containerOrSelector) => {
        const container = normalizeContainer(containerOrSelector);
        if (!container)
            return;
        const component = app._component;
        if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(component) && !component.render && !component.template) {
            // __UNSAFE__
            // Reason: potential execution of JS expressions in in-DOM template.
            // The user must make sure the in-DOM template is trusted. If it's
            // rendered by the server, the template should not contain any user data.
            component.template = container.innerHTML;
        }
        // clear content before mounting
        container.innerHTML = '';
        const proxy = mount(container, false, container instanceof SVGElement);
        if (container instanceof Element) {
            container.removeAttribute('v-cloak');
            container.setAttribute('data-v-app', '');
        }
        return proxy;
    };
    return app;
});
const createSSRApp = ((...args) => {
    const app = ensureHydrationRenderer().createApp(...args);
    if ((true)) {
        injectNativeTagCheck(app);
        injectCompilerOptionsCheck(app);
    }
    const { mount } = app;
    app.mount = (containerOrSelector) => {
        const container = normalizeContainer(containerOrSelector);
        if (container) {
            return mount(container, true, container instanceof SVGElement);
        }
    };
    return app;
});
function injectNativeTagCheck(app) {
    // Inject `isNativeTag`
    // this is used for component name validation (dev only)
    Object.defineProperty(app.config, 'isNativeTag', {
        value: (tag) => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isHTMLTag)(tag) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSVGTag)(tag),
        writable: false
    });
}
// dev only
function injectCompilerOptionsCheck(app) {
    if ((0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isRuntimeOnly)()) {
        const isCustomElement = app.config.isCustomElement;
        Object.defineProperty(app.config, 'isCustomElement', {
            get() {
                return isCustomElement;
            },
            set() {
                (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`The \`isCustomElement\` config option is deprecated. Use ` +
                    `\`compilerOptions.isCustomElement\` instead.`);
            }
        });
        const compilerOptions = app.config.compilerOptions;
        const msg = `The \`compilerOptions\` config option is only respected when using ` +
            `a build of Vue.js that includes the runtime compiler (aka "full build"). ` +
            `Since you are using the runtime-only build, \`compilerOptions\` ` +
            `must be passed to \`@vue/compiler-dom\` in the build setup instead.\n` +
            `- For vue-loader: pass it via vue-loader's \`compilerOptions\` loader option.\n` +
            `- For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader\n` +
            `- For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-dom`;
        Object.defineProperty(app.config, 'compilerOptions', {
            get() {
                (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(msg);
                return compilerOptions;
            },
            set() {
                (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(msg);
            }
        });
    }
}
function normalizeContainer(container) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(container)) {
        const res = document.querySelector(container);
        if (( true) && !res) {
            (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`Failed to mount app: mount target selector "${container}" returned null.`);
        }
        return res;
    }
    if (( true) &&
        window.ShadowRoot &&
        container instanceof window.ShadowRoot &&
        container.mode === 'closed') {
        (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`mounting on a ShadowRoot with \`{mode: "closed"}\` may lead to unpredictable bugs`);
    }
    return container;
}
let ssrDirectiveInitialized = false;
/**
 * @internal
 */
const initDirectivesForSSR = () => {
        if (!ssrDirectiveInitialized) {
            ssrDirectiveInitialized = true;
            initVModelForSSR();
            initVShowForSSR();
        }
    }
    ;




/***/ }),

/***/ "./node_modules/@vue/runtime-dom/node_modules/@vue/shared/dist/shared.esm-bundler.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@vue/runtime-dom/node_modules/@vue/shared/dist/shared.esm-bundler.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EMPTY_ARR": () => (/* binding */ EMPTY_ARR),
/* harmony export */   "EMPTY_OBJ": () => (/* binding */ EMPTY_OBJ),
/* harmony export */   "NO": () => (/* binding */ NO),
/* harmony export */   "NOOP": () => (/* binding */ NOOP),
/* harmony export */   "PatchFlagNames": () => (/* binding */ PatchFlagNames),
/* harmony export */   "camelize": () => (/* binding */ camelize),
/* harmony export */   "capitalize": () => (/* binding */ capitalize),
/* harmony export */   "def": () => (/* binding */ def),
/* harmony export */   "escapeHtml": () => (/* binding */ escapeHtml),
/* harmony export */   "escapeHtmlComment": () => (/* binding */ escapeHtmlComment),
/* harmony export */   "extend": () => (/* binding */ extend),
/* harmony export */   "generateCodeFrame": () => (/* binding */ generateCodeFrame),
/* harmony export */   "getGlobalThis": () => (/* binding */ getGlobalThis),
/* harmony export */   "hasChanged": () => (/* binding */ hasChanged),
/* harmony export */   "hasOwn": () => (/* binding */ hasOwn),
/* harmony export */   "hyphenate": () => (/* binding */ hyphenate),
/* harmony export */   "includeBooleanAttr": () => (/* binding */ includeBooleanAttr),
/* harmony export */   "invokeArrayFns": () => (/* binding */ invokeArrayFns),
/* harmony export */   "isArray": () => (/* binding */ isArray),
/* harmony export */   "isBooleanAttr": () => (/* binding */ isBooleanAttr),
/* harmony export */   "isBuiltInDirective": () => (/* binding */ isBuiltInDirective),
/* harmony export */   "isDate": () => (/* binding */ isDate),
/* harmony export */   "isFunction": () => (/* binding */ isFunction),
/* harmony export */   "isGloballyWhitelisted": () => (/* binding */ isGloballyWhitelisted),
/* harmony export */   "isHTMLTag": () => (/* binding */ isHTMLTag),
/* harmony export */   "isIntegerKey": () => (/* binding */ isIntegerKey),
/* harmony export */   "isKnownHtmlAttr": () => (/* binding */ isKnownHtmlAttr),
/* harmony export */   "isKnownSvgAttr": () => (/* binding */ isKnownSvgAttr),
/* harmony export */   "isMap": () => (/* binding */ isMap),
/* harmony export */   "isModelListener": () => (/* binding */ isModelListener),
/* harmony export */   "isNoUnitNumericStyleProp": () => (/* binding */ isNoUnitNumericStyleProp),
/* harmony export */   "isObject": () => (/* binding */ isObject),
/* harmony export */   "isOn": () => (/* binding */ isOn),
/* harmony export */   "isPlainObject": () => (/* binding */ isPlainObject),
/* harmony export */   "isPromise": () => (/* binding */ isPromise),
/* harmony export */   "isReservedProp": () => (/* binding */ isReservedProp),
/* harmony export */   "isSSRSafeAttrName": () => (/* binding */ isSSRSafeAttrName),
/* harmony export */   "isSVGTag": () => (/* binding */ isSVGTag),
/* harmony export */   "isSet": () => (/* binding */ isSet),
/* harmony export */   "isSpecialBooleanAttr": () => (/* binding */ isSpecialBooleanAttr),
/* harmony export */   "isString": () => (/* binding */ isString),
/* harmony export */   "isSymbol": () => (/* binding */ isSymbol),
/* harmony export */   "isVoidTag": () => (/* binding */ isVoidTag),
/* harmony export */   "looseEqual": () => (/* binding */ looseEqual),
/* harmony export */   "looseIndexOf": () => (/* binding */ looseIndexOf),
/* harmony export */   "makeMap": () => (/* binding */ makeMap),
/* harmony export */   "normalizeClass": () => (/* binding */ normalizeClass),
/* harmony export */   "normalizeProps": () => (/* binding */ normalizeProps),
/* harmony export */   "normalizeStyle": () => (/* binding */ normalizeStyle),
/* harmony export */   "objectToString": () => (/* binding */ objectToString),
/* harmony export */   "parseStringStyle": () => (/* binding */ parseStringStyle),
/* harmony export */   "propsToAttrMap": () => (/* binding */ propsToAttrMap),
/* harmony export */   "remove": () => (/* binding */ remove),
/* harmony export */   "slotFlagsText": () => (/* binding */ slotFlagsText),
/* harmony export */   "stringifyStyle": () => (/* binding */ stringifyStyle),
/* harmony export */   "toDisplayString": () => (/* binding */ toDisplayString),
/* harmony export */   "toHandlerKey": () => (/* binding */ toHandlerKey),
/* harmony export */   "toNumber": () => (/* binding */ toNumber),
/* harmony export */   "toRawType": () => (/* binding */ toRawType),
/* harmony export */   "toTypeString": () => (/* binding */ toTypeString)
/* harmony export */ });
/**
 * Make a map and return a function for checking if a key
 * is in that map.
 * IMPORTANT: all calls of this function must be prefixed with
 * \/\*#\_\_PURE\_\_\*\/
 * So that rollup can tree-shake them if necessary.
 */
function makeMap(str, expectsLowerCase) {
    const map = Object.create(null);
    const list = str.split(',');
    for (let i = 0; i < list.length; i++) {
        map[list[i]] = true;
    }
    return expectsLowerCase ? val => !!map[val.toLowerCase()] : val => !!map[val];
}

/**
 * dev only flag -> name mapping
 */
const PatchFlagNames = {
    [1 /* TEXT */]: `TEXT`,
    [2 /* CLASS */]: `CLASS`,
    [4 /* STYLE */]: `STYLE`,
    [8 /* PROPS */]: `PROPS`,
    [16 /* FULL_PROPS */]: `FULL_PROPS`,
    [32 /* HYDRATE_EVENTS */]: `HYDRATE_EVENTS`,
    [64 /* STABLE_FRAGMENT */]: `STABLE_FRAGMENT`,
    [128 /* KEYED_FRAGMENT */]: `KEYED_FRAGMENT`,
    [256 /* UNKEYED_FRAGMENT */]: `UNKEYED_FRAGMENT`,
    [512 /* NEED_PATCH */]: `NEED_PATCH`,
    [1024 /* DYNAMIC_SLOTS */]: `DYNAMIC_SLOTS`,
    [2048 /* DEV_ROOT_FRAGMENT */]: `DEV_ROOT_FRAGMENT`,
    [-1 /* HOISTED */]: `HOISTED`,
    [-2 /* BAIL */]: `BAIL`
};

/**
 * Dev only
 */
const slotFlagsText = {
    [1 /* STABLE */]: 'STABLE',
    [2 /* DYNAMIC */]: 'DYNAMIC',
    [3 /* FORWARDED */]: 'FORWARDED'
};

const GLOBALS_WHITE_LISTED = 'Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,' +
    'decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,' +
    'Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt';
const isGloballyWhitelisted = /*#__PURE__*/ makeMap(GLOBALS_WHITE_LISTED);

const range = 2;
function generateCodeFrame(source, start = 0, end = source.length) {
    // Split the content into individual lines but capture the newline sequence
    // that separated each line. This is important because the actual sequence is
    // needed to properly take into account the full line length for offset
    // comparison
    let lines = source.split(/(\r?\n)/);
    // Separate the lines and newline sequences into separate arrays for easier referencing
    const newlineSequences = lines.filter((_, idx) => idx % 2 === 1);
    lines = lines.filter((_, idx) => idx % 2 === 0);
    let count = 0;
    const res = [];
    for (let i = 0; i < lines.length; i++) {
        count +=
            lines[i].length +
                ((newlineSequences[i] && newlineSequences[i].length) || 0);
        if (count >= start) {
            for (let j = i - range; j <= i + range || end > count; j++) {
                if (j < 0 || j >= lines.length)
                    continue;
                const line = j + 1;
                res.push(`${line}${' '.repeat(Math.max(3 - String(line).length, 0))}|  ${lines[j]}`);
                const lineLength = lines[j].length;
                const newLineSeqLength = (newlineSequences[j] && newlineSequences[j].length) || 0;
                if (j === i) {
                    // push underline
                    const pad = start - (count - (lineLength + newLineSeqLength));
                    const length = Math.max(1, end > count ? lineLength - pad : end - start);
                    res.push(`   |  ` + ' '.repeat(pad) + '^'.repeat(length));
                }
                else if (j > i) {
                    if (end > count) {
                        const length = Math.max(Math.min(end - count, lineLength), 1);
                        res.push(`   |  ` + '^'.repeat(length));
                    }
                    count += lineLength + newLineSeqLength;
                }
            }
            break;
        }
    }
    return res.join('\n');
}

/**
 * On the client we only need to offer special cases for boolean attributes that
 * have different names from their corresponding dom properties:
 * - itemscope -> N/A
 * - allowfullscreen -> allowFullscreen
 * - formnovalidate -> formNoValidate
 * - ismap -> isMap
 * - nomodule -> noModule
 * - novalidate -> noValidate
 * - readonly -> readOnly
 */
const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
const isSpecialBooleanAttr = /*#__PURE__*/ makeMap(specialBooleanAttrs);
/**
 * The full list is needed during SSR to produce the correct initial markup.
 */
const isBooleanAttr = /*#__PURE__*/ makeMap(specialBooleanAttrs +
    `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,` +
    `loop,open,required,reversed,scoped,seamless,` +
    `checked,muted,multiple,selected`);
/**
 * Boolean attributes should be included if the value is truthy or ''.
 * e.g. `<select multiple>` compiles to `{ multiple: '' }`
 */
function includeBooleanAttr(value) {
    return !!value || value === '';
}
const unsafeAttrCharRE = /[>/="'\u0009\u000a\u000c\u0020]/;
const attrValidationCache = {};
function isSSRSafeAttrName(name) {
    if (attrValidationCache.hasOwnProperty(name)) {
        return attrValidationCache[name];
    }
    const isUnsafe = unsafeAttrCharRE.test(name);
    if (isUnsafe) {
        console.error(`unsafe attribute name: ${name}`);
    }
    return (attrValidationCache[name] = !isUnsafe);
}
const propsToAttrMap = {
    acceptCharset: 'accept-charset',
    className: 'class',
    htmlFor: 'for',
    httpEquiv: 'http-equiv'
};
/**
 * CSS properties that accept plain numbers
 */
const isNoUnitNumericStyleProp = /*#__PURE__*/ makeMap(`animation-iteration-count,border-image-outset,border-image-slice,` +
    `border-image-width,box-flex,box-flex-group,box-ordinal-group,column-count,` +
    `columns,flex,flex-grow,flex-positive,flex-shrink,flex-negative,flex-order,` +
    `grid-row,grid-row-end,grid-row-span,grid-row-start,grid-column,` +
    `grid-column-end,grid-column-span,grid-column-start,font-weight,line-clamp,` +
    `line-height,opacity,order,orphans,tab-size,widows,z-index,zoom,` +
    // SVG
    `fill-opacity,flood-opacity,stop-opacity,stroke-dasharray,stroke-dashoffset,` +
    `stroke-miterlimit,stroke-opacity,stroke-width`);
/**
 * Known attributes, this is used for stringification of runtime static nodes
 * so that we don't stringify bindings that cannot be set from HTML.
 * Don't also forget to allow `data-*` and `aria-*`!
 * Generated from https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes
 */
const isKnownHtmlAttr = /*#__PURE__*/ makeMap(`accept,accept-charset,accesskey,action,align,allow,alt,async,` +
    `autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,` +
    `border,buffered,capture,challenge,charset,checked,cite,class,code,` +
    `codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,` +
    `coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,` +
    `disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,` +
    `formaction,formenctype,formmethod,formnovalidate,formtarget,headers,` +
    `height,hidden,high,href,hreflang,http-equiv,icon,id,importance,integrity,` +
    `ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,` +
    `manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,` +
    `open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,` +
    `referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,` +
    `selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,` +
    `start,step,style,summary,tabindex,target,title,translate,type,usemap,` +
    `value,width,wrap`);
/**
 * Generated from https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute
 */
const isKnownSvgAttr = /*#__PURE__*/ makeMap(`xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,` +
    `arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,` +
    `baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,` +
    `clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,` +
    `color-interpolation-filters,color-profile,color-rendering,` +
    `contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,` +
    `descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,` +
    `dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,` +
    `fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,` +
    `font-family,font-size,font-size-adjust,font-stretch,font-style,` +
    `font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,` +
    `glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,` +
    `gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,` +
    `horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,` +
    `k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,` +
    `lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,` +
    `marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,` +
    `mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,` +
    `name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,` +
    `overflow,overline-position,overline-thickness,panose-1,paint-order,path,` +
    `pathLength,patternContentUnits,patternTransform,patternUnits,ping,` +
    `pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,` +
    `preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,` +
    `rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,` +
    `restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,` +
    `specularConstant,specularExponent,speed,spreadMethod,startOffset,` +
    `stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,` +
    `strikethrough-position,strikethrough-thickness,string,stroke,` +
    `stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,` +
    `stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,` +
    `systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,` +
    `text-decoration,text-rendering,textLength,to,transform,transform-origin,` +
    `type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,` +
    `unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,` +
    `v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,` +
    `vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,` +
    `writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,` +
    `xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xml:base,xml:lang,` +
    `xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan`);

function normalizeStyle(value) {
    if (isArray(value)) {
        const res = {};
        for (let i = 0; i < value.length; i++) {
            const item = value[i];
            const normalized = isString(item)
                ? parseStringStyle(item)
                : normalizeStyle(item);
            if (normalized) {
                for (const key in normalized) {
                    res[key] = normalized[key];
                }
            }
        }
        return res;
    }
    else if (isString(value)) {
        return value;
    }
    else if (isObject(value)) {
        return value;
    }
}
const listDelimiterRE = /;(?![^(]*\))/g;
const propertyDelimiterRE = /:(.+)/;
function parseStringStyle(cssText) {
    const ret = {};
    cssText.split(listDelimiterRE).forEach(item => {
        if (item) {
            const tmp = item.split(propertyDelimiterRE);
            tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
        }
    });
    return ret;
}
function stringifyStyle(styles) {
    let ret = '';
    if (!styles || isString(styles)) {
        return ret;
    }
    for (const key in styles) {
        const value = styles[key];
        const normalizedKey = key.startsWith(`--`) ? key : hyphenate(key);
        if (isString(value) ||
            (typeof value === 'number' && isNoUnitNumericStyleProp(normalizedKey))) {
            // only render valid values
            ret += `${normalizedKey}:${value};`;
        }
    }
    return ret;
}
function normalizeClass(value) {
    let res = '';
    if (isString(value)) {
        res = value;
    }
    else if (isArray(value)) {
        for (let i = 0; i < value.length; i++) {
            const normalized = normalizeClass(value[i]);
            if (normalized) {
                res += normalized + ' ';
            }
        }
    }
    else if (isObject(value)) {
        for (const name in value) {
            if (value[name]) {
                res += name + ' ';
            }
        }
    }
    return res.trim();
}
function normalizeProps(props) {
    if (!props)
        return null;
    let { class: klass, style } = props;
    if (klass && !isString(klass)) {
        props.class = normalizeClass(klass);
    }
    if (style) {
        props.style = normalizeStyle(style);
    }
    return props;
}

// These tag configs are shared between compiler-dom and runtime-dom, so they
// https://developer.mozilla.org/en-US/docs/Web/HTML/Element
const HTML_TAGS = 'html,body,base,head,link,meta,style,title,address,article,aside,footer,' +
    'header,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,' +
    'figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,' +
    'data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,' +
    'time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,' +
    'canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,' +
    'th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,' +
    'option,output,progress,select,textarea,details,dialog,menu,' +
    'summary,template,blockquote,iframe,tfoot';
// https://developer.mozilla.org/en-US/docs/Web/SVG/Element
const SVG_TAGS = 'svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,' +
    'defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,' +
    'feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,' +
    'feDistanceLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,' +
    'feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,' +
    'fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,' +
    'foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,' +
    'mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,' +
    'polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,' +
    'text,textPath,title,tspan,unknown,use,view';
const VOID_TAGS = 'area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr';
/**
 * Compiler only.
 * Do NOT use in runtime code paths unless behind `(process.env.NODE_ENV !== 'production')` flag.
 */
const isHTMLTag = /*#__PURE__*/ makeMap(HTML_TAGS);
/**
 * Compiler only.
 * Do NOT use in runtime code paths unless behind `(process.env.NODE_ENV !== 'production')` flag.
 */
const isSVGTag = /*#__PURE__*/ makeMap(SVG_TAGS);
/**
 * Compiler only.
 * Do NOT use in runtime code paths unless behind `(process.env.NODE_ENV !== 'production')` flag.
 */
const isVoidTag = /*#__PURE__*/ makeMap(VOID_TAGS);

const escapeRE = /["'&<>]/;
function escapeHtml(string) {
    const str = '' + string;
    const match = escapeRE.exec(str);
    if (!match) {
        return str;
    }
    let html = '';
    let escaped;
    let index;
    let lastIndex = 0;
    for (index = match.index; index < str.length; index++) {
        switch (str.charCodeAt(index)) {
            case 34: // "
                escaped = '&quot;';
                break;
            case 38: // &
                escaped = '&amp;';
                break;
            case 39: // '
                escaped = '&#39;';
                break;
            case 60: // <
                escaped = '&lt;';
                break;
            case 62: // >
                escaped = '&gt;';
                break;
            default:
                continue;
        }
        if (lastIndex !== index) {
            html += str.slice(lastIndex, index);
        }
        lastIndex = index + 1;
        html += escaped;
    }
    return lastIndex !== index ? html + str.slice(lastIndex, index) : html;
}
// https://www.w3.org/TR/html52/syntax.html#comments
const commentStripRE = /^-?>|<!--|-->|--!>|<!-$/g;
function escapeHtmlComment(src) {
    return src.replace(commentStripRE, '');
}

function looseCompareArrays(a, b) {
    if (a.length !== b.length)
        return false;
    let equal = true;
    for (let i = 0; equal && i < a.length; i++) {
        equal = looseEqual(a[i], b[i]);
    }
    return equal;
}
function looseEqual(a, b) {
    if (a === b)
        return true;
    let aValidType = isDate(a);
    let bValidType = isDate(b);
    if (aValidType || bValidType) {
        return aValidType && bValidType ? a.getTime() === b.getTime() : false;
    }
    aValidType = isArray(a);
    bValidType = isArray(b);
    if (aValidType || bValidType) {
        return aValidType && bValidType ? looseCompareArrays(a, b) : false;
    }
    aValidType = isObject(a);
    bValidType = isObject(b);
    if (aValidType || bValidType) {
        /* istanbul ignore if: this if will probably never be called */
        if (!aValidType || !bValidType) {
            return false;
        }
        const aKeysCount = Object.keys(a).length;
        const bKeysCount = Object.keys(b).length;
        if (aKeysCount !== bKeysCount) {
            return false;
        }
        for (const key in a) {
            const aHasKey = a.hasOwnProperty(key);
            const bHasKey = b.hasOwnProperty(key);
            if ((aHasKey && !bHasKey) ||
                (!aHasKey && bHasKey) ||
                !looseEqual(a[key], b[key])) {
                return false;
            }
        }
    }
    return String(a) === String(b);
}
function looseIndexOf(arr, val) {
    return arr.findIndex(item => looseEqual(item, val));
}

/**
 * For converting {{ interpolation }} values to displayed strings.
 * @private
 */
const toDisplayString = (val) => {
    return isString(val)
        ? val
        : val == null
            ? ''
            : isArray(val) ||
                (isObject(val) &&
                    (val.toString === objectToString || !isFunction(val.toString)))
                ? JSON.stringify(val, replacer, 2)
                : String(val);
};
const replacer = (_key, val) => {
    // can't use isRef here since @vue/shared has no deps
    if (val && val.__v_isRef) {
        return replacer(_key, val.value);
    }
    else if (isMap(val)) {
        return {
            [`Map(${val.size})`]: [...val.entries()].reduce((entries, [key, val]) => {
                entries[`${key} =>`] = val;
                return entries;
            }, {})
        };
    }
    else if (isSet(val)) {
        return {
            [`Set(${val.size})`]: [...val.values()]
        };
    }
    else if (isObject(val) && !isArray(val) && !isPlainObject(val)) {
        return String(val);
    }
    return val;
};

const EMPTY_OBJ = ( true)
    ? Object.freeze({})
    : 0;
const EMPTY_ARR = ( true) ? Object.freeze([]) : 0;
const NOOP = () => { };
/**
 * Always return false.
 */
const NO = () => false;
const onRE = /^on[^a-z]/;
const isOn = (key) => onRE.test(key);
const isModelListener = (key) => key.startsWith('onUpdate:');
const extend = Object.assign;
const remove = (arr, el) => {
    const i = arr.indexOf(el);
    if (i > -1) {
        arr.splice(i, 1);
    }
};
const hasOwnProperty = Object.prototype.hasOwnProperty;
const hasOwn = (val, key) => hasOwnProperty.call(val, key);
const isArray = Array.isArray;
const isMap = (val) => toTypeString(val) === '[object Map]';
const isSet = (val) => toTypeString(val) === '[object Set]';
const isDate = (val) => val instanceof Date;
const isFunction = (val) => typeof val === 'function';
const isString = (val) => typeof val === 'string';
const isSymbol = (val) => typeof val === 'symbol';
const isObject = (val) => val !== null && typeof val === 'object';
const isPromise = (val) => {
    return isObject(val) && isFunction(val.then) && isFunction(val.catch);
};
const objectToString = Object.prototype.toString;
const toTypeString = (value) => objectToString.call(value);
const toRawType = (value) => {
    // extract "RawType" from strings like "[object RawType]"
    return toTypeString(value).slice(8, -1);
};
const isPlainObject = (val) => toTypeString(val) === '[object Object]';
const isIntegerKey = (key) => isString(key) &&
    key !== 'NaN' &&
    key[0] !== '-' &&
    '' + parseInt(key, 10) === key;
const isReservedProp = /*#__PURE__*/ makeMap(
// the leading comma is intentional so empty string "" is also included
',key,ref,ref_for,ref_key,' +
    'onVnodeBeforeMount,onVnodeMounted,' +
    'onVnodeBeforeUpdate,onVnodeUpdated,' +
    'onVnodeBeforeUnmount,onVnodeUnmounted');
const isBuiltInDirective = /*#__PURE__*/ makeMap('bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo');
const cacheStringFunction = (fn) => {
    const cache = Object.create(null);
    return ((str) => {
        const hit = cache[str];
        return hit || (cache[str] = fn(str));
    });
};
const camelizeRE = /-(\w)/g;
/**
 * @private
 */
const camelize = cacheStringFunction((str) => {
    return str.replace(camelizeRE, (_, c) => (c ? c.toUpperCase() : ''));
});
const hyphenateRE = /\B([A-Z])/g;
/**
 * @private
 */
const hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, '-$1').toLowerCase());
/**
 * @private
 */
const capitalize = cacheStringFunction((str) => str.charAt(0).toUpperCase() + str.slice(1));
/**
 * @private
 */
const toHandlerKey = cacheStringFunction((str) => str ? `on${capitalize(str)}` : ``);
// compare whether a value has changed, accounting for NaN.
const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
const invokeArrayFns = (fns, arg) => {
    for (let i = 0; i < fns.length; i++) {
        fns[i](arg);
    }
};
const def = (obj, key, value) => {
    Object.defineProperty(obj, key, {
        configurable: true,
        enumerable: false,
        value
    });
};
const toNumber = (val) => {
    const n = parseFloat(val);
    return isNaN(n) ? val : n;
};
let _globalThis;
const getGlobalThis = () => {
    return (_globalThis ||
        (_globalThis =
            typeof globalThis !== 'undefined'
                ? globalThis
                : typeof self !== 'undefined'
                    ? self
                    : typeof window !== 'undefined'
                        ? window
                        : typeof __webpack_require__.g !== 'undefined'
                            ? __webpack_require__.g
                            : {}));
};




/***/ }),

/***/ "./node_modules/alpinejs/dist/module.esm.js":
/*!**************************************************!*\
  !*** ./node_modules/alpinejs/dist/module.esm.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ module_default)
/* harmony export */ });
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
var __commonJS = (callback, module) => () => {
  if (!module) {
    module = {exports: {}};
    callback(module.exports, module);
  }
  return module.exports;
};
var __exportStar = (target, module, desc) => {
  if (module && typeof module === "object" || typeof module === "function") {
    for (let key of __getOwnPropNames(module))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, {get: () => module[key], enumerable: !(desc = __getOwnPropDesc(module, key)) || desc.enumerable});
  }
  return target;
};
var __toModule = (module) => {
  return __exportStar(__markAsModule(__defProp(module != null ? __create(__getProtoOf(module)) : {}, "default", module && module.__esModule && "default" in module ? {get: () => module.default, enumerable: true} : {value: module, enumerable: true})), module);
};

// node_modules/@vue/shared/dist/shared.cjs.js
var require_shared_cjs = __commonJS((exports) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", {value: true});
  function makeMap(str, expectsLowerCase) {
    const map = Object.create(null);
    const list = str.split(",");
    for (let i = 0; i < list.length; i++) {
      map[list[i]] = true;
    }
    return expectsLowerCase ? (val) => !!map[val.toLowerCase()] : (val) => !!map[val];
  }
  var PatchFlagNames = {
    [1]: `TEXT`,
    [2]: `CLASS`,
    [4]: `STYLE`,
    [8]: `PROPS`,
    [16]: `FULL_PROPS`,
    [32]: `HYDRATE_EVENTS`,
    [64]: `STABLE_FRAGMENT`,
    [128]: `KEYED_FRAGMENT`,
    [256]: `UNKEYED_FRAGMENT`,
    [512]: `NEED_PATCH`,
    [1024]: `DYNAMIC_SLOTS`,
    [2048]: `DEV_ROOT_FRAGMENT`,
    [-1]: `HOISTED`,
    [-2]: `BAIL`
  };
  var slotFlagsText = {
    [1]: "STABLE",
    [2]: "DYNAMIC",
    [3]: "FORWARDED"
  };
  var GLOBALS_WHITE_LISTED = "Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt";
  var isGloballyWhitelisted = /* @__PURE__ */ makeMap(GLOBALS_WHITE_LISTED);
  var range = 2;
  function generateCodeFrame(source, start2 = 0, end = source.length) {
    const lines = source.split(/\r?\n/);
    let count = 0;
    const res = [];
    for (let i = 0; i < lines.length; i++) {
      count += lines[i].length + 1;
      if (count >= start2) {
        for (let j = i - range; j <= i + range || end > count; j++) {
          if (j < 0 || j >= lines.length)
            continue;
          const line = j + 1;
          res.push(`${line}${" ".repeat(Math.max(3 - String(line).length, 0))}|  ${lines[j]}`);
          const lineLength = lines[j].length;
          if (j === i) {
            const pad = start2 - (count - lineLength) + 1;
            const length = Math.max(1, end > count ? lineLength - pad : end - start2);
            res.push(`   |  ` + " ".repeat(pad) + "^".repeat(length));
          } else if (j > i) {
            if (end > count) {
              const length = Math.max(Math.min(end - count, lineLength), 1);
              res.push(`   |  ` + "^".repeat(length));
            }
            count += lineLength + 1;
          }
        }
        break;
      }
    }
    return res.join("\n");
  }
  var specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
  var isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
  var isBooleanAttr2 = /* @__PURE__ */ makeMap(specialBooleanAttrs + `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected`);
  var unsafeAttrCharRE = /[>/="'\u0009\u000a\u000c\u0020]/;
  var attrValidationCache = {};
  function isSSRSafeAttrName(name) {
    if (attrValidationCache.hasOwnProperty(name)) {
      return attrValidationCache[name];
    }
    const isUnsafe = unsafeAttrCharRE.test(name);
    if (isUnsafe) {
      console.error(`unsafe attribute name: ${name}`);
    }
    return attrValidationCache[name] = !isUnsafe;
  }
  var propsToAttrMap = {
    acceptCharset: "accept-charset",
    className: "class",
    htmlFor: "for",
    httpEquiv: "http-equiv"
  };
  var isNoUnitNumericStyleProp = /* @__PURE__ */ makeMap(`animation-iteration-count,border-image-outset,border-image-slice,border-image-width,box-flex,box-flex-group,box-ordinal-group,column-count,columns,flex,flex-grow,flex-positive,flex-shrink,flex-negative,flex-order,grid-row,grid-row-end,grid-row-span,grid-row-start,grid-column,grid-column-end,grid-column-span,grid-column-start,font-weight,line-clamp,line-height,opacity,order,orphans,tab-size,widows,z-index,zoom,fill-opacity,flood-opacity,stop-opacity,stroke-dasharray,stroke-dashoffset,stroke-miterlimit,stroke-opacity,stroke-width`);
  var isKnownAttr = /* @__PURE__ */ makeMap(`accept,accept-charset,accesskey,action,align,allow,alt,async,autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,border,buffered,capture,challenge,charset,checked,cite,class,code,codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,formaction,formenctype,formmethod,formnovalidate,formtarget,headers,height,hidden,high,href,hreflang,http-equiv,icon,id,importance,integrity,ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,start,step,style,summary,tabindex,target,title,translate,type,usemap,value,width,wrap`);
  function normalizeStyle(value) {
    if (isArray(value)) {
      const res = {};
      for (let i = 0; i < value.length; i++) {
        const item = value[i];
        const normalized = normalizeStyle(isString(item) ? parseStringStyle(item) : item);
        if (normalized) {
          for (const key in normalized) {
            res[key] = normalized[key];
          }
        }
      }
      return res;
    } else if (isObject(value)) {
      return value;
    }
  }
  var listDelimiterRE = /;(?![^(]*\))/g;
  var propertyDelimiterRE = /:(.+)/;
  function parseStringStyle(cssText) {
    const ret = {};
    cssText.split(listDelimiterRE).forEach((item) => {
      if (item) {
        const tmp = item.split(propertyDelimiterRE);
        tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
      }
    });
    return ret;
  }
  function stringifyStyle(styles) {
    let ret = "";
    if (!styles) {
      return ret;
    }
    for (const key in styles) {
      const value = styles[key];
      const normalizedKey = key.startsWith(`--`) ? key : hyphenate(key);
      if (isString(value) || typeof value === "number" && isNoUnitNumericStyleProp(normalizedKey)) {
        ret += `${normalizedKey}:${value};`;
      }
    }
    return ret;
  }
  function normalizeClass(value) {
    let res = "";
    if (isString(value)) {
      res = value;
    } else if (isArray(value)) {
      for (let i = 0; i < value.length; i++) {
        const normalized = normalizeClass(value[i]);
        if (normalized) {
          res += normalized + " ";
        }
      }
    } else if (isObject(value)) {
      for (const name in value) {
        if (value[name]) {
          res += name + " ";
        }
      }
    }
    return res.trim();
  }
  var HTML_TAGS = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot";
  var SVG_TAGS = "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistanceLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view";
  var VOID_TAGS = "area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr";
  var isHTMLTag = /* @__PURE__ */ makeMap(HTML_TAGS);
  var isSVGTag = /* @__PURE__ */ makeMap(SVG_TAGS);
  var isVoidTag = /* @__PURE__ */ makeMap(VOID_TAGS);
  var escapeRE = /["'&<>]/;
  function escapeHtml(string) {
    const str = "" + string;
    const match = escapeRE.exec(str);
    if (!match) {
      return str;
    }
    let html = "";
    let escaped;
    let index;
    let lastIndex = 0;
    for (index = match.index; index < str.length; index++) {
      switch (str.charCodeAt(index)) {
        case 34:
          escaped = "&quot;";
          break;
        case 38:
          escaped = "&amp;";
          break;
        case 39:
          escaped = "&#39;";
          break;
        case 60:
          escaped = "&lt;";
          break;
        case 62:
          escaped = "&gt;";
          break;
        default:
          continue;
      }
      if (lastIndex !== index) {
        html += str.substring(lastIndex, index);
      }
      lastIndex = index + 1;
      html += escaped;
    }
    return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
  }
  var commentStripRE = /^-?>|<!--|-->|--!>|<!-$/g;
  function escapeHtmlComment(src) {
    return src.replace(commentStripRE, "");
  }
  function looseCompareArrays(a, b) {
    if (a.length !== b.length)
      return false;
    let equal = true;
    for (let i = 0; equal && i < a.length; i++) {
      equal = looseEqual(a[i], b[i]);
    }
    return equal;
  }
  function looseEqual(a, b) {
    if (a === b)
      return true;
    let aValidType = isDate(a);
    let bValidType = isDate(b);
    if (aValidType || bValidType) {
      return aValidType && bValidType ? a.getTime() === b.getTime() : false;
    }
    aValidType = isArray(a);
    bValidType = isArray(b);
    if (aValidType || bValidType) {
      return aValidType && bValidType ? looseCompareArrays(a, b) : false;
    }
    aValidType = isObject(a);
    bValidType = isObject(b);
    if (aValidType || bValidType) {
      if (!aValidType || !bValidType) {
        return false;
      }
      const aKeysCount = Object.keys(a).length;
      const bKeysCount = Object.keys(b).length;
      if (aKeysCount !== bKeysCount) {
        return false;
      }
      for (const key in a) {
        const aHasKey = a.hasOwnProperty(key);
        const bHasKey = b.hasOwnProperty(key);
        if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a[key], b[key])) {
          return false;
        }
      }
    }
    return String(a) === String(b);
  }
  function looseIndexOf(arr, val) {
    return arr.findIndex((item) => looseEqual(item, val));
  }
  var toDisplayString = (val) => {
    return val == null ? "" : isObject(val) ? JSON.stringify(val, replacer, 2) : String(val);
  };
  var replacer = (_key, val) => {
    if (isMap(val)) {
      return {
        [`Map(${val.size})`]: [...val.entries()].reduce((entries, [key, val2]) => {
          entries[`${key} =>`] = val2;
          return entries;
        }, {})
      };
    } else if (isSet(val)) {
      return {
        [`Set(${val.size})`]: [...val.values()]
      };
    } else if (isObject(val) && !isArray(val) && !isPlainObject(val)) {
      return String(val);
    }
    return val;
  };
  var babelParserDefaultPlugins = [
    "bigInt",
    "optionalChaining",
    "nullishCoalescingOperator"
  ];
  var EMPTY_OBJ = Object.freeze({});
  var EMPTY_ARR = Object.freeze([]);
  var NOOP = () => {
  };
  var NO = () => false;
  var onRE = /^on[^a-z]/;
  var isOn = (key) => onRE.test(key);
  var isModelListener = (key) => key.startsWith("onUpdate:");
  var extend = Object.assign;
  var remove = (arr, el) => {
    const i = arr.indexOf(el);
    if (i > -1) {
      arr.splice(i, 1);
    }
  };
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var hasOwn = (val, key) => hasOwnProperty.call(val, key);
  var isArray = Array.isArray;
  var isMap = (val) => toTypeString(val) === "[object Map]";
  var isSet = (val) => toTypeString(val) === "[object Set]";
  var isDate = (val) => val instanceof Date;
  var isFunction = (val) => typeof val === "function";
  var isString = (val) => typeof val === "string";
  var isSymbol = (val) => typeof val === "symbol";
  var isObject = (val) => val !== null && typeof val === "object";
  var isPromise = (val) => {
    return isObject(val) && isFunction(val.then) && isFunction(val.catch);
  };
  var objectToString = Object.prototype.toString;
  var toTypeString = (value) => objectToString.call(value);
  var toRawType = (value) => {
    return toTypeString(value).slice(8, -1);
  };
  var isPlainObject = (val) => toTypeString(val) === "[object Object]";
  var isIntegerKey = (key) => isString(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
  var isReservedProp = /* @__PURE__ */ makeMap(",key,ref,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted");
  var cacheStringFunction = (fn) => {
    const cache = Object.create(null);
    return (str) => {
      const hit = cache[str];
      return hit || (cache[str] = fn(str));
    };
  };
  var camelizeRE = /-(\w)/g;
  var camelize = cacheStringFunction((str) => {
    return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : "");
  });
  var hyphenateRE = /\B([A-Z])/g;
  var hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, "-$1").toLowerCase());
  var capitalize = cacheStringFunction((str) => str.charAt(0).toUpperCase() + str.slice(1));
  var toHandlerKey = cacheStringFunction((str) => str ? `on${capitalize(str)}` : ``);
  var hasChanged = (value, oldValue) => value !== oldValue && (value === value || oldValue === oldValue);
  var invokeArrayFns = (fns, arg) => {
    for (let i = 0; i < fns.length; i++) {
      fns[i](arg);
    }
  };
  var def = (obj, key, value) => {
    Object.defineProperty(obj, key, {
      configurable: true,
      enumerable: false,
      value
    });
  };
  var toNumber = (val) => {
    const n = parseFloat(val);
    return isNaN(n) ? val : n;
  };
  var _globalThis;
  var getGlobalThis = () => {
    return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof __webpack_require__.g !== "undefined" ? __webpack_require__.g : {});
  };
  exports.EMPTY_ARR = EMPTY_ARR;
  exports.EMPTY_OBJ = EMPTY_OBJ;
  exports.NO = NO;
  exports.NOOP = NOOP;
  exports.PatchFlagNames = PatchFlagNames;
  exports.babelParserDefaultPlugins = babelParserDefaultPlugins;
  exports.camelize = camelize;
  exports.capitalize = capitalize;
  exports.def = def;
  exports.escapeHtml = escapeHtml;
  exports.escapeHtmlComment = escapeHtmlComment;
  exports.extend = extend;
  exports.generateCodeFrame = generateCodeFrame;
  exports.getGlobalThis = getGlobalThis;
  exports.hasChanged = hasChanged;
  exports.hasOwn = hasOwn;
  exports.hyphenate = hyphenate;
  exports.invokeArrayFns = invokeArrayFns;
  exports.isArray = isArray;
  exports.isBooleanAttr = isBooleanAttr2;
  exports.isDate = isDate;
  exports.isFunction = isFunction;
  exports.isGloballyWhitelisted = isGloballyWhitelisted;
  exports.isHTMLTag = isHTMLTag;
  exports.isIntegerKey = isIntegerKey;
  exports.isKnownAttr = isKnownAttr;
  exports.isMap = isMap;
  exports.isModelListener = isModelListener;
  exports.isNoUnitNumericStyleProp = isNoUnitNumericStyleProp;
  exports.isObject = isObject;
  exports.isOn = isOn;
  exports.isPlainObject = isPlainObject;
  exports.isPromise = isPromise;
  exports.isReservedProp = isReservedProp;
  exports.isSSRSafeAttrName = isSSRSafeAttrName;
  exports.isSVGTag = isSVGTag;
  exports.isSet = isSet;
  exports.isSpecialBooleanAttr = isSpecialBooleanAttr;
  exports.isString = isString;
  exports.isSymbol = isSymbol;
  exports.isVoidTag = isVoidTag;
  exports.looseEqual = looseEqual;
  exports.looseIndexOf = looseIndexOf;
  exports.makeMap = makeMap;
  exports.normalizeClass = normalizeClass;
  exports.normalizeStyle = normalizeStyle;
  exports.objectToString = objectToString;
  exports.parseStringStyle = parseStringStyle;
  exports.propsToAttrMap = propsToAttrMap;
  exports.remove = remove;
  exports.slotFlagsText = slotFlagsText;
  exports.stringifyStyle = stringifyStyle;
  exports.toDisplayString = toDisplayString;
  exports.toHandlerKey = toHandlerKey;
  exports.toNumber = toNumber;
  exports.toRawType = toRawType;
  exports.toTypeString = toTypeString;
});

// node_modules/@vue/shared/index.js
var require_shared = __commonJS((exports, module) => {
  "use strict";
  if (false) {} else {
    module.exports = require_shared_cjs();
  }
});

// node_modules/@vue/reactivity/dist/reactivity.cjs.js
var require_reactivity_cjs = __commonJS((exports) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", {value: true});
  var shared = require_shared();
  var targetMap = new WeakMap();
  var effectStack = [];
  var activeEffect;
  var ITERATE_KEY = Symbol("iterate");
  var MAP_KEY_ITERATE_KEY = Symbol("Map key iterate");
  function isEffect(fn) {
    return fn && fn._isEffect === true;
  }
  function effect3(fn, options = shared.EMPTY_OBJ) {
    if (isEffect(fn)) {
      fn = fn.raw;
    }
    const effect4 = createReactiveEffect(fn, options);
    if (!options.lazy) {
      effect4();
    }
    return effect4;
  }
  function stop2(effect4) {
    if (effect4.active) {
      cleanup(effect4);
      if (effect4.options.onStop) {
        effect4.options.onStop();
      }
      effect4.active = false;
    }
  }
  var uid = 0;
  function createReactiveEffect(fn, options) {
    const effect4 = function reactiveEffect() {
      if (!effect4.active) {
        return fn();
      }
      if (!effectStack.includes(effect4)) {
        cleanup(effect4);
        try {
          enableTracking();
          effectStack.push(effect4);
          activeEffect = effect4;
          return fn();
        } finally {
          effectStack.pop();
          resetTracking();
          activeEffect = effectStack[effectStack.length - 1];
        }
      }
    };
    effect4.id = uid++;
    effect4.allowRecurse = !!options.allowRecurse;
    effect4._isEffect = true;
    effect4.active = true;
    effect4.raw = fn;
    effect4.deps = [];
    effect4.options = options;
    return effect4;
  }
  function cleanup(effect4) {
    const {deps} = effect4;
    if (deps.length) {
      for (let i = 0; i < deps.length; i++) {
        deps[i].delete(effect4);
      }
      deps.length = 0;
    }
  }
  var shouldTrack = true;
  var trackStack = [];
  function pauseTracking() {
    trackStack.push(shouldTrack);
    shouldTrack = false;
  }
  function enableTracking() {
    trackStack.push(shouldTrack);
    shouldTrack = true;
  }
  function resetTracking() {
    const last = trackStack.pop();
    shouldTrack = last === void 0 ? true : last;
  }
  function track(target, type, key) {
    if (!shouldTrack || activeEffect === void 0) {
      return;
    }
    let depsMap = targetMap.get(target);
    if (!depsMap) {
      targetMap.set(target, depsMap = new Map());
    }
    let dep = depsMap.get(key);
    if (!dep) {
      depsMap.set(key, dep = new Set());
    }
    if (!dep.has(activeEffect)) {
      dep.add(activeEffect);
      activeEffect.deps.push(dep);
      if (activeEffect.options.onTrack) {
        activeEffect.options.onTrack({
          effect: activeEffect,
          target,
          type,
          key
        });
      }
    }
  }
  function trigger(target, type, key, newValue, oldValue, oldTarget) {
    const depsMap = targetMap.get(target);
    if (!depsMap) {
      return;
    }
    const effects = new Set();
    const add2 = (effectsToAdd) => {
      if (effectsToAdd) {
        effectsToAdd.forEach((effect4) => {
          if (effect4 !== activeEffect || effect4.allowRecurse) {
            effects.add(effect4);
          }
        });
      }
    };
    if (type === "clear") {
      depsMap.forEach(add2);
    } else if (key === "length" && shared.isArray(target)) {
      depsMap.forEach((dep, key2) => {
        if (key2 === "length" || key2 >= newValue) {
          add2(dep);
        }
      });
    } else {
      if (key !== void 0) {
        add2(depsMap.get(key));
      }
      switch (type) {
        case "add":
          if (!shared.isArray(target)) {
            add2(depsMap.get(ITERATE_KEY));
            if (shared.isMap(target)) {
              add2(depsMap.get(MAP_KEY_ITERATE_KEY));
            }
          } else if (shared.isIntegerKey(key)) {
            add2(depsMap.get("length"));
          }
          break;
        case "delete":
          if (!shared.isArray(target)) {
            add2(depsMap.get(ITERATE_KEY));
            if (shared.isMap(target)) {
              add2(depsMap.get(MAP_KEY_ITERATE_KEY));
            }
          }
          break;
        case "set":
          if (shared.isMap(target)) {
            add2(depsMap.get(ITERATE_KEY));
          }
          break;
      }
    }
    const run = (effect4) => {
      if (effect4.options.onTrigger) {
        effect4.options.onTrigger({
          effect: effect4,
          target,
          key,
          type,
          newValue,
          oldValue,
          oldTarget
        });
      }
      if (effect4.options.scheduler) {
        effect4.options.scheduler(effect4);
      } else {
        effect4();
      }
    };
    effects.forEach(run);
  }
  var isNonTrackableKeys = /* @__PURE__ */ shared.makeMap(`__proto__,__v_isRef,__isVue`);
  var builtInSymbols = new Set(Object.getOwnPropertyNames(Symbol).map((key) => Symbol[key]).filter(shared.isSymbol));
  var get2 = /* @__PURE__ */ createGetter();
  var shallowGet = /* @__PURE__ */ createGetter(false, true);
  var readonlyGet = /* @__PURE__ */ createGetter(true);
  var shallowReadonlyGet = /* @__PURE__ */ createGetter(true, true);
  var arrayInstrumentations = {};
  ["includes", "indexOf", "lastIndexOf"].forEach((key) => {
    const method = Array.prototype[key];
    arrayInstrumentations[key] = function(...args) {
      const arr = toRaw2(this);
      for (let i = 0, l = this.length; i < l; i++) {
        track(arr, "get", i + "");
      }
      const res = method.apply(arr, args);
      if (res === -1 || res === false) {
        return method.apply(arr, args.map(toRaw2));
      } else {
        return res;
      }
    };
  });
  ["push", "pop", "shift", "unshift", "splice"].forEach((key) => {
    const method = Array.prototype[key];
    arrayInstrumentations[key] = function(...args) {
      pauseTracking();
      const res = method.apply(this, args);
      resetTracking();
      return res;
    };
  });
  function createGetter(isReadonly2 = false, shallow = false) {
    return function get3(target, key, receiver) {
      if (key === "__v_isReactive") {
        return !isReadonly2;
      } else if (key === "__v_isReadonly") {
        return isReadonly2;
      } else if (key === "__v_raw" && receiver === (isReadonly2 ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target)) {
        return target;
      }
      const targetIsArray = shared.isArray(target);
      if (!isReadonly2 && targetIsArray && shared.hasOwn(arrayInstrumentations, key)) {
        return Reflect.get(arrayInstrumentations, key, receiver);
      }
      const res = Reflect.get(target, key, receiver);
      if (shared.isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
        return res;
      }
      if (!isReadonly2) {
        track(target, "get", key);
      }
      if (shallow) {
        return res;
      }
      if (isRef(res)) {
        const shouldUnwrap = !targetIsArray || !shared.isIntegerKey(key);
        return shouldUnwrap ? res.value : res;
      }
      if (shared.isObject(res)) {
        return isReadonly2 ? readonly(res) : reactive3(res);
      }
      return res;
    };
  }
  var set2 = /* @__PURE__ */ createSetter();
  var shallowSet = /* @__PURE__ */ createSetter(true);
  function createSetter(shallow = false) {
    return function set3(target, key, value, receiver) {
      let oldValue = target[key];
      if (!shallow) {
        value = toRaw2(value);
        oldValue = toRaw2(oldValue);
        if (!shared.isArray(target) && isRef(oldValue) && !isRef(value)) {
          oldValue.value = value;
          return true;
        }
      }
      const hadKey = shared.isArray(target) && shared.isIntegerKey(key) ? Number(key) < target.length : shared.hasOwn(target, key);
      const result = Reflect.set(target, key, value, receiver);
      if (target === toRaw2(receiver)) {
        if (!hadKey) {
          trigger(target, "add", key, value);
        } else if (shared.hasChanged(value, oldValue)) {
          trigger(target, "set", key, value, oldValue);
        }
      }
      return result;
    };
  }
  function deleteProperty(target, key) {
    const hadKey = shared.hasOwn(target, key);
    const oldValue = target[key];
    const result = Reflect.deleteProperty(target, key);
    if (result && hadKey) {
      trigger(target, "delete", key, void 0, oldValue);
    }
    return result;
  }
  function has(target, key) {
    const result = Reflect.has(target, key);
    if (!shared.isSymbol(key) || !builtInSymbols.has(key)) {
      track(target, "has", key);
    }
    return result;
  }
  function ownKeys(target) {
    track(target, "iterate", shared.isArray(target) ? "length" : ITERATE_KEY);
    return Reflect.ownKeys(target);
  }
  var mutableHandlers = {
    get: get2,
    set: set2,
    deleteProperty,
    has,
    ownKeys
  };
  var readonlyHandlers = {
    get: readonlyGet,
    set(target, key) {
      {
        console.warn(`Set operation on key "${String(key)}" failed: target is readonly.`, target);
      }
      return true;
    },
    deleteProperty(target, key) {
      {
        console.warn(`Delete operation on key "${String(key)}" failed: target is readonly.`, target);
      }
      return true;
    }
  };
  var shallowReactiveHandlers = shared.extend({}, mutableHandlers, {
    get: shallowGet,
    set: shallowSet
  });
  var shallowReadonlyHandlers = shared.extend({}, readonlyHandlers, {
    get: shallowReadonlyGet
  });
  var toReactive = (value) => shared.isObject(value) ? reactive3(value) : value;
  var toReadonly = (value) => shared.isObject(value) ? readonly(value) : value;
  var toShallow = (value) => value;
  var getProto = (v) => Reflect.getPrototypeOf(v);
  function get$1(target, key, isReadonly2 = false, isShallow = false) {
    target = target["__v_raw"];
    const rawTarget = toRaw2(target);
    const rawKey = toRaw2(key);
    if (key !== rawKey) {
      !isReadonly2 && track(rawTarget, "get", key);
    }
    !isReadonly2 && track(rawTarget, "get", rawKey);
    const {has: has2} = getProto(rawTarget);
    const wrap = isShallow ? toShallow : isReadonly2 ? toReadonly : toReactive;
    if (has2.call(rawTarget, key)) {
      return wrap(target.get(key));
    } else if (has2.call(rawTarget, rawKey)) {
      return wrap(target.get(rawKey));
    } else if (target !== rawTarget) {
      target.get(key);
    }
  }
  function has$1(key, isReadonly2 = false) {
    const target = this["__v_raw"];
    const rawTarget = toRaw2(target);
    const rawKey = toRaw2(key);
    if (key !== rawKey) {
      !isReadonly2 && track(rawTarget, "has", key);
    }
    !isReadonly2 && track(rawTarget, "has", rawKey);
    return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
  }
  function size(target, isReadonly2 = false) {
    target = target["__v_raw"];
    !isReadonly2 && track(toRaw2(target), "iterate", ITERATE_KEY);
    return Reflect.get(target, "size", target);
  }
  function add(value) {
    value = toRaw2(value);
    const target = toRaw2(this);
    const proto = getProto(target);
    const hadKey = proto.has.call(target, value);
    if (!hadKey) {
      target.add(value);
      trigger(target, "add", value, value);
    }
    return this;
  }
  function set$1(key, value) {
    value = toRaw2(value);
    const target = toRaw2(this);
    const {has: has2, get: get3} = getProto(target);
    let hadKey = has2.call(target, key);
    if (!hadKey) {
      key = toRaw2(key);
      hadKey = has2.call(target, key);
    } else {
      checkIdentityKeys(target, has2, key);
    }
    const oldValue = get3.call(target, key);
    target.set(key, value);
    if (!hadKey) {
      trigger(target, "add", key, value);
    } else if (shared.hasChanged(value, oldValue)) {
      trigger(target, "set", key, value, oldValue);
    }
    return this;
  }
  function deleteEntry(key) {
    const target = toRaw2(this);
    const {has: has2, get: get3} = getProto(target);
    let hadKey = has2.call(target, key);
    if (!hadKey) {
      key = toRaw2(key);
      hadKey = has2.call(target, key);
    } else {
      checkIdentityKeys(target, has2, key);
    }
    const oldValue = get3 ? get3.call(target, key) : void 0;
    const result = target.delete(key);
    if (hadKey) {
      trigger(target, "delete", key, void 0, oldValue);
    }
    return result;
  }
  function clear() {
    const target = toRaw2(this);
    const hadItems = target.size !== 0;
    const oldTarget = shared.isMap(target) ? new Map(target) : new Set(target);
    const result = target.clear();
    if (hadItems) {
      trigger(target, "clear", void 0, void 0, oldTarget);
    }
    return result;
  }
  function createForEach(isReadonly2, isShallow) {
    return function forEach(callback, thisArg) {
      const observed = this;
      const target = observed["__v_raw"];
      const rawTarget = toRaw2(target);
      const wrap = isShallow ? toShallow : isReadonly2 ? toReadonly : toReactive;
      !isReadonly2 && track(rawTarget, "iterate", ITERATE_KEY);
      return target.forEach((value, key) => {
        return callback.call(thisArg, wrap(value), wrap(key), observed);
      });
    };
  }
  function createIterableMethod(method, isReadonly2, isShallow) {
    return function(...args) {
      const target = this["__v_raw"];
      const rawTarget = toRaw2(target);
      const targetIsMap = shared.isMap(rawTarget);
      const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
      const isKeyOnly = method === "keys" && targetIsMap;
      const innerIterator = target[method](...args);
      const wrap = isShallow ? toShallow : isReadonly2 ? toReadonly : toReactive;
      !isReadonly2 && track(rawTarget, "iterate", isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);
      return {
        next() {
          const {value, done} = innerIterator.next();
          return done ? {value, done} : {
            value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
            done
          };
        },
        [Symbol.iterator]() {
          return this;
        }
      };
    };
  }
  function createReadonlyMethod(type) {
    return function(...args) {
      {
        const key = args[0] ? `on key "${args[0]}" ` : ``;
        console.warn(`${shared.capitalize(type)} operation ${key}failed: target is readonly.`, toRaw2(this));
      }
      return type === "delete" ? false : this;
    };
  }
  var mutableInstrumentations = {
    get(key) {
      return get$1(this, key);
    },
    get size() {
      return size(this);
    },
    has: has$1,
    add,
    set: set$1,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, false)
  };
  var shallowInstrumentations = {
    get(key) {
      return get$1(this, key, false, true);
    },
    get size() {
      return size(this);
    },
    has: has$1,
    add,
    set: set$1,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, true)
  };
  var readonlyInstrumentations = {
    get(key) {
      return get$1(this, key, true);
    },
    get size() {
      return size(this, true);
    },
    has(key) {
      return has$1.call(this, key, true);
    },
    add: createReadonlyMethod("add"),
    set: createReadonlyMethod("set"),
    delete: createReadonlyMethod("delete"),
    clear: createReadonlyMethod("clear"),
    forEach: createForEach(true, false)
  };
  var shallowReadonlyInstrumentations = {
    get(key) {
      return get$1(this, key, true, true);
    },
    get size() {
      return size(this, true);
    },
    has(key) {
      return has$1.call(this, key, true);
    },
    add: createReadonlyMethod("add"),
    set: createReadonlyMethod("set"),
    delete: createReadonlyMethod("delete"),
    clear: createReadonlyMethod("clear"),
    forEach: createForEach(true, true)
  };
  var iteratorMethods = ["keys", "values", "entries", Symbol.iterator];
  iteratorMethods.forEach((method) => {
    mutableInstrumentations[method] = createIterableMethod(method, false, false);
    readonlyInstrumentations[method] = createIterableMethod(method, true, false);
    shallowInstrumentations[method] = createIterableMethod(method, false, true);
    shallowReadonlyInstrumentations[method] = createIterableMethod(method, true, true);
  });
  function createInstrumentationGetter(isReadonly2, shallow) {
    const instrumentations = shallow ? isReadonly2 ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly2 ? readonlyInstrumentations : mutableInstrumentations;
    return (target, key, receiver) => {
      if (key === "__v_isReactive") {
        return !isReadonly2;
      } else if (key === "__v_isReadonly") {
        return isReadonly2;
      } else if (key === "__v_raw") {
        return target;
      }
      return Reflect.get(shared.hasOwn(instrumentations, key) && key in target ? instrumentations : target, key, receiver);
    };
  }
  var mutableCollectionHandlers = {
    get: createInstrumentationGetter(false, false)
  };
  var shallowCollectionHandlers = {
    get: createInstrumentationGetter(false, true)
  };
  var readonlyCollectionHandlers = {
    get: createInstrumentationGetter(true, false)
  };
  var shallowReadonlyCollectionHandlers = {
    get: createInstrumentationGetter(true, true)
  };
  function checkIdentityKeys(target, has2, key) {
    const rawKey = toRaw2(key);
    if (rawKey !== key && has2.call(target, rawKey)) {
      const type = shared.toRawType(target);
      console.warn(`Reactive ${type} contains both the raw and reactive versions of the same object${type === `Map` ? ` as keys` : ``}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`);
    }
  }
  var reactiveMap = new WeakMap();
  var shallowReactiveMap = new WeakMap();
  var readonlyMap = new WeakMap();
  var shallowReadonlyMap = new WeakMap();
  function targetTypeMap(rawType) {
    switch (rawType) {
      case "Object":
      case "Array":
        return 1;
      case "Map":
      case "Set":
      case "WeakMap":
      case "WeakSet":
        return 2;
      default:
        return 0;
    }
  }
  function getTargetType(value) {
    return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap(shared.toRawType(value));
  }
  function reactive3(target) {
    if (target && target["__v_isReadonly"]) {
      return target;
    }
    return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);
  }
  function shallowReactive(target) {
    return createReactiveObject(target, false, shallowReactiveHandlers, shallowCollectionHandlers, shallowReactiveMap);
  }
  function readonly(target) {
    return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);
  }
  function shallowReadonly(target) {
    return createReactiveObject(target, true, shallowReadonlyHandlers, shallowReadonlyCollectionHandlers, shallowReadonlyMap);
  }
  function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
    if (!shared.isObject(target)) {
      {
        console.warn(`value cannot be made reactive: ${String(target)}`);
      }
      return target;
    }
    if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
      return target;
    }
    const existingProxy = proxyMap.get(target);
    if (existingProxy) {
      return existingProxy;
    }
    const targetType = getTargetType(target);
    if (targetType === 0) {
      return target;
    }
    const proxy = new Proxy(target, targetType === 2 ? collectionHandlers : baseHandlers);
    proxyMap.set(target, proxy);
    return proxy;
  }
  function isReactive2(value) {
    if (isReadonly(value)) {
      return isReactive2(value["__v_raw"]);
    }
    return !!(value && value["__v_isReactive"]);
  }
  function isReadonly(value) {
    return !!(value && value["__v_isReadonly"]);
  }
  function isProxy(value) {
    return isReactive2(value) || isReadonly(value);
  }
  function toRaw2(observed) {
    return observed && toRaw2(observed["__v_raw"]) || observed;
  }
  function markRaw(value) {
    shared.def(value, "__v_skip", true);
    return value;
  }
  var convert = (val) => shared.isObject(val) ? reactive3(val) : val;
  function isRef(r) {
    return Boolean(r && r.__v_isRef === true);
  }
  function ref(value) {
    return createRef(value);
  }
  function shallowRef(value) {
    return createRef(value, true);
  }
  var RefImpl = class {
    constructor(_rawValue, _shallow = false) {
      this._rawValue = _rawValue;
      this._shallow = _shallow;
      this.__v_isRef = true;
      this._value = _shallow ? _rawValue : convert(_rawValue);
    }
    get value() {
      track(toRaw2(this), "get", "value");
      return this._value;
    }
    set value(newVal) {
      if (shared.hasChanged(toRaw2(newVal), this._rawValue)) {
        this._rawValue = newVal;
        this._value = this._shallow ? newVal : convert(newVal);
        trigger(toRaw2(this), "set", "value", newVal);
      }
    }
  };
  function createRef(rawValue, shallow = false) {
    if (isRef(rawValue)) {
      return rawValue;
    }
    return new RefImpl(rawValue, shallow);
  }
  function triggerRef(ref2) {
    trigger(toRaw2(ref2), "set", "value", ref2.value);
  }
  function unref(ref2) {
    return isRef(ref2) ? ref2.value : ref2;
  }
  var shallowUnwrapHandlers = {
    get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),
    set: (target, key, value, receiver) => {
      const oldValue = target[key];
      if (isRef(oldValue) && !isRef(value)) {
        oldValue.value = value;
        return true;
      } else {
        return Reflect.set(target, key, value, receiver);
      }
    }
  };
  function proxyRefs(objectWithRefs) {
    return isReactive2(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
  }
  var CustomRefImpl = class {
    constructor(factory) {
      this.__v_isRef = true;
      const {get: get3, set: set3} = factory(() => track(this, "get", "value"), () => trigger(this, "set", "value"));
      this._get = get3;
      this._set = set3;
    }
    get value() {
      return this._get();
    }
    set value(newVal) {
      this._set(newVal);
    }
  };
  function customRef(factory) {
    return new CustomRefImpl(factory);
  }
  function toRefs(object) {
    if (!isProxy(object)) {
      console.warn(`toRefs() expects a reactive object but received a plain one.`);
    }
    const ret = shared.isArray(object) ? new Array(object.length) : {};
    for (const key in object) {
      ret[key] = toRef(object, key);
    }
    return ret;
  }
  var ObjectRefImpl = class {
    constructor(_object, _key) {
      this._object = _object;
      this._key = _key;
      this.__v_isRef = true;
    }
    get value() {
      return this._object[this._key];
    }
    set value(newVal) {
      this._object[this._key] = newVal;
    }
  };
  function toRef(object, key) {
    return isRef(object[key]) ? object[key] : new ObjectRefImpl(object, key);
  }
  var ComputedRefImpl = class {
    constructor(getter, _setter, isReadonly2) {
      this._setter = _setter;
      this._dirty = true;
      this.__v_isRef = true;
      this.effect = effect3(getter, {
        lazy: true,
        scheduler: () => {
          if (!this._dirty) {
            this._dirty = true;
            trigger(toRaw2(this), "set", "value");
          }
        }
      });
      this["__v_isReadonly"] = isReadonly2;
    }
    get value() {
      const self2 = toRaw2(this);
      if (self2._dirty) {
        self2._value = this.effect();
        self2._dirty = false;
      }
      track(self2, "get", "value");
      return self2._value;
    }
    set value(newValue) {
      this._setter(newValue);
    }
  };
  function computed(getterOrOptions) {
    let getter;
    let setter;
    if (shared.isFunction(getterOrOptions)) {
      getter = getterOrOptions;
      setter = () => {
        console.warn("Write operation failed: computed value is readonly");
      };
    } else {
      getter = getterOrOptions.get;
      setter = getterOrOptions.set;
    }
    return new ComputedRefImpl(getter, setter, shared.isFunction(getterOrOptions) || !getterOrOptions.set);
  }
  exports.ITERATE_KEY = ITERATE_KEY;
  exports.computed = computed;
  exports.customRef = customRef;
  exports.effect = effect3;
  exports.enableTracking = enableTracking;
  exports.isProxy = isProxy;
  exports.isReactive = isReactive2;
  exports.isReadonly = isReadonly;
  exports.isRef = isRef;
  exports.markRaw = markRaw;
  exports.pauseTracking = pauseTracking;
  exports.proxyRefs = proxyRefs;
  exports.reactive = reactive3;
  exports.readonly = readonly;
  exports.ref = ref;
  exports.resetTracking = resetTracking;
  exports.shallowReactive = shallowReactive;
  exports.shallowReadonly = shallowReadonly;
  exports.shallowRef = shallowRef;
  exports.stop = stop2;
  exports.toRaw = toRaw2;
  exports.toRef = toRef;
  exports.toRefs = toRefs;
  exports.track = track;
  exports.trigger = trigger;
  exports.triggerRef = triggerRef;
  exports.unref = unref;
});

// node_modules/@vue/reactivity/index.js
var require_reactivity = __commonJS((exports, module) => {
  "use strict";
  if (false) {} else {
    module.exports = require_reactivity_cjs();
  }
});

// packages/alpinejs/src/scheduler.js
var flushPending = false;
var flushing = false;
var queue = [];
function scheduler(callback) {
  queueJob(callback);
}
function queueJob(job) {
  if (!queue.includes(job))
    queue.push(job);
  queueFlush();
}
function dequeueJob(job) {
  const index = queue.indexOf(job);
  if (index !== -1) {
    queue.splice(index, 1);
  }
}
function queueFlush() {
  if (!flushing && !flushPending) {
    flushPending = true;
    queueMicrotask(flushJobs);
  }
}
function flushJobs() {
  flushPending = false;
  flushing = true;
  for (let i = 0; i < queue.length; i++) {
    queue[i]();
  }
  queue.length = 0;
  flushing = false;
}

// packages/alpinejs/src/reactivity.js
var reactive;
var effect;
var release;
var raw;
var shouldSchedule = true;
function disableEffectScheduling(callback) {
  shouldSchedule = false;
  callback();
  shouldSchedule = true;
}
function setReactivityEngine(engine) {
  reactive = engine.reactive;
  release = engine.release;
  effect = (callback) => engine.effect(callback, {scheduler: (task) => {
    if (shouldSchedule) {
      scheduler(task);
    } else {
      task();
    }
  }});
  raw = engine.raw;
}
function overrideEffect(override) {
  effect = override;
}
function elementBoundEffect(el) {
  let cleanup = () => {
  };
  let wrappedEffect = (callback) => {
    let effectReference = effect(callback);
    if (!el._x_effects) {
      el._x_effects = new Set();
      el._x_runEffects = () => {
        el._x_effects.forEach((i) => i());
      };
    }
    el._x_effects.add(effectReference);
    cleanup = () => {
      if (effectReference === void 0)
        return;
      el._x_effects.delete(effectReference);
      release(effectReference);
    };
  };
  return [wrappedEffect, () => {
    cleanup();
  }];
}

// packages/alpinejs/src/mutation.js
var onAttributeAddeds = [];
var onElRemoveds = [];
var onElAddeds = [];
function onElAdded(callback) {
  onElAddeds.push(callback);
}
function onElRemoved(callback) {
  onElRemoveds.push(callback);
}
function onAttributesAdded(callback) {
  onAttributeAddeds.push(callback);
}
function onAttributeRemoved(el, name, callback) {
  if (!el._x_attributeCleanups)
    el._x_attributeCleanups = {};
  if (!el._x_attributeCleanups[name])
    el._x_attributeCleanups[name] = [];
  el._x_attributeCleanups[name].push(callback);
}
function cleanupAttributes(el, names) {
  if (!el._x_attributeCleanups)
    return;
  Object.entries(el._x_attributeCleanups).forEach(([name, value]) => {
    if (names === void 0 || names.includes(name)) {
      value.forEach((i) => i());
      delete el._x_attributeCleanups[name];
    }
  });
}
var observer = new MutationObserver(onMutate);
var currentlyObserving = false;
function startObservingMutations() {
  observer.observe(document, {subtree: true, childList: true, attributes: true, attributeOldValue: true});
  currentlyObserving = true;
}
function stopObservingMutations() {
  flushObserver();
  observer.disconnect();
  currentlyObserving = false;
}
var recordQueue = [];
var willProcessRecordQueue = false;
function flushObserver() {
  recordQueue = recordQueue.concat(observer.takeRecords());
  if (recordQueue.length && !willProcessRecordQueue) {
    willProcessRecordQueue = true;
    queueMicrotask(() => {
      processRecordQueue();
      willProcessRecordQueue = false;
    });
  }
}
function processRecordQueue() {
  onMutate(recordQueue);
  recordQueue.length = 0;
}
function mutateDom(callback) {
  if (!currentlyObserving)
    return callback();
  stopObservingMutations();
  let result = callback();
  startObservingMutations();
  return result;
}
var isCollecting = false;
var deferredMutations = [];
function deferMutations() {
  isCollecting = true;
}
function flushAndStopDeferringMutations() {
  isCollecting = false;
  onMutate(deferredMutations);
  deferredMutations = [];
}
function onMutate(mutations) {
  if (isCollecting) {
    deferredMutations = deferredMutations.concat(mutations);
    return;
  }
  let addedNodes = [];
  let removedNodes = [];
  let addedAttributes = new Map();
  let removedAttributes = new Map();
  for (let i = 0; i < mutations.length; i++) {
    if (mutations[i].target._x_ignoreMutationObserver)
      continue;
    if (mutations[i].type === "childList") {
      mutations[i].addedNodes.forEach((node) => node.nodeType === 1 && addedNodes.push(node));
      mutations[i].removedNodes.forEach((node) => node.nodeType === 1 && removedNodes.push(node));
    }
    if (mutations[i].type === "attributes") {
      let el = mutations[i].target;
      let name = mutations[i].attributeName;
      let oldValue = mutations[i].oldValue;
      let add = () => {
        if (!addedAttributes.has(el))
          addedAttributes.set(el, []);
        addedAttributes.get(el).push({name, value: el.getAttribute(name)});
      };
      let remove = () => {
        if (!removedAttributes.has(el))
          removedAttributes.set(el, []);
        removedAttributes.get(el).push(name);
      };
      if (el.hasAttribute(name) && oldValue === null) {
        add();
      } else if (el.hasAttribute(name)) {
        remove();
        add();
      } else {
        remove();
      }
    }
  }
  removedAttributes.forEach((attrs, el) => {
    cleanupAttributes(el, attrs);
  });
  addedAttributes.forEach((attrs, el) => {
    onAttributeAddeds.forEach((i) => i(el, attrs));
  });
  for (let node of removedNodes) {
    if (addedNodes.includes(node))
      continue;
    onElRemoveds.forEach((i) => i(node));
  }
  addedNodes.forEach((node) => {
    node._x_ignoreSelf = true;
    node._x_ignore = true;
  });
  for (let node of addedNodes) {
    if (removedNodes.includes(node))
      continue;
    if (!node.isConnected)
      continue;
    delete node._x_ignoreSelf;
    delete node._x_ignore;
    onElAddeds.forEach((i) => i(node));
    node._x_ignore = true;
    node._x_ignoreSelf = true;
  }
  addedNodes.forEach((node) => {
    delete node._x_ignoreSelf;
    delete node._x_ignore;
  });
  addedNodes = null;
  removedNodes = null;
  addedAttributes = null;
  removedAttributes = null;
}

// packages/alpinejs/src/scope.js
function scope(node) {
  return mergeProxies(closestDataStack(node));
}
function addScopeToNode(node, data2, referenceNode) {
  node._x_dataStack = [data2, ...closestDataStack(referenceNode || node)];
  return () => {
    node._x_dataStack = node._x_dataStack.filter((i) => i !== data2);
  };
}
function refreshScope(element, scope2) {
  let existingScope = element._x_dataStack[0];
  Object.entries(scope2).forEach(([key, value]) => {
    existingScope[key] = value;
  });
}
function closestDataStack(node) {
  if (node._x_dataStack)
    return node._x_dataStack;
  if (typeof ShadowRoot === "function" && node instanceof ShadowRoot) {
    return closestDataStack(node.host);
  }
  if (!node.parentNode) {
    return [];
  }
  return closestDataStack(node.parentNode);
}
function mergeProxies(objects) {
  let thisProxy = new Proxy({}, {
    ownKeys: () => {
      return Array.from(new Set(objects.flatMap((i) => Object.keys(i))));
    },
    has: (target, name) => {
      return objects.some((obj) => obj.hasOwnProperty(name));
    },
    get: (target, name) => {
      return (objects.find((obj) => {
        if (obj.hasOwnProperty(name)) {
          let descriptor = Object.getOwnPropertyDescriptor(obj, name);
          if (descriptor.get && descriptor.get._x_alreadyBound || descriptor.set && descriptor.set._x_alreadyBound) {
            return true;
          }
          if ((descriptor.get || descriptor.set) && descriptor.enumerable) {
            let getter = descriptor.get;
            let setter = descriptor.set;
            let property = descriptor;
            getter = getter && getter.bind(thisProxy);
            setter = setter && setter.bind(thisProxy);
            if (getter)
              getter._x_alreadyBound = true;
            if (setter)
              setter._x_alreadyBound = true;
            Object.defineProperty(obj, name, {
              ...property,
              get: getter,
              set: setter
            });
          }
          return true;
        }
        return false;
      }) || {})[name];
    },
    set: (target, name, value) => {
      let closestObjectWithKey = objects.find((obj) => obj.hasOwnProperty(name));
      if (closestObjectWithKey) {
        closestObjectWithKey[name] = value;
      } else {
        objects[objects.length - 1][name] = value;
      }
      return true;
    }
  });
  return thisProxy;
}

// packages/alpinejs/src/interceptor.js
function initInterceptors(data2) {
  let isObject = (val) => typeof val === "object" && !Array.isArray(val) && val !== null;
  let recurse = (obj, basePath = "") => {
    Object.entries(Object.getOwnPropertyDescriptors(obj)).forEach(([key, {value, enumerable}]) => {
      if (enumerable === false || value === void 0)
        return;
      let path = basePath === "" ? key : `${basePath}.${key}`;
      if (typeof value === "object" && value !== null && value._x_interceptor) {
        obj[key] = value.initialize(data2, path, key);
      } else {
        if (isObject(value) && value !== obj && !(value instanceof Element)) {
          recurse(value, path);
        }
      }
    });
  };
  return recurse(data2);
}
function interceptor(callback, mutateObj = () => {
}) {
  let obj = {
    initialValue: void 0,
    _x_interceptor: true,
    initialize(data2, path, key) {
      return callback(this.initialValue, () => get(data2, path), (value) => set(data2, path, value), path, key);
    }
  };
  mutateObj(obj);
  return (initialValue) => {
    if (typeof initialValue === "object" && initialValue !== null && initialValue._x_interceptor) {
      let initialize = obj.initialize.bind(obj);
      obj.initialize = (data2, path, key) => {
        let innerValue = initialValue.initialize(data2, path, key);
        obj.initialValue = innerValue;
        return initialize(data2, path, key);
      };
    } else {
      obj.initialValue = initialValue;
    }
    return obj;
  };
}
function get(obj, path) {
  return path.split(".").reduce((carry, segment) => carry[segment], obj);
}
function set(obj, path, value) {
  if (typeof path === "string")
    path = path.split(".");
  if (path.length === 1)
    obj[path[0]] = value;
  else if (path.length === 0)
    throw error;
  else {
    if (obj[path[0]])
      return set(obj[path[0]], path.slice(1), value);
    else {
      obj[path[0]] = {};
      return set(obj[path[0]], path.slice(1), value);
    }
  }
}

// packages/alpinejs/src/magics.js
var magics = {};
function magic(name, callback) {
  magics[name] = callback;
}
function injectMagics(obj, el) {
  Object.entries(magics).forEach(([name, callback]) => {
    Object.defineProperty(obj, `$${name}`, {
      get() {
        return callback(el, {Alpine: alpine_default, interceptor});
      },
      enumerable: false
    });
  });
  return obj;
}

// packages/alpinejs/src/utils/error.js
function tryCatch(el, expression, callback, ...args) {
  try {
    return callback(...args);
  } catch (e) {
    handleError(e, el, expression);
  }
}
function handleError(error2, el, expression = void 0) {
  Object.assign(error2, {el, expression});
  console.warn(`Alpine Expression Error: ${error2.message}

${expression ? 'Expression: "' + expression + '"\n\n' : ""}`, el);
  setTimeout(() => {
    throw error2;
  }, 0);
}

// packages/alpinejs/src/evaluator.js
function evaluate(el, expression, extras = {}) {
  let result;
  evaluateLater(el, expression)((value) => result = value, extras);
  return result;
}
function evaluateLater(...args) {
  return theEvaluatorFunction(...args);
}
var theEvaluatorFunction = normalEvaluator;
function setEvaluator(newEvaluator) {
  theEvaluatorFunction = newEvaluator;
}
function normalEvaluator(el, expression) {
  let overriddenMagics = {};
  injectMagics(overriddenMagics, el);
  let dataStack = [overriddenMagics, ...closestDataStack(el)];
  if (typeof expression === "function") {
    return generateEvaluatorFromFunction(dataStack, expression);
  }
  let evaluator = generateEvaluatorFromString(dataStack, expression, el);
  return tryCatch.bind(null, el, expression, evaluator);
}
function generateEvaluatorFromFunction(dataStack, func) {
  return (receiver = () => {
  }, {scope: scope2 = {}, params = []} = {}) => {
    let result = func.apply(mergeProxies([scope2, ...dataStack]), params);
    runIfTypeOfFunction(receiver, result);
  };
}
var evaluatorMemo = {};
function generateFunctionFromString(expression, el) {
  if (evaluatorMemo[expression]) {
    return evaluatorMemo[expression];
  }
  let AsyncFunction = Object.getPrototypeOf(async function() {
  }).constructor;
  let rightSideSafeExpression = /^[\n\s]*if.*\(.*\)/.test(expression) || /^(let|const)\s/.test(expression) ? `(() => { ${expression} })()` : expression;
  const safeAsyncFunction = () => {
    try {
      return new AsyncFunction(["__self", "scope"], `with (scope) { __self.result = ${rightSideSafeExpression} }; __self.finished = true; return __self.result;`);
    } catch (error2) {
      handleError(error2, el, expression);
      return Promise.resolve();
    }
  };
  let func = safeAsyncFunction();
  evaluatorMemo[expression] = func;
  return func;
}
function generateEvaluatorFromString(dataStack, expression, el) {
  let func = generateFunctionFromString(expression, el);
  return (receiver = () => {
  }, {scope: scope2 = {}, params = []} = {}) => {
    func.result = void 0;
    func.finished = false;
    let completeScope = mergeProxies([scope2, ...dataStack]);
    if (typeof func === "function") {
      let promise = func(func, completeScope).catch((error2) => handleError(error2, el, expression));
      if (func.finished) {
        runIfTypeOfFunction(receiver, func.result, completeScope, params, el);
        func.result = void 0;
      } else {
        promise.then((result) => {
          runIfTypeOfFunction(receiver, result, completeScope, params, el);
        }).catch((error2) => handleError(error2, el, expression)).finally(() => func.result = void 0);
      }
    }
  };
}
function runIfTypeOfFunction(receiver, value, scope2, params, el) {
  if (typeof value === "function") {
    let result = value.apply(scope2, params);
    if (result instanceof Promise) {
      result.then((i) => runIfTypeOfFunction(receiver, i, scope2, params)).catch((error2) => handleError(error2, el, value));
    } else {
      receiver(result);
    }
  } else {
    receiver(value);
  }
}

// packages/alpinejs/src/directives.js
var prefixAsString = "x-";
function prefix(subject = "") {
  return prefixAsString + subject;
}
function setPrefix(newPrefix) {
  prefixAsString = newPrefix;
}
var directiveHandlers = {};
function directive(name, callback) {
  directiveHandlers[name] = callback;
}
function directives(el, attributes, originalAttributeOverride) {
  let transformedAttributeMap = {};
  let directives2 = Array.from(attributes).map(toTransformedAttributes((newName, oldName) => transformedAttributeMap[newName] = oldName)).filter(outNonAlpineAttributes).map(toParsedDirectives(transformedAttributeMap, originalAttributeOverride)).sort(byPriority);
  return directives2.map((directive2) => {
    return getDirectiveHandler(el, directive2);
  });
}
function attributesOnly(attributes) {
  return Array.from(attributes).map(toTransformedAttributes()).filter((attr) => !outNonAlpineAttributes(attr));
}
var isDeferringHandlers = false;
var directiveHandlerStacks = new Map();
var currentHandlerStackKey = Symbol();
function deferHandlingDirectives(callback) {
  isDeferringHandlers = true;
  let key = Symbol();
  currentHandlerStackKey = key;
  directiveHandlerStacks.set(key, []);
  let flushHandlers = () => {
    while (directiveHandlerStacks.get(key).length)
      directiveHandlerStacks.get(key).shift()();
    directiveHandlerStacks.delete(key);
  };
  let stopDeferring = () => {
    isDeferringHandlers = false;
    flushHandlers();
  };
  callback(flushHandlers);
  stopDeferring();
}
function getDirectiveHandler(el, directive2) {
  let noop = () => {
  };
  let handler3 = directiveHandlers[directive2.type] || noop;
  let cleanups = [];
  let cleanup = (callback) => cleanups.push(callback);
  let [effect3, cleanupEffect] = elementBoundEffect(el);
  cleanups.push(cleanupEffect);
  let utilities = {
    Alpine: alpine_default,
    effect: effect3,
    cleanup,
    evaluateLater: evaluateLater.bind(evaluateLater, el),
    evaluate: evaluate.bind(evaluate, el)
  };
  let doCleanup = () => cleanups.forEach((i) => i());
  onAttributeRemoved(el, directive2.original, doCleanup);
  let fullHandler = () => {
    if (el._x_ignore || el._x_ignoreSelf)
      return;
    handler3.inline && handler3.inline(el, directive2, utilities);
    handler3 = handler3.bind(handler3, el, directive2, utilities);
    isDeferringHandlers ? directiveHandlerStacks.get(currentHandlerStackKey).push(handler3) : handler3();
  };
  fullHandler.runCleanups = doCleanup;
  return fullHandler;
}
var startingWith = (subject, replacement) => ({name, value}) => {
  if (name.startsWith(subject))
    name = name.replace(subject, replacement);
  return {name, value};
};
var into = (i) => i;
function toTransformedAttributes(callback = () => {
}) {
  return ({name, value}) => {
    let {name: newName, value: newValue} = attributeTransformers.reduce((carry, transform) => {
      return transform(carry);
    }, {name, value});
    if (newName !== name)
      callback(newName, name);
    return {name: newName, value: newValue};
  };
}
var attributeTransformers = [];
function mapAttributes(callback) {
  attributeTransformers.push(callback);
}
function outNonAlpineAttributes({name}) {
  return alpineAttributeRegex().test(name);
}
var alpineAttributeRegex = () => new RegExp(`^${prefixAsString}([^:^.]+)\\b`);
function toParsedDirectives(transformedAttributeMap, originalAttributeOverride) {
  return ({name, value}) => {
    let typeMatch = name.match(alpineAttributeRegex());
    let valueMatch = name.match(/:([a-zA-Z0-9\-:]+)/);
    let modifiers = name.match(/\.[^.\]]+(?=[^\]]*$)/g) || [];
    let original = originalAttributeOverride || transformedAttributeMap[name] || name;
    return {
      type: typeMatch ? typeMatch[1] : null,
      value: valueMatch ? valueMatch[1] : null,
      modifiers: modifiers.map((i) => i.replace(".", "")),
      expression: value,
      original
    };
  };
}
var DEFAULT = "DEFAULT";
var directiveOrder = [
  "ignore",
  "ref",
  "data",
  "id",
  "bind",
  "init",
  "for",
  "model",
  "modelable",
  "transition",
  "show",
  "if",
  DEFAULT,
  "teleport",
  "element"
];
function byPriority(a, b) {
  let typeA = directiveOrder.indexOf(a.type) === -1 ? DEFAULT : a.type;
  let typeB = directiveOrder.indexOf(b.type) === -1 ? DEFAULT : b.type;
  return directiveOrder.indexOf(typeA) - directiveOrder.indexOf(typeB);
}

// packages/alpinejs/src/utils/dispatch.js
function dispatch(el, name, detail = {}) {
  el.dispatchEvent(new CustomEvent(name, {
    detail,
    bubbles: true,
    composed: true,
    cancelable: true
  }));
}

// packages/alpinejs/src/nextTick.js
var tickStack = [];
var isHolding = false;
function nextTick(callback) {
  tickStack.push(callback);
  queueMicrotask(() => {
    isHolding || setTimeout(() => {
      releaseNextTicks();
    });
  });
}
function releaseNextTicks() {
  isHolding = false;
  while (tickStack.length)
    tickStack.shift()();
}
function holdNextTicks() {
  isHolding = true;
}

// packages/alpinejs/src/utils/walk.js
function walk(el, callback) {
  if (typeof ShadowRoot === "function" && el instanceof ShadowRoot) {
    Array.from(el.children).forEach((el2) => walk(el2, callback));
    return;
  }
  let skip = false;
  callback(el, () => skip = true);
  if (skip)
    return;
  let node = el.firstElementChild;
  while (node) {
    walk(node, callback, false);
    node = node.nextElementSibling;
  }
}

// packages/alpinejs/src/utils/warn.js
function warn(message, ...args) {
  console.warn(`Alpine Warning: ${message}`, ...args);
}

// packages/alpinejs/src/lifecycle.js
function start() {
  if (!document.body)
    warn("Unable to initialize. Trying to load Alpine before `<body>` is available. Did you forget to add `defer` in Alpine's `<script>` tag?");
  dispatch(document, "alpine:init");
  dispatch(document, "alpine:initializing");
  startObservingMutations();
  onElAdded((el) => initTree(el, walk));
  onElRemoved((el) => destroyTree(el));
  onAttributesAdded((el, attrs) => {
    directives(el, attrs).forEach((handle) => handle());
  });
  let outNestedComponents = (el) => !closestRoot(el.parentElement, true);
  Array.from(document.querySelectorAll(allSelectors())).filter(outNestedComponents).forEach((el) => {
    initTree(el);
  });
  dispatch(document, "alpine:initialized");
}
var rootSelectorCallbacks = [];
var initSelectorCallbacks = [];
function rootSelectors() {
  return rootSelectorCallbacks.map((fn) => fn());
}
function allSelectors() {
  return rootSelectorCallbacks.concat(initSelectorCallbacks).map((fn) => fn());
}
function addRootSelector(selectorCallback) {
  rootSelectorCallbacks.push(selectorCallback);
}
function addInitSelector(selectorCallback) {
  initSelectorCallbacks.push(selectorCallback);
}
function closestRoot(el, includeInitSelectors = false) {
  return findClosest(el, (element) => {
    const selectors = includeInitSelectors ? allSelectors() : rootSelectors();
    if (selectors.some((selector) => element.matches(selector)))
      return true;
  });
}
function findClosest(el, callback) {
  if (!el)
    return;
  if (callback(el))
    return el;
  if (el._x_teleportBack)
    el = el._x_teleportBack;
  if (!el.parentElement)
    return;
  return findClosest(el.parentElement, callback);
}
function isRoot(el) {
  return rootSelectors().some((selector) => el.matches(selector));
}
function initTree(el, walker = walk) {
  deferHandlingDirectives(() => {
    walker(el, (el2, skip) => {
      directives(el2, el2.attributes).forEach((handle) => handle());
      el2._x_ignore && skip();
    });
  });
}
function destroyTree(root) {
  walk(root, (el) => cleanupAttributes(el));
}

// packages/alpinejs/src/utils/classes.js
function setClasses(el, value) {
  if (Array.isArray(value)) {
    return setClassesFromString(el, value.join(" "));
  } else if (typeof value === "object" && value !== null) {
    return setClassesFromObject(el, value);
  } else if (typeof value === "function") {
    return setClasses(el, value());
  }
  return setClassesFromString(el, value);
}
function setClassesFromString(el, classString) {
  let split = (classString2) => classString2.split(" ").filter(Boolean);
  let missingClasses = (classString2) => classString2.split(" ").filter((i) => !el.classList.contains(i)).filter(Boolean);
  let addClassesAndReturnUndo = (classes) => {
    el.classList.add(...classes);
    return () => {
      el.classList.remove(...classes);
    };
  };
  classString = classString === true ? classString = "" : classString || "";
  return addClassesAndReturnUndo(missingClasses(classString));
}
function setClassesFromObject(el, classObject) {
  let split = (classString) => classString.split(" ").filter(Boolean);
  let forAdd = Object.entries(classObject).flatMap(([classString, bool]) => bool ? split(classString) : false).filter(Boolean);
  let forRemove = Object.entries(classObject).flatMap(([classString, bool]) => !bool ? split(classString) : false).filter(Boolean);
  let added = [];
  let removed = [];
  forRemove.forEach((i) => {
    if (el.classList.contains(i)) {
      el.classList.remove(i);
      removed.push(i);
    }
  });
  forAdd.forEach((i) => {
    if (!el.classList.contains(i)) {
      el.classList.add(i);
      added.push(i);
    }
  });
  return () => {
    removed.forEach((i) => el.classList.add(i));
    added.forEach((i) => el.classList.remove(i));
  };
}

// packages/alpinejs/src/utils/styles.js
function setStyles(el, value) {
  if (typeof value === "object" && value !== null) {
    return setStylesFromObject(el, value);
  }
  return setStylesFromString(el, value);
}
function setStylesFromObject(el, value) {
  let previousStyles = {};
  Object.entries(value).forEach(([key, value2]) => {
    previousStyles[key] = el.style[key];
    if (!key.startsWith("--")) {
      key = kebabCase(key);
    }
    el.style.setProperty(key, value2);
  });
  setTimeout(() => {
    if (el.style.length === 0) {
      el.removeAttribute("style");
    }
  });
  return () => {
    setStyles(el, previousStyles);
  };
}
function setStylesFromString(el, value) {
  let cache = el.getAttribute("style", value);
  el.setAttribute("style", value);
  return () => {
    el.setAttribute("style", cache || "");
  };
}
function kebabCase(subject) {
  return subject.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
}

// packages/alpinejs/src/utils/once.js
function once(callback, fallback = () => {
}) {
  let called = false;
  return function() {
    if (!called) {
      called = true;
      callback.apply(this, arguments);
    } else {
      fallback.apply(this, arguments);
    }
  };
}

// packages/alpinejs/src/directives/x-transition.js
directive("transition", (el, {value, modifiers, expression}, {evaluate: evaluate2}) => {
  if (typeof expression === "function")
    expression = evaluate2(expression);
  if (!expression) {
    registerTransitionsFromHelper(el, modifiers, value);
  } else {
    registerTransitionsFromClassString(el, expression, value);
  }
});
function registerTransitionsFromClassString(el, classString, stage) {
  registerTransitionObject(el, setClasses, "");
  let directiveStorageMap = {
    enter: (classes) => {
      el._x_transition.enter.during = classes;
    },
    "enter-start": (classes) => {
      el._x_transition.enter.start = classes;
    },
    "enter-end": (classes) => {
      el._x_transition.enter.end = classes;
    },
    leave: (classes) => {
      el._x_transition.leave.during = classes;
    },
    "leave-start": (classes) => {
      el._x_transition.leave.start = classes;
    },
    "leave-end": (classes) => {
      el._x_transition.leave.end = classes;
    }
  };
  directiveStorageMap[stage](classString);
}
function registerTransitionsFromHelper(el, modifiers, stage) {
  registerTransitionObject(el, setStyles);
  let doesntSpecify = !modifiers.includes("in") && !modifiers.includes("out") && !stage;
  let transitioningIn = doesntSpecify || modifiers.includes("in") || ["enter"].includes(stage);
  let transitioningOut = doesntSpecify || modifiers.includes("out") || ["leave"].includes(stage);
  if (modifiers.includes("in") && !doesntSpecify) {
    modifiers = modifiers.filter((i, index) => index < modifiers.indexOf("out"));
  }
  if (modifiers.includes("out") && !doesntSpecify) {
    modifiers = modifiers.filter((i, index) => index > modifiers.indexOf("out"));
  }
  let wantsAll = !modifiers.includes("opacity") && !modifiers.includes("scale");
  let wantsOpacity = wantsAll || modifiers.includes("opacity");
  let wantsScale = wantsAll || modifiers.includes("scale");
  let opacityValue = wantsOpacity ? 0 : 1;
  let scaleValue = wantsScale ? modifierValue(modifiers, "scale", 95) / 100 : 1;
  let delay = modifierValue(modifiers, "delay", 0);
  let origin = modifierValue(modifiers, "origin", "center");
  let property = "opacity, transform";
  let durationIn = modifierValue(modifiers, "duration", 150) / 1e3;
  let durationOut = modifierValue(modifiers, "duration", 75) / 1e3;
  let easing = `cubic-bezier(0.4, 0.0, 0.2, 1)`;
  if (transitioningIn) {
    el._x_transition.enter.during = {
      transformOrigin: origin,
      transitionDelay: delay,
      transitionProperty: property,
      transitionDuration: `${durationIn}s`,
      transitionTimingFunction: easing
    };
    el._x_transition.enter.start = {
      opacity: opacityValue,
      transform: `scale(${scaleValue})`
    };
    el._x_transition.enter.end = {
      opacity: 1,
      transform: `scale(1)`
    };
  }
  if (transitioningOut) {
    el._x_transition.leave.during = {
      transformOrigin: origin,
      transitionDelay: delay,
      transitionProperty: property,
      transitionDuration: `${durationOut}s`,
      transitionTimingFunction: easing
    };
    el._x_transition.leave.start = {
      opacity: 1,
      transform: `scale(1)`
    };
    el._x_transition.leave.end = {
      opacity: opacityValue,
      transform: `scale(${scaleValue})`
    };
  }
}
function registerTransitionObject(el, setFunction, defaultValue = {}) {
  if (!el._x_transition)
    el._x_transition = {
      enter: {during: defaultValue, start: defaultValue, end: defaultValue},
      leave: {during: defaultValue, start: defaultValue, end: defaultValue},
      in(before = () => {
      }, after = () => {
      }) {
        transition(el, setFunction, {
          during: this.enter.during,
          start: this.enter.start,
          end: this.enter.end
        }, before, after);
      },
      out(before = () => {
      }, after = () => {
      }) {
        transition(el, setFunction, {
          during: this.leave.during,
          start: this.leave.start,
          end: this.leave.end
        }, before, after);
      }
    };
}
window.Element.prototype._x_toggleAndCascadeWithTransitions = function(el, value, show, hide) {
  let clickAwayCompatibleShow = () => {
    document.visibilityState === "visible" ? requestAnimationFrame(show) : setTimeout(show);
  };
  if (value) {
    if (el._x_transition && (el._x_transition.enter || el._x_transition.leave)) {
      el._x_transition.enter && (Object.entries(el._x_transition.enter.during).length || Object.entries(el._x_transition.enter.start).length || Object.entries(el._x_transition.enter.end).length) ? el._x_transition.in(show) : clickAwayCompatibleShow();
    } else {
      el._x_transition ? el._x_transition.in(show) : clickAwayCompatibleShow();
    }
    return;
  }
  el._x_hidePromise = el._x_transition ? new Promise((resolve, reject) => {
    el._x_transition.out(() => {
    }, () => resolve(hide));
    el._x_transitioning.beforeCancel(() => reject({isFromCancelledTransition: true}));
  }) : Promise.resolve(hide);
  queueMicrotask(() => {
    let closest = closestHide(el);
    if (closest) {
      if (!closest._x_hideChildren)
        closest._x_hideChildren = [];
      closest._x_hideChildren.push(el);
    } else {
      queueMicrotask(() => {
        let hideAfterChildren = (el2) => {
          let carry = Promise.all([
            el2._x_hidePromise,
            ...(el2._x_hideChildren || []).map(hideAfterChildren)
          ]).then(([i]) => i());
          delete el2._x_hidePromise;
          delete el2._x_hideChildren;
          return carry;
        };
        hideAfterChildren(el).catch((e) => {
          if (!e.isFromCancelledTransition)
            throw e;
        });
      });
    }
  });
};
function closestHide(el) {
  let parent = el.parentNode;
  if (!parent)
    return;
  return parent._x_hidePromise ? parent : closestHide(parent);
}
function transition(el, setFunction, {during, start: start2, end} = {}, before = () => {
}, after = () => {
}) {
  if (el._x_transitioning)
    el._x_transitioning.cancel();
  if (Object.keys(during).length === 0 && Object.keys(start2).length === 0 && Object.keys(end).length === 0) {
    before();
    after();
    return;
  }
  let undoStart, undoDuring, undoEnd;
  performTransition(el, {
    start() {
      undoStart = setFunction(el, start2);
    },
    during() {
      undoDuring = setFunction(el, during);
    },
    before,
    end() {
      undoStart();
      undoEnd = setFunction(el, end);
    },
    after,
    cleanup() {
      undoDuring();
      undoEnd();
    }
  });
}
function performTransition(el, stages) {
  let interrupted, reachedBefore, reachedEnd;
  let finish = once(() => {
    mutateDom(() => {
      interrupted = true;
      if (!reachedBefore)
        stages.before();
      if (!reachedEnd) {
        stages.end();
        releaseNextTicks();
      }
      stages.after();
      if (el.isConnected)
        stages.cleanup();
      delete el._x_transitioning;
    });
  });
  el._x_transitioning = {
    beforeCancels: [],
    beforeCancel(callback) {
      this.beforeCancels.push(callback);
    },
    cancel: once(function() {
      while (this.beforeCancels.length) {
        this.beforeCancels.shift()();
      }
      ;
      finish();
    }),
    finish
  };
  mutateDom(() => {
    stages.start();
    stages.during();
  });
  holdNextTicks();
  requestAnimationFrame(() => {
    if (interrupted)
      return;
    let duration = Number(getComputedStyle(el).transitionDuration.replace(/,.*/, "").replace("s", "")) * 1e3;
    let delay = Number(getComputedStyle(el).transitionDelay.replace(/,.*/, "").replace("s", "")) * 1e3;
    if (duration === 0)
      duration = Number(getComputedStyle(el).animationDuration.replace("s", "")) * 1e3;
    mutateDom(() => {
      stages.before();
    });
    reachedBefore = true;
    requestAnimationFrame(() => {
      if (interrupted)
        return;
      mutateDom(() => {
        stages.end();
      });
      releaseNextTicks();
      setTimeout(el._x_transitioning.finish, duration + delay);
      reachedEnd = true;
    });
  });
}
function modifierValue(modifiers, key, fallback) {
  if (modifiers.indexOf(key) === -1)
    return fallback;
  const rawValue = modifiers[modifiers.indexOf(key) + 1];
  if (!rawValue)
    return fallback;
  if (key === "scale") {
    if (isNaN(rawValue))
      return fallback;
  }
  if (key === "duration") {
    let match = rawValue.match(/([0-9]+)ms/);
    if (match)
      return match[1];
  }
  if (key === "origin") {
    if (["top", "right", "left", "center", "bottom"].includes(modifiers[modifiers.indexOf(key) + 2])) {
      return [rawValue, modifiers[modifiers.indexOf(key) + 2]].join(" ");
    }
  }
  return rawValue;
}

// packages/alpinejs/src/clone.js
var isCloning = false;
function skipDuringClone(callback, fallback = () => {
}) {
  return (...args) => isCloning ? fallback(...args) : callback(...args);
}
function clone(oldEl, newEl) {
  if (!newEl._x_dataStack)
    newEl._x_dataStack = oldEl._x_dataStack;
  isCloning = true;
  dontRegisterReactiveSideEffects(() => {
    cloneTree(newEl);
  });
  isCloning = false;
}
function cloneTree(el) {
  let hasRunThroughFirstEl = false;
  let shallowWalker = (el2, callback) => {
    walk(el2, (el3, skip) => {
      if (hasRunThroughFirstEl && isRoot(el3))
        return skip();
      hasRunThroughFirstEl = true;
      callback(el3, skip);
    });
  };
  initTree(el, shallowWalker);
}
function dontRegisterReactiveSideEffects(callback) {
  let cache = effect;
  overrideEffect((callback2, el) => {
    let storedEffect = cache(callback2);
    release(storedEffect);
    return () => {
    };
  });
  callback();
  overrideEffect(cache);
}

// packages/alpinejs/src/utils/bind.js
function bind(el, name, value, modifiers = []) {
  if (!el._x_bindings)
    el._x_bindings = reactive({});
  el._x_bindings[name] = value;
  name = modifiers.includes("camel") ? camelCase(name) : name;
  switch (name) {
    case "value":
      bindInputValue(el, value);
      break;
    case "style":
      bindStyles(el, value);
      break;
    case "class":
      bindClasses(el, value);
      break;
    default:
      bindAttribute(el, name, value);
      break;
  }
}
function bindInputValue(el, value) {
  if (el.type === "radio") {
    if (el.attributes.value === void 0) {
      el.value = value;
    }
    if (window.fromModel) {
      el.checked = checkedAttrLooseCompare(el.value, value);
    }
  } else if (el.type === "checkbox") {
    if (Number.isInteger(value)) {
      el.value = value;
    } else if (!Number.isInteger(value) && !Array.isArray(value) && typeof value !== "boolean" && ![null, void 0].includes(value)) {
      el.value = String(value);
    } else {
      if (Array.isArray(value)) {
        el.checked = value.some((val) => checkedAttrLooseCompare(val, el.value));
      } else {
        el.checked = !!value;
      }
    }
  } else if (el.tagName === "SELECT") {
    updateSelect(el, value);
  } else {
    if (el.value === value)
      return;
    el.value = value;
  }
}
function bindClasses(el, value) {
  if (el._x_undoAddedClasses)
    el._x_undoAddedClasses();
  el._x_undoAddedClasses = setClasses(el, value);
}
function bindStyles(el, value) {
  if (el._x_undoAddedStyles)
    el._x_undoAddedStyles();
  el._x_undoAddedStyles = setStyles(el, value);
}
function bindAttribute(el, name, value) {
  if ([null, void 0, false].includes(value) && attributeShouldntBePreservedIfFalsy(name)) {
    el.removeAttribute(name);
  } else {
    if (isBooleanAttr(name))
      value = name;
    setIfChanged(el, name, value);
  }
}
function setIfChanged(el, attrName, value) {
  if (el.getAttribute(attrName) != value) {
    el.setAttribute(attrName, value);
  }
}
function updateSelect(el, value) {
  const arrayWrappedValue = [].concat(value).map((value2) => {
    return value2 + "";
  });
  Array.from(el.options).forEach((option) => {
    option.selected = arrayWrappedValue.includes(option.value);
  });
}
function camelCase(subject) {
  return subject.toLowerCase().replace(/-(\w)/g, (match, char) => char.toUpperCase());
}
function checkedAttrLooseCompare(valueA, valueB) {
  return valueA == valueB;
}
function isBooleanAttr(attrName) {
  const booleanAttributes = [
    "disabled",
    "checked",
    "required",
    "readonly",
    "hidden",
    "open",
    "selected",
    "autofocus",
    "itemscope",
    "multiple",
    "novalidate",
    "allowfullscreen",
    "allowpaymentrequest",
    "formnovalidate",
    "autoplay",
    "controls",
    "loop",
    "muted",
    "playsinline",
    "default",
    "ismap",
    "reversed",
    "async",
    "defer",
    "nomodule"
  ];
  return booleanAttributes.includes(attrName);
}
function attributeShouldntBePreservedIfFalsy(name) {
  return !["aria-pressed", "aria-checked", "aria-expanded", "aria-selected"].includes(name);
}
function getBinding(el, name, fallback) {
  if (el._x_bindings && el._x_bindings[name] !== void 0)
    return el._x_bindings[name];
  let attr = el.getAttribute(name);
  if (attr === null)
    return typeof fallback === "function" ? fallback() : fallback;
  if (isBooleanAttr(name)) {
    return !![name, "true"].includes(attr);
  }
  if (attr === "")
    return true;
  return attr;
}

// packages/alpinejs/src/utils/debounce.js
function debounce(func, wait) {
  var timeout;
  return function() {
    var context = this, args = arguments;
    var later = function() {
      timeout = null;
      func.apply(context, args);
    };
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
}

// packages/alpinejs/src/utils/throttle.js
function throttle(func, limit) {
  let inThrottle;
  return function() {
    let context = this, args = arguments;
    if (!inThrottle) {
      func.apply(context, args);
      inThrottle = true;
      setTimeout(() => inThrottle = false, limit);
    }
  };
}

// packages/alpinejs/src/plugin.js
function plugin(callback) {
  callback(alpine_default);
}

// packages/alpinejs/src/store.js
var stores = {};
var isReactive = false;
function store(name, value) {
  if (!isReactive) {
    stores = reactive(stores);
    isReactive = true;
  }
  if (value === void 0) {
    return stores[name];
  }
  stores[name] = value;
  if (typeof value === "object" && value !== null && value.hasOwnProperty("init") && typeof value.init === "function") {
    stores[name].init();
  }
  initInterceptors(stores[name]);
}
function getStores() {
  return stores;
}

// packages/alpinejs/src/binds.js
var binds = {};
function bind2(name, object) {
  binds[name] = typeof object !== "function" ? () => object : object;
}
function injectBindingProviders(obj) {
  Object.entries(binds).forEach(([name, callback]) => {
    Object.defineProperty(obj, name, {
      get() {
        return (...args) => {
          return callback(...args);
        };
      }
    });
  });
  return obj;
}

// packages/alpinejs/src/datas.js
var datas = {};
function data(name, callback) {
  datas[name] = callback;
}
function injectDataProviders(obj, context) {
  Object.entries(datas).forEach(([name, callback]) => {
    Object.defineProperty(obj, name, {
      get() {
        return (...args) => {
          return callback.bind(context)(...args);
        };
      },
      enumerable: false
    });
  });
  return obj;
}

// packages/alpinejs/src/alpine.js
var Alpine = {
  get reactive() {
    return reactive;
  },
  get release() {
    return release;
  },
  get effect() {
    return effect;
  },
  get raw() {
    return raw;
  },
  version: "3.9.0",
  flushAndStopDeferringMutations,
  disableEffectScheduling,
  setReactivityEngine,
  closestDataStack,
  skipDuringClone,
  addRootSelector,
  addInitSelector,
  addScopeToNode,
  deferMutations,
  mapAttributes,
  evaluateLater,
  setEvaluator,
  mergeProxies,
  findClosest,
  closestRoot,
  interceptor,
  transition,
  setStyles,
  mutateDom,
  directive,
  throttle,
  debounce,
  evaluate,
  initTree,
  nextTick,
  prefixed: prefix,
  prefix: setPrefix,
  plugin,
  magic,
  store,
  start,
  clone,
  bound: getBinding,
  $data: scope,
  data,
  bind: bind2
};
var alpine_default = Alpine;

// packages/alpinejs/src/index.js
var import_reactivity9 = __toModule(require_reactivity());

// packages/alpinejs/src/magics/$nextTick.js
magic("nextTick", () => nextTick);

// packages/alpinejs/src/magics/$dispatch.js
magic("dispatch", (el) => dispatch.bind(dispatch, el));

// packages/alpinejs/src/magics/$watch.js
magic("watch", (el) => (key, callback) => {
  let evaluate2 = evaluateLater(el, key);
  let firstTime = true;
  let oldValue;
  effect(() => evaluate2((value) => {
    JSON.stringify(value);
    if (!firstTime) {
      queueMicrotask(() => {
        callback(value, oldValue);
        oldValue = value;
      });
    } else {
      oldValue = value;
    }
    firstTime = false;
  }));
});

// packages/alpinejs/src/magics/$store.js
magic("store", getStores);

// packages/alpinejs/src/magics/$data.js
magic("data", (el) => scope(el));

// packages/alpinejs/src/magics/$root.js
magic("root", (el) => closestRoot(el));

// packages/alpinejs/src/magics/$refs.js
magic("refs", (el) => {
  if (el._x_refs_proxy)
    return el._x_refs_proxy;
  el._x_refs_proxy = mergeProxies(getArrayOfRefObject(el));
  return el._x_refs_proxy;
});
function getArrayOfRefObject(el) {
  let refObjects = [];
  let currentEl = el;
  while (currentEl) {
    if (currentEl._x_refs)
      refObjects.push(currentEl._x_refs);
    currentEl = currentEl.parentNode;
  }
  return refObjects;
}

// packages/alpinejs/src/ids.js
var globalIdMemo = {};
function findAndIncrementId(name) {
  if (!globalIdMemo[name])
    globalIdMemo[name] = 0;
  return ++globalIdMemo[name];
}
function closestIdRoot(el, name) {
  return findClosest(el, (element) => {
    if (element._x_ids && element._x_ids[name])
      return true;
  });
}
function setIdRoot(el, name) {
  if (!el._x_ids)
    el._x_ids = {};
  if (!el._x_ids[name])
    el._x_ids[name] = findAndIncrementId(name);
}

// packages/alpinejs/src/magics/$id.js
magic("id", (el) => (name, key = null) => {
  let root = closestIdRoot(el, name);
  let id = root ? root._x_ids[name] : findAndIncrementId(name);
  return key ? `${name}-${id}-${key}` : `${name}-${id}`;
});

// packages/alpinejs/src/magics/$el.js
magic("el", (el) => el);

// packages/alpinejs/src/directives/x-modelable.js
directive("modelable", (el, {expression}, {effect: effect3, evaluate: evaluate2, evaluateLater: evaluateLater2}) => {
  let func = evaluateLater2(expression);
  let innerGet = () => {
    let result;
    func((i) => result = i);
    return result;
  };
  let evaluateInnerSet = evaluateLater2(`${expression} = __placeholder`);
  let innerSet = (val) => evaluateInnerSet(() => {
  }, {scope: {__placeholder: val}});
  let initialValue = innerGet();
  if (el._x_modelable_hook)
    initialValue = el._x_modelable_hook(initialValue);
  innerSet(initialValue);
  queueMicrotask(() => {
    if (!el._x_model)
      return;
    let outerGet = el._x_model.get;
    let outerSet = el._x_model.set;
    effect3(() => innerSet(outerGet()));
    effect3(() => outerSet(innerGet()));
  });
});

// packages/alpinejs/src/directives/x-teleport.js
directive("teleport", (el, {expression}, {cleanup}) => {
  if (el.tagName.toLowerCase() !== "template")
    warn("x-teleport can only be used on a <template> tag", el);
  let target = document.querySelector(expression);
  if (!target)
    warn(`Cannot find x-teleport element for selector: "${expression}"`);
  let clone2 = el.content.cloneNode(true).firstElementChild;
  el._x_teleport = clone2;
  clone2._x_teleportBack = el;
  if (el._x_forwardEvents) {
    el._x_forwardEvents.forEach((eventName) => {
      clone2.addEventListener(eventName, (e) => {
        e.stopPropagation();
        el.dispatchEvent(new e.constructor(e.type, e));
      });
    });
  }
  addScopeToNode(clone2, {}, el);
  mutateDom(() => {
    target.appendChild(clone2);
    initTree(clone2);
    clone2._x_ignore = true;
  });
  cleanup(() => clone2.remove());
});

// packages/alpinejs/src/directives/x-ignore.js
var handler = () => {
};
handler.inline = (el, {modifiers}, {cleanup}) => {
  modifiers.includes("self") ? el._x_ignoreSelf = true : el._x_ignore = true;
  cleanup(() => {
    modifiers.includes("self") ? delete el._x_ignoreSelf : delete el._x_ignore;
  });
};
directive("ignore", handler);

// packages/alpinejs/src/directives/x-effect.js
directive("effect", (el, {expression}, {effect: effect3}) => effect3(evaluateLater(el, expression)));

// packages/alpinejs/src/utils/on.js
function on(el, event, modifiers, callback) {
  let listenerTarget = el;
  let handler3 = (e) => callback(e);
  let options = {};
  let wrapHandler = (callback2, wrapper) => (e) => wrapper(callback2, e);
  if (modifiers.includes("dot"))
    event = dotSyntax(event);
  if (modifiers.includes("camel"))
    event = camelCase2(event);
  if (modifiers.includes("passive"))
    options.passive = true;
  if (modifiers.includes("capture"))
    options.capture = true;
  if (modifiers.includes("window"))
    listenerTarget = window;
  if (modifiers.includes("document"))
    listenerTarget = document;
  if (modifiers.includes("prevent"))
    handler3 = wrapHandler(handler3, (next, e) => {
      e.preventDefault();
      next(e);
    });
  if (modifiers.includes("stop"))
    handler3 = wrapHandler(handler3, (next, e) => {
      e.stopPropagation();
      next(e);
    });
  if (modifiers.includes("self"))
    handler3 = wrapHandler(handler3, (next, e) => {
      e.target === el && next(e);
    });
  if (modifiers.includes("away") || modifiers.includes("outside")) {
    listenerTarget = document;
    handler3 = wrapHandler(handler3, (next, e) => {
      if (el.contains(e.target))
        return;
      if (el.offsetWidth < 1 && el.offsetHeight < 1)
        return;
      if (el._x_isShown === false)
        return;
      next(e);
    });
  }
  handler3 = wrapHandler(handler3, (next, e) => {
    if (isKeyEvent(event)) {
      if (isListeningForASpecificKeyThatHasntBeenPressed(e, modifiers)) {
        return;
      }
    }
    next(e);
  });
  if (modifiers.includes("debounce")) {
    let nextModifier = modifiers[modifiers.indexOf("debounce") + 1] || "invalid-wait";
    let wait = isNumeric(nextModifier.split("ms")[0]) ? Number(nextModifier.split("ms")[0]) : 250;
    handler3 = debounce(handler3, wait);
  }
  if (modifiers.includes("throttle")) {
    let nextModifier = modifiers[modifiers.indexOf("throttle") + 1] || "invalid-wait";
    let wait = isNumeric(nextModifier.split("ms")[0]) ? Number(nextModifier.split("ms")[0]) : 250;
    handler3 = throttle(handler3, wait);
  }
  if (modifiers.includes("once")) {
    handler3 = wrapHandler(handler3, (next, e) => {
      next(e);
      listenerTarget.removeEventListener(event, handler3, options);
    });
  }
  listenerTarget.addEventListener(event, handler3, options);
  return () => {
    listenerTarget.removeEventListener(event, handler3, options);
  };
}
function dotSyntax(subject) {
  return subject.replace(/-/g, ".");
}
function camelCase2(subject) {
  return subject.toLowerCase().replace(/-(\w)/g, (match, char) => char.toUpperCase());
}
function isNumeric(subject) {
  return !Array.isArray(subject) && !isNaN(subject);
}
function kebabCase2(subject) {
  return subject.replace(/([a-z])([A-Z])/g, "$1-$2").replace(/[_\s]/, "-").toLowerCase();
}
function isKeyEvent(event) {
  return ["keydown", "keyup"].includes(event);
}
function isListeningForASpecificKeyThatHasntBeenPressed(e, modifiers) {
  let keyModifiers = modifiers.filter((i) => {
    return !["window", "document", "prevent", "stop", "once"].includes(i);
  });
  if (keyModifiers.includes("debounce")) {
    let debounceIndex = keyModifiers.indexOf("debounce");
    keyModifiers.splice(debounceIndex, isNumeric((keyModifiers[debounceIndex + 1] || "invalid-wait").split("ms")[0]) ? 2 : 1);
  }
  if (keyModifiers.length === 0)
    return false;
  if (keyModifiers.length === 1 && keyToModifiers(e.key).includes(keyModifiers[0]))
    return false;
  const systemKeyModifiers = ["ctrl", "shift", "alt", "meta", "cmd", "super"];
  const selectedSystemKeyModifiers = systemKeyModifiers.filter((modifier) => keyModifiers.includes(modifier));
  keyModifiers = keyModifiers.filter((i) => !selectedSystemKeyModifiers.includes(i));
  if (selectedSystemKeyModifiers.length > 0) {
    const activelyPressedKeyModifiers = selectedSystemKeyModifiers.filter((modifier) => {
      if (modifier === "cmd" || modifier === "super")
        modifier = "meta";
      return e[`${modifier}Key`];
    });
    if (activelyPressedKeyModifiers.length === selectedSystemKeyModifiers.length) {
      if (keyToModifiers(e.key).includes(keyModifiers[0]))
        return false;
    }
  }
  return true;
}
function keyToModifiers(key) {
  if (!key)
    return [];
  key = kebabCase2(key);
  let modifierToKeyMap = {
    ctrl: "control",
    slash: "/",
    space: "-",
    spacebar: "-",
    cmd: "meta",
    esc: "escape",
    up: "arrow-up",
    down: "arrow-down",
    left: "arrow-left",
    right: "arrow-right",
    period: ".",
    equal: "="
  };
  modifierToKeyMap[key] = key;
  return Object.keys(modifierToKeyMap).map((modifier) => {
    if (modifierToKeyMap[modifier] === key)
      return modifier;
  }).filter((modifier) => modifier);
}

// packages/alpinejs/src/directives/x-model.js
directive("model", (el, {modifiers, expression}, {effect: effect3, cleanup}) => {
  let evaluate2 = evaluateLater(el, expression);
  let assignmentExpression = `${expression} = rightSideOfExpression($event, ${expression})`;
  let evaluateAssignment = evaluateLater(el, assignmentExpression);
  var event = el.tagName.toLowerCase() === "select" || ["checkbox", "radio"].includes(el.type) || modifiers.includes("lazy") ? "change" : "input";
  let assigmentFunction = generateAssignmentFunction(el, modifiers, expression);
  let removeListener = on(el, event, modifiers, (e) => {
    evaluateAssignment(() => {
    }, {scope: {
      $event: e,
      rightSideOfExpression: assigmentFunction
    }});
  });
  cleanup(() => removeListener());
  let evaluateSetModel = evaluateLater(el, `${expression} = __placeholder`);
  el._x_model = {
    get() {
      let result;
      evaluate2((value) => result = value);
      return result;
    },
    set(value) {
      evaluateSetModel(() => {
      }, {scope: {__placeholder: value}});
    }
  };
  el._x_forceModelUpdate = () => {
    evaluate2((value) => {
      if (value === void 0 && expression.match(/\./))
        value = "";
      window.fromModel = true;
      mutateDom(() => bind(el, "value", value));
      delete window.fromModel;
    });
  };
  effect3(() => {
    if (modifiers.includes("unintrusive") && document.activeElement.isSameNode(el))
      return;
    el._x_forceModelUpdate();
  });
});
function generateAssignmentFunction(el, modifiers, expression) {
  if (el.type === "radio") {
    mutateDom(() => {
      if (!el.hasAttribute("name"))
        el.setAttribute("name", expression);
    });
  }
  return (event, currentValue) => {
    return mutateDom(() => {
      if (event instanceof CustomEvent && event.detail !== void 0) {
        return event.detail || event.target.value;
      } else if (el.type === "checkbox") {
        if (Array.isArray(currentValue)) {
          let newValue = modifiers.includes("number") ? safeParseNumber(event.target.value) : event.target.value;
          return event.target.checked ? currentValue.concat([newValue]) : currentValue.filter((el2) => !checkedAttrLooseCompare2(el2, newValue));
        } else {
          return event.target.checked;
        }
      } else if (el.tagName.toLowerCase() === "select" && el.multiple) {
        return modifiers.includes("number") ? Array.from(event.target.selectedOptions).map((option) => {
          let rawValue = option.value || option.text;
          return safeParseNumber(rawValue);
        }) : Array.from(event.target.selectedOptions).map((option) => {
          return option.value || option.text;
        });
      } else {
        let rawValue = event.target.value;
        return modifiers.includes("number") ? safeParseNumber(rawValue) : modifiers.includes("trim") ? rawValue.trim() : rawValue;
      }
    });
  };
}
function safeParseNumber(rawValue) {
  let number = rawValue ? parseFloat(rawValue) : null;
  return isNumeric2(number) ? number : rawValue;
}
function checkedAttrLooseCompare2(valueA, valueB) {
  return valueA == valueB;
}
function isNumeric2(subject) {
  return !Array.isArray(subject) && !isNaN(subject);
}

// packages/alpinejs/src/directives/x-cloak.js
directive("cloak", (el) => queueMicrotask(() => mutateDom(() => el.removeAttribute(prefix("cloak")))));

// packages/alpinejs/src/directives/x-init.js
addInitSelector(() => `[${prefix("init")}]`);
directive("init", skipDuringClone((el, {expression}) => {
  if (typeof expression === "string") {
    return !!expression.trim() && evaluate(el, expression, {}, false);
  }
  return evaluate(el, expression, {}, false);
}));

// packages/alpinejs/src/directives/x-text.js
directive("text", (el, {expression}, {effect: effect3, evaluateLater: evaluateLater2}) => {
  let evaluate2 = evaluateLater2(expression);
  effect3(() => {
    evaluate2((value) => {
      mutateDom(() => {
        el.textContent = value;
      });
    });
  });
});

// packages/alpinejs/src/directives/x-html.js
directive("html", (el, {expression}, {effect: effect3, evaluateLater: evaluateLater2}) => {
  let evaluate2 = evaluateLater2(expression);
  effect3(() => {
    evaluate2((value) => {
      el.innerHTML = value;
    });
  });
});

// packages/alpinejs/src/directives/x-bind.js
mapAttributes(startingWith(":", into(prefix("bind:"))));
directive("bind", (el, {value, modifiers, expression, original}, {effect: effect3}) => {
  if (!value) {
    return applyBindingsObject(el, expression, original, effect3);
  }
  if (value === "key")
    return storeKeyForXFor(el, expression);
  let evaluate2 = evaluateLater(el, expression);
  effect3(() => evaluate2((result) => {
    if (result === void 0 && expression.match(/\./))
      result = "";
    mutateDom(() => bind(el, value, result, modifiers));
  }));
});
function applyBindingsObject(el, expression, original, effect3) {
  let bindingProviders = {};
  injectBindingProviders(bindingProviders);
  let getBindings = evaluateLater(el, expression);
  let cleanupRunners = [];
  while (cleanupRunners.length)
    cleanupRunners.pop()();
  getBindings((bindings) => {
    let attributes = Object.entries(bindings).map(([name, value]) => ({name, value}));
    let staticAttributes = attributesOnly(attributes);
    attributes = attributes.map((attribute) => {
      if (staticAttributes.find((attr) => attr.name === attribute.name)) {
        return {
          name: `x-bind:${attribute.name}`,
          value: `"${attribute.value}"`
        };
      }
      return attribute;
    });
    directives(el, attributes, original).map((handle) => {
      cleanupRunners.push(handle.runCleanups);
      handle();
    });
  }, {scope: bindingProviders});
}
function storeKeyForXFor(el, expression) {
  el._x_keyExpression = expression;
}

// packages/alpinejs/src/directives/x-data.js
addRootSelector(() => `[${prefix("data")}]`);
directive("data", skipDuringClone((el, {expression}, {cleanup}) => {
  expression = expression === "" ? "{}" : expression;
  let magicContext = {};
  injectMagics(magicContext, el);
  let dataProviderContext = {};
  injectDataProviders(dataProviderContext, magicContext);
  let data2 = evaluate(el, expression, {scope: dataProviderContext});
  if (data2 === void 0)
    data2 = {};
  injectMagics(data2, el);
  let reactiveData = reactive(data2);
  initInterceptors(reactiveData);
  let undo = addScopeToNode(el, reactiveData);
  reactiveData["init"] && evaluate(el, reactiveData["init"]);
  cleanup(() => {
    undo();
    reactiveData["destroy"] && evaluate(el, reactiveData["destroy"]);
  });
}));

// packages/alpinejs/src/directives/x-show.js
directive("show", (el, {modifiers, expression}, {effect: effect3}) => {
  let evaluate2 = evaluateLater(el, expression);
  let hide = () => mutateDom(() => {
    el.style.display = "none";
    el._x_isShown = false;
  });
  let show = () => mutateDom(() => {
    if (el.style.length === 1 && el.style.display === "none") {
      el.removeAttribute("style");
    } else {
      el.style.removeProperty("display");
    }
    el._x_isShown = true;
  });
  let clickAwayCompatibleShow = () => setTimeout(show);
  let toggle = once((value) => value ? show() : hide(), (value) => {
    if (typeof el._x_toggleAndCascadeWithTransitions === "function") {
      el._x_toggleAndCascadeWithTransitions(el, value, show, hide);
    } else {
      value ? clickAwayCompatibleShow() : hide();
    }
  });
  let oldValue;
  let firstTime = true;
  effect3(() => evaluate2((value) => {
    if (!firstTime && value === oldValue)
      return;
    if (modifiers.includes("immediate"))
      value ? clickAwayCompatibleShow() : hide();
    toggle(value);
    oldValue = value;
    firstTime = false;
  }));
});

// packages/alpinejs/src/directives/x-for.js
directive("for", (el, {expression}, {effect: effect3, cleanup}) => {
  let iteratorNames = parseForExpression(expression);
  let evaluateItems = evaluateLater(el, iteratorNames.items);
  let evaluateKey = evaluateLater(el, el._x_keyExpression || "index");
  el._x_prevKeys = [];
  el._x_lookup = {};
  effect3(() => loop(el, iteratorNames, evaluateItems, evaluateKey));
  cleanup(() => {
    Object.values(el._x_lookup).forEach((el2) => el2.remove());
    delete el._x_prevKeys;
    delete el._x_lookup;
  });
});
function loop(el, iteratorNames, evaluateItems, evaluateKey) {
  let isObject = (i) => typeof i === "object" && !Array.isArray(i);
  let templateEl = el;
  evaluateItems((items) => {
    if (isNumeric3(items) && items >= 0) {
      items = Array.from(Array(items).keys(), (i) => i + 1);
    }
    if (items === void 0)
      items = [];
    let lookup = el._x_lookup;
    let prevKeys = el._x_prevKeys;
    let scopes = [];
    let keys = [];
    if (isObject(items)) {
      items = Object.entries(items).map(([key, value]) => {
        let scope2 = getIterationScopeVariables(iteratorNames, value, key, items);
        evaluateKey((value2) => keys.push(value2), {scope: {index: key, ...scope2}});
        scopes.push(scope2);
      });
    } else {
      for (let i = 0; i < items.length; i++) {
        let scope2 = getIterationScopeVariables(iteratorNames, items[i], i, items);
        evaluateKey((value) => keys.push(value), {scope: {index: i, ...scope2}});
        scopes.push(scope2);
      }
    }
    let adds = [];
    let moves = [];
    let removes = [];
    let sames = [];
    for (let i = 0; i < prevKeys.length; i++) {
      let key = prevKeys[i];
      if (keys.indexOf(key) === -1)
        removes.push(key);
    }
    prevKeys = prevKeys.filter((key) => !removes.includes(key));
    let lastKey = "template";
    for (let i = 0; i < keys.length; i++) {
      let key = keys[i];
      let prevIndex = prevKeys.indexOf(key);
      if (prevIndex === -1) {
        prevKeys.splice(i, 0, key);
        adds.push([lastKey, i]);
      } else if (prevIndex !== i) {
        let keyInSpot = prevKeys.splice(i, 1)[0];
        let keyForSpot = prevKeys.splice(prevIndex - 1, 1)[0];
        prevKeys.splice(i, 0, keyForSpot);
        prevKeys.splice(prevIndex, 0, keyInSpot);
        moves.push([keyInSpot, keyForSpot]);
      } else {
        sames.push(key);
      }
      lastKey = key;
    }
    for (let i = 0; i < removes.length; i++) {
      let key = removes[i];
      if (!!lookup[key]._x_effects) {
        lookup[key]._x_effects.forEach(dequeueJob);
      }
      lookup[key].remove();
      lookup[key] = null;
      delete lookup[key];
    }
    for (let i = 0; i < moves.length; i++) {
      let [keyInSpot, keyForSpot] = moves[i];
      let elInSpot = lookup[keyInSpot];
      let elForSpot = lookup[keyForSpot];
      let marker = document.createElement("div");
      mutateDom(() => {
        elForSpot.after(marker);
        elInSpot.after(elForSpot);
        elForSpot._x_currentIfEl && elForSpot.after(elForSpot._x_currentIfEl);
        marker.before(elInSpot);
        elInSpot._x_currentIfEl && elInSpot.after(elInSpot._x_currentIfEl);
        marker.remove();
      });
      refreshScope(elForSpot, scopes[keys.indexOf(keyForSpot)]);
    }
    for (let i = 0; i < adds.length; i++) {
      let [lastKey2, index] = adds[i];
      let lastEl = lastKey2 === "template" ? templateEl : lookup[lastKey2];
      if (lastEl._x_currentIfEl)
        lastEl = lastEl._x_currentIfEl;
      let scope2 = scopes[index];
      let key = keys[index];
      let clone2 = document.importNode(templateEl.content, true).firstElementChild;
      addScopeToNode(clone2, reactive(scope2), templateEl);
      mutateDom(() => {
        lastEl.after(clone2);
        initTree(clone2);
      });
      if (typeof key === "object") {
        warn("x-for key cannot be an object, it must be a string or an integer", templateEl);
      }
      lookup[key] = clone2;
    }
    for (let i = 0; i < sames.length; i++) {
      refreshScope(lookup[sames[i]], scopes[keys.indexOf(sames[i])]);
    }
    templateEl._x_prevKeys = keys;
  });
}
function parseForExpression(expression) {
  let forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/;
  let stripParensRE = /^\s*\(|\)\s*$/g;
  let forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/;
  let inMatch = expression.match(forAliasRE);
  if (!inMatch)
    return;
  let res = {};
  res.items = inMatch[2].trim();
  let item = inMatch[1].replace(stripParensRE, "").trim();
  let iteratorMatch = item.match(forIteratorRE);
  if (iteratorMatch) {
    res.item = item.replace(forIteratorRE, "").trim();
    res.index = iteratorMatch[1].trim();
    if (iteratorMatch[2]) {
      res.collection = iteratorMatch[2].trim();
    }
  } else {
    res.item = item;
  }
  return res;
}
function getIterationScopeVariables(iteratorNames, item, index, items) {
  let scopeVariables = {};
  if (/^\[.*\]$/.test(iteratorNames.item) && Array.isArray(item)) {
    let names = iteratorNames.item.replace("[", "").replace("]", "").split(",").map((i) => i.trim());
    names.forEach((name, i) => {
      scopeVariables[name] = item[i];
    });
  } else if (/^\{.*\}$/.test(iteratorNames.item) && !Array.isArray(item) && typeof item === "object") {
    let names = iteratorNames.item.replace("{", "").replace("}", "").split(",").map((i) => i.trim());
    names.forEach((name) => {
      scopeVariables[name] = item[name];
    });
  } else {
    scopeVariables[iteratorNames.item] = item;
  }
  if (iteratorNames.index)
    scopeVariables[iteratorNames.index] = index;
  if (iteratorNames.collection)
    scopeVariables[iteratorNames.collection] = items;
  return scopeVariables;
}
function isNumeric3(subject) {
  return !Array.isArray(subject) && !isNaN(subject);
}

// packages/alpinejs/src/directives/x-ref.js
function handler2() {
}
handler2.inline = (el, {expression}, {cleanup}) => {
  let root = closestRoot(el);
  if (!root._x_refs)
    root._x_refs = {};
  root._x_refs[expression] = el;
  cleanup(() => delete root._x_refs[expression]);
};
directive("ref", handler2);

// packages/alpinejs/src/directives/x-if.js
directive("if", (el, {expression}, {effect: effect3, cleanup}) => {
  let evaluate2 = evaluateLater(el, expression);
  let show = () => {
    if (el._x_currentIfEl)
      return el._x_currentIfEl;
    let clone2 = el.content.cloneNode(true).firstElementChild;
    addScopeToNode(clone2, {}, el);
    mutateDom(() => {
      el.after(clone2);
      initTree(clone2);
    });
    el._x_currentIfEl = clone2;
    el._x_undoIf = () => {
      walk(clone2, (node) => {
        if (!!node._x_effects) {
          node._x_effects.forEach(dequeueJob);
        }
      });
      clone2.remove();
      delete el._x_currentIfEl;
    };
    return clone2;
  };
  let hide = () => {
    if (!el._x_undoIf)
      return;
    el._x_undoIf();
    delete el._x_undoIf;
  };
  effect3(() => evaluate2((value) => {
    value ? show() : hide();
  }));
  cleanup(() => el._x_undoIf && el._x_undoIf());
});

// packages/alpinejs/src/directives/x-id.js
directive("id", (el, {expression}, {evaluate: evaluate2}) => {
  let names = evaluate2(expression);
  names.forEach((name) => setIdRoot(el, name));
});

// packages/alpinejs/src/directives/x-on.js
mapAttributes(startingWith("@", into(prefix("on:"))));
directive("on", skipDuringClone((el, {value, modifiers, expression}, {cleanup}) => {
  let evaluate2 = expression ? evaluateLater(el, expression) : () => {
  };
  if (el.tagName.toLowerCase() === "template") {
    if (!el._x_forwardEvents)
      el._x_forwardEvents = [];
    if (!el._x_forwardEvents.includes(value))
      el._x_forwardEvents.push(value);
  }
  let removeListener = on(el, value, modifiers, (e) => {
    evaluate2(() => {
    }, {scope: {$event: e}, params: [e]});
  });
  cleanup(() => removeListener());
}));

// packages/alpinejs/src/index.js
alpine_default.setEvaluator(normalEvaluator);
alpine_default.setReactivityEngine({reactive: import_reactivity9.reactive, effect: import_reactivity9.effect, release: import_reactivity9.stop, raw: import_reactivity9.toRaw});
var src_default = alpine_default;

// packages/alpinejs/builds/module.js
var module_default = src_default;



/***/ }),

/***/ "./node_modules/axios/index.js":
/*!*************************************!*\
  !*** ./node_modules/axios/index.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(/*! ./lib/axios */ "./node_modules/axios/lib/axios.js");

/***/ }),

/***/ "./node_modules/axios/lib/adapters/xhr.js":
/*!************************************************!*\
  !*** ./node_modules/axios/lib/adapters/xhr.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");
var settle = __webpack_require__(/*! ./../core/settle */ "./node_modules/axios/lib/core/settle.js");
var cookies = __webpack_require__(/*! ./../helpers/cookies */ "./node_modules/axios/lib/helpers/cookies.js");
var buildURL = __webpack_require__(/*! ./../helpers/buildURL */ "./node_modules/axios/lib/helpers/buildURL.js");
var buildFullPath = __webpack_require__(/*! ../core/buildFullPath */ "./node_modules/axios/lib/core/buildFullPath.js");
var parseHeaders = __webpack_require__(/*! ./../helpers/parseHeaders */ "./node_modules/axios/lib/helpers/parseHeaders.js");
var isURLSameOrigin = __webpack_require__(/*! ./../helpers/isURLSameOrigin */ "./node_modules/axios/lib/helpers/isURLSameOrigin.js");
var createError = __webpack_require__(/*! ../core/createError */ "./node_modules/axios/lib/core/createError.js");

module.exports = function xhrAdapter(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    var requestData = config.data;
    var requestHeaders = config.headers;
    var responseType = config.responseType;

    if (utils.isFormData(requestData)) {
      delete requestHeaders['Content-Type']; // Let the browser set it
    }

    var request = new XMLHttpRequest();

    // HTTP basic authentication
    if (config.auth) {
      var username = config.auth.username || '';
      var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';
      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
    }

    var fullPath = buildFullPath(config.baseURL, config.url);
    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);

    // Set the request timeout in MS
    request.timeout = config.timeout;

    function onloadend() {
      if (!request) {
        return;
      }
      // Prepare the response
      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
      var responseData = !responseType || responseType === 'text' ||  responseType === 'json' ?
        request.responseText : request.response;
      var response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config: config,
        request: request
      };

      settle(resolve, reject, response);

      // Clean up request
      request = null;
    }

    if ('onloadend' in request) {
      // Use onloadend if available
      request.onloadend = onloadend;
    } else {
      // Listen for ready state to emulate onloadend
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }

        // The request errored out and we didn't get a response, this will be
        // handled by onerror instead
        // With one exception: request that using file: protocol, most browsers
        // will return status as 0 even though it's a successful request
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
          return;
        }
        // readystate handler is calling before onerror or ontimeout handlers,
        // so we should call onloadend on the next 'tick'
        setTimeout(onloadend);
      };
    }

    // Handle browser request cancellation (as opposed to a manual cancellation)
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }

      reject(createError('Request aborted', config, 'ECONNABORTED', request));

      // Clean up request
      request = null;
    };

    // Handle low level network errors
    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(createError('Network Error', config, null, request));

      // Clean up request
      request = null;
    };

    // Handle timeout
    request.ontimeout = function handleTimeout() {
      var timeoutErrorMessage = 'timeout of ' + config.timeout + 'ms exceeded';
      if (config.timeoutErrorMessage) {
        timeoutErrorMessage = config.timeoutErrorMessage;
      }
      reject(createError(
        timeoutErrorMessage,
        config,
        config.transitional && config.transitional.clarifyTimeoutError ? 'ETIMEDOUT' : 'ECONNABORTED',
        request));

      // Clean up request
      request = null;
    };

    // Add xsrf header
    // This is only done if running in a standard browser environment.
    // Specifically not if we're in a web worker, or react-native.
    if (utils.isStandardBrowserEnv()) {
      // Add xsrf header
      var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ?
        cookies.read(config.xsrfCookieName) :
        undefined;

      if (xsrfValue) {
        requestHeaders[config.xsrfHeaderName] = xsrfValue;
      }
    }

    // Add headers to the request
    if ('setRequestHeader' in request) {
      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
          // Remove Content-Type if data is undefined
          delete requestHeaders[key];
        } else {
          // Otherwise add header to the request
          request.setRequestHeader(key, val);
        }
      });
    }

    // Add withCredentials to request if needed
    if (!utils.isUndefined(config.withCredentials)) {
      request.withCredentials = !!config.withCredentials;
    }

    // Add responseType to request if needed
    if (responseType && responseType !== 'json') {
      request.responseType = config.responseType;
    }

    // Handle progress if needed
    if (typeof config.onDownloadProgress === 'function') {
      request.addEventListener('progress', config.onDownloadProgress);
    }

    // Not all browsers support upload events
    if (typeof config.onUploadProgress === 'function' && request.upload) {
      request.upload.addEventListener('progress', config.onUploadProgress);
    }

    if (config.cancelToken) {
      // Handle cancellation
      config.cancelToken.promise.then(function onCanceled(cancel) {
        if (!request) {
          return;
        }

        request.abort();
        reject(cancel);
        // Clean up request
        request = null;
      });
    }

    if (!requestData) {
      requestData = null;
    }

    // Send the request
    request.send(requestData);
  });
};


/***/ }),

/***/ "./node_modules/axios/lib/axios.js":
/*!*****************************************!*\
  !*** ./node_modules/axios/lib/axios.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./utils */ "./node_modules/axios/lib/utils.js");
var bind = __webpack_require__(/*! ./helpers/bind */ "./node_modules/axios/lib/helpers/bind.js");
var Axios = __webpack_require__(/*! ./core/Axios */ "./node_modules/axios/lib/core/Axios.js");
var mergeConfig = __webpack_require__(/*! ./core/mergeConfig */ "./node_modules/axios/lib/core/mergeConfig.js");
var defaults = __webpack_require__(/*! ./defaults */ "./node_modules/axios/lib/defaults.js");

/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 * @return {Axios} A new instance of Axios
 */
function createInstance(defaultConfig) {
  var context = new Axios(defaultConfig);
  var instance = bind(Axios.prototype.request, context);

  // Copy axios.prototype to instance
  utils.extend(instance, Axios.prototype, context);

  // Copy context to instance
  utils.extend(instance, context);

  return instance;
}

// Create the default instance to be exported
var axios = createInstance(defaults);

// Expose Axios class to allow class inheritance
axios.Axios = Axios;

// Factory for creating new instances
axios.create = function create(instanceConfig) {
  return createInstance(mergeConfig(axios.defaults, instanceConfig));
};

// Expose Cancel & CancelToken
axios.Cancel = __webpack_require__(/*! ./cancel/Cancel */ "./node_modules/axios/lib/cancel/Cancel.js");
axios.CancelToken = __webpack_require__(/*! ./cancel/CancelToken */ "./node_modules/axios/lib/cancel/CancelToken.js");
axios.isCancel = __webpack_require__(/*! ./cancel/isCancel */ "./node_modules/axios/lib/cancel/isCancel.js");

// Expose all/spread
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = __webpack_require__(/*! ./helpers/spread */ "./node_modules/axios/lib/helpers/spread.js");

// Expose isAxiosError
axios.isAxiosError = __webpack_require__(/*! ./helpers/isAxiosError */ "./node_modules/axios/lib/helpers/isAxiosError.js");

module.exports = axios;

// Allow use of default import syntax in TypeScript
module.exports["default"] = axios;


/***/ }),

/***/ "./node_modules/axios/lib/cancel/Cancel.js":
/*!*************************************************!*\
  !*** ./node_modules/axios/lib/cancel/Cancel.js ***!
  \*************************************************/
/***/ ((module) => {

"use strict";


/**
 * A `Cancel` is an object that is thrown when an operation is canceled.
 *
 * @class
 * @param {string=} message The message.
 */
function Cancel(message) {
  this.message = message;
}

Cancel.prototype.toString = function toString() {
  return 'Cancel' + (this.message ? ': ' + this.message : '');
};

Cancel.prototype.__CANCEL__ = true;

module.exports = Cancel;


/***/ }),

/***/ "./node_modules/axios/lib/cancel/CancelToken.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/cancel/CancelToken.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var Cancel = __webpack_require__(/*! ./Cancel */ "./node_modules/axios/lib/cancel/Cancel.js");

/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @class
 * @param {Function} executor The executor function.
 */
function CancelToken(executor) {
  if (typeof executor !== 'function') {
    throw new TypeError('executor must be a function.');
  }

  var resolvePromise;
  this.promise = new Promise(function promiseExecutor(resolve) {
    resolvePromise = resolve;
  });

  var token = this;
  executor(function cancel(message) {
    if (token.reason) {
      // Cancellation has already been requested
      return;
    }

    token.reason = new Cancel(message);
    resolvePromise(token.reason);
  });
}

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
CancelToken.prototype.throwIfRequested = function throwIfRequested() {
  if (this.reason) {
    throw this.reason;
  }
};

/**
 * Returns an object that contains a new `CancelToken` and a function that, when called,
 * cancels the `CancelToken`.
 */
CancelToken.source = function source() {
  var cancel;
  var token = new CancelToken(function executor(c) {
    cancel = c;
  });
  return {
    token: token,
    cancel: cancel
  };
};

module.exports = CancelToken;


/***/ }),

/***/ "./node_modules/axios/lib/cancel/isCancel.js":
/*!***************************************************!*\
  !*** ./node_modules/axios/lib/cancel/isCancel.js ***!
  \***************************************************/
/***/ ((module) => {

"use strict";


module.exports = function isCancel(value) {
  return !!(value && value.__CANCEL__);
};


/***/ }),

/***/ "./node_modules/axios/lib/core/Axios.js":
/*!**********************************************!*\
  !*** ./node_modules/axios/lib/core/Axios.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");
var buildURL = __webpack_require__(/*! ../helpers/buildURL */ "./node_modules/axios/lib/helpers/buildURL.js");
var InterceptorManager = __webpack_require__(/*! ./InterceptorManager */ "./node_modules/axios/lib/core/InterceptorManager.js");
var dispatchRequest = __webpack_require__(/*! ./dispatchRequest */ "./node_modules/axios/lib/core/dispatchRequest.js");
var mergeConfig = __webpack_require__(/*! ./mergeConfig */ "./node_modules/axios/lib/core/mergeConfig.js");
var validator = __webpack_require__(/*! ../helpers/validator */ "./node_modules/axios/lib/helpers/validator.js");

var validators = validator.validators;
/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 */
function Axios(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}

/**
 * Dispatch a request
 *
 * @param {Object} config The config specific for this request (merged with this.defaults)
 */
Axios.prototype.request = function request(config) {
  /*eslint no-param-reassign:0*/
  // Allow for axios('example/url'[, config]) a la fetch API
  if (typeof config === 'string') {
    config = arguments[1] || {};
    config.url = arguments[0];
  } else {
    config = config || {};
  }

  config = mergeConfig(this.defaults, config);

  // Set config.method
  if (config.method) {
    config.method = config.method.toLowerCase();
  } else if (this.defaults.method) {
    config.method = this.defaults.method.toLowerCase();
  } else {
    config.method = 'get';
  }

  var transitional = config.transitional;

  if (transitional !== undefined) {
    validator.assertOptions(transitional, {
      silentJSONParsing: validators.transitional(validators.boolean, '1.0.0'),
      forcedJSONParsing: validators.transitional(validators.boolean, '1.0.0'),
      clarifyTimeoutError: validators.transitional(validators.boolean, '1.0.0')
    }, false);
  }

  // filter out skipped interceptors
  var requestInterceptorChain = [];
  var synchronousRequestInterceptors = true;
  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {
      return;
    }

    synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;

    requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
  });

  var responseInterceptorChain = [];
  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
  });

  var promise;

  if (!synchronousRequestInterceptors) {
    var chain = [dispatchRequest, undefined];

    Array.prototype.unshift.apply(chain, requestInterceptorChain);
    chain = chain.concat(responseInterceptorChain);

    promise = Promise.resolve(config);
    while (chain.length) {
      promise = promise.then(chain.shift(), chain.shift());
    }

    return promise;
  }


  var newConfig = config;
  while (requestInterceptorChain.length) {
    var onFulfilled = requestInterceptorChain.shift();
    var onRejected = requestInterceptorChain.shift();
    try {
      newConfig = onFulfilled(newConfig);
    } catch (error) {
      onRejected(error);
      break;
    }
  }

  try {
    promise = dispatchRequest(newConfig);
  } catch (error) {
    return Promise.reject(error);
  }

  while (responseInterceptorChain.length) {
    promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
  }

  return promise;
};

Axios.prototype.getUri = function getUri(config) {
  config = mergeConfig(this.defaults, config);
  return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, '');
};

// Provide aliases for supported request methods
utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, config) {
    return this.request(mergeConfig(config || {}, {
      method: method,
      url: url,
      data: (config || {}).data
    }));
  };
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, data, config) {
    return this.request(mergeConfig(config || {}, {
      method: method,
      url: url,
      data: data
    }));
  };
});

module.exports = Axios;


/***/ }),

/***/ "./node_modules/axios/lib/core/InterceptorManager.js":
/*!***********************************************************!*\
  !*** ./node_modules/axios/lib/core/InterceptorManager.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

function InterceptorManager() {
  this.handlers = [];
}

/**
 * Add a new interceptor to the stack
 *
 * @param {Function} fulfilled The function to handle `then` for a `Promise`
 * @param {Function} rejected The function to handle `reject` for a `Promise`
 *
 * @return {Number} An ID used to remove interceptor later
 */
InterceptorManager.prototype.use = function use(fulfilled, rejected, options) {
  this.handlers.push({
    fulfilled: fulfilled,
    rejected: rejected,
    synchronous: options ? options.synchronous : false,
    runWhen: options ? options.runWhen : null
  });
  return this.handlers.length - 1;
};

/**
 * Remove an interceptor from the stack
 *
 * @param {Number} id The ID that was returned by `use`
 */
InterceptorManager.prototype.eject = function eject(id) {
  if (this.handlers[id]) {
    this.handlers[id] = null;
  }
};

/**
 * Iterate over all the registered interceptors
 *
 * This method is particularly useful for skipping over any
 * interceptors that may have become `null` calling `eject`.
 *
 * @param {Function} fn The function to call for each interceptor
 */
InterceptorManager.prototype.forEach = function forEach(fn) {
  utils.forEach(this.handlers, function forEachHandler(h) {
    if (h !== null) {
      fn(h);
    }
  });
};

module.exports = InterceptorManager;


/***/ }),

/***/ "./node_modules/axios/lib/core/buildFullPath.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/core/buildFullPath.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var isAbsoluteURL = __webpack_require__(/*! ../helpers/isAbsoluteURL */ "./node_modules/axios/lib/helpers/isAbsoluteURL.js");
var combineURLs = __webpack_require__(/*! ../helpers/combineURLs */ "./node_modules/axios/lib/helpers/combineURLs.js");

/**
 * Creates a new URL by combining the baseURL with the requestedURL,
 * only when the requestedURL is not already an absolute URL.
 * If the requestURL is absolute, this function returns the requestedURL untouched.
 *
 * @param {string} baseURL The base URL
 * @param {string} requestedURL Absolute or relative URL to combine
 * @returns {string} The combined full path
 */
module.exports = function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
};


/***/ }),

/***/ "./node_modules/axios/lib/core/createError.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/core/createError.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var enhanceError = __webpack_require__(/*! ./enhanceError */ "./node_modules/axios/lib/core/enhanceError.js");

/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The created error.
 */
module.exports = function createError(message, config, code, request, response) {
  var error = new Error(message);
  return enhanceError(error, config, code, request, response);
};


/***/ }),

/***/ "./node_modules/axios/lib/core/dispatchRequest.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/core/dispatchRequest.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");
var transformData = __webpack_require__(/*! ./transformData */ "./node_modules/axios/lib/core/transformData.js");
var isCancel = __webpack_require__(/*! ../cancel/isCancel */ "./node_modules/axios/lib/cancel/isCancel.js");
var defaults = __webpack_require__(/*! ../defaults */ "./node_modules/axios/lib/defaults.js");

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
}

/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 * @returns {Promise} The Promise to be fulfilled
 */
module.exports = function dispatchRequest(config) {
  throwIfCancellationRequested(config);

  // Ensure headers exist
  config.headers = config.headers || {};

  // Transform request data
  config.data = transformData.call(
    config,
    config.data,
    config.headers,
    config.transformRequest
  );

  // Flatten headers
  config.headers = utils.merge(
    config.headers.common || {},
    config.headers[config.method] || {},
    config.headers
  );

  utils.forEach(
    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
    function cleanHeaderConfig(method) {
      delete config.headers[method];
    }
  );

  var adapter = config.adapter || defaults.adapter;

  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);

    // Transform response data
    response.data = transformData.call(
      config,
      response.data,
      response.headers,
      config.transformResponse
    );

    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);

      // Transform response data
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config,
          reason.response.data,
          reason.response.headers,
          config.transformResponse
        );
      }
    }

    return Promise.reject(reason);
  });
};


/***/ }),

/***/ "./node_modules/axios/lib/core/enhanceError.js":
/*!*****************************************************!*\
  !*** ./node_modules/axios/lib/core/enhanceError.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";


/**
 * Update an Error with the specified config, error code, and response.
 *
 * @param {Error} error The error to update.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The error.
 */
module.exports = function enhanceError(error, config, code, request, response) {
  error.config = config;
  if (code) {
    error.code = code;
  }

  error.request = request;
  error.response = response;
  error.isAxiosError = true;

  error.toJSON = function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: this.config,
      code: this.code
    };
  };
  return error;
};


/***/ }),

/***/ "./node_modules/axios/lib/core/mergeConfig.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/core/mergeConfig.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/axios/lib/utils.js");

/**
 * Config-specific merge-function which creates a new config-object
 * by merging two configuration objects together.
 *
 * @param {Object} config1
 * @param {Object} config2
 * @returns {Object} New object resulting from merging config2 to config1
 */
module.exports = function mergeConfig(config1, config2) {
  // eslint-disable-next-line no-param-reassign
  config2 = config2 || {};
  var config = {};

  var valueFromConfig2Keys = ['url', 'method', 'data'];
  var mergeDeepPropertiesKeys = ['headers', 'auth', 'proxy', 'params'];
  var defaultToConfig2Keys = [
    'baseURL', 'transformRequest', 'transformResponse', 'paramsSerializer',
    'timeout', 'timeoutMessage', 'withCredentials', 'adapter', 'responseType', 'xsrfCookieName',
    'xsrfHeaderName', 'onUploadProgress', 'onDownloadProgress', 'decompress',
    'maxContentLength', 'maxBodyLength', 'maxRedirects', 'transport', 'httpAgent',
    'httpsAgent', 'cancelToken', 'socketPath', 'responseEncoding'
  ];
  var directMergeKeys = ['validateStatus'];

  function getMergedValue(target, source) {
    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
      return utils.merge(target, source);
    } else if (utils.isPlainObject(source)) {
      return utils.merge({}, source);
    } else if (utils.isArray(source)) {
      return source.slice();
    }
    return source;
  }

  function mergeDeepProperties(prop) {
    if (!utils.isUndefined(config2[prop])) {
      config[prop] = getMergedValue(config1[prop], config2[prop]);
    } else if (!utils.isUndefined(config1[prop])) {
      config[prop] = getMergedValue(undefined, config1[prop]);
    }
  }

  utils.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {
    if (!utils.isUndefined(config2[prop])) {
      config[prop] = getMergedValue(undefined, config2[prop]);
    }
  });

  utils.forEach(mergeDeepPropertiesKeys, mergeDeepProperties);

  utils.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {
    if (!utils.isUndefined(config2[prop])) {
      config[prop] = getMergedValue(undefined, config2[prop]);
    } else if (!utils.isUndefined(config1[prop])) {
      config[prop] = getMergedValue(undefined, config1[prop]);
    }
  });

  utils.forEach(directMergeKeys, function merge(prop) {
    if (prop in config2) {
      config[prop] = getMergedValue(config1[prop], config2[prop]);
    } else if (prop in config1) {
      config[prop] = getMergedValue(undefined, config1[prop]);
    }
  });

  var axiosKeys = valueFromConfig2Keys
    .concat(mergeDeepPropertiesKeys)
    .concat(defaultToConfig2Keys)
    .concat(directMergeKeys);

  var otherKeys = Object
    .keys(config1)
    .concat(Object.keys(config2))
    .filter(function filterAxiosKeys(key) {
      return axiosKeys.indexOf(key) === -1;
    });

  utils.forEach(otherKeys, mergeDeepProperties);

  return config;
};


/***/ }),

/***/ "./node_modules/axios/lib/core/settle.js":
/*!***********************************************!*\
  !*** ./node_modules/axios/lib/core/settle.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var createError = __webpack_require__(/*! ./createError */ "./node_modules/axios/lib/core/createError.js");

/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 */
module.exports = function settle(resolve, reject, response) {
  var validateStatus = response.config.validateStatus;
  if (!response.status || !validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(createError(
      'Request failed with status code ' + response.status,
      response.config,
      null,
      response.request,
      response
    ));
  }
};


/***/ }),

/***/ "./node_modules/axios/lib/core/transformData.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/core/transformData.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");
var defaults = __webpack_require__(/*! ./../defaults */ "./node_modules/axios/lib/defaults.js");

/**
 * Transform the data for a request or a response
 *
 * @param {Object|String} data The data to be transformed
 * @param {Array} headers The headers for the request or response
 * @param {Array|Function} fns A single function or Array of functions
 * @returns {*} The resulting transformed data
 */
module.exports = function transformData(data, headers, fns) {
  var context = this || defaults;
  /*eslint no-param-reassign:0*/
  utils.forEach(fns, function transform(fn) {
    data = fn.call(context, data, headers);
  });

  return data;
};


/***/ }),

/***/ "./node_modules/axios/lib/defaults.js":
/*!********************************************!*\
  !*** ./node_modules/axios/lib/defaults.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var process = __webpack_require__(/*! process/browser.js */ "./node_modules/process/browser.js");


var utils = __webpack_require__(/*! ./utils */ "./node_modules/axios/lib/utils.js");
var normalizeHeaderName = __webpack_require__(/*! ./helpers/normalizeHeaderName */ "./node_modules/axios/lib/helpers/normalizeHeaderName.js");
var enhanceError = __webpack_require__(/*! ./core/enhanceError */ "./node_modules/axios/lib/core/enhanceError.js");

var DEFAULT_CONTENT_TYPE = {
  'Content-Type': 'application/x-www-form-urlencoded'
};

function setContentTypeIfUnset(headers, value) {
  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
    headers['Content-Type'] = value;
  }
}

function getDefaultAdapter() {
  var adapter;
  if (typeof XMLHttpRequest !== 'undefined') {
    // For browsers use XHR adapter
    adapter = __webpack_require__(/*! ./adapters/xhr */ "./node_modules/axios/lib/adapters/xhr.js");
  } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {
    // For node use HTTP adapter
    adapter = __webpack_require__(/*! ./adapters/http */ "./node_modules/axios/lib/adapters/xhr.js");
  }
  return adapter;
}

function stringifySafely(rawValue, parser, encoder) {
  if (utils.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils.trim(rawValue);
    } catch (e) {
      if (e.name !== 'SyntaxError') {
        throw e;
      }
    }
  }

  return (encoder || JSON.stringify)(rawValue);
}

var defaults = {

  transitional: {
    silentJSONParsing: true,
    forcedJSONParsing: true,
    clarifyTimeoutError: false
  },

  adapter: getDefaultAdapter(),

  transformRequest: [function transformRequest(data, headers) {
    normalizeHeaderName(headers, 'Accept');
    normalizeHeaderName(headers, 'Content-Type');

    if (utils.isFormData(data) ||
      utils.isArrayBuffer(data) ||
      utils.isBuffer(data) ||
      utils.isStream(data) ||
      utils.isFile(data) ||
      utils.isBlob(data)
    ) {
      return data;
    }
    if (utils.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils.isURLSearchParams(data)) {
      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
      return data.toString();
    }
    if (utils.isObject(data) || (headers && headers['Content-Type'] === 'application/json')) {
      setContentTypeIfUnset(headers, 'application/json');
      return stringifySafely(data);
    }
    return data;
  }],

  transformResponse: [function transformResponse(data) {
    var transitional = this.transitional;
    var silentJSONParsing = transitional && transitional.silentJSONParsing;
    var forcedJSONParsing = transitional && transitional.forcedJSONParsing;
    var strictJSONParsing = !silentJSONParsing && this.responseType === 'json';

    if (strictJSONParsing || (forcedJSONParsing && utils.isString(data) && data.length)) {
      try {
        return JSON.parse(data);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === 'SyntaxError') {
            throw enhanceError(e, this, 'E_JSON_PARSE');
          }
          throw e;
        }
      }
    }

    return data;
  }],

  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,

  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',

  maxContentLength: -1,
  maxBodyLength: -1,

  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  }
};

defaults.headers = {
  common: {
    'Accept': 'application/json, text/plain, */*'
  }
};

utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
  defaults.headers[method] = {};
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
});

module.exports = defaults;


/***/ }),

/***/ "./node_modules/axios/lib/helpers/bind.js":
/*!************************************************!*\
  !*** ./node_modules/axios/lib/helpers/bind.js ***!
  \************************************************/
/***/ ((module) => {

"use strict";


module.exports = function bind(fn, thisArg) {
  return function wrap() {
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }
    return fn.apply(thisArg, args);
  };
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/buildURL.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/helpers/buildURL.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

function encode(val) {
  return encodeURIComponent(val).
    replace(/%3A/gi, ':').
    replace(/%24/g, '$').
    replace(/%2C/gi, ',').
    replace(/%20/g, '+').
    replace(/%5B/gi, '[').
    replace(/%5D/gi, ']');
}

/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @returns {string} The formatted url
 */
module.exports = function buildURL(url, params, paramsSerializer) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }

  var serializedParams;
  if (paramsSerializer) {
    serializedParams = paramsSerializer(params);
  } else if (utils.isURLSearchParams(params)) {
    serializedParams = params.toString();
  } else {
    var parts = [];

    utils.forEach(params, function serialize(val, key) {
      if (val === null || typeof val === 'undefined') {
        return;
      }

      if (utils.isArray(val)) {
        key = key + '[]';
      } else {
        val = [val];
      }

      utils.forEach(val, function parseValue(v) {
        if (utils.isDate(v)) {
          v = v.toISOString();
        } else if (utils.isObject(v)) {
          v = JSON.stringify(v);
        }
        parts.push(encode(key) + '=' + encode(v));
      });
    });

    serializedParams = parts.join('&');
  }

  if (serializedParams) {
    var hashmarkIndex = url.indexOf('#');
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }

    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }

  return url;
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/combineURLs.js":
/*!*******************************************************!*\
  !*** ./node_modules/axios/lib/helpers/combineURLs.js ***!
  \*******************************************************/
/***/ ((module) => {

"use strict";


/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 * @returns {string} The combined URL
 */
module.exports = function combineURLs(baseURL, relativeURL) {
  return relativeURL
    ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '')
    : baseURL;
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/cookies.js":
/*!***************************************************!*\
  !*** ./node_modules/axios/lib/helpers/cookies.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs support document.cookie
    (function standardBrowserEnv() {
      return {
        write: function write(name, value, expires, path, domain, secure) {
          var cookie = [];
          cookie.push(name + '=' + encodeURIComponent(value));

          if (utils.isNumber(expires)) {
            cookie.push('expires=' + new Date(expires).toGMTString());
          }

          if (utils.isString(path)) {
            cookie.push('path=' + path);
          }

          if (utils.isString(domain)) {
            cookie.push('domain=' + domain);
          }

          if (secure === true) {
            cookie.push('secure');
          }

          document.cookie = cookie.join('; ');
        },

        read: function read(name) {
          var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
          return (match ? decodeURIComponent(match[3]) : null);
        },

        remove: function remove(name) {
          this.write(name, '', Date.now() - 86400000);
        }
      };
    })() :

  // Non standard browser env (web workers, react-native) lack needed support.
    (function nonStandardBrowserEnv() {
      return {
        write: function write() {},
        read: function read() { return null; },
        remove: function remove() {}
      };
    })()
);


/***/ }),

/***/ "./node_modules/axios/lib/helpers/isAbsoluteURL.js":
/*!*********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isAbsoluteURL.js ***!
  \*********************************************************/
/***/ ((module) => {

"use strict";


/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */
module.exports = function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/isAxiosError.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isAxiosError.js ***!
  \********************************************************/
/***/ ((module) => {

"use strict";


/**
 * Determines whether the payload is an error thrown by Axios
 *
 * @param {*} payload The value to test
 * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
 */
module.exports = function isAxiosError(payload) {
  return (typeof payload === 'object') && (payload.isAxiosError === true);
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/isURLSameOrigin.js":
/*!***********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isURLSameOrigin.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
    (function standardBrowserEnv() {
      var msie = /(msie|trident)/i.test(navigator.userAgent);
      var urlParsingNode = document.createElement('a');
      var originURL;

      /**
    * Parse a URL to discover it's components
    *
    * @param {String} url The URL to be parsed
    * @returns {Object}
    */
      function resolveURL(url) {
        var href = url;

        if (msie) {
        // IE needs attribute set twice to normalize properties
          urlParsingNode.setAttribute('href', href);
          href = urlParsingNode.href;
        }

        urlParsingNode.setAttribute('href', href);

        // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
        return {
          href: urlParsingNode.href,
          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
          host: urlParsingNode.host,
          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
          hostname: urlParsingNode.hostname,
          port: urlParsingNode.port,
          pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
            urlParsingNode.pathname :
            '/' + urlParsingNode.pathname
        };
      }

      originURL = resolveURL(window.location.href);

      /**
    * Determine if a URL shares the same origin as the current location
    *
    * @param {String} requestURL The URL to test
    * @returns {boolean} True if URL shares the same origin, otherwise false
    */
      return function isURLSameOrigin(requestURL) {
        var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
        return (parsed.protocol === originURL.protocol &&
            parsed.host === originURL.host);
      };
    })() :

  // Non standard browser envs (web workers, react-native) lack needed support.
    (function nonStandardBrowserEnv() {
      return function isURLSameOrigin() {
        return true;
      };
    })()
);


/***/ }),

/***/ "./node_modules/axios/lib/helpers/normalizeHeaderName.js":
/*!***************************************************************!*\
  !*** ./node_modules/axios/lib/helpers/normalizeHeaderName.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/axios/lib/utils.js");

module.exports = function normalizeHeaderName(headers, normalizedName) {
  utils.forEach(headers, function processHeader(value, name) {
    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
      headers[normalizedName] = value;
      delete headers[name];
    }
  });
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/parseHeaders.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/parseHeaders.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

// Headers whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers
var ignoreDuplicateOf = [
  'age', 'authorization', 'content-length', 'content-type', 'etag',
  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
  'last-modified', 'location', 'max-forwards', 'proxy-authorization',
  'referer', 'retry-after', 'user-agent'
];

/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} headers Headers needing to be parsed
 * @returns {Object} Headers parsed into an object
 */
module.exports = function parseHeaders(headers) {
  var parsed = {};
  var key;
  var val;
  var i;

  if (!headers) { return parsed; }

  utils.forEach(headers.split('\n'), function parser(line) {
    i = line.indexOf(':');
    key = utils.trim(line.substr(0, i)).toLowerCase();
    val = utils.trim(line.substr(i + 1));

    if (key) {
      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
        return;
      }
      if (key === 'set-cookie') {
        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
      } else {
        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
      }
    }
  });

  return parsed;
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/spread.js":
/*!**************************************************!*\
  !*** ./node_modules/axios/lib/helpers/spread.js ***!
  \**************************************************/
/***/ ((module) => {

"use strict";


/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 * @returns {Function}
 */
module.exports = function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/validator.js":
/*!*****************************************************!*\
  !*** ./node_modules/axios/lib/helpers/validator.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var pkg = __webpack_require__(/*! ./../../package.json */ "./node_modules/axios/package.json");

var validators = {};

// eslint-disable-next-line func-names
['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach(function(type, i) {
  validators[type] = function validator(thing) {
    return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;
  };
});

var deprecatedWarnings = {};
var currentVerArr = pkg.version.split('.');

/**
 * Compare package versions
 * @param {string} version
 * @param {string?} thanVersion
 * @returns {boolean}
 */
function isOlderVersion(version, thanVersion) {
  var pkgVersionArr = thanVersion ? thanVersion.split('.') : currentVerArr;
  var destVer = version.split('.');
  for (var i = 0; i < 3; i++) {
    if (pkgVersionArr[i] > destVer[i]) {
      return true;
    } else if (pkgVersionArr[i] < destVer[i]) {
      return false;
    }
  }
  return false;
}

/**
 * Transitional option validator
 * @param {function|boolean?} validator
 * @param {string?} version
 * @param {string} message
 * @returns {function}
 */
validators.transitional = function transitional(validator, version, message) {
  var isDeprecated = version && isOlderVersion(version);

  function formatMessage(opt, desc) {
    return '[Axios v' + pkg.version + '] Transitional option \'' + opt + '\'' + desc + (message ? '. ' + message : '');
  }

  // eslint-disable-next-line func-names
  return function(value, opt, opts) {
    if (validator === false) {
      throw new Error(formatMessage(opt, ' has been removed in ' + version));
    }

    if (isDeprecated && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      // eslint-disable-next-line no-console
      console.warn(
        formatMessage(
          opt,
          ' has been deprecated since v' + version + ' and will be removed in the near future'
        )
      );
    }

    return validator ? validator(value, opt, opts) : true;
  };
};

/**
 * Assert object's properties type
 * @param {object} options
 * @param {object} schema
 * @param {boolean?} allowUnknown
 */

function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== 'object') {
    throw new TypeError('options must be an object');
  }
  var keys = Object.keys(options);
  var i = keys.length;
  while (i-- > 0) {
    var opt = keys[i];
    var validator = schema[opt];
    if (validator) {
      var value = options[opt];
      var result = value === undefined || validator(value, opt, options);
      if (result !== true) {
        throw new TypeError('option ' + opt + ' must be ' + result);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw Error('Unknown option ' + opt);
    }
  }
}

module.exports = {
  isOlderVersion: isOlderVersion,
  assertOptions: assertOptions,
  validators: validators
};


/***/ }),

/***/ "./node_modules/axios/lib/utils.js":
/*!*****************************************!*\
  !*** ./node_modules/axios/lib/utils.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var bind = __webpack_require__(/*! ./helpers/bind */ "./node_modules/axios/lib/helpers/bind.js");

// utils is a library of generic helper functions non-specific to axios

var toString = Object.prototype.toString;

/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Array, otherwise false
 */
function isArray(val) {
  return toString.call(val) === '[object Array]';
}

/**
 * Determine if a value is undefined
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if the value is undefined, otherwise false
 */
function isUndefined(val) {
  return typeof val === 'undefined';
}

/**
 * Determine if a value is a Buffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Buffer, otherwise false
 */
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)
    && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);
}

/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */
function isArrayBuffer(val) {
  return toString.call(val) === '[object ArrayBuffer]';
}

/**
 * Determine if a value is a FormData
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an FormData, otherwise false
 */
function isFormData(val) {
  return (typeof FormData !== 'undefined') && (val instanceof FormData);
}

/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */
function isArrayBufferView(val) {
  var result;
  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
    result = ArrayBuffer.isView(val);
  } else {
    result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);
  }
  return result;
}

/**
 * Determine if a value is a String
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a String, otherwise false
 */
function isString(val) {
  return typeof val === 'string';
}

/**
 * Determine if a value is a Number
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Number, otherwise false
 */
function isNumber(val) {
  return typeof val === 'number';
}

/**
 * Determine if a value is an Object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Object, otherwise false
 */
function isObject(val) {
  return val !== null && typeof val === 'object';
}

/**
 * Determine if a value is a plain Object
 *
 * @param {Object} val The value to test
 * @return {boolean} True if value is a plain Object, otherwise false
 */
function isPlainObject(val) {
  if (toString.call(val) !== '[object Object]') {
    return false;
  }

  var prototype = Object.getPrototypeOf(val);
  return prototype === null || prototype === Object.prototype;
}

/**
 * Determine if a value is a Date
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Date, otherwise false
 */
function isDate(val) {
  return toString.call(val) === '[object Date]';
}

/**
 * Determine if a value is a File
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a File, otherwise false
 */
function isFile(val) {
  return toString.call(val) === '[object File]';
}

/**
 * Determine if a value is a Blob
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Blob, otherwise false
 */
function isBlob(val) {
  return toString.call(val) === '[object Blob]';
}

/**
 * Determine if a value is a Function
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */
function isFunction(val) {
  return toString.call(val) === '[object Function]';
}

/**
 * Determine if a value is a Stream
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Stream, otherwise false
 */
function isStream(val) {
  return isObject(val) && isFunction(val.pipe);
}

/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */
function isURLSearchParams(val) {
  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
}

/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 * @returns {String} The String freed of excess whitespace
 */
function trim(str) {
  return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, '');
}

/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 * nativescript
 *  navigator.product -> 'NativeScript' or 'NS'
 */
function isStandardBrowserEnv() {
  if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' ||
                                           navigator.product === 'NativeScript' ||
                                           navigator.product === 'NS')) {
    return false;
  }
  return (
    typeof window !== 'undefined' &&
    typeof document !== 'undefined'
  );
}

/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 */
function forEach(obj, fn) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  }

  // Force an array if not already something iterable
  if (typeof obj !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray(obj)) {
    // Iterate over array values
    for (var i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        fn.call(null, obj[key], key, obj);
      }
    }
  }
}

/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 * @returns {Object} Result of all merge properties
 */
function merge(/* obj1, obj2, obj3, ... */) {
  var result = {};
  function assignValue(val, key) {
    if (isPlainObject(result[key]) && isPlainObject(val)) {
      result[key] = merge(result[key], val);
    } else if (isPlainObject(val)) {
      result[key] = merge({}, val);
    } else if (isArray(val)) {
      result[key] = val.slice();
    } else {
      result[key] = val;
    }
  }

  for (var i = 0, l = arguments.length; i < l; i++) {
    forEach(arguments[i], assignValue);
  }
  return result;
}

/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 * @return {Object} The resulting value of object a
 */
function extend(a, b, thisArg) {
  forEach(b, function assignValue(val, key) {
    if (thisArg && typeof val === 'function') {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  });
  return a;
}

/**
 * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
 *
 * @param {string} content with BOM
 * @return {string} content value without BOM
 */
function stripBOM(content) {
  if (content.charCodeAt(0) === 0xFEFF) {
    content = content.slice(1);
  }
  return content;
}

module.exports = {
  isArray: isArray,
  isArrayBuffer: isArrayBuffer,
  isBuffer: isBuffer,
  isFormData: isFormData,
  isArrayBufferView: isArrayBufferView,
  isString: isString,
  isNumber: isNumber,
  isObject: isObject,
  isPlainObject: isPlainObject,
  isUndefined: isUndefined,
  isDate: isDate,
  isFile: isFile,
  isBlob: isBlob,
  isFunction: isFunction,
  isStream: isStream,
  isURLSearchParams: isURLSearchParams,
  isStandardBrowserEnv: isStandardBrowserEnv,
  forEach: forEach,
  merge: merge,
  extend: extend,
  trim: trim,
  stripBOM: stripBOM
};


/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/Card.vue?vue&type=script&lang=js":
/*!**********************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/Card.vue?vue&type=script&lang=js ***!
  \**********************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  mounted: function mounted() {
    this.width = this.$refs.card.offsetWidth;
    this.height = this.$refs.card.offsetHeight;
  },
  props: ["dataImage"],
  data: function data() {
    return {
      width: 0,
      height: 0,
      mouseX: 0,
      mouseY: 0,
      mouseLeaveDelay: null
    };
  },
  computed: {
    mousePX: function mousePX() {
      return this.mouseX / this.width;
    },
    mousePY: function mousePY() {
      return this.mouseY / this.height;
    },
    cardStyle: function cardStyle() {
      var rX = this.mousePX * 30;
      var rY = this.mousePY * -30;
      return {
        transform: "rotateY(".concat(rX, "deg) rotateX(").concat(rY, "deg)")
      };
    },
    cardBgTransform: function cardBgTransform() {
      var tX = this.mousePX * -40;
      var tY = this.mousePY * -40;
      return {
        transform: "translateX(".concat(tX, "px) translateY(").concat(tY, "px)")
      };
    },
    cardBgImage: function cardBgImage() {
      return {
        backgroundImage: "url(".concat(this.dataImage, ")")
      };
    }
  },
  methods: {
    handleMouseMove: function handleMouseMove(e) {
      this.mouseX = e.pageX - this.$refs.card.offsetLeft - this.width / 2;
      this.mouseY = e.pageY - this.$refs.card.offsetTop - this.height / 2;
    },
    handleMouseEnter: function handleMouseEnter() {
      clearTimeout(this.mouseLeaveDelay);
    },
    handleMouseLeave: function handleMouseLeave() {
      var _this = this;

      this.mouseLeaveDelay = setTimeout(function () {
        _this.mouseX = 0;
        _this.mouseY = 0;
      }, 100);
    }
  }
});

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/Flashmessage.vue?vue&type=script&lang=js":
/*!******************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/Flashmessage.vue?vue&type=script&lang=js ***!
  \******************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vue/runtime-core */ "./node_modules/@vue/runtime-core/node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js");

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: "Flashmessage",
  props: ["message"],
  setup: function setup() {
    var showFlash = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.ref)(true);
    var hideFlash = setTimeout(function () {
      showFlash.value = false;
    }, 5000);
    return {
      showFlash: showFlash,
      hideFlash: hideFlash
    };
  }
});

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/categories/Dropdown.vue?vue&type=script&lang=js":
/*!*************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/categories/Dropdown.vue?vue&type=script&lang=js ***!
  \*************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var click_outside_vue3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! click-outside-vue3 */ "./node_modules/click-outside-vue3/dist/v-click-outside.umd.js");
/* harmony import */ var click_outside_vue3__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(click_outside_vue3__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm-bundler.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: "Dropdown",
  props: ["title"],
  directives: {
    clickOutside: (click_outside_vue3__WEBPACK_IMPORTED_MODULE_0___default().directive)
  },
  setup: function setup() {
    var sharedState = (0,vue__WEBPACK_IMPORTED_MODULE_1__.ref)(false);

    var showCategories = function showCategories() {
      sharedState.value = !sharedState.value;
    };

    var onClickOutside = function onClickOutside(event) {
      sharedState.value = false;
    };

    (0,vue__WEBPACK_IMPORTED_MODULE_1__.provide)("sharedState", sharedState);
    return {
      sharedState: sharedState,
      showCategories: showCategories,
      onClickOutside: onClickOutside
    };
  }
});

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/categories/Dropdowncontent.vue?vue&type=script&lang=js":
/*!********************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/categories/Dropdowncontent.vue?vue&type=script&lang=js ***!
  \********************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm-bundler.js");

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: "Dropdowncontent",
  setup: function setup() {
    var sharedState = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)("sharedState");
    return {
      sharedState: sharedState
    };
  }
});

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/categories/Dropdownitems.vue?vue&type=script&lang=js":
/*!******************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/categories/Dropdownitems.vue?vue&type=script&lang=js ***!
  \******************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: "Dropdownitems",
  props: ["category"]
});

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/darkcomponents/Svglogodark.vue?vue&type=script&lang=js":
/*!********************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/darkcomponents/Svglogodark.vue?vue&type=script&lang=js ***!
  \********************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _store_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./store.js */ "./resources/js/components/darkcomponents/store.js");

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  data: function data() {
    return {
      store: _store_js__WEBPACK_IMPORTED_MODULE_0__.store
    };
  }
});

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/darkcomponents/Svgnewsletterdark.vue?vue&type=script&lang=js":
/*!**************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/darkcomponents/Svgnewsletterdark.vue?vue&type=script&lang=js ***!
  \**************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _store_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./store.js */ "./resources/js/components/darkcomponents/store.js");

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  data: function data() {
    return {
      store: _store_js__WEBPACK_IMPORTED_MODULE_0__.store
    };
  }
});

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/darkcomponents/Switchdark.vue?vue&type=script&lang=js":
/*!*******************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/darkcomponents/Switchdark.vue?vue&type=script&lang=js ***!
  \*******************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _store_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./store.js */ "./resources/js/components/darkcomponents/store.js");

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  props: ["theme"],
  data: function data() {
    return {
      store: _store_js__WEBPACK_IMPORTED_MODULE_0__.store
    };
  },
  mounted: function mounted() {
    if (this.theme === "false") {
      _store_js__WEBPACK_IMPORTED_MODULE_0__.store.light();
    } else {
      _store_js__WEBPACK_IMPORTED_MODULE_0__.store.dark();
    }
  },
  methods: {
    dark: function dark() {
      this.$emit("dark");
    },
    light: function light() {
      this.$emit("light");
    },
    modeToggle: function modeToggle() {
      if (this.darkMode || document.querySelector("body").classList.contains("dark")) {
        this.light();
      } else {
        this.dark();
      }

      var isDarkModeOn = _store_js__WEBPACK_IMPORTED_MODULE_0__.store.toggleActive;
      createCookie("isDarkModeOn", isDarkModeOn.toString(), 60 * 60 * 24);
    }
  }
});

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/devto/Swiperimg.vue?vue&type=script&lang=js":
/*!*********************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/devto/Swiperimg.vue?vue&type=script&lang=js ***!
  \*********************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({});

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/devto/Swiperslides.vue?vue&type=script&lang=js":
/*!************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/devto/Swiperslides.vue?vue&type=script&lang=js ***!
  \************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var swiper_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! swiper/css */ "./node_modules/swiper/swiper.min.css");
/* harmony import */ var swiper_css_pagination__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! swiper/css/pagination */ "./node_modules/swiper/modules/pagination/pagination.min.css");
/* harmony import */ var swiper_css_navigation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! swiper/css/navigation */ "./node_modules/swiper/modules/navigation/navigation.min.css");
/* harmony import */ var _Swiperslidescontent__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Swiperslidescontent */ "./resources/js/components/devto/Swiperslidescontent.vue");
// Import Swiper styles




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  components: {
    Swiperslidescontent: _Swiperslidescontent__WEBPACK_IMPORTED_MODULE_3__["default"]
  }
});

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/devto/Swiperslidescontent.vue?vue&type=script&lang=js":
/*!*******************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/devto/Swiperslidescontent.vue?vue&type=script&lang=js ***!
  \*******************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: "Swiperslidescontent"
});

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/devto/Swiperslidesitems.vue?vue&type=script&lang=js":
/*!*****************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/devto/Swiperslidesitems.vue?vue&type=script&lang=js ***!
  \*****************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: "Swiperslideitems",
  props: ["title", "created_at", "thumbnail"]
});

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/Card.vue?vue&type=template&id=b9bc2c0a":
/*!**************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/Card.vue?vue&type=template&id=b9bc2c0a ***!
  \**************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* binding */ render)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm-bundler.js");

function render(_ctx, _cache, $props, $setup, $data, $options) {
  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", {
    "class": "card-wrap",
    onMousemove: _cache[0] || (_cache[0] = function () {
      return $options.handleMouseMove && $options.handleMouseMove.apply($options, arguments);
    }),
    onMouseenter: _cache[1] || (_cache[1] = function () {
      return $options.handleMouseEnter && $options.handleMouseEnter.apply($options, arguments);
    }),
    onMouseleave: _cache[2] || (_cache[2] = function () {
      return $options.handleMouseLeave && $options.handleMouseLeave.apply($options, arguments);
    }),
    ref: "card"
  }, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("div", {
    "class": "card",
    style: (0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeStyle)($options.cardStyle)
  }, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "default")], 4
  /* STYLE */
  )], 544
  /* HYDRATE_EVENTS, NEED_PATCH */
  );
}

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/Flashmessage.vue?vue&type=template&id=4cfe5afc":
/*!**********************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/Flashmessage.vue?vue&type=template&id=4cfe5afc ***!
  \**********************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* binding */ render)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm-bundler.js");

var _hoisted_1 = {
  "class": "fixed bottom-3 right-3 rounded-xl bg-blue-500 py-2 px-4 text-sm text-white"
};
function render(_ctx, _cache, $props, $setup, $data, $options) {
  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createBlock)(vue__WEBPACK_IMPORTED_MODULE_0__.Transition, {
    duration: 1000,
    "enter-active-class": "transform transition duration-300 ease-custom",
    "enter-class": "-translate-y-1/2 scale-y-0 opacity-0",
    "enter-to-class": "translate-y-0 scale-y-100 opacity-100",
    "leave-active-class": "transform transition duration-300 ease-custom",
    "leave-class": "translate-y-0 scale-y-100 opacity-100",
    "leave-to-class": "-translate-y-1/2 scale-y-0 opacity-0"
  }, {
    "default": (0,vue__WEBPACK_IMPORTED_MODULE_0__.withCtx)(function () {
      return [(0,vue__WEBPACK_IMPORTED_MODULE_0__.withDirectives)((0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("div", _hoisted_1, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("p", null, (0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)($props.message), 1
      /* TEXT */
      )], 512
      /* NEED_PATCH */
      ), [[vue__WEBPACK_IMPORTED_MODULE_0__.vShow, $setup.showFlash]])];
    }),
    _: 1
    /* STABLE */

  });
}

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/categories/Dropdown.vue?vue&type=template&id=13f3326e":
/*!*****************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/categories/Dropdown.vue?vue&type=template&id=13f3326e ***!
  \*****************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* binding */ render)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm-bundler.js");

var _hoisted_1 = {
  "class": "flex max-h-52 w-full overflow-auto py-2 pl-3 text-sm font-semibold lg:inline-flex lg:w-32"
};

var _hoisted_2 = /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("g", {
  fill: "none",
  "fill-rule": "evenodd"
}, [/*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("path", {
  stroke: "#000",
  "stroke-opacity": ".012",
  "stroke-width": ".5",
  d: "M21 1v20.16H.84V1z"
}), /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("path", {
  fill: "#222",
  d: "M13.854 7.224l-3.847 3.856 3.847 3.856-1.184 1.184-5.04-5.04 5.04-5.04z"
})], -1
/* HOISTED */
);

var _hoisted_3 = [_hoisted_2];
function render(_ctx, _cache, $props, $setup, $data, $options) {
  var _directive_click_outside = (0,vue__WEBPACK_IMPORTED_MODULE_0__.resolveDirective)("click-outside");

  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.withDirectives)(((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", {
    "class": "relative",
    onClick: _cache[0] || (_cache[0] = function () {
      return $setup.showCategories && $setup.showCategories.apply($setup, arguments);
    })
  }, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "toggler", {}, function () {
    return [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("button", _hoisted_1, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createTextVNode)((0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)($props.title) + " ", 1
    /* TEXT */
    ), ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("svg", {
      "class": (0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)(["absolute", $setup.sharedState ? '-rotate-90 transform transition duration-500 ease-in-out' : 'rotate-90 transform transition duration-500 ease-in-out']),
      style: {
        "right": "12px"
      },
      width: "22",
      height: "22",
      viewBox: "0 0 22 22"
    }, _hoisted_3, 2
    /* CLASS */
    ))])];
  }), (0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "default")])), [[_directive_click_outside, $setup.onClickOutside]]);
}

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/categories/Dropdowncontent.vue?vue&type=template&id=6d946540":
/*!************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/categories/Dropdowncontent.vue?vue&type=template&id=6d946540 ***!
  \************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* binding */ render)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm-bundler.js");

var _hoisted_1 = {
  "class": "absolute left-0 right-0 z-50 mt-2 w-full rounded-lg bg-blue-100 bg-gradient-to-r from-purple-600 to-blue-500 py-2"
};
function render(_ctx, _cache, $props, $setup, $data, $options) {
  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createBlock)(vue__WEBPACK_IMPORTED_MODULE_0__.Transition, {
    duration: 1000,
    "enter-active-class": "transform transition duration-300 ease-custom",
    "enter-class": "-translate-y-1/2 scale-y-0 opacity-0",
    "enter-to-class": "translate-y-0 scale-y-100 opacity-100",
    "leave-active-class": "transform transition duration-300 ease-custom",
    "leave-class": "translate-y-0 scale-y-100 opacity-100",
    "leave-to-class": "-translate-y-1/2 scale-y-0 opacity-0"
  }, {
    "default": (0,vue__WEBPACK_IMPORTED_MODULE_0__.withCtx)(function () {
      return [(0,vue__WEBPACK_IMPORTED_MODULE_0__.withDirectives)((0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("div", _hoisted_1, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "default")], 512
      /* NEED_PATCH */
      ), [[vue__WEBPACK_IMPORTED_MODULE_0__.vShow, $setup.sharedState]])];
    }),
    _: 3
    /* FORWARDED */

  });
}

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/categories/Dropdownitems.vue?vue&type=template&id=64b8fcc7":
/*!**********************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/categories/Dropdownitems.vue?vue&type=template&id=64b8fcc7 ***!
  \**********************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* binding */ render)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm-bundler.js");

var _hoisted_1 = {
  href: "",
  type: "",
  "class": "demogard categoryItems"
};
function render(_ctx, _cache, $props, $setup, $data, $options) {
  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("a", _hoisted_1, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "default", {}, function () {
    return [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createTextVNode)((0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)($props.category), 1
    /* TEXT */
    )];
  })]);
}

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/darkcomponents/Svglogodark.vue?vue&type=template&id=0c63f626":
/*!************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/darkcomponents/Svglogodark.vue?vue&type=template&id=0c63f626 ***!
  \************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* binding */ render)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm-bundler.js");
var _hoisted_1={key:0,xmlns:"http://www.w3.org/2000/svg","xmlns:xlink":"http://www.w3.org/1999/xlink",width:"170",height:"70",viewBox:"0 0 4792 1625"};var _hoisted_2=/*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("image",{x:"20",y:"25",width:"2634",height:"1567","xlink:href":"data:img/png;base64,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"},null,-1/* HOISTED */);var _hoisted_3=/*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("image",{x:"2673",y:"426",width:"2102",height:"688","xlink:href":"data:img/png;base64,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"},null,-1/* HOISTED */);var _hoisted_4=[_hoisted_2,_hoisted_3];var _hoisted_5={key:1,xmlns:"http://www.w3.org/2000/svg","xmlns:xlink":"http://www.w3.org/1999/xlink",width:"170",height:"70",viewBox:"0 0 1150 390"};var _hoisted_6=/*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("image",{x:"5",y:"6",width:"1141",height:"376","xlink:href":"data:img/png;base64,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"},null,-1/* HOISTED */);var _hoisted_7=[_hoisted_6];function render(_ctx,_cache,$props,$setup,$data,$options){return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(),(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(vue__WEBPACK_IMPORTED_MODULE_0__.Fragment,null,[!$data.store.toggleActive?((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(),(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("svg",_hoisted_1,_hoisted_4)):(0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)("v-if",true),$data.store.toggleActive?((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(),(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("svg",_hoisted_5,_hoisted_7)):(0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)("v-if",true)],64/* STABLE_FRAGMENT */);}

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/darkcomponents/Svgnewsletterdark.vue?vue&type=template&id=aaffc20a":
/*!******************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/darkcomponents/Svgnewsletterdark.vue?vue&type=template&id=aaffc20a ***!
  \******************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* binding */ render)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm-bundler.js");

var _hoisted_1 = {
  key: 0,
  src: "/images/My-Logo-Newsletter-Dark.png",
  width: "240",
  alt: "Newsletter logo dark"
};
var _hoisted_2 = {
  key: 1,
  src: "/images/My-Logo-Newsletter.png",
  width: "240",
  alt: "Newsletter logo"
};
function render(_ctx, _cache, $props, $setup, $data, $options) {
  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(vue__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, [!$data.store.toggleActive ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("img", _hoisted_1)) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)("v-if", true), $data.store.toggleActive ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("img", _hoisted_2)) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)("v-if", true)], 64
  /* STABLE_FRAGMENT */
  );
}

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/darkcomponents/Switchdark.vue?vue&type=template&id=069fc572":
/*!***********************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/darkcomponents/Switchdark.vue?vue&type=template&id=069fc572 ***!
  \***********************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* binding */ render)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm-bundler.js");

function render(_ctx, _cache, $props, $setup, $data, $options) {
  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", {
    "class": "flex cursor-pointer items-center justify-between",
    onClick: _cache[0] || (_cache[0] = function ($event) {
      return $data.store.modeToggle(), $options.modeToggle();
    })
  }, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("div", {
    "class": (0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)(["flex h-4 w-12 items-center rounded-full bg-gray-300 p-1 duration-300 ease-in-out", {
      'bg-green-400': $data.store.toggleActive
    }])
  }, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("div", {
    "class": (0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)(["h-3 w-3 transform rounded-full bg-white shadow-md duration-300 ease-in-out", {
      'translate-x-7': $data.store.toggleActive
    }])
  }, null, 2
  /* CLASS */
  )], 2
  /* CLASS */
  )]);
}

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/devto/Swiperimg.vue?vue&type=template&id=28a22cb1":
/*!*************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/devto/Swiperimg.vue?vue&type=template&id=28a22cb1 ***!
  \*************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* binding */ render)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm-bundler.js");

var _hoisted_1 = {
  src: "",
  "class": "rounded-lg"
};
function render(_ctx, _cache, $props, $setup, $data, $options) {
  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("img", _hoisted_1);
}

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/devto/Swiperslides.vue?vue&type=template&id=6225d6e4":
/*!****************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/devto/Swiperslides.vue?vue&type=template&id=6225d6e4 ***!
  \****************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* binding */ render)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm-bundler.js");

var _hoisted_1 = {
  "class": "swiper mySwiper"
};
var _hoisted_2 = {
  "class": "swiper-wrapper"
};

var _hoisted_3 = /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("div", {
  "class": "swiper-button-next"
}, null, -1
/* HOISTED */
);

var _hoisted_4 = /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("div", {
  "class": "swiper-button-prev"
}, null, -1
/* HOISTED */
);

var _hoisted_5 = /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("div", {
  "class": "swiper-pagination"
}, null, -1
/* HOISTED */
);

function render(_ctx, _cache, $props, $setup, $data, $options) {
  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", _hoisted_1, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("div", _hoisted_2, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "default")]), _hoisted_3, _hoisted_4, _hoisted_5]);
}

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/devto/Swiperslidescontent.vue?vue&type=template&id=68f6b0c5":
/*!***********************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/devto/Swiperslidescontent.vue?vue&type=template&id=68f6b0c5 ***!
  \***********************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* binding */ render)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm-bundler.js");

var _hoisted_1 = {
  "class": "swiper-slide flex flex-col justify-between rounded-xl border border-black border-opacity-0 py-6 px-12 text-white transition-colors duration-300 hover:border-opacity-5 dark:text-black dark:hover:bg-blue-50 dark:hover:bg-none"
};
function render(_ctx, _cache, $props, $setup, $data, $options) {
  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("article", _hoisted_1, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "default")]);
}

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/devto/Swiperslidesitems.vue?vue&type=template&id=00d2658c":
/*!*********************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/devto/Swiperslidesitems.vue?vue&type=template&id=00d2658c ***!
  \*********************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* binding */ render)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm-bundler.js");

var _hoisted_1 = {
  "class": "mt-4"
};
var _hoisted_2 = {
  "class": "mt-4"
};
var _hoisted_3 = {
  href: ""
};
var _hoisted_4 = {
  "class": "text-center text-lg font-semibold"
};
var _hoisted_5 = {
  "class": "mt-4 block text-center text-xs text-gray-400"
};

var _hoisted_6 = /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createTextVNode)(" Published ");

var _hoisted_7 = /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("footer", {
  "class": "mt-8 flex flex-col items-center justify-between"
}, [/*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("div"), /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("a", {
  href: "/",
  "class": "demogard rounded-full bg-gradient-to-r from-purple-600 to-blue-500 py-2 px-8 text-xs font-semibold text-white transition duration-300 hover:bg-gradient-to-bl focus:ring-4 focus:ring-blue-300 dark:focus:ring-blue-800"
}, "Read More ")], -1
/* HOISTED */
);

function render(_ctx, _cache, $props, $setup, $data, $options) {
  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(vue__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("div", null, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "default")]), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("header", _hoisted_1, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("div", _hoisted_2, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("a", _hoisted_3, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("h1", _hoisted_4, (0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)($props.title), 1
  /* TEXT */
  )]), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("span", _hoisted_5, [_hoisted_6, (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("time", null, (0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)($props.created_at), 1
  /* TEXT */
  )])])]), _hoisted_7], 64
  /* STABLE_FRAGMENT */
  );
}

/***/ }),

/***/ "./resources/js/app.js":
/*!*****************************!*\
  !*** ./resources/js/app.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var alpinejs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! alpinejs */ "./node_modules/alpinejs/dist/module.esm.js");
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm-bundler.js");
/* harmony import */ var _components_categories_Dropdown__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./components/categories/Dropdown */ "./resources/js/components/categories/Dropdown.vue");
/* harmony import */ var _components_categories_Dropdowncontent__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./components/categories/Dropdowncontent */ "./resources/js/components/categories/Dropdowncontent.vue");
/* harmony import */ var _components_categories_Dropdownitems__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./components/categories/Dropdownitems */ "./resources/js/components/categories/Dropdownitems.vue");
/* harmony import */ var click_outside_vue3__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! click-outside-vue3 */ "./node_modules/click-outside-vue3/dist/v-click-outside.umd.js");
/* harmony import */ var click_outside_vue3__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(click_outside_vue3__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _components_Flashmessage__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./components/Flashmessage */ "./resources/js/components/Flashmessage.vue");
/* harmony import */ var _components_Card__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./components/Card */ "./resources/js/components/Card.vue");
/* harmony import */ var _components_darkcomponents_Switchdark__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./components/darkcomponents/Switchdark */ "./resources/js/components/darkcomponents/Switchdark.vue");
/* harmony import */ var _components_darkcomponents_Svglogodark__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./components/darkcomponents/Svglogodark */ "./resources/js/components/darkcomponents/Svglogodark.vue");
/* harmony import */ var _components_darkcomponents_Svgnewsletterdark__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./components/darkcomponents/Svgnewsletterdark */ "./resources/js/components/darkcomponents/Svgnewsletterdark.vue");
/* harmony import */ var _components_devto_Swiperslides__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./components/devto/Swiperslides */ "./resources/js/components/devto/Swiperslides.vue");
/* harmony import */ var _components_devto_Swiperslidescontent__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./components/devto/Swiperslidescontent */ "./resources/js/components/devto/Swiperslidescontent.vue");
/* harmony import */ var _components_devto_Swiperslidesitems__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./components/devto/Swiperslidesitems */ "./resources/js/components/devto/Swiperslidesitems.vue");
/* harmony import */ var _components_devto_Swiperimg__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./components/devto/Swiperimg */ "./resources/js/components/devto/Swiperimg.vue");
/* harmony import */ var swiper__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! swiper */ "./node_modules/swiper/swiper.esm.js");
/* harmony import */ var swiper_css__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! swiper/css */ "./node_modules/swiper/swiper.min.css");
/* harmony import */ var swiper_css_navigation__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! swiper/css/navigation */ "./node_modules/swiper/modules/navigation/navigation.min.css");
/* harmony import */ var swiper_css_pagination__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! swiper/css/pagination */ "./node_modules/swiper/modules/pagination/pagination.min.css");
__webpack_require__(/*! ./bootstrap */ "./resources/js/bootstrap.js");


window.Alpine = alpinejs__WEBPACK_IMPORTED_MODULE_0__["default"];
alpinejs__WEBPACK_IMPORTED_MODULE_0__["default"].start();














(0,vue__WEBPACK_IMPORTED_MODULE_1__.createApp)({
  components: {
    Dropdown: _components_categories_Dropdown__WEBPACK_IMPORTED_MODULE_2__["default"],
    Dropdowncontent: _components_categories_Dropdowncontent__WEBPACK_IMPORTED_MODULE_3__["default"],
    Dropdownitems: _components_categories_Dropdownitems__WEBPACK_IMPORTED_MODULE_4__["default"],
    Flashmessage: _components_Flashmessage__WEBPACK_IMPORTED_MODULE_6__["default"],
    Card: _components_Card__WEBPACK_IMPORTED_MODULE_7__["default"],
    Switchdark: _components_darkcomponents_Switchdark__WEBPACK_IMPORTED_MODULE_8__["default"],
    Svglogodark: _components_darkcomponents_Svglogodark__WEBPACK_IMPORTED_MODULE_9__["default"],
    Svgnewsletterdark: _components_darkcomponents_Svgnewsletterdark__WEBPACK_IMPORTED_MODULE_10__["default"],
    Swiperslides: _components_devto_Swiperslides__WEBPACK_IMPORTED_MODULE_11__["default"],
    Swiperslidescontent: _components_devto_Swiperslidescontent__WEBPACK_IMPORTED_MODULE_12__["default"],
    Swiperslidesitems: _components_devto_Swiperslidesitems__WEBPACK_IMPORTED_MODULE_13__["default"],
    Swiperimg: _components_devto_Swiperimg__WEBPACK_IMPORTED_MODULE_14__["default"]
  }
}).use((click_outside_vue3__WEBPACK_IMPORTED_MODULE_5___default())).mount("#app");
 // import Swiper and modules styles




var swiper = new swiper__WEBPACK_IMPORTED_MODULE_15__["default"](".mySwiper", {
  slidesPerView: "3",
  // Responsive breakpoints
  breakpoints: {
    // when window width is >= 320px
    320: {
      slidesPerView: 1
    },
    // when window width is >= 480px
    480: {
      slidesPerView: 2
    },
    // when window width is >= 640px
    640: {
      slidesPerView: 3
    }
  },
  modules: [swiper__WEBPACK_IMPORTED_MODULE_15__.Pagination, swiper__WEBPACK_IMPORTED_MODULE_15__.Navigation],
  pagination: {
    el: ".swiper-pagination",
    type: "progressbar"
  },
  navigation: {
    nextEl: ".swiper-button-next",
    prevEl: ".swiper-button-prev"
  }
});

/***/ }),

/***/ "./resources/js/bootstrap.js":
/*!***********************************!*\
  !*** ./resources/js/bootstrap.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

window._ = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
/**
 * We'll load the axios HTTP library which allows us to easily issue requests
 * to our Laravel back-end. This library automatically handles sending the
 * CSRF token as a header based on the value of the "XSRF" token cookie.
 */

window.axios = __webpack_require__(/*! axios */ "./node_modules/axios/index.js");
window.axios.defaults.headers.common['X-Requested-With'] = 'XMLHttpRequest';
/**
 * Echo exposes an expressive API for subscribing to channels and listening
 * for events that are broadcast by Laravel. Echo and event broadcasting
 * allows your team to easily build robust real-time web applications.
 */
// import Echo from 'laravel-echo';
// window.Pusher = require('pusher-js');
// window.Echo = new Echo({
//     broadcaster: 'pusher',
//     key: process.env.MIX_PUSHER_APP_KEY,
//     cluster: process.env.MIX_PUSHER_APP_CLUSTER,
//     forceTLS: true
// });

/***/ }),

/***/ "./resources/js/components/darkcomponents/store.js":
/*!*********************************************************!*\
  !*** ./resources/js/components/darkcomponents/store.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "store": () => (/* binding */ store)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm-bundler.js");

var store = (0,vue__WEBPACK_IMPORTED_MODULE_0__.reactive)({
  toggleActive: false,
  dark: function dark() {
    document.querySelector("body").classList.add("dark");
    this.toggleActive = true;
  },
  light: function light() {
    document.querySelector("body").classList.remove("dark");
    this.toggleActive = false;
  },
  modeToggle: function modeToggle() {
    if (this.darkMode || document.querySelector("body").classList.contains("dark")) {
      this.light();
    } else {
      this.dark();
    }
  }
});

/***/ }),

/***/ "./node_modules/click-outside-vue3/dist/v-click-outside.umd.js":
/*!*********************************************************************!*\
  !*** ./node_modules/click-outside-vue3/dist/v-click-outside.umd.js ***!
  \*********************************************************************/
/***/ (function(module) {

!function(e,n){ true?module.exports=n():0}(this,function(){var e="__v-click-outside",n="undefined"!=typeof window,t="undefined"!=typeof navigator,r=n&&("ontouchstart"in window||t&&navigator.msMaxTouchPoints>0)?["touchstart"]:["click"],i=function(e){var n=e.event,t=e.handler;(0,e.middleware)(n)&&t(n)},a=function(n,t){var a=function(e){var n="function"==typeof e;if(!n&&"object"!=typeof e)throw new Error("v-click-outside: Binding value must be a function or an object");return{handler:n?e:e.handler,middleware:e.middleware||function(e){return e},events:e.events||r,isActive:!(!1===e.isActive),detectIframe:!(!1===e.detectIframe),capture:Boolean(e.capture)}}(t.value),o=a.handler,d=a.middleware,c=a.detectIframe,u=a.capture;if(a.isActive){if(n[e]=a.events.map(function(e){return{event:e,srcTarget:document.documentElement,handler:function(e){return function(e){var n=e.el,t=e.event,r=e.handler,a=e.middleware,o=t.path||t.composedPath&&t.composedPath();(o?o.indexOf(n)<0:!n.contains(t.target))&&i({event:t,handler:r,middleware:a})}({el:n,event:e,handler:o,middleware:d})},capture:u}}),c){var l={event:"blur",srcTarget:window,handler:function(e){return function(e){var n=e.el,t=e.event,r=e.handler,a=e.middleware;setTimeout(function(){var e=document.activeElement;e&&"IFRAME"===e.tagName&&!n.contains(e)&&i({event:t,handler:r,middleware:a})},0)}({el:n,event:e,handler:o,middleware:d})},capture:u};n[e]=[].concat(n[e],[l])}n[e].forEach(function(t){var r=t.event,i=t.srcTarget,a=t.handler;return setTimeout(function(){n[e]&&i.addEventListener(r,a,u)},0)})}},o=function(n){(n[e]||[]).forEach(function(e){return e.srcTarget.removeEventListener(e.event,e.handler,e.capture)}),delete n[e]},d=n?{beforeMount:a,updated:function(e,n){var t=n.value,r=n.oldValue;JSON.stringify(t)!==JSON.stringify(r)&&(o(e),a(e,{value:t}))},unmounted:o}:{};return{install:function(e){e.directive("click-outside",d)},directive:d}});
//# sourceMappingURL=v-click-outside.umd.js.map


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js??clonedRuleSet-9.use[1]!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9.use[2]!./node_modules/swiper/modules/navigation/navigation.min.css":
/*!***************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js??clonedRuleSet-9.use[1]!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9.use[2]!./node_modules/swiper/modules/navigation/navigation.min.css ***!
  \***************************************************************************************************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__);
// Imports

var ___CSS_LOADER_EXPORT___ = _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default()(function(i){return i[1]});
// Module
___CSS_LOADER_EXPORT___.push([module.id, ":root{--swiper-navigation-size:44px}.swiper-button-next,.swiper-button-prev{position:absolute;top:50%;width:calc(var(--swiper-navigation-size)/ 44 * 27);height:var(--swiper-navigation-size);margin-top:calc(0px - (var(--swiper-navigation-size)/ 2));z-index:10;cursor:pointer;display:flex;align-items:center;justify-content:center;color:var(--swiper-navigation-color,var(--swiper-theme-color))}.swiper-button-next.swiper-button-disabled,.swiper-button-prev.swiper-button-disabled{opacity:.35;cursor:auto;pointer-events:none}.swiper-button-next:after,.swiper-button-prev:after{font-family:swiper-icons;font-size:var(--swiper-navigation-size);text-transform:none!important;letter-spacing:0;text-transform:none;font-variant:initial;line-height:1}.swiper-button-prev,.swiper-rtl .swiper-button-next{left:10px;right:auto}.swiper-button-prev:after,.swiper-rtl .swiper-button-next:after{content:'prev'}.swiper-button-next,.swiper-rtl .swiper-button-prev{right:10px;left:auto}.swiper-button-next:after,.swiper-rtl .swiper-button-prev:after{content:'next'}.swiper-button-lock{display:none}", ""]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js??clonedRuleSet-9.use[1]!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9.use[2]!./node_modules/swiper/modules/pagination/pagination.min.css":
/*!***************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js??clonedRuleSet-9.use[1]!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9.use[2]!./node_modules/swiper/modules/pagination/pagination.min.css ***!
  \***************************************************************************************************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__);
// Imports

var ___CSS_LOADER_EXPORT___ = _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default()(function(i){return i[1]});
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".swiper-pagination{position:absolute;text-align:center;transition:.3s opacity;transform:translate3d(0,0,0);z-index:10}.swiper-pagination.swiper-pagination-hidden{opacity:0}.swiper-horizontal>.swiper-pagination-bullets,.swiper-pagination-bullets.swiper-pagination-horizontal,.swiper-pagination-custom,.swiper-pagination-fraction{bottom:10px;left:0;width:100%}.swiper-pagination-bullets-dynamic{overflow:hidden;font-size:0}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet{transform:scale(.33);position:relative}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active{transform:scale(1)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-main{transform:scale(1)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-prev{transform:scale(.66)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-prev-prev{transform:scale(.33)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-next{transform:scale(.66)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-next-next{transform:scale(.33)}.swiper-pagination-bullet{width:var(--swiper-pagination-bullet-width,var(--swiper-pagination-bullet-size,8px));height:var(--swiper-pagination-bullet-height,var(--swiper-pagination-bullet-size,8px));display:inline-block;border-radius:50%;background:var(--swiper-pagination-bullet-inactive-color,#000);opacity:var(--swiper-pagination-bullet-inactive-opacity, .2)}button.swiper-pagination-bullet{border:none;margin:0;padding:0;box-shadow:none;-webkit-appearance:none;-moz-appearance:none;appearance:none}.swiper-pagination-clickable .swiper-pagination-bullet{cursor:pointer}.swiper-pagination-bullet:only-child{display:none!important}.swiper-pagination-bullet-active{opacity:var(--swiper-pagination-bullet-opacity, 1);background:var(--swiper-pagination-color,var(--swiper-theme-color))}.swiper-pagination-vertical.swiper-pagination-bullets,.swiper-vertical>.swiper-pagination-bullets{right:10px;top:50%;transform:translate3d(0px,-50%,0)}.swiper-pagination-vertical.swiper-pagination-bullets .swiper-pagination-bullet,.swiper-vertical>.swiper-pagination-bullets .swiper-pagination-bullet{margin:var(--swiper-pagination-bullet-vertical-gap,6px) 0;display:block}.swiper-pagination-vertical.swiper-pagination-bullets.swiper-pagination-bullets-dynamic,.swiper-vertical>.swiper-pagination-bullets.swiper-pagination-bullets-dynamic{top:50%;transform:translateY(-50%);width:8px}.swiper-pagination-vertical.swiper-pagination-bullets.swiper-pagination-bullets-dynamic .swiper-pagination-bullet,.swiper-vertical>.swiper-pagination-bullets.swiper-pagination-bullets-dynamic .swiper-pagination-bullet{display:inline-block;transition:.2s transform,.2s top}.swiper-horizontal>.swiper-pagination-bullets .swiper-pagination-bullet,.swiper-pagination-horizontal.swiper-pagination-bullets .swiper-pagination-bullet{margin:0 var(--swiper-pagination-bullet-horizontal-gap,4px)}.swiper-horizontal>.swiper-pagination-bullets.swiper-pagination-bullets-dynamic,.swiper-pagination-horizontal.swiper-pagination-bullets.swiper-pagination-bullets-dynamic{left:50%;transform:translateX(-50%);white-space:nowrap}.swiper-horizontal>.swiper-pagination-bullets.swiper-pagination-bullets-dynamic .swiper-pagination-bullet,.swiper-pagination-horizontal.swiper-pagination-bullets.swiper-pagination-bullets-dynamic .swiper-pagination-bullet{transition:.2s transform,.2s left}.swiper-horizontal.swiper-rtl>.swiper-pagination-bullets-dynamic .swiper-pagination-bullet{transition:.2s transform,.2s right}.swiper-pagination-progressbar{background:rgba(0,0,0,.25);position:absolute}.swiper-pagination-progressbar .swiper-pagination-progressbar-fill{background:var(--swiper-pagination-color,var(--swiper-theme-color));position:absolute;left:0;top:0;width:100%;height:100%;transform:scale(0);transform-origin:left top}.swiper-rtl .swiper-pagination-progressbar .swiper-pagination-progressbar-fill{transform-origin:right top}.swiper-horizontal>.swiper-pagination-progressbar,.swiper-pagination-progressbar.swiper-pagination-horizontal,.swiper-pagination-progressbar.swiper-pagination-vertical.swiper-pagination-progressbar-opposite,.swiper-vertical>.swiper-pagination-progressbar.swiper-pagination-progressbar-opposite{width:100%;height:4px;left:0;top:0}.swiper-horizontal>.swiper-pagination-progressbar.swiper-pagination-progressbar-opposite,.swiper-pagination-progressbar.swiper-pagination-horizontal.swiper-pagination-progressbar-opposite,.swiper-pagination-progressbar.swiper-pagination-vertical,.swiper-vertical>.swiper-pagination-progressbar{width:4px;height:100%;left:0;top:0}.swiper-pagination-lock{display:none}", ""]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js??clonedRuleSet-9.use[1]!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9.use[2]!./node_modules/swiper/swiper.min.css":
/*!****************************************************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js??clonedRuleSet-9.use[1]!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9.use[2]!./node_modules/swiper/swiper.min.css ***!
  \****************************************************************************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__);
// Imports

var ___CSS_LOADER_EXPORT___ = _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default()(function(i){return i[1]});
// Module
___CSS_LOADER_EXPORT___.push([module.id, "/**\n * Swiper 8.0.6\n * Most modern mobile touch slider and framework with hardware accelerated transitions\n * https://swiperjs.com\n *\n * Copyright 2014-2022 Vladimir Kharlampidi\n *\n * Released under the MIT License\n *\n * Released on: February 14, 2022\n */\n\n@font-face{font-family:swiper-icons;src:url('data:application/font-woff;charset=utf-8;base64, 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');font-weight:400;font-style:normal}:root{--swiper-theme-color:#007aff}.swiper{margin-left:auto;margin-right:auto;position:relative;overflow:hidden;list-style:none;padding:0;z-index:1}.swiper-vertical>.swiper-wrapper{flex-direction:column}.swiper-wrapper{position:relative;width:100%;height:100%;z-index:1;display:flex;transition-property:transform;box-sizing:content-box}.swiper-android .swiper-slide,.swiper-wrapper{transform:translate3d(0px,0,0)}.swiper-pointer-events{touch-action:pan-y}.swiper-pointer-events.swiper-vertical{touch-action:pan-x}.swiper-slide{flex-shrink:0;width:100%;height:100%;position:relative;transition-property:transform}.swiper-slide-invisible-blank{visibility:hidden}.swiper-autoheight,.swiper-autoheight .swiper-slide{height:auto}.swiper-autoheight .swiper-wrapper{align-items:flex-start;transition-property:transform,height}.swiper-backface-hidden .swiper-slide{transform:translateZ(0);-webkit-backface-visibility:hidden;backface-visibility:hidden}.swiper-3d,.swiper-3d.swiper-css-mode .swiper-wrapper{perspective:1200px}.swiper-3d .swiper-cube-shadow,.swiper-3d .swiper-slide,.swiper-3d .swiper-slide-shadow,.swiper-3d .swiper-slide-shadow-bottom,.swiper-3d .swiper-slide-shadow-left,.swiper-3d .swiper-slide-shadow-right,.swiper-3d .swiper-slide-shadow-top,.swiper-3d .swiper-wrapper{transform-style:preserve-3d}.swiper-3d .swiper-slide-shadow,.swiper-3d .swiper-slide-shadow-bottom,.swiper-3d .swiper-slide-shadow-left,.swiper-3d .swiper-slide-shadow-right,.swiper-3d .swiper-slide-shadow-top{position:absolute;left:0;top:0;width:100%;height:100%;pointer-events:none;z-index:10}.swiper-3d .swiper-slide-shadow{background:rgba(0,0,0,.15)}.swiper-3d .swiper-slide-shadow-left{background-image:linear-gradient(to left,rgba(0,0,0,.5),rgba(0,0,0,0))}.swiper-3d .swiper-slide-shadow-right{background-image:linear-gradient(to right,rgba(0,0,0,.5),rgba(0,0,0,0))}.swiper-3d .swiper-slide-shadow-top{background-image:linear-gradient(to top,rgba(0,0,0,.5),rgba(0,0,0,0))}.swiper-3d .swiper-slide-shadow-bottom{background-image:linear-gradient(to bottom,rgba(0,0,0,.5),rgba(0,0,0,0))}.swiper-css-mode>.swiper-wrapper{overflow:auto;scrollbar-width:none;-ms-overflow-style:none}.swiper-css-mode>.swiper-wrapper::-webkit-scrollbar{display:none}.swiper-css-mode>.swiper-wrapper>.swiper-slide{scroll-snap-align:start start}.swiper-horizontal.swiper-css-mode>.swiper-wrapper{-ms-scroll-snap-type:x mandatory;scroll-snap-type:x mandatory}.swiper-vertical.swiper-css-mode>.swiper-wrapper{-ms-scroll-snap-type:y mandatory;scroll-snap-type:y mandatory}.swiper-centered>.swiper-wrapper::before{content:'';flex-shrink:0;order:9999}.swiper-centered.swiper-horizontal>.swiper-wrapper>.swiper-slide:first-child{-webkit-margin-start:var(--swiper-centered-offset-before);margin-inline-start:var(--swiper-centered-offset-before)}.swiper-centered.swiper-horizontal>.swiper-wrapper::before{height:100%;min-height:1px;width:var(--swiper-centered-offset-after)}.swiper-centered.swiper-vertical>.swiper-wrapper>.swiper-slide:first-child{-webkit-margin-before:var(--swiper-centered-offset-before);margin-block-start:var(--swiper-centered-offset-before)}.swiper-centered.swiper-vertical>.swiper-wrapper::before{width:100%;min-width:1px;height:var(--swiper-centered-offset-after)}.swiper-centered>.swiper-wrapper>.swiper-slide{scroll-snap-align:center center}", ""]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js??clonedRuleSet-9.use[1]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9.use[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/Card.vue?vue&type=style&index=0&id=b9bc2c0a&lang=css":
/*!***********************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js??clonedRuleSet-9.use[1]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9.use[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/Card.vue?vue&type=style&index=0&id=b9bc2c0a&lang=css ***!
  \***********************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__);
// Imports

var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default()(function(i){return i[1]});
// Module
___CSS_LOADER_EXPORT___.push([module.id, "\n@media screen and (max-width: 1024px) {\n.card {\r\n        transform: none !important;\n}\n}\r\n", ""]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js??clonedRuleSet-9.use[1]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9.use[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/categories/Dropdowncontent.vue?vue&type=style&index=0&id=6d946540&lang=css":
/*!*********************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js??clonedRuleSet-9.use[1]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9.use[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/categories/Dropdowncontent.vue?vue&type=style&index=0&id=6d946540&lang=css ***!
  \*********************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__);
// Imports

var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default()(function(i){return i[1]});
// Module
___CSS_LOADER_EXPORT___.push([module.id, "\n.ease-custom {\r\n    transition-timing-function: cubic-bezier(0.61, -0.53, 0.43, 1.43);\n}\r\n", ""]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";


/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
// eslint-disable-next-line func-names
module.exports = function (cssWithMappingToString) {
  var list = []; // return the list of modules as css string

  list.toString = function toString() {
    return this.map(function (item) {
      var content = cssWithMappingToString(item);

      if (item[2]) {
        return "@media ".concat(item[2], " {").concat(content, "}");
      }

      return content;
    }).join("");
  }; // import a list of modules into the list
  // eslint-disable-next-line func-names


  list.i = function (modules, mediaQuery, dedupe) {
    if (typeof modules === "string") {
      // eslint-disable-next-line no-param-reassign
      modules = [[null, modules, ""]];
    }

    var alreadyImportedModules = {};

    if (dedupe) {
      for (var i = 0; i < this.length; i++) {
        // eslint-disable-next-line prefer-destructuring
        var id = this[i][0];

        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }

    for (var _i = 0; _i < modules.length; _i++) {
      var item = [].concat(modules[_i]);

      if (dedupe && alreadyImportedModules[item[0]]) {
        // eslint-disable-next-line no-continue
        continue;
      }

      if (mediaQuery) {
        if (!item[2]) {
          item[2] = mediaQuery;
        } else {
          item[2] = "".concat(mediaQuery, " and ").concat(item[2]);
        }
      }

      list.push(item);
    }
  };

  return list;
};

/***/ }),

/***/ "./node_modules/lodash/lodash.js":
/*!***************************************!*\
  !*** ./node_modules/lodash/lodash.js ***!
  \***************************************/
/***/ (function(module, exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
var __WEBPACK_AMD_DEFINE_RESULT__;/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
;(function() {

  /** Used as a safe reference for `undefined` in pre-ES5 environments. */
  var undefined;

  /** Used as the semantic version number. */
  var VERSION = '4.17.21';

  /** Used as the size to enable large array optimizations. */
  var LARGE_ARRAY_SIZE = 200;

  /** Error message constants. */
  var CORE_ERROR_TEXT = 'Unsupported core-js use. Try https://npms.io/search?q=ponyfill.',
      FUNC_ERROR_TEXT = 'Expected a function',
      INVALID_TEMPL_VAR_ERROR_TEXT = 'Invalid `variable` option passed into `_.template`';

  /** Used to stand-in for `undefined` hash values. */
  var HASH_UNDEFINED = '__lodash_hash_undefined__';

  /** Used as the maximum memoize cache size. */
  var MAX_MEMOIZE_SIZE = 500;

  /** Used as the internal argument placeholder. */
  var PLACEHOLDER = '__lodash_placeholder__';

  /** Used to compose bitmasks for cloning. */
  var CLONE_DEEP_FLAG = 1,
      CLONE_FLAT_FLAG = 2,
      CLONE_SYMBOLS_FLAG = 4;

  /** Used to compose bitmasks for value comparisons. */
  var COMPARE_PARTIAL_FLAG = 1,
      COMPARE_UNORDERED_FLAG = 2;

  /** Used to compose bitmasks for function metadata. */
  var WRAP_BIND_FLAG = 1,
      WRAP_BIND_KEY_FLAG = 2,
      WRAP_CURRY_BOUND_FLAG = 4,
      WRAP_CURRY_FLAG = 8,
      WRAP_CURRY_RIGHT_FLAG = 16,
      WRAP_PARTIAL_FLAG = 32,
      WRAP_PARTIAL_RIGHT_FLAG = 64,
      WRAP_ARY_FLAG = 128,
      WRAP_REARG_FLAG = 256,
      WRAP_FLIP_FLAG = 512;

  /** Used as default options for `_.truncate`. */
  var DEFAULT_TRUNC_LENGTH = 30,
      DEFAULT_TRUNC_OMISSION = '...';

  /** Used to detect hot functions by number of calls within a span of milliseconds. */
  var HOT_COUNT = 800,
      HOT_SPAN = 16;

  /** Used to indicate the type of lazy iteratees. */
  var LAZY_FILTER_FLAG = 1,
      LAZY_MAP_FLAG = 2,
      LAZY_WHILE_FLAG = 3;

  /** Used as references for various `Number` constants. */
  var INFINITY = 1 / 0,
      MAX_SAFE_INTEGER = 9007199254740991,
      MAX_INTEGER = 1.7976931348623157e+308,
      NAN = 0 / 0;

  /** Used as references for the maximum length and index of an array. */
  var MAX_ARRAY_LENGTH = 4294967295,
      MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,
      HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;

  /** Used to associate wrap methods with their bit flags. */
  var wrapFlags = [
    ['ary', WRAP_ARY_FLAG],
    ['bind', WRAP_BIND_FLAG],
    ['bindKey', WRAP_BIND_KEY_FLAG],
    ['curry', WRAP_CURRY_FLAG],
    ['curryRight', WRAP_CURRY_RIGHT_FLAG],
    ['flip', WRAP_FLIP_FLAG],
    ['partial', WRAP_PARTIAL_FLAG],
    ['partialRight', WRAP_PARTIAL_RIGHT_FLAG],
    ['rearg', WRAP_REARG_FLAG]
  ];

  /** `Object#toString` result references. */
  var argsTag = '[object Arguments]',
      arrayTag = '[object Array]',
      asyncTag = '[object AsyncFunction]',
      boolTag = '[object Boolean]',
      dateTag = '[object Date]',
      domExcTag = '[object DOMException]',
      errorTag = '[object Error]',
      funcTag = '[object Function]',
      genTag = '[object GeneratorFunction]',
      mapTag = '[object Map]',
      numberTag = '[object Number]',
      nullTag = '[object Null]',
      objectTag = '[object Object]',
      promiseTag = '[object Promise]',
      proxyTag = '[object Proxy]',
      regexpTag = '[object RegExp]',
      setTag = '[object Set]',
      stringTag = '[object String]',
      symbolTag = '[object Symbol]',
      undefinedTag = '[object Undefined]',
      weakMapTag = '[object WeakMap]',
      weakSetTag = '[object WeakSet]';

  var arrayBufferTag = '[object ArrayBuffer]',
      dataViewTag = '[object DataView]',
      float32Tag = '[object Float32Array]',
      float64Tag = '[object Float64Array]',
      int8Tag = '[object Int8Array]',
      int16Tag = '[object Int16Array]',
      int32Tag = '[object Int32Array]',
      uint8Tag = '[object Uint8Array]',
      uint8ClampedTag = '[object Uint8ClampedArray]',
      uint16Tag = '[object Uint16Array]',
      uint32Tag = '[object Uint32Array]';

  /** Used to match empty string literals in compiled template source. */
  var reEmptyStringLeading = /\b__p \+= '';/g,
      reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
      reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

  /** Used to match HTML entities and HTML characters. */
  var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g,
      reUnescapedHtml = /[&<>"']/g,
      reHasEscapedHtml = RegExp(reEscapedHtml.source),
      reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

  /** Used to match template delimiters. */
  var reEscape = /<%-([\s\S]+?)%>/g,
      reEvaluate = /<%([\s\S]+?)%>/g,
      reInterpolate = /<%=([\s\S]+?)%>/g;

  /** Used to match property names within property paths. */
  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
      reIsPlainProp = /^\w*$/,
      rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

  /**
   * Used to match `RegExp`
   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
   */
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g,
      reHasRegExpChar = RegExp(reRegExpChar.source);

  /** Used to match leading whitespace. */
  var reTrimStart = /^\s+/;

  /** Used to match a single whitespace character. */
  var reWhitespace = /\s/;

  /** Used to match wrap detail comments. */
  var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,
      reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/,
      reSplitDetails = /,? & /;

  /** Used to match words composed of alphanumeric characters. */
  var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;

  /**
   * Used to validate the `validate` option in `_.template` variable.
   *
   * Forbids characters which could potentially change the meaning of the function argument definition:
   * - "()," (modification of function parameters)
   * - "=" (default value)
   * - "[]{}" (destructuring of function parameters)
   * - "/" (beginning of a comment)
   * - whitespace
   */
  var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;

  /** Used to match backslashes in property paths. */
  var reEscapeChar = /\\(\\)?/g;

  /**
   * Used to match
   * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
   */
  var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

  /** Used to match `RegExp` flags from their coerced string values. */
  var reFlags = /\w*$/;

  /** Used to detect bad signed hexadecimal string values. */
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

  /** Used to detect binary string values. */
  var reIsBinary = /^0b[01]+$/i;

  /** Used to detect host constructors (Safari). */
  var reIsHostCtor = /^\[object .+?Constructor\]$/;

  /** Used to detect octal string values. */
  var reIsOctal = /^0o[0-7]+$/i;

  /** Used to detect unsigned integer values. */
  var reIsUint = /^(?:0|[1-9]\d*)$/;

  /** Used to match Latin Unicode letters (excluding mathematical operators). */
  var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;

  /** Used to ensure capturing order of template delimiters. */
  var reNoMatch = /($^)/;

  /** Used to match unescaped characters in compiled string literals. */
  var reUnescapedString = /['\n\r\u2028\u2029\\]/g;

  /** Used to compose unicode character classes. */
  var rsAstralRange = '\\ud800-\\udfff',
      rsComboMarksRange = '\\u0300-\\u036f',
      reComboHalfMarksRange = '\\ufe20-\\ufe2f',
      rsComboSymbolsRange = '\\u20d0-\\u20ff',
      rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
      rsDingbatRange = '\\u2700-\\u27bf',
      rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
      rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
      rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
      rsPunctuationRange = '\\u2000-\\u206f',
      rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
      rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
      rsVarRange = '\\ufe0e\\ufe0f',
      rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;

  /** Used to compose unicode capture groups. */
  var rsApos = "['\u2019]",
      rsAstral = '[' + rsAstralRange + ']',
      rsBreak = '[' + rsBreakRange + ']',
      rsCombo = '[' + rsComboRange + ']',
      rsDigits = '\\d+',
      rsDingbat = '[' + rsDingbatRange + ']',
      rsLower = '[' + rsLowerRange + ']',
      rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
      rsFitz = '\\ud83c[\\udffb-\\udfff]',
      rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
      rsNonAstral = '[^' + rsAstralRange + ']',
      rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
      rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
      rsUpper = '[' + rsUpperRange + ']',
      rsZWJ = '\\u200d';

  /** Used to compose unicode regexes. */
  var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',
      rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',
      rsOptContrLower = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',
      rsOptContrUpper = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',
      reOptMod = rsModifier + '?',
      rsOptVar = '[' + rsVarRange + ']?',
      rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
      rsOrdLower = '\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])',
      rsOrdUpper = '\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])',
      rsSeq = rsOptVar + reOptMod + rsOptJoin,
      rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq,
      rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';

  /** Used to match apostrophes. */
  var reApos = RegExp(rsApos, 'g');

  /**
   * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
   * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
   */
  var reComboMark = RegExp(rsCombo, 'g');

  /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
  var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

  /** Used to match complex or compound words. */
  var reUnicodeWord = RegExp([
    rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',
    rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')',
    rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower,
    rsUpper + '+' + rsOptContrUpper,
    rsOrdUpper,
    rsOrdLower,
    rsDigits,
    rsEmoji
  ].join('|'), 'g');

  /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
  var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');

  /** Used to detect strings that need a more robust regexp to match words. */
  var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;

  /** Used to assign default `context` object properties. */
  var contextProps = [
    'Array', 'Buffer', 'DataView', 'Date', 'Error', 'Float32Array', 'Float64Array',
    'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Map', 'Math', 'Object',
    'Promise', 'RegExp', 'Set', 'String', 'Symbol', 'TypeError', 'Uint8Array',
    'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap',
    '_', 'clearTimeout', 'isFinite', 'parseInt', 'setTimeout'
  ];

  /** Used to make template sourceURLs easier to identify. */
  var templateCounter = -1;

  /** Used to identify `toStringTag` values of typed arrays. */
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
  typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
  typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
  typedArrayTags[errorTag] = typedArrayTags[funcTag] =
  typedArrayTags[mapTag] = typedArrayTags[numberTag] =
  typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
  typedArrayTags[setTag] = typedArrayTags[stringTag] =
  typedArrayTags[weakMapTag] = false;

  /** Used to identify `toStringTag` values supported by `_.clone`. */
  var cloneableTags = {};
  cloneableTags[argsTag] = cloneableTags[arrayTag] =
  cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
  cloneableTags[boolTag] = cloneableTags[dateTag] =
  cloneableTags[float32Tag] = cloneableTags[float64Tag] =
  cloneableTags[int8Tag] = cloneableTags[int16Tag] =
  cloneableTags[int32Tag] = cloneableTags[mapTag] =
  cloneableTags[numberTag] = cloneableTags[objectTag] =
  cloneableTags[regexpTag] = cloneableTags[setTag] =
  cloneableTags[stringTag] = cloneableTags[symbolTag] =
  cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
  cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
  cloneableTags[errorTag] = cloneableTags[funcTag] =
  cloneableTags[weakMapTag] = false;

  /** Used to map Latin Unicode letters to basic Latin letters. */
  var deburredLetters = {
    // Latin-1 Supplement block.
    '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
    '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
    '\xc7': 'C',  '\xe7': 'c',
    '\xd0': 'D',  '\xf0': 'd',
    '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
    '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
    '\xcc': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
    '\xec': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
    '\xd1': 'N',  '\xf1': 'n',
    '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
    '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
    '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
    '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
    '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
    '\xc6': 'Ae', '\xe6': 'ae',
    '\xde': 'Th', '\xfe': 'th',
    '\xdf': 'ss',
    // Latin Extended-A block.
    '\u0100': 'A',  '\u0102': 'A', '\u0104': 'A',
    '\u0101': 'a',  '\u0103': 'a', '\u0105': 'a',
    '\u0106': 'C',  '\u0108': 'C', '\u010a': 'C', '\u010c': 'C',
    '\u0107': 'c',  '\u0109': 'c', '\u010b': 'c', '\u010d': 'c',
    '\u010e': 'D',  '\u0110': 'D', '\u010f': 'd', '\u0111': 'd',
    '\u0112': 'E',  '\u0114': 'E', '\u0116': 'E', '\u0118': 'E', '\u011a': 'E',
    '\u0113': 'e',  '\u0115': 'e', '\u0117': 'e', '\u0119': 'e', '\u011b': 'e',
    '\u011c': 'G',  '\u011e': 'G', '\u0120': 'G', '\u0122': 'G',
    '\u011d': 'g',  '\u011f': 'g', '\u0121': 'g', '\u0123': 'g',
    '\u0124': 'H',  '\u0126': 'H', '\u0125': 'h', '\u0127': 'h',
    '\u0128': 'I',  '\u012a': 'I', '\u012c': 'I', '\u012e': 'I', '\u0130': 'I',
    '\u0129': 'i',  '\u012b': 'i', '\u012d': 'i', '\u012f': 'i', '\u0131': 'i',
    '\u0134': 'J',  '\u0135': 'j',
    '\u0136': 'K',  '\u0137': 'k', '\u0138': 'k',
    '\u0139': 'L',  '\u013b': 'L', '\u013d': 'L', '\u013f': 'L', '\u0141': 'L',
    '\u013a': 'l',  '\u013c': 'l', '\u013e': 'l', '\u0140': 'l', '\u0142': 'l',
    '\u0143': 'N',  '\u0145': 'N', '\u0147': 'N', '\u014a': 'N',
    '\u0144': 'n',  '\u0146': 'n', '\u0148': 'n', '\u014b': 'n',
    '\u014c': 'O',  '\u014e': 'O', '\u0150': 'O',
    '\u014d': 'o',  '\u014f': 'o', '\u0151': 'o',
    '\u0154': 'R',  '\u0156': 'R', '\u0158': 'R',
    '\u0155': 'r',  '\u0157': 'r', '\u0159': 'r',
    '\u015a': 'S',  '\u015c': 'S', '\u015e': 'S', '\u0160': 'S',
    '\u015b': 's',  '\u015d': 's', '\u015f': 's', '\u0161': 's',
    '\u0162': 'T',  '\u0164': 'T', '\u0166': 'T',
    '\u0163': 't',  '\u0165': 't', '\u0167': 't',
    '\u0168': 'U',  '\u016a': 'U', '\u016c': 'U', '\u016e': 'U', '\u0170': 'U', '\u0172': 'U',
    '\u0169': 'u',  '\u016b': 'u', '\u016d': 'u', '\u016f': 'u', '\u0171': 'u', '\u0173': 'u',
    '\u0174': 'W',  '\u0175': 'w',
    '\u0176': 'Y',  '\u0177': 'y', '\u0178': 'Y',
    '\u0179': 'Z',  '\u017b': 'Z', '\u017d': 'Z',
    '\u017a': 'z',  '\u017c': 'z', '\u017e': 'z',
    '\u0132': 'IJ', '\u0133': 'ij',
    '\u0152': 'Oe', '\u0153': 'oe',
    '\u0149': "'n", '\u017f': 's'
  };

  /** Used to map characters to HTML entities. */
  var htmlEscapes = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#39;'
  };

  /** Used to map HTML entities to characters. */
  var htmlUnescapes = {
    '&amp;': '&',
    '&lt;': '<',
    '&gt;': '>',
    '&quot;': '"',
    '&#39;': "'"
  };

  /** Used to escape characters for inclusion in compiled string literals. */
  var stringEscapes = {
    '\\': '\\',
    "'": "'",
    '\n': 'n',
    '\r': 'r',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  /** Built-in method references without a dependency on `root`. */
  var freeParseFloat = parseFloat,
      freeParseInt = parseInt;

  /** Detect free variable `global` from Node.js. */
  var freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g && __webpack_require__.g.Object === Object && __webpack_require__.g;

  /** Detect free variable `self`. */
  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

  /** Used as a reference to the global object. */
  var root = freeGlobal || freeSelf || Function('return this')();

  /** Detect free variable `exports`. */
  var freeExports =  true && exports && !exports.nodeType && exports;

  /** Detect free variable `module`. */
  var freeModule = freeExports && "object" == 'object' && module && !module.nodeType && module;

  /** Detect the popular CommonJS extension `module.exports`. */
  var moduleExports = freeModule && freeModule.exports === freeExports;

  /** Detect free variable `process` from Node.js. */
  var freeProcess = moduleExports && freeGlobal.process;

  /** Used to access faster Node.js helpers. */
  var nodeUtil = (function() {
    try {
      // Use `util.types` for Node.js 10+.
      var types = freeModule && freeModule.require && freeModule.require('util').types;

      if (types) {
        return types;
      }

      // Legacy `process.binding('util')` for Node.js < 10.
      return freeProcess && freeProcess.binding && freeProcess.binding('util');
    } catch (e) {}
  }());

  /* Node.js helper references. */
  var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer,
      nodeIsDate = nodeUtil && nodeUtil.isDate,
      nodeIsMap = nodeUtil && nodeUtil.isMap,
      nodeIsRegExp = nodeUtil && nodeUtil.isRegExp,
      nodeIsSet = nodeUtil && nodeUtil.isSet,
      nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

  /*--------------------------------------------------------------------------*/

  /**
   * A faster alternative to `Function#apply`, this function invokes `func`
   * with the `this` binding of `thisArg` and the arguments of `args`.
   *
   * @private
   * @param {Function} func The function to invoke.
   * @param {*} thisArg The `this` binding of `func`.
   * @param {Array} args The arguments to invoke `func` with.
   * @returns {*} Returns the result of `func`.
   */
  function apply(func, thisArg, args) {
    switch (args.length) {
      case 0: return func.call(thisArg);
      case 1: return func.call(thisArg, args[0]);
      case 2: return func.call(thisArg, args[0], args[1]);
      case 3: return func.call(thisArg, args[0], args[1], args[2]);
    }
    return func.apply(thisArg, args);
  }

  /**
   * A specialized version of `baseAggregator` for arrays.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} setter The function to set `accumulator` values.
   * @param {Function} iteratee The iteratee to transform keys.
   * @param {Object} accumulator The initial aggregated object.
   * @returns {Function} Returns `accumulator`.
   */
  function arrayAggregator(array, setter, iteratee, accumulator) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      var value = array[index];
      setter(accumulator, value, iteratee(value), array);
    }
    return accumulator;
  }

  /**
   * A specialized version of `_.forEach` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */
  function arrayEach(array, iteratee) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (iteratee(array[index], index, array) === false) {
        break;
      }
    }
    return array;
  }

  /**
   * A specialized version of `_.forEachRight` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */
  function arrayEachRight(array, iteratee) {
    var length = array == null ? 0 : array.length;

    while (length--) {
      if (iteratee(array[length], length, array) === false) {
        break;
      }
    }
    return array;
  }

  /**
   * A specialized version of `_.every` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if all elements pass the predicate check,
   *  else `false`.
   */
  function arrayEvery(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (!predicate(array[index], index, array)) {
        return false;
      }
    }
    return true;
  }

  /**
   * A specialized version of `_.filter` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {Array} Returns the new filtered array.
   */
  function arrayFilter(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length,
        resIndex = 0,
        result = [];

    while (++index < length) {
      var value = array[index];
      if (predicate(value, index, array)) {
        result[resIndex++] = value;
      }
    }
    return result;
  }

  /**
   * A specialized version of `_.includes` for arrays without support for
   * specifying an index to search from.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */
  function arrayIncludes(array, value) {
    var length = array == null ? 0 : array.length;
    return !!length && baseIndexOf(array, value, 0) > -1;
  }

  /**
   * This function is like `arrayIncludes` except that it accepts a comparator.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @param {Function} comparator The comparator invoked per element.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */
  function arrayIncludesWith(array, value, comparator) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (comparator(value, array[index])) {
        return true;
      }
    }
    return false;
  }

  /**
   * A specialized version of `_.map` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the new mapped array.
   */
  function arrayMap(array, iteratee) {
    var index = -1,
        length = array == null ? 0 : array.length,
        result = Array(length);

    while (++index < length) {
      result[index] = iteratee(array[index], index, array);
    }
    return result;
  }

  /**
   * Appends the elements of `values` to `array`.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {Array} values The values to append.
   * @returns {Array} Returns `array`.
   */
  function arrayPush(array, values) {
    var index = -1,
        length = values.length,
        offset = array.length;

    while (++index < length) {
      array[offset + index] = values[index];
    }
    return array;
  }

  /**
   * A specialized version of `_.reduce` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @param {boolean} [initAccum] Specify using the first element of `array` as
   *  the initial value.
   * @returns {*} Returns the accumulated value.
   */
  function arrayReduce(array, iteratee, accumulator, initAccum) {
    var index = -1,
        length = array == null ? 0 : array.length;

    if (initAccum && length) {
      accumulator = array[++index];
    }
    while (++index < length) {
      accumulator = iteratee(accumulator, array[index], index, array);
    }
    return accumulator;
  }

  /**
   * A specialized version of `_.reduceRight` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @param {boolean} [initAccum] Specify using the last element of `array` as
   *  the initial value.
   * @returns {*} Returns the accumulated value.
   */
  function arrayReduceRight(array, iteratee, accumulator, initAccum) {
    var length = array == null ? 0 : array.length;
    if (initAccum && length) {
      accumulator = array[--length];
    }
    while (length--) {
      accumulator = iteratee(accumulator, array[length], length, array);
    }
    return accumulator;
  }

  /**
   * A specialized version of `_.some` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if any element passes the predicate check,
   *  else `false`.
   */
  function arraySome(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (predicate(array[index], index, array)) {
        return true;
      }
    }
    return false;
  }

  /**
   * Gets the size of an ASCII `string`.
   *
   * @private
   * @param {string} string The string inspect.
   * @returns {number} Returns the string size.
   */
  var asciiSize = baseProperty('length');

  /**
   * Converts an ASCII `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function asciiToArray(string) {
    return string.split('');
  }

  /**
   * Splits an ASCII `string` into an array of its words.
   *
   * @private
   * @param {string} The string to inspect.
   * @returns {Array} Returns the words of `string`.
   */
  function asciiWords(string) {
    return string.match(reAsciiWord) || [];
  }

  /**
   * The base implementation of methods like `_.findKey` and `_.findLastKey`,
   * without support for iteratee shorthands, which iterates over `collection`
   * using `eachFunc`.
   *
   * @private
   * @param {Array|Object} collection The collection to inspect.
   * @param {Function} predicate The function invoked per iteration.
   * @param {Function} eachFunc The function to iterate over `collection`.
   * @returns {*} Returns the found element or its key, else `undefined`.
   */
  function baseFindKey(collection, predicate, eachFunc) {
    var result;
    eachFunc(collection, function(value, key, collection) {
      if (predicate(value, key, collection)) {
        result = key;
        return false;
      }
    });
    return result;
  }

  /**
   * The base implementation of `_.findIndex` and `_.findLastIndex` without
   * support for iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {Function} predicate The function invoked per iteration.
   * @param {number} fromIndex The index to search from.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseFindIndex(array, predicate, fromIndex, fromRight) {
    var length = array.length,
        index = fromIndex + (fromRight ? 1 : -1);

    while ((fromRight ? index-- : ++index < length)) {
      if (predicate(array[index], index, array)) {
        return index;
      }
    }
    return -1;
  }

  /**
   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseIndexOf(array, value, fromIndex) {
    return value === value
      ? strictIndexOf(array, value, fromIndex)
      : baseFindIndex(array, baseIsNaN, fromIndex);
  }

  /**
   * This function is like `baseIndexOf` except that it accepts a comparator.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @param {Function} comparator The comparator invoked per element.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseIndexOfWith(array, value, fromIndex, comparator) {
    var index = fromIndex - 1,
        length = array.length;

    while (++index < length) {
      if (comparator(array[index], value)) {
        return index;
      }
    }
    return -1;
  }

  /**
   * The base implementation of `_.isNaN` without support for number objects.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
   */
  function baseIsNaN(value) {
    return value !== value;
  }

  /**
   * The base implementation of `_.mean` and `_.meanBy` without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {number} Returns the mean.
   */
  function baseMean(array, iteratee) {
    var length = array == null ? 0 : array.length;
    return length ? (baseSum(array, iteratee) / length) : NAN;
  }

  /**
   * The base implementation of `_.property` without support for deep paths.
   *
   * @private
   * @param {string} key The key of the property to get.
   * @returns {Function} Returns the new accessor function.
   */
  function baseProperty(key) {
    return function(object) {
      return object == null ? undefined : object[key];
    };
  }

  /**
   * The base implementation of `_.propertyOf` without support for deep paths.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Function} Returns the new accessor function.
   */
  function basePropertyOf(object) {
    return function(key) {
      return object == null ? undefined : object[key];
    };
  }

  /**
   * The base implementation of `_.reduce` and `_.reduceRight`, without support
   * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
   *
   * @private
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} accumulator The initial value.
   * @param {boolean} initAccum Specify using the first or last element of
   *  `collection` as the initial value.
   * @param {Function} eachFunc The function to iterate over `collection`.
   * @returns {*} Returns the accumulated value.
   */
  function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
    eachFunc(collection, function(value, index, collection) {
      accumulator = initAccum
        ? (initAccum = false, value)
        : iteratee(accumulator, value, index, collection);
    });
    return accumulator;
  }

  /**
   * The base implementation of `_.sortBy` which uses `comparer` to define the
   * sort order of `array` and replaces criteria objects with their corresponding
   * values.
   *
   * @private
   * @param {Array} array The array to sort.
   * @param {Function} comparer The function to define sort order.
   * @returns {Array} Returns `array`.
   */
  function baseSortBy(array, comparer) {
    var length = array.length;

    array.sort(comparer);
    while (length--) {
      array[length] = array[length].value;
    }
    return array;
  }

  /**
   * The base implementation of `_.sum` and `_.sumBy` without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {number} Returns the sum.
   */
  function baseSum(array, iteratee) {
    var result,
        index = -1,
        length = array.length;

    while (++index < length) {
      var current = iteratee(array[index]);
      if (current !== undefined) {
        result = result === undefined ? current : (result + current);
      }
    }
    return result;
  }

  /**
   * The base implementation of `_.times` without support for iteratee shorthands
   * or max array length checks.
   *
   * @private
   * @param {number} n The number of times to invoke `iteratee`.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the array of results.
   */
  function baseTimes(n, iteratee) {
    var index = -1,
        result = Array(n);

    while (++index < n) {
      result[index] = iteratee(index);
    }
    return result;
  }

  /**
   * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array
   * of key-value pairs for `object` corresponding to the property names of `props`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array} props The property names to get values for.
   * @returns {Object} Returns the key-value pairs.
   */
  function baseToPairs(object, props) {
    return arrayMap(props, function(key) {
      return [key, object[key]];
    });
  }

  /**
   * The base implementation of `_.trim`.
   *
   * @private
   * @param {string} string The string to trim.
   * @returns {string} Returns the trimmed string.
   */
  function baseTrim(string) {
    return string
      ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')
      : string;
  }

  /**
   * The base implementation of `_.unary` without support for storing metadata.
   *
   * @private
   * @param {Function} func The function to cap arguments for.
   * @returns {Function} Returns the new capped function.
   */
  function baseUnary(func) {
    return function(value) {
      return func(value);
    };
  }

  /**
   * The base implementation of `_.values` and `_.valuesIn` which creates an
   * array of `object` property values corresponding to the property names
   * of `props`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array} props The property names to get values for.
   * @returns {Object} Returns the array of property values.
   */
  function baseValues(object, props) {
    return arrayMap(props, function(key) {
      return object[key];
    });
  }

  /**
   * Checks if a `cache` value for `key` exists.
   *
   * @private
   * @param {Object} cache The cache to query.
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function cacheHas(cache, key) {
    return cache.has(key);
  }

  /**
   * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol
   * that is not found in the character symbols.
   *
   * @private
   * @param {Array} strSymbols The string symbols to inspect.
   * @param {Array} chrSymbols The character symbols to find.
   * @returns {number} Returns the index of the first unmatched string symbol.
   */
  function charsStartIndex(strSymbols, chrSymbols) {
    var index = -1,
        length = strSymbols.length;

    while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
    return index;
  }

  /**
   * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol
   * that is not found in the character symbols.
   *
   * @private
   * @param {Array} strSymbols The string symbols to inspect.
   * @param {Array} chrSymbols The character symbols to find.
   * @returns {number} Returns the index of the last unmatched string symbol.
   */
  function charsEndIndex(strSymbols, chrSymbols) {
    var index = strSymbols.length;

    while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
    return index;
  }

  /**
   * Gets the number of `placeholder` occurrences in `array`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} placeholder The placeholder to search for.
   * @returns {number} Returns the placeholder count.
   */
  function countHolders(array, placeholder) {
    var length = array.length,
        result = 0;

    while (length--) {
      if (array[length] === placeholder) {
        ++result;
      }
    }
    return result;
  }

  /**
   * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
   * letters to basic Latin letters.
   *
   * @private
   * @param {string} letter The matched letter to deburr.
   * @returns {string} Returns the deburred letter.
   */
  var deburrLetter = basePropertyOf(deburredLetters);

  /**
   * Used by `_.escape` to convert characters to HTML entities.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
  var escapeHtmlChar = basePropertyOf(htmlEscapes);

  /**
   * Used by `_.template` to escape characters for inclusion in compiled string literals.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
  function escapeStringChar(chr) {
    return '\\' + stringEscapes[chr];
  }

  /**
   * Gets the value at `key` of `object`.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {string} key The key of the property to get.
   * @returns {*} Returns the property value.
   */
  function getValue(object, key) {
    return object == null ? undefined : object[key];
  }

  /**
   * Checks if `string` contains Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a symbol is found, else `false`.
   */
  function hasUnicode(string) {
    return reHasUnicode.test(string);
  }

  /**
   * Checks if `string` contains a word composed of Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a word is found, else `false`.
   */
  function hasUnicodeWord(string) {
    return reHasUnicodeWord.test(string);
  }

  /**
   * Converts `iterator` to an array.
   *
   * @private
   * @param {Object} iterator The iterator to convert.
   * @returns {Array} Returns the converted array.
   */
  function iteratorToArray(iterator) {
    var data,
        result = [];

    while (!(data = iterator.next()).done) {
      result.push(data.value);
    }
    return result;
  }

  /**
   * Converts `map` to its key-value pairs.
   *
   * @private
   * @param {Object} map The map to convert.
   * @returns {Array} Returns the key-value pairs.
   */
  function mapToArray(map) {
    var index = -1,
        result = Array(map.size);

    map.forEach(function(value, key) {
      result[++index] = [key, value];
    });
    return result;
  }

  /**
   * Creates a unary function that invokes `func` with its argument transformed.
   *
   * @private
   * @param {Function} func The function to wrap.
   * @param {Function} transform The argument transform.
   * @returns {Function} Returns the new function.
   */
  function overArg(func, transform) {
    return function(arg) {
      return func(transform(arg));
    };
  }

  /**
   * Replaces all `placeholder` elements in `array` with an internal placeholder
   * and returns an array of their indexes.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {*} placeholder The placeholder to replace.
   * @returns {Array} Returns the new array of placeholder indexes.
   */
  function replaceHolders(array, placeholder) {
    var index = -1,
        length = array.length,
        resIndex = 0,
        result = [];

    while (++index < length) {
      var value = array[index];
      if (value === placeholder || value === PLACEHOLDER) {
        array[index] = PLACEHOLDER;
        result[resIndex++] = index;
      }
    }
    return result;
  }

  /**
   * Converts `set` to an array of its values.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the values.
   */
  function setToArray(set) {
    var index = -1,
        result = Array(set.size);

    set.forEach(function(value) {
      result[++index] = value;
    });
    return result;
  }

  /**
   * Converts `set` to its value-value pairs.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the value-value pairs.
   */
  function setToPairs(set) {
    var index = -1,
        result = Array(set.size);

    set.forEach(function(value) {
      result[++index] = [value, value];
    });
    return result;
  }

  /**
   * A specialized version of `_.indexOf` which performs strict equality
   * comparisons of values, i.e. `===`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function strictIndexOf(array, value, fromIndex) {
    var index = fromIndex - 1,
        length = array.length;

    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  }

  /**
   * A specialized version of `_.lastIndexOf` which performs strict equality
   * comparisons of values, i.e. `===`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function strictLastIndexOf(array, value, fromIndex) {
    var index = fromIndex + 1;
    while (index--) {
      if (array[index] === value) {
        return index;
      }
    }
    return index;
  }

  /**
   * Gets the number of symbols in `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the string size.
   */
  function stringSize(string) {
    return hasUnicode(string)
      ? unicodeSize(string)
      : asciiSize(string);
  }

  /**
   * Converts `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function stringToArray(string) {
    return hasUnicode(string)
      ? unicodeToArray(string)
      : asciiToArray(string);
  }

  /**
   * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
   * character of `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the index of the last non-whitespace character.
   */
  function trimmedEndIndex(string) {
    var index = string.length;

    while (index-- && reWhitespace.test(string.charAt(index))) {}
    return index;
  }

  /**
   * Used by `_.unescape` to convert HTML entities to characters.
   *
   * @private
   * @param {string} chr The matched character to unescape.
   * @returns {string} Returns the unescaped character.
   */
  var unescapeHtmlChar = basePropertyOf(htmlUnescapes);

  /**
   * Gets the size of a Unicode `string`.
   *
   * @private
   * @param {string} string The string inspect.
   * @returns {number} Returns the string size.
   */
  function unicodeSize(string) {
    var result = reUnicode.lastIndex = 0;
    while (reUnicode.test(string)) {
      ++result;
    }
    return result;
  }

  /**
   * Converts a Unicode `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function unicodeToArray(string) {
    return string.match(reUnicode) || [];
  }

  /**
   * Splits a Unicode `string` into an array of its words.
   *
   * @private
   * @param {string} The string to inspect.
   * @returns {Array} Returns the words of `string`.
   */
  function unicodeWords(string) {
    return string.match(reUnicodeWord) || [];
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Create a new pristine `lodash` function using the `context` object.
   *
   * @static
   * @memberOf _
   * @since 1.1.0
   * @category Util
   * @param {Object} [context=root] The context object.
   * @returns {Function} Returns a new `lodash` function.
   * @example
   *
   * _.mixin({ 'foo': _.constant('foo') });
   *
   * var lodash = _.runInContext();
   * lodash.mixin({ 'bar': lodash.constant('bar') });
   *
   * _.isFunction(_.foo);
   * // => true
   * _.isFunction(_.bar);
   * // => false
   *
   * lodash.isFunction(lodash.foo);
   * // => false
   * lodash.isFunction(lodash.bar);
   * // => true
   *
   * // Create a suped-up `defer` in Node.js.
   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
   */
  var runInContext = (function runInContext(context) {
    context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));

    /** Built-in constructor references. */
    var Array = context.Array,
        Date = context.Date,
        Error = context.Error,
        Function = context.Function,
        Math = context.Math,
        Object = context.Object,
        RegExp = context.RegExp,
        String = context.String,
        TypeError = context.TypeError;

    /** Used for built-in method references. */
    var arrayProto = Array.prototype,
        funcProto = Function.prototype,
        objectProto = Object.prototype;

    /** Used to detect overreaching core-js shims. */
    var coreJsData = context['__core-js_shared__'];

    /** Used to resolve the decompiled source of functions. */
    var funcToString = funcProto.toString;

    /** Used to check objects for own properties. */
    var hasOwnProperty = objectProto.hasOwnProperty;

    /** Used to generate unique IDs. */
    var idCounter = 0;

    /** Used to detect methods masquerading as native. */
    var maskSrcKey = (function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
      return uid ? ('Symbol(src)_1.' + uid) : '';
    }());

    /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */
    var nativeObjectToString = objectProto.toString;

    /** Used to infer the `Object` constructor. */
    var objectCtorString = funcToString.call(Object);

    /** Used to restore the original `_` reference in `_.noConflict`. */
    var oldDash = root._;

    /** Used to detect if a method is native. */
    var reIsNative = RegExp('^' +
      funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
      .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
    );

    /** Built-in value references. */
    var Buffer = moduleExports ? context.Buffer : undefined,
        Symbol = context.Symbol,
        Uint8Array = context.Uint8Array,
        allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined,
        getPrototype = overArg(Object.getPrototypeOf, Object),
        objectCreate = Object.create,
        propertyIsEnumerable = objectProto.propertyIsEnumerable,
        splice = arrayProto.splice,
        spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined,
        symIterator = Symbol ? Symbol.iterator : undefined,
        symToStringTag = Symbol ? Symbol.toStringTag : undefined;

    var defineProperty = (function() {
      try {
        var func = getNative(Object, 'defineProperty');
        func({}, '', {});
        return func;
      } catch (e) {}
    }());

    /** Mocked built-ins. */
    var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout,
        ctxNow = Date && Date.now !== root.Date.now && Date.now,
        ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeCeil = Math.ceil,
        nativeFloor = Math.floor,
        nativeGetSymbols = Object.getOwnPropertySymbols,
        nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
        nativeIsFinite = context.isFinite,
        nativeJoin = arrayProto.join,
        nativeKeys = overArg(Object.keys, Object),
        nativeMax = Math.max,
        nativeMin = Math.min,
        nativeNow = Date.now,
        nativeParseInt = context.parseInt,
        nativeRandom = Math.random,
        nativeReverse = arrayProto.reverse;

    /* Built-in method references that are verified to be native. */
    var DataView = getNative(context, 'DataView'),
        Map = getNative(context, 'Map'),
        Promise = getNative(context, 'Promise'),
        Set = getNative(context, 'Set'),
        WeakMap = getNative(context, 'WeakMap'),
        nativeCreate = getNative(Object, 'create');

    /** Used to store function metadata. */
    var metaMap = WeakMap && new WeakMap;

    /** Used to lookup unminified function names. */
    var realNames = {};

    /** Used to detect maps, sets, and weakmaps. */
    var dataViewCtorString = toSource(DataView),
        mapCtorString = toSource(Map),
        promiseCtorString = toSource(Promise),
        setCtorString = toSource(Set),
        weakMapCtorString = toSource(WeakMap);

    /** Used to convert symbols to primitives and strings. */
    var symbolProto = Symbol ? Symbol.prototype : undefined,
        symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,
        symbolToString = symbolProto ? symbolProto.toString : undefined;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` object which wraps `value` to enable implicit method
     * chain sequences. Methods that operate on and return arrays, collections,
     * and functions can be chained together. Methods that retrieve a single value
     * or may return a primitive value will automatically end the chain sequence
     * and return the unwrapped value. Otherwise, the value must be unwrapped
     * with `_#value`.
     *
     * Explicit chain sequences, which must be unwrapped with `_#value`, may be
     * enabled using `_.chain`.
     *
     * The execution of chained methods is lazy, that is, it's deferred until
     * `_#value` is implicitly or explicitly called.
     *
     * Lazy evaluation allows several methods to support shortcut fusion.
     * Shortcut fusion is an optimization to merge iteratee calls; this avoids
     * the creation of intermediate arrays and can greatly reduce the number of
     * iteratee executions. Sections of a chain sequence qualify for shortcut
     * fusion if the section is applied to an array and iteratees accept only
     * one argument. The heuristic for whether a section qualifies for shortcut
     * fusion is subject to change.
     *
     * Chaining is supported in custom builds as long as the `_#value` method is
     * directly or indirectly included in the build.
     *
     * In addition to lodash methods, wrappers have `Array` and `String` methods.
     *
     * The wrapper `Array` methods are:
     * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
     *
     * The wrapper `String` methods are:
     * `replace` and `split`
     *
     * The wrapper methods that support shortcut fusion are:
     * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
     * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
     * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
     *
     * The chainable wrapper methods are:
     * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
     * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
     * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
     * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
     * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
     * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
     * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
     * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
     * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
     * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
     * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
     * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
     * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
     * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
     * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
     * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
     * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
     * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
     * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
     * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
     * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
     * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
     * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
     * `zipObject`, `zipObjectDeep`, and `zipWith`
     *
     * The wrapper methods that are **not** chainable by default are:
     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
     * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,
     * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,
     * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,
     * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,
     * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,
     * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,
     * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,
     * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,
     * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,
     * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,
     * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,
     * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,
     * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,
     * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,
     * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,
     * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,
     * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,
     * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,
     * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,
     * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,
     * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,
     * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,
     * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,
     * `upperFirst`, `value`, and `words`
     *
     * @name _
     * @constructor
     * @category Seq
     * @param {*} value The value to wrap in a `lodash` instance.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var wrapped = _([1, 2, 3]);
     *
     * // Returns an unwrapped value.
     * wrapped.reduce(_.add);
     * // => 6
     *
     * // Returns a wrapped value.
     * var squares = wrapped.map(square);
     *
     * _.isArray(squares);
     * // => false
     *
     * _.isArray(squares.value());
     * // => true
     */
    function lodash(value) {
      if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
        if (value instanceof LodashWrapper) {
          return value;
        }
        if (hasOwnProperty.call(value, '__wrapped__')) {
          return wrapperClone(value);
        }
      }
      return new LodashWrapper(value);
    }

    /**
     * The base implementation of `_.create` without support for assigning
     * properties to the created object.
     *
     * @private
     * @param {Object} proto The object to inherit from.
     * @returns {Object} Returns the new object.
     */
    var baseCreate = (function() {
      function object() {}
      return function(proto) {
        if (!isObject(proto)) {
          return {};
        }
        if (objectCreate) {
          return objectCreate(proto);
        }
        object.prototype = proto;
        var result = new object;
        object.prototype = undefined;
        return result;
      };
    }());

    /**
     * The function whose prototype chain sequence wrappers inherit from.
     *
     * @private
     */
    function baseLodash() {
      // No operation performed.
    }

    /**
     * The base constructor for creating `lodash` wrapper objects.
     *
     * @private
     * @param {*} value The value to wrap.
     * @param {boolean} [chainAll] Enable explicit method chain sequences.
     */
    function LodashWrapper(value, chainAll) {
      this.__wrapped__ = value;
      this.__actions__ = [];
      this.__chain__ = !!chainAll;
      this.__index__ = 0;
      this.__values__ = undefined;
    }

    /**
     * By default, the template delimiters used by lodash are like those in
     * embedded Ruby (ERB) as well as ES2015 template strings. Change the
     * following template settings to use alternative delimiters.
     *
     * @static
     * @memberOf _
     * @type {Object}
     */
    lodash.templateSettings = {

      /**
       * Used to detect `data` property values to be HTML-escaped.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */
      'escape': reEscape,

      /**
       * Used to detect code to be evaluated.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */
      'evaluate': reEvaluate,

      /**
       * Used to detect `data` property values to inject.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */
      'interpolate': reInterpolate,

      /**
       * Used to reference the data object in the template text.
       *
       * @memberOf _.templateSettings
       * @type {string}
       */
      'variable': '',

      /**
       * Used to import variables into the compiled template.
       *
       * @memberOf _.templateSettings
       * @type {Object}
       */
      'imports': {

        /**
         * A reference to the `lodash` function.
         *
         * @memberOf _.templateSettings.imports
         * @type {Function}
         */
        '_': lodash
      }
    };

    // Ensure wrappers are instances of `baseLodash`.
    lodash.prototype = baseLodash.prototype;
    lodash.prototype.constructor = lodash;

    LodashWrapper.prototype = baseCreate(baseLodash.prototype);
    LodashWrapper.prototype.constructor = LodashWrapper;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
     *
     * @private
     * @constructor
     * @param {*} value The value to wrap.
     */
    function LazyWrapper(value) {
      this.__wrapped__ = value;
      this.__actions__ = [];
      this.__dir__ = 1;
      this.__filtered__ = false;
      this.__iteratees__ = [];
      this.__takeCount__ = MAX_ARRAY_LENGTH;
      this.__views__ = [];
    }

    /**
     * Creates a clone of the lazy wrapper object.
     *
     * @private
     * @name clone
     * @memberOf LazyWrapper
     * @returns {Object} Returns the cloned `LazyWrapper` object.
     */
    function lazyClone() {
      var result = new LazyWrapper(this.__wrapped__);
      result.__actions__ = copyArray(this.__actions__);
      result.__dir__ = this.__dir__;
      result.__filtered__ = this.__filtered__;
      result.__iteratees__ = copyArray(this.__iteratees__);
      result.__takeCount__ = this.__takeCount__;
      result.__views__ = copyArray(this.__views__);
      return result;
    }

    /**
     * Reverses the direction of lazy iteration.
     *
     * @private
     * @name reverse
     * @memberOf LazyWrapper
     * @returns {Object} Returns the new reversed `LazyWrapper` object.
     */
    function lazyReverse() {
      if (this.__filtered__) {
        var result = new LazyWrapper(this);
        result.__dir__ = -1;
        result.__filtered__ = true;
      } else {
        result = this.clone();
        result.__dir__ *= -1;
      }
      return result;
    }

    /**
     * Extracts the unwrapped value from its lazy wrapper.
     *
     * @private
     * @name value
     * @memberOf LazyWrapper
     * @returns {*} Returns the unwrapped value.
     */
    function lazyValue() {
      var array = this.__wrapped__.value(),
          dir = this.__dir__,
          isArr = isArray(array),
          isRight = dir < 0,
          arrLength = isArr ? array.length : 0,
          view = getView(0, arrLength, this.__views__),
          start = view.start,
          end = view.end,
          length = end - start,
          index = isRight ? end : (start - 1),
          iteratees = this.__iteratees__,
          iterLength = iteratees.length,
          resIndex = 0,
          takeCount = nativeMin(length, this.__takeCount__);

      if (!isArr || (!isRight && arrLength == length && takeCount == length)) {
        return baseWrapperValue(array, this.__actions__);
      }
      var result = [];

      outer:
      while (length-- && resIndex < takeCount) {
        index += dir;

        var iterIndex = -1,
            value = array[index];

        while (++iterIndex < iterLength) {
          var data = iteratees[iterIndex],
              iteratee = data.iteratee,
              type = data.type,
              computed = iteratee(value);

          if (type == LAZY_MAP_FLAG) {
            value = computed;
          } else if (!computed) {
            if (type == LAZY_FILTER_FLAG) {
              continue outer;
            } else {
              break outer;
            }
          }
        }
        result[resIndex++] = value;
      }
      return result;
    }

    // Ensure `LazyWrapper` is an instance of `baseLodash`.
    LazyWrapper.prototype = baseCreate(baseLodash.prototype);
    LazyWrapper.prototype.constructor = LazyWrapper;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a hash object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function Hash(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    /**
     * Removes all key-value entries from the hash.
     *
     * @private
     * @name clear
     * @memberOf Hash
     */
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }

    /**
     * Removes `key` and its value from the hash.
     *
     * @private
     * @name delete
     * @memberOf Hash
     * @param {Object} hash The hash to modify.
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }

    /**
     * Gets the hash value for `key`.
     *
     * @private
     * @name get
     * @memberOf Hash
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? undefined : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : undefined;
    }

    /**
     * Checks if a hash value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Hash
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
    }

    /**
     * Sets the hash `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Hash
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the hash instance.
     */
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
      return this;
    }

    // Add methods to `Hash`.
    Hash.prototype.clear = hashClear;
    Hash.prototype['delete'] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;

    /*------------------------------------------------------------------------*/

    /**
     * Creates an list cache object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function ListCache(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    /**
     * Removes all key-value entries from the list cache.
     *
     * @private
     * @name clear
     * @memberOf ListCache
     */
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }

    /**
     * Removes `key` and its value from the list cache.
     *
     * @private
     * @name delete
     * @memberOf ListCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function listCacheDelete(key) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }

    /**
     * Gets the list cache value for `key`.
     *
     * @private
     * @name get
     * @memberOf ListCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function listCacheGet(key) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      return index < 0 ? undefined : data[index][1];
    }

    /**
     * Checks if a list cache value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf ListCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }

    /**
     * Sets the list cache `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf ListCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the list cache instance.
     */
    function listCacheSet(key, value) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      if (index < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }

    // Add methods to `ListCache`.
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype['delete'] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a map cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function MapCache(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    /**
     * Removes all key-value entries from the map.
     *
     * @private
     * @name clear
     * @memberOf MapCache
     */
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        'hash': new Hash,
        'map': new (Map || ListCache),
        'string': new Hash
      };
    }

    /**
     * Removes `key` and its value from the map.
     *
     * @private
     * @name delete
     * @memberOf MapCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function mapCacheDelete(key) {
      var result = getMapData(this, key)['delete'](key);
      this.size -= result ? 1 : 0;
      return result;
    }

    /**
     * Gets the map value for `key`.
     *
     * @private
     * @name get
     * @memberOf MapCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }

    /**
     * Checks if a map value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf MapCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }

    /**
     * Sets the map `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf MapCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the map cache instance.
     */
    function mapCacheSet(key, value) {
      var data = getMapData(this, key),
          size = data.size;

      data.set(key, value);
      this.size += data.size == size ? 0 : 1;
      return this;
    }

    // Add methods to `MapCache`.
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype['delete'] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;

    /*------------------------------------------------------------------------*/

    /**
     *
     * Creates an array cache object to store unique values.
     *
     * @private
     * @constructor
     * @param {Array} [values] The values to cache.
     */
    function SetCache(values) {
      var index = -1,
          length = values == null ? 0 : values.length;

      this.__data__ = new MapCache;
      while (++index < length) {
        this.add(values[index]);
      }
    }

    /**
     * Adds `value` to the array cache.
     *
     * @private
     * @name add
     * @memberOf SetCache
     * @alias push
     * @param {*} value The value to cache.
     * @returns {Object} Returns the cache instance.
     */
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }

    /**
     * Checks if `value` is in the array cache.
     *
     * @private
     * @name has
     * @memberOf SetCache
     * @param {*} value The value to search for.
     * @returns {number} Returns `true` if `value` is found, else `false`.
     */
    function setCacheHas(value) {
      return this.__data__.has(value);
    }

    // Add methods to `SetCache`.
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a stack cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }

    /**
     * Removes all key-value entries from the stack.
     *
     * @private
     * @name clear
     * @memberOf Stack
     */
    function stackClear() {
      this.__data__ = new ListCache;
      this.size = 0;
    }

    /**
     * Removes `key` and its value from the stack.
     *
     * @private
     * @name delete
     * @memberOf Stack
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function stackDelete(key) {
      var data = this.__data__,
          result = data['delete'](key);

      this.size = data.size;
      return result;
    }

    /**
     * Gets the stack value for `key`.
     *
     * @private
     * @name get
     * @memberOf Stack
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function stackGet(key) {
      return this.__data__.get(key);
    }

    /**
     * Checks if a stack value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Stack
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function stackHas(key) {
      return this.__data__.has(key);
    }

    /**
     * Sets the stack `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Stack
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the stack cache instance.
     */
    function stackSet(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }

    // Add methods to `Stack`.
    Stack.prototype.clear = stackClear;
    Stack.prototype['delete'] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;

    /*------------------------------------------------------------------------*/

    /**
     * Creates an array of the enumerable property names of the array-like `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @param {boolean} inherited Specify returning inherited property names.
     * @returns {Array} Returns the array of property names.
     */
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value),
          isArg = !isArr && isArguments(value),
          isBuff = !isArr && !isArg && isBuffer(value),
          isType = !isArr && !isArg && !isBuff && isTypedArray(value),
          skipIndexes = isArr || isArg || isBuff || isType,
          result = skipIndexes ? baseTimes(value.length, String) : [],
          length = result.length;

      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) &&
            !(skipIndexes && (
               // Safari 9 has enumerable `arguments.length` in strict mode.
               key == 'length' ||
               // Node.js 0.10 has enumerable non-index properties on buffers.
               (isBuff && (key == 'offset' || key == 'parent')) ||
               // PhantomJS 2 has enumerable non-index properties on typed arrays.
               (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
               // Skip index properties.
               isIndex(key, length)
            ))) {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * A specialized version of `_.sample` for arrays.
     *
     * @private
     * @param {Array} array The array to sample.
     * @returns {*} Returns the random element.
     */
    function arraySample(array) {
      var length = array.length;
      return length ? array[baseRandom(0, length - 1)] : undefined;
    }

    /**
     * A specialized version of `_.sampleSize` for arrays.
     *
     * @private
     * @param {Array} array The array to sample.
     * @param {number} n The number of elements to sample.
     * @returns {Array} Returns the random elements.
     */
    function arraySampleSize(array, n) {
      return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
    }

    /**
     * A specialized version of `_.shuffle` for arrays.
     *
     * @private
     * @param {Array} array The array to shuffle.
     * @returns {Array} Returns the new shuffled array.
     */
    function arrayShuffle(array) {
      return shuffleSelf(copyArray(array));
    }

    /**
     * This function is like `assignValue` except that it doesn't assign
     * `undefined` values.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */
    function assignMergeValue(object, key, value) {
      if ((value !== undefined && !eq(object[key], value)) ||
          (value === undefined && !(key in object))) {
        baseAssignValue(object, key, value);
      }
    }

    /**
     * Assigns `value` to `key` of `object` if the existing value is not equivalent
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
          (value === undefined && !(key in object))) {
        baseAssignValue(object, key, value);
      }
    }

    /**
     * Gets the index at which the `key` is found in `array` of key-value pairs.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} key The key to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }

    /**
     * Aggregates elements of `collection` on `accumulator` with keys transformed
     * by `iteratee` and values set by `setter`.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} setter The function to set `accumulator` values.
     * @param {Function} iteratee The iteratee to transform keys.
     * @param {Object} accumulator The initial aggregated object.
     * @returns {Function} Returns `accumulator`.
     */
    function baseAggregator(collection, setter, iteratee, accumulator) {
      baseEach(collection, function(value, key, collection) {
        setter(accumulator, value, iteratee(value), collection);
      });
      return accumulator;
    }

    /**
     * The base implementation of `_.assign` without support for multiple sources
     * or `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */
    function baseAssign(object, source) {
      return object && copyObject(source, keys(source), object);
    }

    /**
     * The base implementation of `_.assignIn` without support for multiple sources
     * or `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */
    function baseAssignIn(object, source) {
      return object && copyObject(source, keysIn(source), object);
    }

    /**
     * The base implementation of `assignValue` and `assignMergeValue` without
     * value checks.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */
    function baseAssignValue(object, key, value) {
      if (key == '__proto__' && defineProperty) {
        defineProperty(object, key, {
          'configurable': true,
          'enumerable': true,
          'value': value,
          'writable': true
        });
      } else {
        object[key] = value;
      }
    }

    /**
     * The base implementation of `_.at` without support for individual paths.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {string[]} paths The property paths to pick.
     * @returns {Array} Returns the picked elements.
     */
    function baseAt(object, paths) {
      var index = -1,
          length = paths.length,
          result = Array(length),
          skip = object == null;

      while (++index < length) {
        result[index] = skip ? undefined : get(object, paths[index]);
      }
      return result;
    }

    /**
     * The base implementation of `_.clamp` which doesn't coerce arguments.
     *
     * @private
     * @param {number} number The number to clamp.
     * @param {number} [lower] The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the clamped number.
     */
    function baseClamp(number, lower, upper) {
      if (number === number) {
        if (upper !== undefined) {
          number = number <= upper ? number : upper;
        }
        if (lower !== undefined) {
          number = number >= lower ? number : lower;
        }
      }
      return number;
    }

    /**
     * The base implementation of `_.clone` and `_.cloneDeep` which tracks
     * traversed objects.
     *
     * @private
     * @param {*} value The value to clone.
     * @param {boolean} bitmask The bitmask flags.
     *  1 - Deep clone
     *  2 - Flatten inherited properties
     *  4 - Clone symbols
     * @param {Function} [customizer] The function to customize cloning.
     * @param {string} [key] The key of `value`.
     * @param {Object} [object] The parent object of `value`.
     * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
     * @returns {*} Returns the cloned value.
     */
    function baseClone(value, bitmask, customizer, key, object, stack) {
      var result,
          isDeep = bitmask & CLONE_DEEP_FLAG,
          isFlat = bitmask & CLONE_FLAT_FLAG,
          isFull = bitmask & CLONE_SYMBOLS_FLAG;

      if (customizer) {
        result = object ? customizer(value, key, object, stack) : customizer(value);
      }
      if (result !== undefined) {
        return result;
      }
      if (!isObject(value)) {
        return value;
      }
      var isArr = isArray(value);
      if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) {
          return copyArray(value, result);
        }
      } else {
        var tag = getTag(value),
            isFunc = tag == funcTag || tag == genTag;

        if (isBuffer(value)) {
          return cloneBuffer(value, isDeep);
        }
        if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
          result = (isFlat || isFunc) ? {} : initCloneObject(value);
          if (!isDeep) {
            return isFlat
              ? copySymbolsIn(value, baseAssignIn(result, value))
              : copySymbols(value, baseAssign(result, value));
          }
        } else {
          if (!cloneableTags[tag]) {
            return object ? value : {};
          }
          result = initCloneByTag(value, tag, isDeep);
        }
      }
      // Check for circular references and return its corresponding clone.
      stack || (stack = new Stack);
      var stacked = stack.get(value);
      if (stacked) {
        return stacked;
      }
      stack.set(value, result);

      if (isSet(value)) {
        value.forEach(function(subValue) {
          result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
        });
      } else if (isMap(value)) {
        value.forEach(function(subValue, key) {
          result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
        });
      }

      var keysFunc = isFull
        ? (isFlat ? getAllKeysIn : getAllKeys)
        : (isFlat ? keysIn : keys);

      var props = isArr ? undefined : keysFunc(value);
      arrayEach(props || value, function(subValue, key) {
        if (props) {
          key = subValue;
          subValue = value[key];
        }
        // Recursively populate clone (susceptible to call stack limits).
        assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
      });
      return result;
    }

    /**
     * The base implementation of `_.conforms` which doesn't clone `source`.
     *
     * @private
     * @param {Object} source The object of property predicates to conform to.
     * @returns {Function} Returns the new spec function.
     */
    function baseConforms(source) {
      var props = keys(source);
      return function(object) {
        return baseConformsTo(object, source, props);
      };
    }

    /**
     * The base implementation of `_.conformsTo` which accepts `props` to check.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property predicates to conform to.
     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
     */
    function baseConformsTo(object, source, props) {
      var length = props.length;
      if (object == null) {
        return !length;
      }
      object = Object(object);
      while (length--) {
        var key = props[length],
            predicate = source[key],
            value = object[key];

        if ((value === undefined && !(key in object)) || !predicate(value)) {
          return false;
        }
      }
      return true;
    }

    /**
     * The base implementation of `_.delay` and `_.defer` which accepts `args`
     * to provide to `func`.
     *
     * @private
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {Array} args The arguments to provide to `func`.
     * @returns {number|Object} Returns the timer id or timeout object.
     */
    function baseDelay(func, wait, args) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return setTimeout(function() { func.apply(undefined, args); }, wait);
    }

    /**
     * The base implementation of methods like `_.difference` without support
     * for excluding multiple arrays or iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Array} values The values to exclude.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     */
    function baseDifference(array, values, iteratee, comparator) {
      var index = -1,
          includes = arrayIncludes,
          isCommon = true,
          length = array.length,
          result = [],
          valuesLength = values.length;

      if (!length) {
        return result;
      }
      if (iteratee) {
        values = arrayMap(values, baseUnary(iteratee));
      }
      if (comparator) {
        includes = arrayIncludesWith;
        isCommon = false;
      }
      else if (values.length >= LARGE_ARRAY_SIZE) {
        includes = cacheHas;
        isCommon = false;
        values = new SetCache(values);
      }
      outer:
      while (++index < length) {
        var value = array[index],
            computed = iteratee == null ? value : iteratee(value);

        value = (comparator || value !== 0) ? value : 0;
        if (isCommon && computed === computed) {
          var valuesIndex = valuesLength;
          while (valuesIndex--) {
            if (values[valuesIndex] === computed) {
              continue outer;
            }
          }
          result.push(value);
        }
        else if (!includes(values, computed, comparator)) {
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.forEach` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     */
    var baseEach = createBaseEach(baseForOwn);

    /**
     * The base implementation of `_.forEachRight` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     */
    var baseEachRight = createBaseEach(baseForOwnRight, true);

    /**
     * The base implementation of `_.every` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`
     */
    function baseEvery(collection, predicate) {
      var result = true;
      baseEach(collection, function(value, index, collection) {
        result = !!predicate(value, index, collection);
        return result;
      });
      return result;
    }

    /**
     * The base implementation of methods like `_.max` and `_.min` which accepts a
     * `comparator` to determine the extremum value.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The iteratee invoked per iteration.
     * @param {Function} comparator The comparator used to compare values.
     * @returns {*} Returns the extremum value.
     */
    function baseExtremum(array, iteratee, comparator) {
      var index = -1,
          length = array.length;

      while (++index < length) {
        var value = array[index],
            current = iteratee(value);

        if (current != null && (computed === undefined
              ? (current === current && !isSymbol(current))
              : comparator(current, computed)
            )) {
          var computed = current,
              result = value;
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.fill` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     */
    function baseFill(array, value, start, end) {
      var length = array.length;

      start = toInteger(start);
      if (start < 0) {
        start = -start > length ? 0 : (length + start);
      }
      end = (end === undefined || end > length) ? length : toInteger(end);
      if (end < 0) {
        end += length;
      }
      end = start > end ? 0 : toLength(end);
      while (start < end) {
        array[start++] = value;
      }
      return array;
    }

    /**
     * The base implementation of `_.filter` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     */
    function baseFilter(collection, predicate) {
      var result = [];
      baseEach(collection, function(value, index, collection) {
        if (predicate(value, index, collection)) {
          result.push(value);
        }
      });
      return result;
    }

    /**
     * The base implementation of `_.flatten` with support for restricting flattening.
     *
     * @private
     * @param {Array} array The array to flatten.
     * @param {number} depth The maximum recursion depth.
     * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
     * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
     * @param {Array} [result=[]] The initial result value.
     * @returns {Array} Returns the new flattened array.
     */
    function baseFlatten(array, depth, predicate, isStrict, result) {
      var index = -1,
          length = array.length;

      predicate || (predicate = isFlattenable);
      result || (result = []);

      while (++index < length) {
        var value = array[index];
        if (depth > 0 && predicate(value)) {
          if (depth > 1) {
            // Recursively flatten arrays (susceptible to call stack limits).
            baseFlatten(value, depth - 1, predicate, isStrict, result);
          } else {
            arrayPush(result, value);
          }
        } else if (!isStrict) {
          result[result.length] = value;
        }
      }
      return result;
    }

    /**
     * The base implementation of `baseForOwn` which iterates over `object`
     * properties returned by `keysFunc` and invokes `iteratee` for each property.
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */
    var baseFor = createBaseFor();

    /**
     * This function is like `baseFor` except that it iterates over properties
     * in the opposite order.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */
    var baseForRight = createBaseFor(true);

    /**
     * The base implementation of `_.forOwn` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForOwn(object, iteratee) {
      return object && baseFor(object, iteratee, keys);
    }

    /**
     * The base implementation of `_.forOwnRight` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForOwnRight(object, iteratee) {
      return object && baseForRight(object, iteratee, keys);
    }

    /**
     * The base implementation of `_.functions` which creates an array of
     * `object` function property names filtered from `props`.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Array} props The property names to filter.
     * @returns {Array} Returns the function names.
     */
    function baseFunctions(object, props) {
      return arrayFilter(props, function(key) {
        return isFunction(object[key]);
      });
    }

    /**
     * The base implementation of `_.get` without support for default values.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @returns {*} Returns the resolved value.
     */
    function baseGet(object, path) {
      path = castPath(path, object);

      var index = 0,
          length = path.length;

      while (object != null && index < length) {
        object = object[toKey(path[index++])];
      }
      return (index && index == length) ? object : undefined;
    }

    /**
     * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
     * `keysFunc` and `symbolsFunc` to get the enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @param {Function} symbolsFunc The function to get the symbols of `object`.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
    }

    /**
     * The base implementation of `getTag` without fallbacks for buggy environments.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */
    function baseGetTag(value) {
      if (value == null) {
        return value === undefined ? undefinedTag : nullTag;
      }
      return (symToStringTag && symToStringTag in Object(value))
        ? getRawTag(value)
        : objectToString(value);
    }

    /**
     * The base implementation of `_.gt` which doesn't coerce arguments.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than `other`,
     *  else `false`.
     */
    function baseGt(value, other) {
      return value > other;
    }

    /**
     * The base implementation of `_.has` without support for deep paths.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {Array|string} key The key to check.
     * @returns {boolean} Returns `true` if `key` exists, else `false`.
     */
    function baseHas(object, key) {
      return object != null && hasOwnProperty.call(object, key);
    }

    /**
     * The base implementation of `_.hasIn` without support for deep paths.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {Array|string} key The key to check.
     * @returns {boolean} Returns `true` if `key` exists, else `false`.
     */
    function baseHasIn(object, key) {
      return object != null && key in Object(object);
    }

    /**
     * The base implementation of `_.inRange` which doesn't coerce arguments.
     *
     * @private
     * @param {number} number The number to check.
     * @param {number} start The start of the range.
     * @param {number} end The end of the range.
     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
     */
    function baseInRange(number, start, end) {
      return number >= nativeMin(start, end) && number < nativeMax(start, end);
    }

    /**
     * The base implementation of methods like `_.intersection`, without support
     * for iteratee shorthands, that accepts an array of arrays to inspect.
     *
     * @private
     * @param {Array} arrays The arrays to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of shared values.
     */
    function baseIntersection(arrays, iteratee, comparator) {
      var includes = comparator ? arrayIncludesWith : arrayIncludes,
          length = arrays[0].length,
          othLength = arrays.length,
          othIndex = othLength,
          caches = Array(othLength),
          maxLength = Infinity,
          result = [];

      while (othIndex--) {
        var array = arrays[othIndex];
        if (othIndex && iteratee) {
          array = arrayMap(array, baseUnary(iteratee));
        }
        maxLength = nativeMin(array.length, maxLength);
        caches[othIndex] = !comparator && (iteratee || (length >= 120 && array.length >= 120))
          ? new SetCache(othIndex && array)
          : undefined;
      }
      array = arrays[0];

      var index = -1,
          seen = caches[0];

      outer:
      while (++index < length && result.length < maxLength) {
        var value = array[index],
            computed = iteratee ? iteratee(value) : value;

        value = (comparator || value !== 0) ? value : 0;
        if (!(seen
              ? cacheHas(seen, computed)
              : includes(result, computed, comparator)
            )) {
          othIndex = othLength;
          while (--othIndex) {
            var cache = caches[othIndex];
            if (!(cache
                  ? cacheHas(cache, computed)
                  : includes(arrays[othIndex], computed, comparator))
                ) {
              continue outer;
            }
          }
          if (seen) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.invert` and `_.invertBy` which inverts
     * `object` with values transformed by `iteratee` and set by `setter`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} setter The function to set `accumulator` values.
     * @param {Function} iteratee The iteratee to transform values.
     * @param {Object} accumulator The initial inverted object.
     * @returns {Function} Returns `accumulator`.
     */
    function baseInverter(object, setter, iteratee, accumulator) {
      baseForOwn(object, function(value, key, object) {
        setter(accumulator, iteratee(value), key, object);
      });
      return accumulator;
    }

    /**
     * The base implementation of `_.invoke` without support for individual
     * method arguments.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the method to invoke.
     * @param {Array} args The arguments to invoke the method with.
     * @returns {*} Returns the result of the invoked method.
     */
    function baseInvoke(object, path, args) {
      path = castPath(path, object);
      object = parent(object, path);
      var func = object == null ? object : object[toKey(last(path))];
      return func == null ? undefined : apply(func, object, args);
    }

    /**
     * The base implementation of `_.isArguments`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     */
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }

    /**
     * The base implementation of `_.isArrayBuffer` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
     */
    function baseIsArrayBuffer(value) {
      return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
    }

    /**
     * The base implementation of `_.isDate` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
     */
    function baseIsDate(value) {
      return isObjectLike(value) && baseGetTag(value) == dateTag;
    }

    /**
     * The base implementation of `_.isEqual` which supports partial comparisons
     * and tracks traversed objects.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {boolean} bitmask The bitmask flags.
     *  1 - Unordered comparison
     *  2 - Partial comparison
     * @param {Function} [customizer] The function to customize comparisons.
     * @param {Object} [stack] Tracks traversed `value` and `other` objects.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     */
    function baseIsEqual(value, other, bitmask, customizer, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
    }

    /**
     * A specialized version of `baseIsEqual` for arrays and objects which performs
     * deep comparisons and tracks traversed objects enabling objects with circular
     * references to be compared.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} [stack] Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
      var objIsArr = isArray(object),
          othIsArr = isArray(other),
          objTag = objIsArr ? arrayTag : getTag(object),
          othTag = othIsArr ? arrayTag : getTag(other);

      objTag = objTag == argsTag ? objectTag : objTag;
      othTag = othTag == argsTag ? objectTag : othTag;

      var objIsObj = objTag == objectTag,
          othIsObj = othTag == objectTag,
          isSameTag = objTag == othTag;

      if (isSameTag && isBuffer(object)) {
        if (!isBuffer(other)) {
          return false;
        }
        objIsArr = true;
        objIsObj = false;
      }
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack);
        return (objIsArr || isTypedArray(object))
          ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
          : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
      }
      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
            othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object,
              othUnwrapped = othIsWrapped ? other.value() : other;

          stack || (stack = new Stack);
          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack);
      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
    }

    /**
     * The base implementation of `_.isMap` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
     */
    function baseIsMap(value) {
      return isObjectLike(value) && getTag(value) == mapTag;
    }

    /**
     * The base implementation of `_.isMatch` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Array} matchData The property names, values, and compare flags to match.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     */
    function baseIsMatch(object, source, matchData, customizer) {
      var index = matchData.length,
          length = index,
          noCustomizer = !customizer;

      if (object == null) {
        return !length;
      }
      object = Object(object);
      while (index--) {
        var data = matchData[index];
        if ((noCustomizer && data[2])
              ? data[1] !== object[data[0]]
              : !(data[0] in object)
            ) {
          return false;
        }
      }
      while (++index < length) {
        data = matchData[index];
        var key = data[0],
            objValue = object[key],
            srcValue = data[1];

        if (noCustomizer && data[2]) {
          if (objValue === undefined && !(key in object)) {
            return false;
          }
        } else {
          var stack = new Stack;
          if (customizer) {
            var result = customizer(objValue, srcValue, key, object, source, stack);
          }
          if (!(result === undefined
                ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)
                : result
              )) {
            return false;
          }
        }
      }
      return true;
    }

    /**
     * The base implementation of `_.isNative` without bad shim checks.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     */
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }

    /**
     * The base implementation of `_.isRegExp` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
     */
    function baseIsRegExp(value) {
      return isObjectLike(value) && baseGetTag(value) == regexpTag;
    }

    /**
     * The base implementation of `_.isSet` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
     */
    function baseIsSet(value) {
      return isObjectLike(value) && getTag(value) == setTag;
    }

    /**
     * The base implementation of `_.isTypedArray` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     */
    function baseIsTypedArray(value) {
      return isObjectLike(value) &&
        isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }

    /**
     * The base implementation of `_.iteratee`.
     *
     * @private
     * @param {*} [value=_.identity] The value to convert to an iteratee.
     * @returns {Function} Returns the iteratee.
     */
    function baseIteratee(value) {
      // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
      // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
      if (typeof value == 'function') {
        return value;
      }
      if (value == null) {
        return identity;
      }
      if (typeof value == 'object') {
        return isArray(value)
          ? baseMatchesProperty(value[0], value[1])
          : baseMatches(value);
      }
      return property(value);
    }

    /**
     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != 'constructor') {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function baseKeysIn(object) {
      if (!isObject(object)) {
        return nativeKeysIn(object);
      }
      var isProto = isPrototype(object),
          result = [];

      for (var key in object) {
        if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.lt` which doesn't coerce arguments.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than `other`,
     *  else `false`.
     */
    function baseLt(value, other) {
      return value < other;
    }

    /**
     * The base implementation of `_.map` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */
    function baseMap(collection, iteratee) {
      var index = -1,
          result = isArrayLike(collection) ? Array(collection.length) : [];

      baseEach(collection, function(value, key, collection) {
        result[++index] = iteratee(value, key, collection);
      });
      return result;
    }

    /**
     * The base implementation of `_.matches` which doesn't clone `source`.
     *
     * @private
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new spec function.
     */
    function baseMatches(source) {
      var matchData = getMatchData(source);
      if (matchData.length == 1 && matchData[0][2]) {
        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
      }
      return function(object) {
        return object === source || baseIsMatch(object, source, matchData);
      };
    }

    /**
     * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
     *
     * @private
     * @param {string} path The path of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     */
    function baseMatchesProperty(path, srcValue) {
      if (isKey(path) && isStrictComparable(srcValue)) {
        return matchesStrictComparable(toKey(path), srcValue);
      }
      return function(object) {
        var objValue = get(object, path);
        return (objValue === undefined && objValue === srcValue)
          ? hasIn(object, path)
          : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
      };
    }

    /**
     * The base implementation of `_.merge` without support for multiple sources.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {number} srcIndex The index of `source`.
     * @param {Function} [customizer] The function to customize merged values.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     */
    function baseMerge(object, source, srcIndex, customizer, stack) {
      if (object === source) {
        return;
      }
      baseFor(source, function(srcValue, key) {
        stack || (stack = new Stack);
        if (isObject(srcValue)) {
          baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
        }
        else {
          var newValue = customizer
            ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)
            : undefined;

          if (newValue === undefined) {
            newValue = srcValue;
          }
          assignMergeValue(object, key, newValue);
        }
      }, keysIn);
    }

    /**
     * A specialized version of `baseMerge` for arrays and objects which performs
     * deep merges and tracks traversed objects enabling objects with circular
     * references to be merged.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {string} key The key of the value to merge.
     * @param {number} srcIndex The index of `source`.
     * @param {Function} mergeFunc The function to merge values.
     * @param {Function} [customizer] The function to customize assigned values.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     */
    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
      var objValue = safeGet(object, key),
          srcValue = safeGet(source, key),
          stacked = stack.get(srcValue);

      if (stacked) {
        assignMergeValue(object, key, stacked);
        return;
      }
      var newValue = customizer
        ? customizer(objValue, srcValue, (key + ''), object, source, stack)
        : undefined;

      var isCommon = newValue === undefined;

      if (isCommon) {
        var isArr = isArray(srcValue),
            isBuff = !isArr && isBuffer(srcValue),
            isTyped = !isArr && !isBuff && isTypedArray(srcValue);

        newValue = srcValue;
        if (isArr || isBuff || isTyped) {
          if (isArray(objValue)) {
            newValue = objValue;
          }
          else if (isArrayLikeObject(objValue)) {
            newValue = copyArray(objValue);
          }
          else if (isBuff) {
            isCommon = false;
            newValue = cloneBuffer(srcValue, true);
          }
          else if (isTyped) {
            isCommon = false;
            newValue = cloneTypedArray(srcValue, true);
          }
          else {
            newValue = [];
          }
        }
        else if (isPlainObject(srcValue) || isArguments(srcValue)) {
          newValue = objValue;
          if (isArguments(objValue)) {
            newValue = toPlainObject(objValue);
          }
          else if (!isObject(objValue) || isFunction(objValue)) {
            newValue = initCloneObject(srcValue);
          }
        }
        else {
          isCommon = false;
        }
      }
      if (isCommon) {
        // Recursively merge objects and arrays (susceptible to call stack limits).
        stack.set(srcValue, newValue);
        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
        stack['delete'](srcValue);
      }
      assignMergeValue(object, key, newValue);
    }

    /**
     * The base implementation of `_.nth` which doesn't coerce arguments.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {number} n The index of the element to return.
     * @returns {*} Returns the nth element of `array`.
     */
    function baseNth(array, n) {
      var length = array.length;
      if (!length) {
        return;
      }
      n += n < 0 ? length : 0;
      return isIndex(n, length) ? array[n] : undefined;
    }

    /**
     * The base implementation of `_.orderBy` without param guards.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
     * @param {string[]} orders The sort orders of `iteratees`.
     * @returns {Array} Returns the new sorted array.
     */
    function baseOrderBy(collection, iteratees, orders) {
      if (iteratees.length) {
        iteratees = arrayMap(iteratees, function(iteratee) {
          if (isArray(iteratee)) {
            return function(value) {
              return baseGet(value, iteratee.length === 1 ? iteratee[0] : iteratee);
            }
          }
          return iteratee;
        });
      } else {
        iteratees = [identity];
      }

      var index = -1;
      iteratees = arrayMap(iteratees, baseUnary(getIteratee()));

      var result = baseMap(collection, function(value, key, collection) {
        var criteria = arrayMap(iteratees, function(iteratee) {
          return iteratee(value);
        });
        return { 'criteria': criteria, 'index': ++index, 'value': value };
      });

      return baseSortBy(result, function(object, other) {
        return compareMultiple(object, other, orders);
      });
    }

    /**
     * The base implementation of `_.pick` without support for individual
     * property identifiers.
     *
     * @private
     * @param {Object} object The source object.
     * @param {string[]} paths The property paths to pick.
     * @returns {Object} Returns the new object.
     */
    function basePick(object, paths) {
      return basePickBy(object, paths, function(value, path) {
        return hasIn(object, path);
      });
    }

    /**
     * The base implementation of  `_.pickBy` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The source object.
     * @param {string[]} paths The property paths to pick.
     * @param {Function} predicate The function invoked per property.
     * @returns {Object} Returns the new object.
     */
    function basePickBy(object, paths, predicate) {
      var index = -1,
          length = paths.length,
          result = {};

      while (++index < length) {
        var path = paths[index],
            value = baseGet(object, path);

        if (predicate(value, path)) {
          baseSet(result, castPath(path, object), value);
        }
      }
      return result;
    }

    /**
     * A specialized version of `baseProperty` which supports deep paths.
     *
     * @private
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new accessor function.
     */
    function basePropertyDeep(path) {
      return function(object) {
        return baseGet(object, path);
      };
    }

    /**
     * The base implementation of `_.pullAllBy` without support for iteratee
     * shorthands.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns `array`.
     */
    function basePullAll(array, values, iteratee, comparator) {
      var indexOf = comparator ? baseIndexOfWith : baseIndexOf,
          index = -1,
          length = values.length,
          seen = array;

      if (array === values) {
        values = copyArray(values);
      }
      if (iteratee) {
        seen = arrayMap(array, baseUnary(iteratee));
      }
      while (++index < length) {
        var fromIndex = 0,
            value = values[index],
            computed = iteratee ? iteratee(value) : value;

        while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {
          if (seen !== array) {
            splice.call(seen, fromIndex, 1);
          }
          splice.call(array, fromIndex, 1);
        }
      }
      return array;
    }

    /**
     * The base implementation of `_.pullAt` without support for individual
     * indexes or capturing the removed elements.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {number[]} indexes The indexes of elements to remove.
     * @returns {Array} Returns `array`.
     */
    function basePullAt(array, indexes) {
      var length = array ? indexes.length : 0,
          lastIndex = length - 1;

      while (length--) {
        var index = indexes[length];
        if (length == lastIndex || index !== previous) {
          var previous = index;
          if (isIndex(index)) {
            splice.call(array, index, 1);
          } else {
            baseUnset(array, index);
          }
        }
      }
      return array;
    }

    /**
     * The base implementation of `_.random` without support for returning
     * floating-point numbers.
     *
     * @private
     * @param {number} lower The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the random number.
     */
    function baseRandom(lower, upper) {
      return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
    }

    /**
     * The base implementation of `_.range` and `_.rangeRight` which doesn't
     * coerce arguments.
     *
     * @private
     * @param {number} start The start of the range.
     * @param {number} end The end of the range.
     * @param {number} step The value to increment or decrement by.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Array} Returns the range of numbers.
     */
    function baseRange(start, end, step, fromRight) {
      var index = -1,
          length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
          result = Array(length);

      while (length--) {
        result[fromRight ? length : ++index] = start;
        start += step;
      }
      return result;
    }

    /**
     * The base implementation of `_.repeat` which doesn't coerce arguments.
     *
     * @private
     * @param {string} string The string to repeat.
     * @param {number} n The number of times to repeat the string.
     * @returns {string} Returns the repeated string.
     */
    function baseRepeat(string, n) {
      var result = '';
      if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
        return result;
      }
      // Leverage the exponentiation by squaring algorithm for a faster repeat.
      // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
      do {
        if (n % 2) {
          result += string;
        }
        n = nativeFloor(n / 2);
        if (n) {
          string += string;
        }
      } while (n);

      return result;
    }

    /**
     * The base implementation of `_.rest` which doesn't validate or coerce arguments.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @returns {Function} Returns the new function.
     */
    function baseRest(func, start) {
      return setToString(overRest(func, start, identity), func + '');
    }

    /**
     * The base implementation of `_.sample`.
     *
     * @private
     * @param {Array|Object} collection The collection to sample.
     * @returns {*} Returns the random element.
     */
    function baseSample(collection) {
      return arraySample(values(collection));
    }

    /**
     * The base implementation of `_.sampleSize` without param guards.
     *
     * @private
     * @param {Array|Object} collection The collection to sample.
     * @param {number} n The number of elements to sample.
     * @returns {Array} Returns the random elements.
     */
    function baseSampleSize(collection, n) {
      var array = values(collection);
      return shuffleSelf(array, baseClamp(n, 0, array.length));
    }

    /**
     * The base implementation of `_.set`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @param {Function} [customizer] The function to customize path creation.
     * @returns {Object} Returns `object`.
     */
    function baseSet(object, path, value, customizer) {
      if (!isObject(object)) {
        return object;
      }
      path = castPath(path, object);

      var index = -1,
          length = path.length,
          lastIndex = length - 1,
          nested = object;

      while (nested != null && ++index < length) {
        var key = toKey(path[index]),
            newValue = value;

        if (key === '__proto__' || key === 'constructor' || key === 'prototype') {
          return object;
        }

        if (index != lastIndex) {
          var objValue = nested[key];
          newValue = customizer ? customizer(objValue, key, nested) : undefined;
          if (newValue === undefined) {
            newValue = isObject(objValue)
              ? objValue
              : (isIndex(path[index + 1]) ? [] : {});
          }
        }
        assignValue(nested, key, newValue);
        nested = nested[key];
      }
      return object;
    }

    /**
     * The base implementation of `setData` without support for hot loop shorting.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */
    var baseSetData = !metaMap ? identity : function(func, data) {
      metaMap.set(func, data);
      return func;
    };

    /**
     * The base implementation of `setToString` without support for hot loop shorting.
     *
     * @private
     * @param {Function} func The function to modify.
     * @param {Function} string The `toString` result.
     * @returns {Function} Returns `func`.
     */
    var baseSetToString = !defineProperty ? identity : function(func, string) {
      return defineProperty(func, 'toString', {
        'configurable': true,
        'enumerable': false,
        'value': constant(string),
        'writable': true
      });
    };

    /**
     * The base implementation of `_.shuffle`.
     *
     * @private
     * @param {Array|Object} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     */
    function baseShuffle(collection) {
      return shuffleSelf(values(collection));
    }

    /**
     * The base implementation of `_.slice` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */
    function baseSlice(array, start, end) {
      var index = -1,
          length = array.length;

      if (start < 0) {
        start = -start > length ? 0 : (length + start);
      }
      end = end > length ? length : end;
      if (end < 0) {
        end += length;
      }
      length = start > end ? 0 : ((end - start) >>> 0);
      start >>>= 0;

      var result = Array(length);
      while (++index < length) {
        result[index] = array[index + start];
      }
      return result;
    }

    /**
     * The base implementation of `_.some` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     */
    function baseSome(collection, predicate) {
      var result;

      baseEach(collection, function(value, index, collection) {
        result = predicate(value, index, collection);
        return !result;
      });
      return !!result;
    }

    /**
     * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which
     * performs a binary search of `array` to determine the index at which `value`
     * should be inserted into `array` in order to maintain its sort order.
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */
    function baseSortedIndex(array, value, retHighest) {
      var low = 0,
          high = array == null ? low : array.length;

      if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
        while (low < high) {
          var mid = (low + high) >>> 1,
              computed = array[mid];

          if (computed !== null && !isSymbol(computed) &&
              (retHighest ? (computed <= value) : (computed < value))) {
            low = mid + 1;
          } else {
            high = mid;
          }
        }
        return high;
      }
      return baseSortedIndexBy(array, value, identity, retHighest);
    }

    /**
     * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`
     * which invokes `iteratee` for `value` and each element of `array` to compute
     * their sort ranking. The iteratee is invoked with one argument; (value).
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} iteratee The iteratee invoked per element.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */
    function baseSortedIndexBy(array, value, iteratee, retHighest) {
      var low = 0,
          high = array == null ? 0 : array.length;
      if (high === 0) {
        return 0;
      }

      value = iteratee(value);
      var valIsNaN = value !== value,
          valIsNull = value === null,
          valIsSymbol = isSymbol(value),
          valIsUndefined = value === undefined;

      while (low < high) {
        var mid = nativeFloor((low + high) / 2),
            computed = iteratee(array[mid]),
            othIsDefined = computed !== undefined,
            othIsNull = computed === null,
            othIsReflexive = computed === computed,
            othIsSymbol = isSymbol(computed);

        if (valIsNaN) {
          var setLow = retHighest || othIsReflexive;
        } else if (valIsUndefined) {
          setLow = othIsReflexive && (retHighest || othIsDefined);
        } else if (valIsNull) {
          setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
        } else if (valIsSymbol) {
          setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
        } else if (othIsNull || othIsSymbol) {
          setLow = false;
        } else {
          setLow = retHighest ? (computed <= value) : (computed < value);
        }
        if (setLow) {
          low = mid + 1;
        } else {
          high = mid;
        }
      }
      return nativeMin(high, MAX_ARRAY_INDEX);
    }

    /**
     * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without
     * support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     */
    function baseSortedUniq(array, iteratee) {
      var index = -1,
          length = array.length,
          resIndex = 0,
          result = [];

      while (++index < length) {
        var value = array[index],
            computed = iteratee ? iteratee(value) : value;

        if (!index || !eq(computed, seen)) {
          var seen = computed;
          result[resIndex++] = value === 0 ? 0 : value;
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.toNumber` which doesn't ensure correct
     * conversions of binary, hexadecimal, or octal string values.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     */
    function baseToNumber(value) {
      if (typeof value == 'number') {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      return +value;
    }

    /**
     * The base implementation of `_.toString` which doesn't convert nullish
     * values to empty strings.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {string} Returns the string.
     */
    function baseToString(value) {
      // Exit early for strings to avoid a performance hit in some environments.
      if (typeof value == 'string') {
        return value;
      }
      if (isArray(value)) {
        // Recursively convert values (susceptible to call stack limits).
        return arrayMap(value, baseToString) + '';
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : '';
      }
      var result = (value + '');
      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
    }

    /**
     * The base implementation of `_.uniqBy` without support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     */
    function baseUniq(array, iteratee, comparator) {
      var index = -1,
          includes = arrayIncludes,
          length = array.length,
          isCommon = true,
          result = [],
          seen = result;

      if (comparator) {
        isCommon = false;
        includes = arrayIncludesWith;
      }
      else if (length >= LARGE_ARRAY_SIZE) {
        var set = iteratee ? null : createSet(array);
        if (set) {
          return setToArray(set);
        }
        isCommon = false;
        includes = cacheHas;
        seen = new SetCache;
      }
      else {
        seen = iteratee ? [] : result;
      }
      outer:
      while (++index < length) {
        var value = array[index],
            computed = iteratee ? iteratee(value) : value;

        value = (comparator || value !== 0) ? value : 0;
        if (isCommon && computed === computed) {
          var seenIndex = seen.length;
          while (seenIndex--) {
            if (seen[seenIndex] === computed) {
              continue outer;
            }
          }
          if (iteratee) {
            seen.push(computed);
          }
          result.push(value);
        }
        else if (!includes(seen, computed, comparator)) {
          if (seen !== result) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.unset`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The property path to unset.
     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
     */
    function baseUnset(object, path) {
      path = castPath(path, object);
      object = parent(object, path);
      return object == null || delete object[toKey(last(path))];
    }

    /**
     * The base implementation of `_.update`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to update.
     * @param {Function} updater The function to produce the updated value.
     * @param {Function} [customizer] The function to customize path creation.
     * @returns {Object} Returns `object`.
     */
    function baseUpdate(object, path, updater, customizer) {
      return baseSet(object, path, updater(baseGet(object, path)), customizer);
    }

    /**
     * The base implementation of methods like `_.dropWhile` and `_.takeWhile`
     * without support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {Function} predicate The function invoked per iteration.
     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Array} Returns the slice of `array`.
     */
    function baseWhile(array, predicate, isDrop, fromRight) {
      var length = array.length,
          index = fromRight ? length : -1;

      while ((fromRight ? index-- : ++index < length) &&
        predicate(array[index], index, array)) {}

      return isDrop
        ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))
        : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));
    }

    /**
     * The base implementation of `wrapperValue` which returns the result of
     * performing a sequence of actions on the unwrapped `value`, where each
     * successive action is supplied the return value of the previous.
     *
     * @private
     * @param {*} value The unwrapped value.
     * @param {Array} actions Actions to perform to resolve the unwrapped value.
     * @returns {*} Returns the resolved value.
     */
    function baseWrapperValue(value, actions) {
      var result = value;
      if (result instanceof LazyWrapper) {
        result = result.value();
      }
      return arrayReduce(actions, function(result, action) {
        return action.func.apply(action.thisArg, arrayPush([result], action.args));
      }, result);
    }

    /**
     * The base implementation of methods like `_.xor`, without support for
     * iteratee shorthands, that accepts an array of arrays to inspect.
     *
     * @private
     * @param {Array} arrays The arrays to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of values.
     */
    function baseXor(arrays, iteratee, comparator) {
      var length = arrays.length;
      if (length < 2) {
        return length ? baseUniq(arrays[0]) : [];
      }
      var index = -1,
          result = Array(length);

      while (++index < length) {
        var array = arrays[index],
            othIndex = -1;

        while (++othIndex < length) {
          if (othIndex != index) {
            result[index] = baseDifference(result[index] || array, arrays[othIndex], iteratee, comparator);
          }
        }
      }
      return baseUniq(baseFlatten(result, 1), iteratee, comparator);
    }

    /**
     * This base implementation of `_.zipObject` which assigns values using `assignFunc`.
     *
     * @private
     * @param {Array} props The property identifiers.
     * @param {Array} values The property values.
     * @param {Function} assignFunc The function to assign values.
     * @returns {Object} Returns the new object.
     */
    function baseZipObject(props, values, assignFunc) {
      var index = -1,
          length = props.length,
          valsLength = values.length,
          result = {};

      while (++index < length) {
        var value = index < valsLength ? values[index] : undefined;
        assignFunc(result, props[index], value);
      }
      return result;
    }

    /**
     * Casts `value` to an empty array if it's not an array like object.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {Array|Object} Returns the cast array-like object.
     */
    function castArrayLikeObject(value) {
      return isArrayLikeObject(value) ? value : [];
    }

    /**
     * Casts `value` to `identity` if it's not a function.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {Function} Returns cast function.
     */
    function castFunction(value) {
      return typeof value == 'function' ? value : identity;
    }

    /**
     * Casts `value` to a path array if it's not one.
     *
     * @private
     * @param {*} value The value to inspect.
     * @param {Object} [object] The object to query keys on.
     * @returns {Array} Returns the cast property path array.
     */
    function castPath(value, object) {
      if (isArray(value)) {
        return value;
      }
      return isKey(value, object) ? [value] : stringToPath(toString(value));
    }

    /**
     * A `baseRest` alias which can be replaced with `identity` by module
     * replacement plugins.
     *
     * @private
     * @type {Function}
     * @param {Function} func The function to apply a rest parameter to.
     * @returns {Function} Returns the new function.
     */
    var castRest = baseRest;

    /**
     * Casts `array` to a slice if it's needed.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {number} start The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the cast slice.
     */
    function castSlice(array, start, end) {
      var length = array.length;
      end = end === undefined ? length : end;
      return (!start && end >= length) ? array : baseSlice(array, start, end);
    }

    /**
     * A simple wrapper around the global [`clearTimeout`](https://mdn.io/clearTimeout).
     *
     * @private
     * @param {number|Object} id The timer id or timeout object of the timer to clear.
     */
    var clearTimeout = ctxClearTimeout || function(id) {
      return root.clearTimeout(id);
    };

    /**
     * Creates a clone of  `buffer`.
     *
     * @private
     * @param {Buffer} buffer The buffer to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Buffer} Returns the cloned buffer.
     */
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var length = buffer.length,
          result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

      buffer.copy(result);
      return result;
    }

    /**
     * Creates a clone of `arrayBuffer`.
     *
     * @private
     * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
     * @returns {ArrayBuffer} Returns the cloned array buffer.
     */
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array(result).set(new Uint8Array(arrayBuffer));
      return result;
    }

    /**
     * Creates a clone of `dataView`.
     *
     * @private
     * @param {Object} dataView The data view to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned data view.
     */
    function cloneDataView(dataView, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
    }

    /**
     * Creates a clone of `regexp`.
     *
     * @private
     * @param {Object} regexp The regexp to clone.
     * @returns {Object} Returns the cloned regexp.
     */
    function cloneRegExp(regexp) {
      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
      result.lastIndex = regexp.lastIndex;
      return result;
    }

    /**
     * Creates a clone of the `symbol` object.
     *
     * @private
     * @param {Object} symbol The symbol object to clone.
     * @returns {Object} Returns the cloned symbol object.
     */
    function cloneSymbol(symbol) {
      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
    }

    /**
     * Creates a clone of `typedArray`.
     *
     * @private
     * @param {Object} typedArray The typed array to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned typed array.
     */
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }

    /**
     * Compares values to sort them in ascending order.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {number} Returns the sort order indicator for `value`.
     */
    function compareAscending(value, other) {
      if (value !== other) {
        var valIsDefined = value !== undefined,
            valIsNull = value === null,
            valIsReflexive = value === value,
            valIsSymbol = isSymbol(value);

        var othIsDefined = other !== undefined,
            othIsNull = other === null,
            othIsReflexive = other === other,
            othIsSymbol = isSymbol(other);

        if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||
            (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||
            (valIsNull && othIsDefined && othIsReflexive) ||
            (!valIsDefined && othIsReflexive) ||
            !valIsReflexive) {
          return 1;
        }
        if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||
            (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||
            (othIsNull && valIsDefined && valIsReflexive) ||
            (!othIsDefined && valIsReflexive) ||
            !othIsReflexive) {
          return -1;
        }
      }
      return 0;
    }

    /**
     * Used by `_.orderBy` to compare multiple properties of a value to another
     * and stable sort them.
     *
     * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
     * specify an order of "desc" for descending or "asc" for ascending sort order
     * of corresponding values.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {boolean[]|string[]} orders The order to sort by for each property.
     * @returns {number} Returns the sort order indicator for `object`.
     */
    function compareMultiple(object, other, orders) {
      var index = -1,
          objCriteria = object.criteria,
          othCriteria = other.criteria,
          length = objCriteria.length,
          ordersLength = orders.length;

      while (++index < length) {
        var result = compareAscending(objCriteria[index], othCriteria[index]);
        if (result) {
          if (index >= ordersLength) {
            return result;
          }
          var order = orders[index];
          return result * (order == 'desc' ? -1 : 1);
        }
      }
      // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
      // that causes it, under certain circumstances, to provide the same value for
      // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
      // for more details.
      //
      // This also ensures a stable sort in V8 and other engines.
      // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
      return object.index - other.index;
    }

    /**
     * Creates an array that is the composition of partially applied arguments,
     * placeholders, and provided arguments into a single array of arguments.
     *
     * @private
     * @param {Array} args The provided arguments.
     * @param {Array} partials The arguments to prepend to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @params {boolean} [isCurried] Specify composing for a curried function.
     * @returns {Array} Returns the new array of composed arguments.
     */
    function composeArgs(args, partials, holders, isCurried) {
      var argsIndex = -1,
          argsLength = args.length,
          holdersLength = holders.length,
          leftIndex = -1,
          leftLength = partials.length,
          rangeLength = nativeMax(argsLength - holdersLength, 0),
          result = Array(leftLength + rangeLength),
          isUncurried = !isCurried;

      while (++leftIndex < leftLength) {
        result[leftIndex] = partials[leftIndex];
      }
      while (++argsIndex < holdersLength) {
        if (isUncurried || argsIndex < argsLength) {
          result[holders[argsIndex]] = args[argsIndex];
        }
      }
      while (rangeLength--) {
        result[leftIndex++] = args[argsIndex++];
      }
      return result;
    }

    /**
     * This function is like `composeArgs` except that the arguments composition
     * is tailored for `_.partialRight`.
     *
     * @private
     * @param {Array} args The provided arguments.
     * @param {Array} partials The arguments to append to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @params {boolean} [isCurried] Specify composing for a curried function.
     * @returns {Array} Returns the new array of composed arguments.
     */
    function composeArgsRight(args, partials, holders, isCurried) {
      var argsIndex = -1,
          argsLength = args.length,
          holdersIndex = -1,
          holdersLength = holders.length,
          rightIndex = -1,
          rightLength = partials.length,
          rangeLength = nativeMax(argsLength - holdersLength, 0),
          result = Array(rangeLength + rightLength),
          isUncurried = !isCurried;

      while (++argsIndex < rangeLength) {
        result[argsIndex] = args[argsIndex];
      }
      var offset = argsIndex;
      while (++rightIndex < rightLength) {
        result[offset + rightIndex] = partials[rightIndex];
      }
      while (++holdersIndex < holdersLength) {
        if (isUncurried || argsIndex < argsLength) {
          result[offset + holders[holdersIndex]] = args[argsIndex++];
        }
      }
      return result;
    }

    /**
     * Copies the values of `source` to `array`.
     *
     * @private
     * @param {Array} source The array to copy values from.
     * @param {Array} [array=[]] The array to copy values to.
     * @returns {Array} Returns `array`.
     */
    function copyArray(source, array) {
      var index = -1,
          length = source.length;

      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }

    /**
     * Copies properties of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy properties from.
     * @param {Array} props The property identifiers to copy.
     * @param {Object} [object={}] The object to copy properties to.
     * @param {Function} [customizer] The function to customize copied values.
     * @returns {Object} Returns `object`.
     */
    function copyObject(source, props, object, customizer) {
      var isNew = !object;
      object || (object = {});

      var index = -1,
          length = props.length;

      while (++index < length) {
        var key = props[index];

        var newValue = customizer
          ? customizer(object[key], source[key], key, object, source)
          : undefined;

        if (newValue === undefined) {
          newValue = source[key];
        }
        if (isNew) {
          baseAssignValue(object, key, newValue);
        } else {
          assignValue(object, key, newValue);
        }
      }
      return object;
    }

    /**
     * Copies own symbols of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy symbols from.
     * @param {Object} [object={}] The object to copy symbols to.
     * @returns {Object} Returns `object`.
     */
    function copySymbols(source, object) {
      return copyObject(source, getSymbols(source), object);
    }

    /**
     * Copies own and inherited symbols of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy symbols from.
     * @param {Object} [object={}] The object to copy symbols to.
     * @returns {Object} Returns `object`.
     */
    function copySymbolsIn(source, object) {
      return copyObject(source, getSymbolsIn(source), object);
    }

    /**
     * Creates a function like `_.groupBy`.
     *
     * @private
     * @param {Function} setter The function to set accumulator values.
     * @param {Function} [initializer] The accumulator object initializer.
     * @returns {Function} Returns the new aggregator function.
     */
    function createAggregator(setter, initializer) {
      return function(collection, iteratee) {
        var func = isArray(collection) ? arrayAggregator : baseAggregator,
            accumulator = initializer ? initializer() : {};

        return func(collection, setter, getIteratee(iteratee, 2), accumulator);
      };
    }

    /**
     * Creates a function like `_.assign`.
     *
     * @private
     * @param {Function} assigner The function to assign values.
     * @returns {Function} Returns the new assigner function.
     */
    function createAssigner(assigner) {
      return baseRest(function(object, sources) {
        var index = -1,
            length = sources.length,
            customizer = length > 1 ? sources[length - 1] : undefined,
            guard = length > 2 ? sources[2] : undefined;

        customizer = (assigner.length > 3 && typeof customizer == 'function')
          ? (length--, customizer)
          : undefined;

        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length < 3 ? undefined : customizer;
          length = 1;
        }
        object = Object(object);
        while (++index < length) {
          var source = sources[index];
          if (source) {
            assigner(object, source, index, customizer);
          }
        }
        return object;
      });
    }

    /**
     * Creates a `baseEach` or `baseEachRight` function.
     *
     * @private
     * @param {Function} eachFunc The function to iterate over a collection.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */
    function createBaseEach(eachFunc, fromRight) {
      return function(collection, iteratee) {
        if (collection == null) {
          return collection;
        }
        if (!isArrayLike(collection)) {
          return eachFunc(collection, iteratee);
        }
        var length = collection.length,
            index = fromRight ? length : -1,
            iterable = Object(collection);

        while ((fromRight ? index-- : ++index < length)) {
          if (iteratee(iterable[index], index, iterable) === false) {
            break;
          }
        }
        return collection;
      };
    }

    /**
     * Creates a base function for methods like `_.forIn` and `_.forOwn`.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index = -1,
            iterable = Object(object),
            props = keysFunc(object),
            length = props.length;

        while (length--) {
          var key = props[fromRight ? length : ++index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }

    /**
     * Creates a function that wraps `func` to invoke it with the optional `this`
     * binding of `thisArg`.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createBind(func, bitmask, thisArg) {
      var isBind = bitmask & WRAP_BIND_FLAG,
          Ctor = createCtor(func);

      function wrapper() {
        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
        return fn.apply(isBind ? thisArg : this, arguments);
      }
      return wrapper;
    }

    /**
     * Creates a function like `_.lowerFirst`.
     *
     * @private
     * @param {string} methodName The name of the `String` case method to use.
     * @returns {Function} Returns the new case function.
     */
    function createCaseFirst(methodName) {
      return function(string) {
        string = toString(string);

        var strSymbols = hasUnicode(string)
          ? stringToArray(string)
          : undefined;

        var chr = strSymbols
          ? strSymbols[0]
          : string.charAt(0);

        var trailing = strSymbols
          ? castSlice(strSymbols, 1).join('')
          : string.slice(1);

        return chr[methodName]() + trailing;
      };
    }

    /**
     * Creates a function like `_.camelCase`.
     *
     * @private
     * @param {Function} callback The function to combine each word.
     * @returns {Function} Returns the new compounder function.
     */
    function createCompounder(callback) {
      return function(string) {
        return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');
      };
    }

    /**
     * Creates a function that produces an instance of `Ctor` regardless of
     * whether it was invoked as part of a `new` expression or by `call` or `apply`.
     *
     * @private
     * @param {Function} Ctor The constructor to wrap.
     * @returns {Function} Returns the new wrapped function.
     */
    function createCtor(Ctor) {
      return function() {
        // Use a `switch` statement to work with class constructors. See
        // http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
        // for more details.
        var args = arguments;
        switch (args.length) {
          case 0: return new Ctor;
          case 1: return new Ctor(args[0]);
          case 2: return new Ctor(args[0], args[1]);
          case 3: return new Ctor(args[0], args[1], args[2]);
          case 4: return new Ctor(args[0], args[1], args[2], args[3]);
          case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);
          case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
          case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
        }
        var thisBinding = baseCreate(Ctor.prototype),
            result = Ctor.apply(thisBinding, args);

        // Mimic the constructor's `return` behavior.
        // See https://es5.github.io/#x13.2.2 for more details.
        return isObject(result) ? result : thisBinding;
      };
    }

    /**
     * Creates a function that wraps `func` to enable currying.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {number} arity The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createCurry(func, bitmask, arity) {
      var Ctor = createCtor(func);

      function wrapper() {
        var length = arguments.length,
            args = Array(length),
            index = length,
            placeholder = getHolder(wrapper);

        while (index--) {
          args[index] = arguments[index];
        }
        var holders = (length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder)
          ? []
          : replaceHolders(args, placeholder);

        length -= holders.length;
        if (length < arity) {
          return createRecurry(
            func, bitmask, createHybrid, wrapper.placeholder, undefined,
            args, holders, undefined, undefined, arity - length);
        }
        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
        return apply(fn, this, args);
      }
      return wrapper;
    }

    /**
     * Creates a `_.find` or `_.findLast` function.
     *
     * @private
     * @param {Function} findIndexFunc The function to find the collection index.
     * @returns {Function} Returns the new find function.
     */
    function createFind(findIndexFunc) {
      return function(collection, predicate, fromIndex) {
        var iterable = Object(collection);
        if (!isArrayLike(collection)) {
          var iteratee = getIteratee(predicate, 3);
          collection = keys(collection);
          predicate = function(key) { return iteratee(iterable[key], key, iterable); };
        }
        var index = findIndexFunc(collection, predicate, fromIndex);
        return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;
      };
    }

    /**
     * Creates a `_.flow` or `_.flowRight` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new flow function.
     */
    function createFlow(fromRight) {
      return flatRest(function(funcs) {
        var length = funcs.length,
            index = length,
            prereq = LodashWrapper.prototype.thru;

        if (fromRight) {
          funcs.reverse();
        }
        while (index--) {
          var func = funcs[index];
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          if (prereq && !wrapper && getFuncName(func) == 'wrapper') {
            var wrapper = new LodashWrapper([], true);
          }
        }
        index = wrapper ? index : length;
        while (++index < length) {
          func = funcs[index];

          var funcName = getFuncName(func),
              data = funcName == 'wrapper' ? getData(func) : undefined;

          if (data && isLaziable(data[0]) &&
                data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) &&
                !data[4].length && data[9] == 1
              ) {
            wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
          } else {
            wrapper = (func.length == 1 && isLaziable(func))
              ? wrapper[funcName]()
              : wrapper.thru(func);
          }
        }
        return function() {
          var args = arguments,
              value = args[0];

          if (wrapper && args.length == 1 && isArray(value)) {
            return wrapper.plant(value).value();
          }
          var index = 0,
              result = length ? funcs[index].apply(this, args) : value;

          while (++index < length) {
            result = funcs[index].call(this, result);
          }
          return result;
        };
      });
    }

    /**
     * Creates a function that wraps `func` to invoke it with optional `this`
     * binding of `thisArg`, partial application, and currying.
     *
     * @private
     * @param {Function|string} func The function or method name to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to prepend to those provided to
     *  the new function.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [partialsRight] The arguments to append to those provided
     *  to the new function.
     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
      var isAry = bitmask & WRAP_ARY_FLAG,
          isBind = bitmask & WRAP_BIND_FLAG,
          isBindKey = bitmask & WRAP_BIND_KEY_FLAG,
          isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG),
          isFlip = bitmask & WRAP_FLIP_FLAG,
          Ctor = isBindKey ? undefined : createCtor(func);

      function wrapper() {
        var length = arguments.length,
            args = Array(length),
            index = length;

        while (index--) {
          args[index] = arguments[index];
        }
        if (isCurried) {
          var placeholder = getHolder(wrapper),
              holdersCount = countHolders(args, placeholder);
        }
        if (partials) {
          args = composeArgs(args, partials, holders, isCurried);
        }
        if (partialsRight) {
          args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
        }
        length -= holdersCount;
        if (isCurried && length < arity) {
          var newHolders = replaceHolders(args, placeholder);
          return createRecurry(
            func, bitmask, createHybrid, wrapper.placeholder, thisArg,
            args, newHolders, argPos, ary, arity - length
          );
        }
        var thisBinding = isBind ? thisArg : this,
            fn = isBindKey ? thisBinding[func] : func;

        length = args.length;
        if (argPos) {
          args = reorder(args, argPos);
        } else if (isFlip && length > 1) {
          args.reverse();
        }
        if (isAry && ary < length) {
          args.length = ary;
        }
        if (this && this !== root && this instanceof wrapper) {
          fn = Ctor || createCtor(fn);
        }
        return fn.apply(thisBinding, args);
      }
      return wrapper;
    }

    /**
     * Creates a function like `_.invertBy`.
     *
     * @private
     * @param {Function} setter The function to set accumulator values.
     * @param {Function} toIteratee The function to resolve iteratees.
     * @returns {Function} Returns the new inverter function.
     */
    function createInverter(setter, toIteratee) {
      return function(object, iteratee) {
        return baseInverter(object, setter, toIteratee(iteratee), {});
      };
    }

    /**
     * Creates a function that performs a mathematical operation on two values.
     *
     * @private
     * @param {Function} operator The function to perform the operation.
     * @param {number} [defaultValue] The value used for `undefined` arguments.
     * @returns {Function} Returns the new mathematical operation function.
     */
    function createMathOperation(operator, defaultValue) {
      return function(value, other) {
        var result;
        if (value === undefined && other === undefined) {
          return defaultValue;
        }
        if (value !== undefined) {
          result = value;
        }
        if (other !== undefined) {
          if (result === undefined) {
            return other;
          }
          if (typeof value == 'string' || typeof other == 'string') {
            value = baseToString(value);
            other = baseToString(other);
          } else {
            value = baseToNumber(value);
            other = baseToNumber(other);
          }
          result = operator(value, other);
        }
        return result;
      };
    }

    /**
     * Creates a function like `_.over`.
     *
     * @private
     * @param {Function} arrayFunc The function to iterate over iteratees.
     * @returns {Function} Returns the new over function.
     */
    function createOver(arrayFunc) {
      return flatRest(function(iteratees) {
        iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
        return baseRest(function(args) {
          var thisArg = this;
          return arrayFunc(iteratees, function(iteratee) {
            return apply(iteratee, thisArg, args);
          });
        });
      });
    }

    /**
     * Creates the padding for `string` based on `length`. The `chars` string
     * is truncated if the number of characters exceeds `length`.
     *
     * @private
     * @param {number} length The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padding for `string`.
     */
    function createPadding(length, chars) {
      chars = chars === undefined ? ' ' : baseToString(chars);

      var charsLength = chars.length;
      if (charsLength < 2) {
        return charsLength ? baseRepeat(chars, length) : chars;
      }
      var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
      return hasUnicode(chars)
        ? castSlice(stringToArray(result), 0, length).join('')
        : result.slice(0, length);
    }

    /**
     * Creates a function that wraps `func` to invoke it with the `this` binding
     * of `thisArg` and `partials` prepended to the arguments it receives.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {Array} partials The arguments to prepend to those provided to
     *  the new function.
     * @returns {Function} Returns the new wrapped function.
     */
    function createPartial(func, bitmask, thisArg, partials) {
      var isBind = bitmask & WRAP_BIND_FLAG,
          Ctor = createCtor(func);

      function wrapper() {
        var argsIndex = -1,
            argsLength = arguments.length,
            leftIndex = -1,
            leftLength = partials.length,
            args = Array(leftLength + argsLength),
            fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;

        while (++leftIndex < leftLength) {
          args[leftIndex] = partials[leftIndex];
        }
        while (argsLength--) {
          args[leftIndex++] = arguments[++argsIndex];
        }
        return apply(fn, isBind ? thisArg : this, args);
      }
      return wrapper;
    }

    /**
     * Creates a `_.range` or `_.rangeRight` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new range function.
     */
    function createRange(fromRight) {
      return function(start, end, step) {
        if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {
          end = step = undefined;
        }
        // Ensure the sign of `-0` is preserved.
        start = toFinite(start);
        if (end === undefined) {
          end = start;
          start = 0;
        } else {
          end = toFinite(end);
        }
        step = step === undefined ? (start < end ? 1 : -1) : toFinite(step);
        return baseRange(start, end, step, fromRight);
      };
    }

    /**
     * Creates a function that performs a relational operation on two values.
     *
     * @private
     * @param {Function} operator The function to perform the operation.
     * @returns {Function} Returns the new relational operation function.
     */
    function createRelationalOperation(operator) {
      return function(value, other) {
        if (!(typeof value == 'string' && typeof other == 'string')) {
          value = toNumber(value);
          other = toNumber(other);
        }
        return operator(value, other);
      };
    }

    /**
     * Creates a function that wraps `func` to continue currying.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {Function} wrapFunc The function to create the `func` wrapper.
     * @param {*} placeholder The placeholder value.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to prepend to those provided to
     *  the new function.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
      var isCurry = bitmask & WRAP_CURRY_FLAG,
          newHolders = isCurry ? holders : undefined,
          newHoldersRight = isCurry ? undefined : holders,
          newPartials = isCurry ? partials : undefined,
          newPartialsRight = isCurry ? undefined : partials;

      bitmask |= (isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG);
      bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);

      if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
        bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
      }
      var newData = [
        func, bitmask, thisArg, newPartials, newHolders, newPartialsRight,
        newHoldersRight, argPos, ary, arity
      ];

      var result = wrapFunc.apply(undefined, newData);
      if (isLaziable(func)) {
        setData(result, newData);
      }
      result.placeholder = placeholder;
      return setWrapToString(result, func, bitmask);
    }

    /**
     * Creates a function like `_.round`.
     *
     * @private
     * @param {string} methodName The name of the `Math` method to use when rounding.
     * @returns {Function} Returns the new round function.
     */
    function createRound(methodName) {
      var func = Math[methodName];
      return function(number, precision) {
        number = toNumber(number);
        precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
        if (precision && nativeIsFinite(number)) {
          // Shift with exponential notation to avoid floating-point issues.
          // See [MDN](https://mdn.io/round#Examples) for more details.
          var pair = (toString(number) + 'e').split('e'),
              value = func(pair[0] + 'e' + (+pair[1] + precision));

          pair = (toString(value) + 'e').split('e');
          return +(pair[0] + 'e' + (+pair[1] - precision));
        }
        return func(number);
      };
    }

    /**
     * Creates a set object of `values`.
     *
     * @private
     * @param {Array} values The values to add to the set.
     * @returns {Object} Returns the new set.
     */
    var createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {
      return new Set(values);
    };

    /**
     * Creates a `_.toPairs` or `_.toPairsIn` function.
     *
     * @private
     * @param {Function} keysFunc The function to get the keys of a given object.
     * @returns {Function} Returns the new pairs function.
     */
    function createToPairs(keysFunc) {
      return function(object) {
        var tag = getTag(object);
        if (tag == mapTag) {
          return mapToArray(object);
        }
        if (tag == setTag) {
          return setToPairs(object);
        }
        return baseToPairs(object, keysFunc(object));
      };
    }

    /**
     * Creates a function that either curries or invokes `func` with optional
     * `this` binding and partially applied arguments.
     *
     * @private
     * @param {Function|string} func The function or method name to wrap.
     * @param {number} bitmask The bitmask flags.
     *    1 - `_.bind`
     *    2 - `_.bindKey`
     *    4 - `_.curry` or `_.curryRight` of a bound function
     *    8 - `_.curry`
     *   16 - `_.curryRight`
     *   32 - `_.partial`
     *   64 - `_.partialRight`
     *  128 - `_.rearg`
     *  256 - `_.ary`
     *  512 - `_.flip`
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to be partially applied.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
      var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
      if (!isBindKey && typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var length = partials ? partials.length : 0;
      if (!length) {
        bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
        partials = holders = undefined;
      }
      ary = ary === undefined ? ary : nativeMax(toInteger(ary), 0);
      arity = arity === undefined ? arity : toInteger(arity);
      length -= holders ? holders.length : 0;

      if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
        var partialsRight = partials,
            holdersRight = holders;

        partials = holders = undefined;
      }
      var data = isBindKey ? undefined : getData(func);

      var newData = [
        func, bitmask, thisArg, partials, holders, partialsRight, holdersRight,
        argPos, ary, arity
      ];

      if (data) {
        mergeData(newData, data);
      }
      func = newData[0];
      bitmask = newData[1];
      thisArg = newData[2];
      partials = newData[3];
      holders = newData[4];
      arity = newData[9] = newData[9] === undefined
        ? (isBindKey ? 0 : func.length)
        : nativeMax(newData[9] - length, 0);

      if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
        bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
      }
      if (!bitmask || bitmask == WRAP_BIND_FLAG) {
        var result = createBind(func, bitmask, thisArg);
      } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
        result = createCurry(func, bitmask, arity);
      } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
        result = createPartial(func, bitmask, thisArg, partials);
      } else {
        result = createHybrid.apply(undefined, newData);
      }
      var setter = data ? baseSetData : setData;
      return setWrapToString(setter(result, newData), func, bitmask);
    }

    /**
     * Used by `_.defaults` to customize its `_.assignIn` use to assign properties
     * of source objects to the destination object for all destination properties
     * that resolve to `undefined`.
     *
     * @private
     * @param {*} objValue The destination value.
     * @param {*} srcValue The source value.
     * @param {string} key The key of the property to assign.
     * @param {Object} object The parent object of `objValue`.
     * @returns {*} Returns the value to assign.
     */
    function customDefaultsAssignIn(objValue, srcValue, key, object) {
      if (objValue === undefined ||
          (eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key))) {
        return srcValue;
      }
      return objValue;
    }

    /**
     * Used by `_.defaultsDeep` to customize its `_.merge` use to merge source
     * objects into destination objects that are passed thru.
     *
     * @private
     * @param {*} objValue The destination value.
     * @param {*} srcValue The source value.
     * @param {string} key The key of the property to merge.
     * @param {Object} object The parent object of `objValue`.
     * @param {Object} source The parent object of `srcValue`.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     * @returns {*} Returns the value to assign.
     */
    function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
      if (isObject(objValue) && isObject(srcValue)) {
        // Recursively merge objects and arrays (susceptible to call stack limits).
        stack.set(srcValue, objValue);
        baseMerge(objValue, srcValue, undefined, customDefaultsMerge, stack);
        stack['delete'](srcValue);
      }
      return objValue;
    }

    /**
     * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain
     * objects.
     *
     * @private
     * @param {*} value The value to inspect.
     * @param {string} key The key of the property to inspect.
     * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.
     */
    function customOmitClone(value) {
      return isPlainObject(value) ? undefined : value;
    }

    /**
     * A specialized version of `baseIsEqualDeep` for arrays with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Array} array The array to compare.
     * @param {Array} other The other array to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `array` and `other` objects.
     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
     */
    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
          arrLength = array.length,
          othLength = other.length;

      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      // Check that cyclic values are equal.
      var arrStacked = stack.get(array);
      var othStacked = stack.get(other);
      if (arrStacked && othStacked) {
        return arrStacked == other && othStacked == array;
      }
      var index = -1,
          result = true,
          seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;

      stack.set(array, other);
      stack.set(other, array);

      // Ignore non-index properties.
      while (++index < arrLength) {
        var arrValue = array[index],
            othValue = other[index];

        if (customizer) {
          var compared = isPartial
            ? customizer(othValue, arrValue, index, other, array, stack)
            : customizer(arrValue, othValue, index, array, other, stack);
        }
        if (compared !== undefined) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        // Recursively compare arrays (susceptible to call stack limits).
        if (seen) {
          if (!arraySome(other, function(othValue, othIndex) {
                if (!cacheHas(seen, othIndex) &&
                    (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                  return seen.push(othIndex);
                }
              })) {
            result = false;
            break;
          }
        } else if (!(
              arrValue === othValue ||
                equalFunc(arrValue, othValue, bitmask, customizer, stack)
            )) {
          result = false;
          break;
        }
      }
      stack['delete'](array);
      stack['delete'](other);
      return result;
    }

    /**
     * A specialized version of `baseIsEqualDeep` for comparing objects of
     * the same `toStringTag`.
     *
     * **Note:** This function only supports comparing values with tags of
     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {string} tag The `toStringTag` of the objects to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
      switch (tag) {
        case dataViewTag:
          if ((object.byteLength != other.byteLength) ||
              (object.byteOffset != other.byteOffset)) {
            return false;
          }
          object = object.buffer;
          other = other.buffer;

        case arrayBufferTag:
          if ((object.byteLength != other.byteLength) ||
              !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
            return false;
          }
          return true;

        case boolTag:
        case dateTag:
        case numberTag:
          // Coerce booleans to `1` or `0` and dates to milliseconds.
          // Invalid dates are coerced to `NaN`.
          return eq(+object, +other);

        case errorTag:
          return object.name == other.name && object.message == other.message;

        case regexpTag:
        case stringTag:
          // Coerce regexes to strings and treat strings, primitives and objects,
          // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
          // for more details.
          return object == (other + '');

        case mapTag:
          var convert = mapToArray;

        case setTag:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
          convert || (convert = setToArray);

          if (object.size != other.size && !isPartial) {
            return false;
          }
          // Assume cyclic values are equal.
          var stacked = stack.get(object);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= COMPARE_UNORDERED_FLAG;

          // Recursively compare objects (susceptible to call stack limits).
          stack.set(object, other);
          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
          stack['delete'](object);
          return result;

        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
          }
      }
      return false;
    }

    /**
     * A specialized version of `baseIsEqualDeep` for objects with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
          objProps = getAllKeys(object),
          objLength = objProps.length,
          othProps = getAllKeys(other),
          othLength = othProps.length;

      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
          return false;
        }
      }
      // Check that cyclic values are equal.
      var objStacked = stack.get(object);
      var othStacked = stack.get(other);
      if (objStacked && othStacked) {
        return objStacked == other && othStacked == object;
      }
      var result = true;
      stack.set(object, other);
      stack.set(other, object);

      var skipCtor = isPartial;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key],
            othValue = other[key];

        if (customizer) {
          var compared = isPartial
            ? customizer(othValue, objValue, key, other, object, stack)
            : customizer(objValue, othValue, key, object, other, stack);
        }
        // Recursively compare objects (susceptible to call stack limits).
        if (!(compared === undefined
              ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
              : compared
            )) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == 'constructor');
      }
      if (result && !skipCtor) {
        var objCtor = object.constructor,
            othCtor = other.constructor;

        // Non `Object` object instances with different constructors are not equal.
        if (objCtor != othCtor &&
            ('constructor' in object && 'constructor' in other) &&
            !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
              typeof othCtor == 'function' && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack['delete'](object);
      stack['delete'](other);
      return result;
    }

    /**
     * A specialized version of `baseRest` which flattens the rest array.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @returns {Function} Returns the new function.
     */
    function flatRest(func) {
      return setToString(overRest(func, undefined, flatten), func + '');
    }

    /**
     * Creates an array of own enumerable property names and symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function getAllKeys(object) {
      return baseGetAllKeys(object, keys, getSymbols);
    }

    /**
     * Creates an array of own and inherited enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function getAllKeysIn(object) {
      return baseGetAllKeys(object, keysIn, getSymbolsIn);
    }

    /**
     * Gets metadata for `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {*} Returns the metadata for `func`.
     */
    var getData = !metaMap ? noop : function(func) {
      return metaMap.get(func);
    };

    /**
     * Gets the name of `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {string} Returns the function name.
     */
    function getFuncName(func) {
      var result = (func.name + ''),
          array = realNames[result],
          length = hasOwnProperty.call(realNames, result) ? array.length : 0;

      while (length--) {
        var data = array[length],
            otherFunc = data.func;
        if (otherFunc == null || otherFunc == func) {
          return data.name;
        }
      }
      return result;
    }

    /**
     * Gets the argument placeholder value for `func`.
     *
     * @private
     * @param {Function} func The function to inspect.
     * @returns {*} Returns the placeholder value.
     */
    function getHolder(func) {
      var object = hasOwnProperty.call(lodash, 'placeholder') ? lodash : func;
      return object.placeholder;
    }

    /**
     * Gets the appropriate "iteratee" function. If `_.iteratee` is customized,
     * this function returns the custom method, otherwise it returns `baseIteratee`.
     * If arguments are provided, the chosen function is invoked with them and
     * its result is returned.
     *
     * @private
     * @param {*} [value] The value to convert to an iteratee.
     * @param {number} [arity] The arity of the created iteratee.
     * @returns {Function} Returns the chosen function or its result.
     */
    function getIteratee() {
      var result = lodash.iteratee || iteratee;
      result = result === iteratee ? baseIteratee : result;
      return arguments.length ? result(arguments[0], arguments[1]) : result;
    }

    /**
     * Gets the data for `map`.
     *
     * @private
     * @param {Object} map The map to query.
     * @param {string} key The reference key.
     * @returns {*} Returns the map data.
     */
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key)
        ? data[typeof key == 'string' ? 'string' : 'hash']
        : data.map;
    }

    /**
     * Gets the property names, values, and compare flags of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the match data of `object`.
     */
    function getMatchData(object) {
      var result = keys(object),
          length = result.length;

      while (length--) {
        var key = result[length],
            value = object[key];

        result[length] = [key, value, isStrictComparable(value)];
      }
      return result;
    }

    /**
     * Gets the native function at `key` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the method to get.
     * @returns {*} Returns the function if it's native, else `undefined`.
     */
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : undefined;
    }

    /**
     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the raw `toStringTag`.
     */
    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag),
          tag = value[symToStringTag];

      try {
        value[symToStringTag] = undefined;
        var unmasked = true;
      } catch (e) {}

      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }

    /**
     * Creates an array of the own enumerable symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */
    var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
      if (object == null) {
        return [];
      }
      object = Object(object);
      return arrayFilter(nativeGetSymbols(object), function(symbol) {
        return propertyIsEnumerable.call(object, symbol);
      });
    };

    /**
     * Creates an array of the own and inherited enumerable symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */
    var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
      var result = [];
      while (object) {
        arrayPush(result, getSymbols(object));
        object = getPrototype(object);
      }
      return result;
    };

    /**
     * Gets the `toStringTag` of `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */
    var getTag = baseGetTag;

    // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
    if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
        (Map && getTag(new Map) != mapTag) ||
        (Promise && getTag(Promise.resolve()) != promiseTag) ||
        (Set && getTag(new Set) != setTag) ||
        (WeakMap && getTag(new WeakMap) != weakMapTag)) {
      getTag = function(value) {
        var result = baseGetTag(value),
            Ctor = result == objectTag ? value.constructor : undefined,
            ctorString = Ctor ? toSource(Ctor) : '';

        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString: return dataViewTag;
            case mapCtorString: return mapTag;
            case promiseCtorString: return promiseTag;
            case setCtorString: return setTag;
            case weakMapCtorString: return weakMapTag;
          }
        }
        return result;
      };
    }

    /**
     * Gets the view, applying any `transforms` to the `start` and `end` positions.
     *
     * @private
     * @param {number} start The start of the view.
     * @param {number} end The end of the view.
     * @param {Array} transforms The transformations to apply to the view.
     * @returns {Object} Returns an object containing the `start` and `end`
     *  positions of the view.
     */
    function getView(start, end, transforms) {
      var index = -1,
          length = transforms.length;

      while (++index < length) {
        var data = transforms[index],
            size = data.size;

        switch (data.type) {
          case 'drop':      start += size; break;
          case 'dropRight': end -= size; break;
          case 'take':      end = nativeMin(end, start + size); break;
          case 'takeRight': start = nativeMax(start, end - size); break;
        }
      }
      return { 'start': start, 'end': end };
    }

    /**
     * Extracts wrapper details from the `source` body comment.
     *
     * @private
     * @param {string} source The source to inspect.
     * @returns {Array} Returns the wrapper details.
     */
    function getWrapDetails(source) {
      var match = source.match(reWrapDetails);
      return match ? match[1].split(reSplitDetails) : [];
    }

    /**
     * Checks if `path` exists on `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @param {Function} hasFunc The function to check properties.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     */
    function hasPath(object, path, hasFunc) {
      path = castPath(path, object);

      var index = -1,
          length = path.length,
          result = false;

      while (++index < length) {
        var key = toKey(path[index]);
        if (!(result = object != null && hasFunc(object, key))) {
          break;
        }
        object = object[key];
      }
      if (result || ++index != length) {
        return result;
      }
      length = object == null ? 0 : object.length;
      return !!length && isLength(length) && isIndex(key, length) &&
        (isArray(object) || isArguments(object));
    }

    /**
     * Initializes an array clone.
     *
     * @private
     * @param {Array} array The array to clone.
     * @returns {Array} Returns the initialized clone.
     */
    function initCloneArray(array) {
      var length = array.length,
          result = new array.constructor(length);

      // Add properties assigned by `RegExp#exec`.
      if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
        result.index = array.index;
        result.input = array.input;
      }
      return result;
    }

    /**
     * Initializes an object clone.
     *
     * @private
     * @param {Object} object The object to clone.
     * @returns {Object} Returns the initialized clone.
     */
    function initCloneObject(object) {
      return (typeof object.constructor == 'function' && !isPrototype(object))
        ? baseCreate(getPrototype(object))
        : {};
    }

    /**
     * Initializes an object clone based on its `toStringTag`.
     *
     * **Note:** This function only supports cloning values with tags of
     * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
     *
     * @private
     * @param {Object} object The object to clone.
     * @param {string} tag The `toStringTag` of the object to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the initialized clone.
     */
    function initCloneByTag(object, tag, isDeep) {
      var Ctor = object.constructor;
      switch (tag) {
        case arrayBufferTag:
          return cloneArrayBuffer(object);

        case boolTag:
        case dateTag:
          return new Ctor(+object);

        case dataViewTag:
          return cloneDataView(object, isDeep);

        case float32Tag: case float64Tag:
        case int8Tag: case int16Tag: case int32Tag:
        case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
          return cloneTypedArray(object, isDeep);

        case mapTag:
          return new Ctor;

        case numberTag:
        case stringTag:
          return new Ctor(object);

        case regexpTag:
          return cloneRegExp(object);

        case setTag:
          return new Ctor;

        case symbolTag:
          return cloneSymbol(object);
      }
    }

    /**
     * Inserts wrapper `details` in a comment at the top of the `source` body.
     *
     * @private
     * @param {string} source The source to modify.
     * @returns {Array} details The details to insert.
     * @returns {string} Returns the modified source.
     */
    function insertWrapDetails(source, details) {
      var length = details.length;
      if (!length) {
        return source;
      }
      var lastIndex = length - 1;
      details[lastIndex] = (length > 1 ? '& ' : '') + details[lastIndex];
      details = details.join(length > 2 ? ', ' : ' ');
      return source.replace(reWrapComment, '{\n/* [wrapped with ' + details + '] */\n');
    }

    /**
     * Checks if `value` is a flattenable `arguments` object or array.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
     */
    function isFlattenable(value) {
      return isArray(value) || isArguments(value) ||
        !!(spreadableSymbol && value && value[spreadableSymbol]);
    }

    /**
     * Checks if `value` is a valid array-like index.
     *
     * @private
     * @param {*} value The value to check.
     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
     */
    function isIndex(value, length) {
      var type = typeof value;
      length = length == null ? MAX_SAFE_INTEGER : length;

      return !!length &&
        (type == 'number' ||
          (type != 'symbol' && reIsUint.test(value))) &&
            (value > -1 && value % 1 == 0 && value < length);
    }

    /**
     * Checks if the given arguments are from an iteratee call.
     *
     * @private
     * @param {*} value The potential iteratee value argument.
     * @param {*} index The potential iteratee index or key argument.
     * @param {*} object The potential iteratee object argument.
     * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
     *  else `false`.
     */
    function isIterateeCall(value, index, object) {
      if (!isObject(object)) {
        return false;
      }
      var type = typeof index;
      if (type == 'number'
            ? (isArrayLike(object) && isIndex(index, object.length))
            : (type == 'string' && index in object)
          ) {
        return eq(object[index], value);
      }
      return false;
    }

    /**
     * Checks if `value` is a property name and not a property path.
     *
     * @private
     * @param {*} value The value to check.
     * @param {Object} [object] The object to query keys on.
     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
     */
    function isKey(value, object) {
      if (isArray(value)) {
        return false;
      }
      var type = typeof value;
      if (type == 'number' || type == 'symbol' || type == 'boolean' ||
          value == null || isSymbol(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
        (object != null && value in Object(object));
    }

    /**
     * Checks if `value` is suitable for use as unique object key.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
     */
    function isKeyable(value) {
      var type = typeof value;
      return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
        ? (value !== '__proto__')
        : (value === null);
    }

    /**
     * Checks if `func` has a lazy counterpart.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` has a lazy counterpart,
     *  else `false`.
     */
    function isLaziable(func) {
      var funcName = getFuncName(func),
          other = lodash[funcName];

      if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {
        return false;
      }
      if (func === other) {
        return true;
      }
      var data = getData(other);
      return !!data && func === data[0];
    }

    /**
     * Checks if `func` has its source masked.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` is masked, else `false`.
     */
    function isMasked(func) {
      return !!maskSrcKey && (maskSrcKey in func);
    }

    /**
     * Checks if `func` is capable of being masked.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `func` is maskable, else `false`.
     */
    var isMaskable = coreJsData ? isFunction : stubFalse;

    /**
     * Checks if `value` is likely a prototype object.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
     */
    function isPrototype(value) {
      var Ctor = value && value.constructor,
          proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

      return value === proto;
    }

    /**
     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` if suitable for strict
     *  equality comparisons, else `false`.
     */
    function isStrictComparable(value) {
      return value === value && !isObject(value);
    }

    /**
     * A specialized version of `matchesProperty` for source values suitable
     * for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {string} key The key of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     */
    function matchesStrictComparable(key, srcValue) {
      return function(object) {
        if (object == null) {
          return false;
        }
        return object[key] === srcValue &&
          (srcValue !== undefined || (key in Object(object)));
      };
    }

    /**
     * A specialized version of `_.memoize` which clears the memoized function's
     * cache when it exceeds `MAX_MEMOIZE_SIZE`.
     *
     * @private
     * @param {Function} func The function to have its output memoized.
     * @returns {Function} Returns the new memoized function.
     */
    function memoizeCapped(func) {
      var result = memoize(func, function(key) {
        if (cache.size === MAX_MEMOIZE_SIZE) {
          cache.clear();
        }
        return key;
      });

      var cache = result.cache;
      return result;
    }

    /**
     * Merges the function metadata of `source` into `data`.
     *
     * Merging metadata reduces the number of wrappers used to invoke a function.
     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
     * may be applied regardless of execution order. Methods like `_.ary` and
     * `_.rearg` modify function arguments, making the order in which they are
     * executed important, preventing the merging of metadata. However, we make
     * an exception for a safe combined case where curried functions have `_.ary`
     * and or `_.rearg` applied.
     *
     * @private
     * @param {Array} data The destination metadata.
     * @param {Array} source The source metadata.
     * @returns {Array} Returns `data`.
     */
    function mergeData(data, source) {
      var bitmask = data[1],
          srcBitmask = source[1],
          newBitmask = bitmask | srcBitmask,
          isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);

      var isCombo =
        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_CURRY_FLAG)) ||
        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_REARG_FLAG) && (data[7].length <= source[8])) ||
        ((srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG)) && (source[7].length <= source[8]) && (bitmask == WRAP_CURRY_FLAG));

      // Exit early if metadata can't be merged.
      if (!(isCommon || isCombo)) {
        return data;
      }
      // Use source `thisArg` if available.
      if (srcBitmask & WRAP_BIND_FLAG) {
        data[2] = source[2];
        // Set when currying a bound function.
        newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
      }
      // Compose partial arguments.
      var value = source[3];
      if (value) {
        var partials = data[3];
        data[3] = partials ? composeArgs(partials, value, source[4]) : value;
        data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
      }
      // Compose partial right arguments.
      value = source[5];
      if (value) {
        partials = data[5];
        data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
        data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
      }
      // Use source `argPos` if available.
      value = source[7];
      if (value) {
        data[7] = value;
      }
      // Use source `ary` if it's smaller.
      if (srcBitmask & WRAP_ARY_FLAG) {
        data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
      }
      // Use source `arity` if one is not provided.
      if (data[9] == null) {
        data[9] = source[9];
      }
      // Use source `func` and merge bitmasks.
      data[0] = source[0];
      data[1] = newBitmask;

      return data;
    }

    /**
     * This function is like
     * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * except that it includes inherited enumerable properties.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function nativeKeysIn(object) {
      var result = [];
      if (object != null) {
        for (var key in Object(object)) {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * Converts `value` to a string using `Object.prototype.toString`.
     *
     * @private
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     */
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }

    /**
     * A specialized version of `baseRest` which transforms the rest array.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @param {Function} transform The rest array transform.
     * @returns {Function} Returns the new function.
     */
    function overRest(func, start, transform) {
      start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
      return function() {
        var args = arguments,
            index = -1,
            length = nativeMax(args.length - start, 0),
            array = Array(length);

        while (++index < length) {
          array[index] = args[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = transform(array);
        return apply(func, this, otherArgs);
      };
    }

    /**
     * Gets the parent value at `path` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array} path The path to get the parent value of.
     * @returns {*} Returns the parent value.
     */
    function parent(object, path) {
      return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
    }

    /**
     * Reorder `array` according to the specified indexes where the element at
     * the first index is assigned as the first element, the element at
     * the second index is assigned as the second element, and so on.
     *
     * @private
     * @param {Array} array The array to reorder.
     * @param {Array} indexes The arranged array indexes.
     * @returns {Array} Returns `array`.
     */
    function reorder(array, indexes) {
      var arrLength = array.length,
          length = nativeMin(indexes.length, arrLength),
          oldArray = copyArray(array);

      while (length--) {
        var index = indexes[length];
        array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
      }
      return array;
    }

    /**
     * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the property to get.
     * @returns {*} Returns the property value.
     */
    function safeGet(object, key) {
      if (key === 'constructor' && typeof object[key] === 'function') {
        return;
      }

      if (key == '__proto__') {
        return;
      }

      return object[key];
    }

    /**
     * Sets metadata for `func`.
     *
     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
     * period of time, it will trip its breaker and transition to an identity
     * function to avoid garbage collection pauses in V8. See
     * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)
     * for more details.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */
    var setData = shortOut(baseSetData);

    /**
     * A simple wrapper around the global [`setTimeout`](https://mdn.io/setTimeout).
     *
     * @private
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @returns {number|Object} Returns the timer id or timeout object.
     */
    var setTimeout = ctxSetTimeout || function(func, wait) {
      return root.setTimeout(func, wait);
    };

    /**
     * Sets the `toString` method of `func` to return `string`.
     *
     * @private
     * @param {Function} func The function to modify.
     * @param {Function} string The `toString` result.
     * @returns {Function} Returns `func`.
     */
    var setToString = shortOut(baseSetToString);

    /**
     * Sets the `toString` method of `wrapper` to mimic the source of `reference`
     * with wrapper details in a comment at the top of the source body.
     *
     * @private
     * @param {Function} wrapper The function to modify.
     * @param {Function} reference The reference function.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @returns {Function} Returns `wrapper`.
     */
    function setWrapToString(wrapper, reference, bitmask) {
      var source = (reference + '');
      return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
    }

    /**
     * Creates a function that'll short out and invoke `identity` instead
     * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
     * milliseconds.
     *
     * @private
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new shortable function.
     */
    function shortOut(func) {
      var count = 0,
          lastCalled = 0;

      return function() {
        var stamp = nativeNow(),
            remaining = HOT_SPAN - (stamp - lastCalled);

        lastCalled = stamp;
        if (remaining > 0) {
          if (++count >= HOT_COUNT) {
            return arguments[0];
          }
        } else {
          count = 0;
        }
        return func.apply(undefined, arguments);
      };
    }

    /**
     * A specialized version of `_.shuffle` which mutates and sets the size of `array`.
     *
     * @private
     * @param {Array} array The array to shuffle.
     * @param {number} [size=array.length] The size of `array`.
     * @returns {Array} Returns `array`.
     */
    function shuffleSelf(array, size) {
      var index = -1,
          length = array.length,
          lastIndex = length - 1;

      size = size === undefined ? length : size;
      while (++index < size) {
        var rand = baseRandom(index, lastIndex),
            value = array[rand];

        array[rand] = array[index];
        array[index] = value;
      }
      array.length = size;
      return array;
    }

    /**
     * Converts `string` to a property path array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the property path array.
     */
    var stringToPath = memoizeCapped(function(string) {
      var result = [];
      if (string.charCodeAt(0) === 46 /* . */) {
        result.push('');
      }
      string.replace(rePropName, function(match, number, quote, subString) {
        result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
      });
      return result;
    });

    /**
     * Converts `value` to a string key if it's not a string or symbol.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {string|symbol} Returns the key.
     */
    function toKey(value) {
      if (typeof value == 'string' || isSymbol(value)) {
        return value;
      }
      var result = (value + '');
      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
    }

    /**
     * Converts `func` to its source code.
     *
     * @private
     * @param {Function} func The function to convert.
     * @returns {string} Returns the source code.
     */
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {}
        try {
          return (func + '');
        } catch (e) {}
      }
      return '';
    }

    /**
     * Updates wrapper `details` based on `bitmask` flags.
     *
     * @private
     * @returns {Array} details The details to modify.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @returns {Array} Returns `details`.
     */
    function updateWrapDetails(details, bitmask) {
      arrayEach(wrapFlags, function(pair) {
        var value = '_.' + pair[0];
        if ((bitmask & pair[1]) && !arrayIncludes(details, value)) {
          details.push(value);
        }
      });
      return details.sort();
    }

    /**
     * Creates a clone of `wrapper`.
     *
     * @private
     * @param {Object} wrapper The wrapper to clone.
     * @returns {Object} Returns the cloned wrapper.
     */
    function wrapperClone(wrapper) {
      if (wrapper instanceof LazyWrapper) {
        return wrapper.clone();
      }
      var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
      result.__actions__ = copyArray(wrapper.__actions__);
      result.__index__  = wrapper.__index__;
      result.__values__ = wrapper.__values__;
      return result;
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates an array of elements split into groups the length of `size`.
     * If `array` can't be split evenly, the final chunk will be the remaining
     * elements.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to process.
     * @param {number} [size=1] The length of each chunk
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the new array of chunks.
     * @example
     *
     * _.chunk(['a', 'b', 'c', 'd'], 2);
     * // => [['a', 'b'], ['c', 'd']]
     *
     * _.chunk(['a', 'b', 'c', 'd'], 3);
     * // => [['a', 'b', 'c'], ['d']]
     */
    function chunk(array, size, guard) {
      if ((guard ? isIterateeCall(array, size, guard) : size === undefined)) {
        size = 1;
      } else {
        size = nativeMax(toInteger(size), 0);
      }
      var length = array == null ? 0 : array.length;
      if (!length || size < 1) {
        return [];
      }
      var index = 0,
          resIndex = 0,
          result = Array(nativeCeil(length / size));

      while (index < length) {
        result[resIndex++] = baseSlice(array, index, (index += size));
      }
      return result;
    }

    /**
     * Creates an array with all falsey values removed. The values `false`, `null`,
     * `0`, `""`, `undefined`, and `NaN` are falsey.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to compact.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.compact([0, 1, false, 2, '', 3]);
     * // => [1, 2, 3]
     */
    function compact(array) {
      var index = -1,
          length = array == null ? 0 : array.length,
          resIndex = 0,
          result = [];

      while (++index < length) {
        var value = array[index];
        if (value) {
          result[resIndex++] = value;
        }
      }
      return result;
    }

    /**
     * Creates a new array concatenating `array` with any additional arrays
     * and/or values.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to concatenate.
     * @param {...*} [values] The values to concatenate.
     * @returns {Array} Returns the new concatenated array.
     * @example
     *
     * var array = [1];
     * var other = _.concat(array, 2, [3], [[4]]);
     *
     * console.log(other);
     * // => [1, 2, 3, [4]]
     *
     * console.log(array);
     * // => [1]
     */
    function concat() {
      var length = arguments.length;
      if (!length) {
        return [];
      }
      var args = Array(length - 1),
          array = arguments[0],
          index = length;

      while (index--) {
        args[index - 1] = arguments[index];
      }
      return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
    }

    /**
     * Creates an array of `array` values not included in the other given arrays
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. The order and references of result values are
     * determined by the first array.
     *
     * **Note:** Unlike `_.pullAll`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.without, _.xor
     * @example
     *
     * _.difference([2, 1], [2, 3]);
     * // => [1]
     */
    var difference = baseRest(function(array, values) {
      return isArrayLikeObject(array)
        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true))
        : [];
    });

    /**
     * This method is like `_.difference` except that it accepts `iteratee` which
     * is invoked for each element of `array` and `values` to generate the criterion
     * by which they're compared. The order and references of result values are
     * determined by the first array. The iteratee is invoked with one argument:
     * (value).
     *
     * **Note:** Unlike `_.pullAllBy`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');
     * // => [{ 'x': 2 }]
     */
    var differenceBy = baseRest(function(array, values) {
      var iteratee = last(values);
      if (isArrayLikeObject(iteratee)) {
        iteratee = undefined;
      }
      return isArrayLikeObject(array)
        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), getIteratee(iteratee, 2))
        : [];
    });

    /**
     * This method is like `_.difference` except that it accepts `comparator`
     * which is invoked to compare elements of `array` to `values`. The order and
     * references of result values are determined by the first array. The comparator
     * is invoked with two arguments: (arrVal, othVal).
     *
     * **Note:** Unlike `_.pullAllWith`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     *
     * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);
     * // => [{ 'x': 2, 'y': 1 }]
     */
    var differenceWith = baseRest(function(array, values) {
      var comparator = last(values);
      if (isArrayLikeObject(comparator)) {
        comparator = undefined;
      }
      return isArrayLikeObject(array)
        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), undefined, comparator)
        : [];
    });

    /**
     * Creates a slice of `array` with `n` elements dropped from the beginning.
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.drop([1, 2, 3]);
     * // => [2, 3]
     *
     * _.drop([1, 2, 3], 2);
     * // => [3]
     *
     * _.drop([1, 2, 3], 5);
     * // => []
     *
     * _.drop([1, 2, 3], 0);
     * // => [1, 2, 3]
     */
    function drop(array, n, guard) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      n = (guard || n === undefined) ? 1 : toInteger(n);
      return baseSlice(array, n < 0 ? 0 : n, length);
    }

    /**
     * Creates a slice of `array` with `n` elements dropped from the end.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.dropRight([1, 2, 3]);
     * // => [1, 2]
     *
     * _.dropRight([1, 2, 3], 2);
     * // => [1]
     *
     * _.dropRight([1, 2, 3], 5);
     * // => []
     *
     * _.dropRight([1, 2, 3], 0);
     * // => [1, 2, 3]
     */
    function dropRight(array, n, guard) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      n = (guard || n === undefined) ? 1 : toInteger(n);
      n = length - n;
      return baseSlice(array, 0, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` excluding elements dropped from the end.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.dropRightWhile(users, function(o) { return !o.active; });
     * // => objects for ['barney']
     *
     * // The `_.matches` iteratee shorthand.
     * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });
     * // => objects for ['barney', 'fred']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.dropRightWhile(users, ['active', false]);
     * // => objects for ['barney']
     *
     * // The `_.property` iteratee shorthand.
     * _.dropRightWhile(users, 'active');
     * // => objects for ['barney', 'fred', 'pebbles']
     */
    function dropRightWhile(array, predicate) {
      return (array && array.length)
        ? baseWhile(array, getIteratee(predicate, 3), true, true)
        : [];
    }

    /**
     * Creates a slice of `array` excluding elements dropped from the beginning.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.dropWhile(users, function(o) { return !o.active; });
     * // => objects for ['pebbles']
     *
     * // The `_.matches` iteratee shorthand.
     * _.dropWhile(users, { 'user': 'barney', 'active': false });
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.dropWhile(users, ['active', false]);
     * // => objects for ['pebbles']
     *
     * // The `_.property` iteratee shorthand.
     * _.dropWhile(users, 'active');
     * // => objects for ['barney', 'fred', 'pebbles']
     */
    function dropWhile(array, predicate) {
      return (array && array.length)
        ? baseWhile(array, getIteratee(predicate, 3), true)
        : [];
    }

    /**
     * Fills elements of `array` with `value` from `start` up to, but not
     * including, `end`.
     *
     * **Note:** This method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Array
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _.fill(array, 'a');
     * console.log(array);
     * // => ['a', 'a', 'a']
     *
     * _.fill(Array(3), 2);
     * // => [2, 2, 2]
     *
     * _.fill([4, 6, 8, 10], '*', 1, 3);
     * // => [4, '*', '*', 10]
     */
    function fill(array, value, start, end) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
        start = 0;
        end = length;
      }
      return baseFill(array, value, start, end);
    }

    /**
     * This method is like `_.find` except that it returns the index of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.findIndex(users, function(o) { return o.user == 'barney'; });
     * // => 0
     *
     * // The `_.matches` iteratee shorthand.
     * _.findIndex(users, { 'user': 'fred', 'active': false });
     * // => 1
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findIndex(users, ['active', false]);
     * // => 0
     *
     * // The `_.property` iteratee shorthand.
     * _.findIndex(users, 'active');
     * // => 2
     */
    function findIndex(array, predicate, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = fromIndex == null ? 0 : toInteger(fromIndex);
      if (index < 0) {
        index = nativeMax(length + index, 0);
      }
      return baseFindIndex(array, getIteratee(predicate, 3), index);
    }

    /**
     * This method is like `_.findIndex` except that it iterates over elements
     * of `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });
     * // => 2
     *
     * // The `_.matches` iteratee shorthand.
     * _.findLastIndex(users, { 'user': 'barney', 'active': true });
     * // => 0
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findLastIndex(users, ['active', false]);
     * // => 2
     *
     * // The `_.property` iteratee shorthand.
     * _.findLastIndex(users, 'active');
     * // => 0
     */
    function findLastIndex(array, predicate, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = length - 1;
      if (fromIndex !== undefined) {
        index = toInteger(fromIndex);
        index = fromIndex < 0
          ? nativeMax(length + index, 0)
          : nativeMin(index, length - 1);
      }
      return baseFindIndex(array, getIteratee(predicate, 3), index, true);
    }

    /**
     * Flattens `array` a single level deep.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flatten([1, [2, [3, [4]], 5]]);
     * // => [1, 2, [3, [4]], 5]
     */
    function flatten(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseFlatten(array, 1) : [];
    }

    /**
     * Recursively flattens `array`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flattenDeep([1, [2, [3, [4]], 5]]);
     * // => [1, 2, 3, 4, 5]
     */
    function flattenDeep(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseFlatten(array, INFINITY) : [];
    }

    /**
     * Recursively flatten `array` up to `depth` times.
     *
     * @static
     * @memberOf _
     * @since 4.4.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @param {number} [depth=1] The maximum recursion depth.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * var array = [1, [2, [3, [4]], 5]];
     *
     * _.flattenDepth(array, 1);
     * // => [1, 2, [3, [4]], 5]
     *
     * _.flattenDepth(array, 2);
     * // => [1, 2, 3, [4], 5]
     */
    function flattenDepth(array, depth) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      depth = depth === undefined ? 1 : toInteger(depth);
      return baseFlatten(array, depth);
    }

    /**
     * The inverse of `_.toPairs`; this method returns an object composed
     * from key-value `pairs`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} pairs The key-value pairs.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.fromPairs([['a', 1], ['b', 2]]);
     * // => { 'a': 1, 'b': 2 }
     */
    function fromPairs(pairs) {
      var index = -1,
          length = pairs == null ? 0 : pairs.length,
          result = {};

      while (++index < length) {
        var pair = pairs[index];
        result[pair[0]] = pair[1];
      }
      return result;
    }

    /**
     * Gets the first element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @alias first
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the first element of `array`.
     * @example
     *
     * _.head([1, 2, 3]);
     * // => 1
     *
     * _.head([]);
     * // => undefined
     */
    function head(array) {
      return (array && array.length) ? array[0] : undefined;
    }

    /**
     * Gets the index at which the first occurrence of `value` is found in `array`
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. If `fromIndex` is negative, it's used as the
     * offset from the end of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.indexOf([1, 2, 1, 2], 2);
     * // => 1
     *
     * // Search from the `fromIndex`.
     * _.indexOf([1, 2, 1, 2], 2, 2);
     * // => 3
     */
    function indexOf(array, value, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = fromIndex == null ? 0 : toInteger(fromIndex);
      if (index < 0) {
        index = nativeMax(length + index, 0);
      }
      return baseIndexOf(array, value, index);
    }

    /**
     * Gets all but the last element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.initial([1, 2, 3]);
     * // => [1, 2]
     */
    function initial(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseSlice(array, 0, -1) : [];
    }

    /**
     * Creates an array of unique values that are included in all given arrays
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. The order and references of result values are
     * determined by the first array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * _.intersection([2, 1], [2, 3]);
     * // => [2]
     */
    var intersection = baseRest(function(arrays) {
      var mapped = arrayMap(arrays, castArrayLikeObject);
      return (mapped.length && mapped[0] === arrays[0])
        ? baseIntersection(mapped)
        : [];
    });

    /**
     * This method is like `_.intersection` except that it accepts `iteratee`
     * which is invoked for each element of each `arrays` to generate the criterion
     * by which they're compared. The order and references of result values are
     * determined by the first array. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [2.1]
     *
     * // The `_.property` iteratee shorthand.
     * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }]
     */
    var intersectionBy = baseRest(function(arrays) {
      var iteratee = last(arrays),
          mapped = arrayMap(arrays, castArrayLikeObject);

      if (iteratee === last(mapped)) {
        iteratee = undefined;
      } else {
        mapped.pop();
      }
      return (mapped.length && mapped[0] === arrays[0])
        ? baseIntersection(mapped, getIteratee(iteratee, 2))
        : [];
    });

    /**
     * This method is like `_.intersection` except that it accepts `comparator`
     * which is invoked to compare elements of `arrays`. The order and references
     * of result values are determined by the first array. The comparator is
     * invoked with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.intersectionWith(objects, others, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }]
     */
    var intersectionWith = baseRest(function(arrays) {
      var comparator = last(arrays),
          mapped = arrayMap(arrays, castArrayLikeObject);

      comparator = typeof comparator == 'function' ? comparator : undefined;
      if (comparator) {
        mapped.pop();
      }
      return (mapped.length && mapped[0] === arrays[0])
        ? baseIntersection(mapped, undefined, comparator)
        : [];
    });

    /**
     * Converts all elements in `array` into a string separated by `separator`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to convert.
     * @param {string} [separator=','] The element separator.
     * @returns {string} Returns the joined string.
     * @example
     *
     * _.join(['a', 'b', 'c'], '~');
     * // => 'a~b~c'
     */
    function join(array, separator) {
      return array == null ? '' : nativeJoin.call(array, separator);
    }

    /**
     * Gets the last element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the last element of `array`.
     * @example
     *
     * _.last([1, 2, 3]);
     * // => 3
     */
    function last(array) {
      var length = array == null ? 0 : array.length;
      return length ? array[length - 1] : undefined;
    }

    /**
     * This method is like `_.indexOf` except that it iterates over elements of
     * `array` from right to left.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.lastIndexOf([1, 2, 1, 2], 2);
     * // => 3
     *
     * // Search from the `fromIndex`.
     * _.lastIndexOf([1, 2, 1, 2], 2, 2);
     * // => 1
     */
    function lastIndexOf(array, value, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = length;
      if (fromIndex !== undefined) {
        index = toInteger(fromIndex);
        index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
      }
      return value === value
        ? strictLastIndexOf(array, value, index)
        : baseFindIndex(array, baseIsNaN, index, true);
    }

    /**
     * Gets the element at index `n` of `array`. If `n` is negative, the nth
     * element from the end is returned.
     *
     * @static
     * @memberOf _
     * @since 4.11.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=0] The index of the element to return.
     * @returns {*} Returns the nth element of `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'd'];
     *
     * _.nth(array, 1);
     * // => 'b'
     *
     * _.nth(array, -2);
     * // => 'c';
     */
    function nth(array, n) {
      return (array && array.length) ? baseNth(array, toInteger(n)) : undefined;
    }

    /**
     * Removes all given values from `array` using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`
     * to remove elements from an array by predicate.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...*} [values] The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
     *
     * _.pull(array, 'a', 'c');
     * console.log(array);
     * // => ['b', 'b']
     */
    var pull = baseRest(pullAll);

    /**
     * This method is like `_.pull` except that it accepts an array of values to remove.
     *
     * **Note:** Unlike `_.difference`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
     *
     * _.pullAll(array, ['a', 'c']);
     * console.log(array);
     * // => ['b', 'b']
     */
    function pullAll(array, values) {
      return (array && array.length && values && values.length)
        ? basePullAll(array, values)
        : array;
    }

    /**
     * This method is like `_.pullAll` except that it accepts `iteratee` which is
     * invoked for each element of `array` and `values` to generate the criterion
     * by which they're compared. The iteratee is invoked with one argument: (value).
     *
     * **Note:** Unlike `_.differenceBy`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];
     *
     * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');
     * console.log(array);
     * // => [{ 'x': 2 }]
     */
    function pullAllBy(array, values, iteratee) {
      return (array && array.length && values && values.length)
        ? basePullAll(array, values, getIteratee(iteratee, 2))
        : array;
    }

    /**
     * This method is like `_.pullAll` except that it accepts `comparator` which
     * is invoked to compare elements of `array` to `values`. The comparator is
     * invoked with two arguments: (arrVal, othVal).
     *
     * **Note:** Unlike `_.differenceWith`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];
     *
     * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);
     * console.log(array);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]
     */
    function pullAllWith(array, values, comparator) {
      return (array && array.length && values && values.length)
        ? basePullAll(array, values, undefined, comparator)
        : array;
    }

    /**
     * Removes elements from `array` corresponding to `indexes` and returns an
     * array of removed elements.
     *
     * **Note:** Unlike `_.at`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...(number|number[])} [indexes] The indexes of elements to remove.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = ['a', 'b', 'c', 'd'];
     * var pulled = _.pullAt(array, [1, 3]);
     *
     * console.log(array);
     * // => ['a', 'c']
     *
     * console.log(pulled);
     * // => ['b', 'd']
     */
    var pullAt = flatRest(function(array, indexes) {
      var length = array == null ? 0 : array.length,
          result = baseAt(array, indexes);

      basePullAt(array, arrayMap(indexes, function(index) {
        return isIndex(index, length) ? +index : index;
      }).sort(compareAscending));

      return result;
    });

    /**
     * Removes all elements from `array` that `predicate` returns truthy for
     * and returns an array of the removed elements. The predicate is invoked
     * with three arguments: (value, index, array).
     *
     * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`
     * to pull elements from an array by value.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = [1, 2, 3, 4];
     * var evens = _.remove(array, function(n) {
     *   return n % 2 == 0;
     * });
     *
     * console.log(array);
     * // => [1, 3]
     *
     * console.log(evens);
     * // => [2, 4]
     */
    function remove(array, predicate) {
      var result = [];
      if (!(array && array.length)) {
        return result;
      }
      var index = -1,
          indexes = [],
          length = array.length;

      predicate = getIteratee(predicate, 3);
      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result.push(value);
          indexes.push(index);
        }
      }
      basePullAt(array, indexes);
      return result;
    }

    /**
     * Reverses `array` so that the first element becomes the last, the second
     * element becomes the second to last, and so on.
     *
     * **Note:** This method mutates `array` and is based on
     * [`Array#reverse`](https://mdn.io/Array/reverse).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _.reverse(array);
     * // => [3, 2, 1]
     *
     * console.log(array);
     * // => [3, 2, 1]
     */
    function reverse(array) {
      return array == null ? array : nativeReverse.call(array);
    }

    /**
     * Creates a slice of `array` from `start` up to, but not including, `end`.
     *
     * **Note:** This method is used instead of
     * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are
     * returned.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */
    function slice(array, start, end) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
        start = 0;
        end = length;
      }
      else {
        start = start == null ? 0 : toInteger(start);
        end = end === undefined ? length : toInteger(end);
      }
      return baseSlice(array, start, end);
    }

    /**
     * Uses a binary search to determine the lowest index at which `value`
     * should be inserted into `array` in order to maintain its sort order.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedIndex([30, 50], 40);
     * // => 1
     */
    function sortedIndex(array, value) {
      return baseSortedIndex(array, value);
    }

    /**
     * This method is like `_.sortedIndex` except that it accepts `iteratee`
     * which is invoked for `value` and each element of `array` to compute their
     * sort ranking. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * var objects = [{ 'x': 4 }, { 'x': 5 }];
     *
     * _.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
     * // => 0
     *
     * // The `_.property` iteratee shorthand.
     * _.sortedIndexBy(objects, { 'x': 4 }, 'x');
     * // => 0
     */
    function sortedIndexBy(array, value, iteratee) {
      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2));
    }

    /**
     * This method is like `_.indexOf` except that it performs a binary
     * search on a sorted `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.sortedIndexOf([4, 5, 5, 5, 6], 5);
     * // => 1
     */
    function sortedIndexOf(array, value) {
      var length = array == null ? 0 : array.length;
      if (length) {
        var index = baseSortedIndex(array, value);
        if (index < length && eq(array[index], value)) {
          return index;
        }
      }
      return -1;
    }

    /**
     * This method is like `_.sortedIndex` except that it returns the highest
     * index at which `value` should be inserted into `array` in order to
     * maintain its sort order.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedLastIndex([4, 5, 5, 5, 6], 5);
     * // => 4
     */
    function sortedLastIndex(array, value) {
      return baseSortedIndex(array, value, true);
    }

    /**
     * This method is like `_.sortedLastIndex` except that it accepts `iteratee`
     * which is invoked for `value` and each element of `array` to compute their
     * sort ranking. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * var objects = [{ 'x': 4 }, { 'x': 5 }];
     *
     * _.sortedLastIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
     * // => 1
     *
     * // The `_.property` iteratee shorthand.
     * _.sortedLastIndexBy(objects, { 'x': 4 }, 'x');
     * // => 1
     */
    function sortedLastIndexBy(array, value, iteratee) {
      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2), true);
    }

    /**
     * This method is like `_.lastIndexOf` except that it performs a binary
     * search on a sorted `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.sortedLastIndexOf([4, 5, 5, 5, 6], 5);
     * // => 3
     */
    function sortedLastIndexOf(array, value) {
      var length = array == null ? 0 : array.length;
      if (length) {
        var index = baseSortedIndex(array, value, true) - 1;
        if (eq(array[index], value)) {
          return index;
        }
      }
      return -1;
    }

    /**
     * This method is like `_.uniq` except that it's designed and optimized
     * for sorted arrays.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.sortedUniq([1, 1, 2]);
     * // => [1, 2]
     */
    function sortedUniq(array) {
      return (array && array.length)
        ? baseSortedUniq(array)
        : [];
    }

    /**
     * This method is like `_.uniqBy` except that it's designed and optimized
     * for sorted arrays.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);
     * // => [1.1, 2.3]
     */
    function sortedUniqBy(array, iteratee) {
      return (array && array.length)
        ? baseSortedUniq(array, getIteratee(iteratee, 2))
        : [];
    }

    /**
     * Gets all but the first element of `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.tail([1, 2, 3]);
     * // => [2, 3]
     */
    function tail(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseSlice(array, 1, length) : [];
    }

    /**
     * Creates a slice of `array` with `n` elements taken from the beginning.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.take([1, 2, 3]);
     * // => [1]
     *
     * _.take([1, 2, 3], 2);
     * // => [1, 2]
     *
     * _.take([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.take([1, 2, 3], 0);
     * // => []
     */
    function take(array, n, guard) {
      if (!(array && array.length)) {
        return [];
      }
      n = (guard || n === undefined) ? 1 : toInteger(n);
      return baseSlice(array, 0, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` with `n` elements taken from the end.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.takeRight([1, 2, 3]);
     * // => [3]
     *
     * _.takeRight([1, 2, 3], 2);
     * // => [2, 3]
     *
     * _.takeRight([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.takeRight([1, 2, 3], 0);
     * // => []
     */
    function takeRight(array, n, guard) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      n = (guard || n === undefined) ? 1 : toInteger(n);
      n = length - n;
      return baseSlice(array, n < 0 ? 0 : n, length);
    }

    /**
     * Creates a slice of `array` with elements taken from the end. Elements are
     * taken until `predicate` returns falsey. The predicate is invoked with
     * three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.takeRightWhile(users, function(o) { return !o.active; });
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.matches` iteratee shorthand.
     * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });
     * // => objects for ['pebbles']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.takeRightWhile(users, ['active', false]);
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.property` iteratee shorthand.
     * _.takeRightWhile(users, 'active');
     * // => []
     */
    function takeRightWhile(array, predicate) {
      return (array && array.length)
        ? baseWhile(array, getIteratee(predicate, 3), false, true)
        : [];
    }

    /**
     * Creates a slice of `array` with elements taken from the beginning. Elements
     * are taken until `predicate` returns falsey. The predicate is invoked with
     * three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.takeWhile(users, function(o) { return !o.active; });
     * // => objects for ['barney', 'fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.takeWhile(users, { 'user': 'barney', 'active': false });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.takeWhile(users, ['active', false]);
     * // => objects for ['barney', 'fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.takeWhile(users, 'active');
     * // => []
     */
    function takeWhile(array, predicate) {
      return (array && array.length)
        ? baseWhile(array, getIteratee(predicate, 3))
        : [];
    }

    /**
     * Creates an array of unique values, in order, from all given arrays using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * _.union([2], [1, 2]);
     * // => [2, 1]
     */
    var union = baseRest(function(arrays) {
      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
    });

    /**
     * This method is like `_.union` except that it accepts `iteratee` which is
     * invoked for each element of each `arrays` to generate the criterion by
     * which uniqueness is computed. Result values are chosen from the first
     * array in which the value occurs. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * _.unionBy([2.1], [1.2, 2.3], Math.floor);
     * // => [2.1, 1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */
    var unionBy = baseRest(function(arrays) {
      var iteratee = last(arrays);
      if (isArrayLikeObject(iteratee)) {
        iteratee = undefined;
      }
      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee, 2));
    });

    /**
     * This method is like `_.union` except that it accepts `comparator` which
     * is invoked to compare elements of `arrays`. Result values are chosen from
     * the first array in which the value occurs. The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.unionWith(objects, others, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
     */
    var unionWith = baseRest(function(arrays) {
      var comparator = last(arrays);
      comparator = typeof comparator == 'function' ? comparator : undefined;
      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined, comparator);
    });

    /**
     * Creates a duplicate-free version of an array, using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons, in which only the first occurrence of each element
     * is kept. The order of result values is determined by the order they occur
     * in the array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.uniq([2, 1, 2]);
     * // => [2, 1]
     */
    function uniq(array) {
      return (array && array.length) ? baseUniq(array) : [];
    }

    /**
     * This method is like `_.uniq` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * uniqueness is computed. The order of result values is determined by the
     * order they occur in the array. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.uniqBy([2.1, 1.2, 2.3], Math.floor);
     * // => [2.1, 1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */
    function uniqBy(array, iteratee) {
      return (array && array.length) ? baseUniq(array, getIteratee(iteratee, 2)) : [];
    }

    /**
     * This method is like `_.uniq` except that it accepts `comparator` which
     * is invoked to compare elements of `array`. The order of result values is
     * determined by the order they occur in the array.The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.uniqWith(objects, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
     */
    function uniqWith(array, comparator) {
      comparator = typeof comparator == 'function' ? comparator : undefined;
      return (array && array.length) ? baseUniq(array, undefined, comparator) : [];
    }

    /**
     * This method is like `_.zip` except that it accepts an array of grouped
     * elements and creates an array regrouping the elements to their pre-zip
     * configuration.
     *
     * @static
     * @memberOf _
     * @since 1.2.0
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);
     * // => [['a', 1, true], ['b', 2, false]]
     *
     * _.unzip(zipped);
     * // => [['a', 'b'], [1, 2], [true, false]]
     */
    function unzip(array) {
      if (!(array && array.length)) {
        return [];
      }
      var length = 0;
      array = arrayFilter(array, function(group) {
        if (isArrayLikeObject(group)) {
          length = nativeMax(group.length, length);
          return true;
        }
      });
      return baseTimes(length, function(index) {
        return arrayMap(array, baseProperty(index));
      });
    }

    /**
     * This method is like `_.unzip` except that it accepts `iteratee` to specify
     * how regrouped values should be combined. The iteratee is invoked with the
     * elements of each group: (...group).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @param {Function} [iteratee=_.identity] The function to combine
     *  regrouped values.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
     * // => [[1, 10, 100], [2, 20, 200]]
     *
     * _.unzipWith(zipped, _.add);
     * // => [3, 30, 300]
     */
    function unzipWith(array, iteratee) {
      if (!(array && array.length)) {
        return [];
      }
      var result = unzip(array);
      if (iteratee == null) {
        return result;
      }
      return arrayMap(result, function(group) {
        return apply(iteratee, undefined, group);
      });
    }

    /**
     * Creates an array excluding all given values using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * **Note:** Unlike `_.pull`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...*} [values] The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.difference, _.xor
     * @example
     *
     * _.without([2, 1, 2, 3], 1, 2);
     * // => [3]
     */
    var without = baseRest(function(array, values) {
      return isArrayLikeObject(array)
        ? baseDifference(array, values)
        : [];
    });

    /**
     * Creates an array of unique values that is the
     * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
     * of the given arrays. The order of result values is determined by the order
     * they occur in the arrays.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.difference, _.without
     * @example
     *
     * _.xor([2, 1], [2, 3]);
     * // => [1, 3]
     */
    var xor = baseRest(function(arrays) {
      return baseXor(arrayFilter(arrays, isArrayLikeObject));
    });

    /**
     * This method is like `_.xor` except that it accepts `iteratee` which is
     * invoked for each element of each `arrays` to generate the criterion by
     * which by which they're compared. The order of result values is determined
     * by the order they occur in the arrays. The iteratee is invoked with one
     * argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [1.2, 3.4]
     *
     * // The `_.property` iteratee shorthand.
     * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 2 }]
     */
    var xorBy = baseRest(function(arrays) {
      var iteratee = last(arrays);
      if (isArrayLikeObject(iteratee)) {
        iteratee = undefined;
      }
      return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee, 2));
    });

    /**
     * This method is like `_.xor` except that it accepts `comparator` which is
     * invoked to compare elements of `arrays`. The order of result values is
     * determined by the order they occur in the arrays. The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.xorWith(objects, others, _.isEqual);
     * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
     */
    var xorWith = baseRest(function(arrays) {
      var comparator = last(arrays);
      comparator = typeof comparator == 'function' ? comparator : undefined;
      return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined, comparator);
    });

    /**
     * Creates an array of grouped elements, the first of which contains the
     * first elements of the given arrays, the second of which contains the
     * second elements of the given arrays, and so on.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zip(['a', 'b'], [1, 2], [true, false]);
     * // => [['a', 1, true], ['b', 2, false]]
     */
    var zip = baseRest(unzip);

    /**
     * This method is like `_.fromPairs` except that it accepts two arrays,
     * one of property identifiers and one of corresponding values.
     *
     * @static
     * @memberOf _
     * @since 0.4.0
     * @category Array
     * @param {Array} [props=[]] The property identifiers.
     * @param {Array} [values=[]] The property values.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.zipObject(['a', 'b'], [1, 2]);
     * // => { 'a': 1, 'b': 2 }
     */
    function zipObject(props, values) {
      return baseZipObject(props || [], values || [], assignValue);
    }

    /**
     * This method is like `_.zipObject` except that it supports property paths.
     *
     * @static
     * @memberOf _
     * @since 4.1.0
     * @category Array
     * @param {Array} [props=[]] The property identifiers.
     * @param {Array} [values=[]] The property values.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);
     * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }
     */
    function zipObjectDeep(props, values) {
      return baseZipObject(props || [], values || [], baseSet);
    }

    /**
     * This method is like `_.zip` except that it accepts `iteratee` to specify
     * how grouped values should be combined. The iteratee is invoked with the
     * elements of each group: (...group).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @param {Function} [iteratee=_.identity] The function to combine
     *  grouped values.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {
     *   return a + b + c;
     * });
     * // => [111, 222]
     */
    var zipWith = baseRest(function(arrays) {
      var length = arrays.length,
          iteratee = length > 1 ? arrays[length - 1] : undefined;

      iteratee = typeof iteratee == 'function' ? (arrays.pop(), iteratee) : undefined;
      return unzipWith(arrays, iteratee);
    });

    /*------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` wrapper instance that wraps `value` with explicit method
     * chain sequences enabled. The result of such sequences must be unwrapped
     * with `_#value`.
     *
     * @static
     * @memberOf _
     * @since 1.3.0
     * @category Seq
     * @param {*} value The value to wrap.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36 },
     *   { 'user': 'fred',    'age': 40 },
     *   { 'user': 'pebbles', 'age': 1 }
     * ];
     *
     * var youngest = _
     *   .chain(users)
     *   .sortBy('age')
     *   .map(function(o) {
     *     return o.user + ' is ' + o.age;
     *   })
     *   .head()
     *   .value();
     * // => 'pebbles is 1'
     */
    function chain(value) {
      var result = lodash(value);
      result.__chain__ = true;
      return result;
    }

    /**
     * This method invokes `interceptor` and returns `value`. The interceptor
     * is invoked with one argument; (value). The purpose of this method is to
     * "tap into" a method chain sequence in order to modify intermediate results.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns `value`.
     * @example
     *
     * _([1, 2, 3])
     *  .tap(function(array) {
     *    // Mutate input array.
     *    array.pop();
     *  })
     *  .reverse()
     *  .value();
     * // => [2, 1]
     */
    function tap(value, interceptor) {
      interceptor(value);
      return value;
    }

    /**
     * This method is like `_.tap` except that it returns the result of `interceptor`.
     * The purpose of this method is to "pass thru" values replacing intermediate
     * results in a method chain sequence.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Seq
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns the result of `interceptor`.
     * @example
     *
     * _('  abc  ')
     *  .chain()
     *  .trim()
     *  .thru(function(value) {
     *    return [value];
     *  })
     *  .value();
     * // => ['abc']
     */
    function thru(value, interceptor) {
      return interceptor(value);
    }

    /**
     * This method is the wrapper version of `_.at`.
     *
     * @name at
     * @memberOf _
     * @since 1.0.0
     * @category Seq
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
     *
     * _(object).at(['a[0].b.c', 'a[1]']).value();
     * // => [3, 4]
     */
    var wrapperAt = flatRest(function(paths) {
      var length = paths.length,
          start = length ? paths[0] : 0,
          value = this.__wrapped__,
          interceptor = function(object) { return baseAt(object, paths); };

      if (length > 1 || this.__actions__.length ||
          !(value instanceof LazyWrapper) || !isIndex(start)) {
        return this.thru(interceptor);
      }
      value = value.slice(start, +start + (length ? 1 : 0));
      value.__actions__.push({
        'func': thru,
        'args': [interceptor],
        'thisArg': undefined
      });
      return new LodashWrapper(value, this.__chain__).thru(function(array) {
        if (length && !array.length) {
          array.push(undefined);
        }
        return array;
      });
    });

    /**
     * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.
     *
     * @name chain
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * // A sequence without explicit chaining.
     * _(users).head();
     * // => { 'user': 'barney', 'age': 36 }
     *
     * // A sequence with explicit chaining.
     * _(users)
     *   .chain()
     *   .head()
     *   .pick('user')
     *   .value();
     * // => { 'user': 'barney' }
     */
    function wrapperChain() {
      return chain(this);
    }

    /**
     * Executes the chain sequence and returns the wrapped result.
     *
     * @name commit
     * @memberOf _
     * @since 3.2.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2];
     * var wrapped = _(array).push(3);
     *
     * console.log(array);
     * // => [1, 2]
     *
     * wrapped = wrapped.commit();
     * console.log(array);
     * // => [1, 2, 3]
     *
     * wrapped.last();
     * // => 3
     *
     * console.log(array);
     * // => [1, 2, 3]
     */
    function wrapperCommit() {
      return new LodashWrapper(this.value(), this.__chain__);
    }

    /**
     * Gets the next value on a wrapped object following the
     * [iterator protocol](https://mdn.io/iteration_protocols#iterator).
     *
     * @name next
     * @memberOf _
     * @since 4.0.0
     * @category Seq
     * @returns {Object} Returns the next iterator value.
     * @example
     *
     * var wrapped = _([1, 2]);
     *
     * wrapped.next();
     * // => { 'done': false, 'value': 1 }
     *
     * wrapped.next();
     * // => { 'done': false, 'value': 2 }
     *
     * wrapped.next();
     * // => { 'done': true, 'value': undefined }
     */
    function wrapperNext() {
      if (this.__values__ === undefined) {
        this.__values__ = toArray(this.value());
      }
      var done = this.__index__ >= this.__values__.length,
          value = done ? undefined : this.__values__[this.__index__++];

      return { 'done': done, 'value': value };
    }

    /**
     * Enables the wrapper to be iterable.
     *
     * @name Symbol.iterator
     * @memberOf _
     * @since 4.0.0
     * @category Seq
     * @returns {Object} Returns the wrapper object.
     * @example
     *
     * var wrapped = _([1, 2]);
     *
     * wrapped[Symbol.iterator]() === wrapped;
     * // => true
     *
     * Array.from(wrapped);
     * // => [1, 2]
     */
    function wrapperToIterator() {
      return this;
    }

    /**
     * Creates a clone of the chain sequence planting `value` as the wrapped value.
     *
     * @name plant
     * @memberOf _
     * @since 3.2.0
     * @category Seq
     * @param {*} value The value to plant.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var wrapped = _([1, 2]).map(square);
     * var other = wrapped.plant([3, 4]);
     *
     * other.value();
     * // => [9, 16]
     *
     * wrapped.value();
     * // => [1, 4]
     */
    function wrapperPlant(value) {
      var result,
          parent = this;

      while (parent instanceof baseLodash) {
        var clone = wrapperClone(parent);
        clone.__index__ = 0;
        clone.__values__ = undefined;
        if (result) {
          previous.__wrapped__ = clone;
        } else {
          result = clone;
        }
        var previous = clone;
        parent = parent.__wrapped__;
      }
      previous.__wrapped__ = value;
      return result;
    }

    /**
     * This method is the wrapper version of `_.reverse`.
     *
     * **Note:** This method mutates the wrapped array.
     *
     * @name reverse
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _(array).reverse().value()
     * // => [3, 2, 1]
     *
     * console.log(array);
     * // => [3, 2, 1]
     */
    function wrapperReverse() {
      var value = this.__wrapped__;
      if (value instanceof LazyWrapper) {
        var wrapped = value;
        if (this.__actions__.length) {
          wrapped = new LazyWrapper(this);
        }
        wrapped = wrapped.reverse();
        wrapped.__actions__.push({
          'func': thru,
          'args': [reverse],
          'thisArg': undefined
        });
        return new LodashWrapper(wrapped, this.__chain__);
      }
      return this.thru(reverse);
    }

    /**
     * Executes the chain sequence to resolve the unwrapped value.
     *
     * @name value
     * @memberOf _
     * @since 0.1.0
     * @alias toJSON, valueOf
     * @category Seq
     * @returns {*} Returns the resolved unwrapped value.
     * @example
     *
     * _([1, 2, 3]).value();
     * // => [1, 2, 3]
     */
    function wrapperValue() {
      return baseWrapperValue(this.__wrapped__, this.__actions__);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The corresponding value of
     * each key is the number of times the key was returned by `iteratee`. The
     * iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.countBy([6.1, 4.2, 6.3], Math.floor);
     * // => { '4': 1, '6': 2 }
     *
     * // The `_.property` iteratee shorthand.
     * _.countBy(['one', 'two', 'three'], 'length');
     * // => { '3': 2, '5': 1 }
     */
    var countBy = createAggregator(function(result, value, key) {
      if (hasOwnProperty.call(result, key)) {
        ++result[key];
      } else {
        baseAssignValue(result, key, 1);
      }
    });

    /**
     * Checks if `predicate` returns truthy for **all** elements of `collection`.
     * Iteration is stopped once `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index|key, collection).
     *
     * **Note:** This method returns `true` for
     * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because
     * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of
     * elements of empty collections.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`.
     * @example
     *
     * _.every([true, 1, null, 'yes'], Boolean);
     * // => false
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.every(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.every(users, ['active', false]);
     * // => true
     *
     * // The `_.property` iteratee shorthand.
     * _.every(users, 'active');
     * // => false
     */
    function every(collection, predicate, guard) {
      var func = isArray(collection) ? arrayEvery : baseEvery;
      if (guard && isIterateeCall(collection, predicate, guard)) {
        predicate = undefined;
      }
      return func(collection, getIteratee(predicate, 3));
    }

    /**
     * Iterates over elements of `collection`, returning an array of all elements
     * `predicate` returns truthy for. The predicate is invoked with three
     * arguments: (value, index|key, collection).
     *
     * **Note:** Unlike `_.remove`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     * @see _.reject
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * _.filter(users, function(o) { return !o.active; });
     * // => objects for ['fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.filter(users, { 'age': 36, 'active': true });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.filter(users, ['active', false]);
     * // => objects for ['fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.filter(users, 'active');
     * // => objects for ['barney']
     *
     * // Combining several predicates using `_.overEvery` or `_.overSome`.
     * _.filter(users, _.overSome([{ 'age': 36 }, ['age', 40]]));
     * // => objects for ['fred', 'barney']
     */
    function filter(collection, predicate) {
      var func = isArray(collection) ? arrayFilter : baseFilter;
      return func(collection, getIteratee(predicate, 3));
    }

    /**
     * Iterates over elements of `collection`, returning the first element
     * `predicate` returns truthy for. The predicate is invoked with three
     * arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': true },
     *   { 'user': 'fred',    'age': 40, 'active': false },
     *   { 'user': 'pebbles', 'age': 1,  'active': true }
     * ];
     *
     * _.find(users, function(o) { return o.age < 40; });
     * // => object for 'barney'
     *
     * // The `_.matches` iteratee shorthand.
     * _.find(users, { 'age': 1, 'active': true });
     * // => object for 'pebbles'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.find(users, ['active', false]);
     * // => object for 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.find(users, 'active');
     * // => object for 'barney'
     */
    var find = createFind(findIndex);

    /**
     * This method is like `_.find` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=collection.length-1] The index to search from.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * _.findLast([1, 2, 3, 4], function(n) {
     *   return n % 2 == 1;
     * });
     * // => 3
     */
    var findLast = createFind(findLastIndex);

    /**
     * Creates a flattened array of values by running each element in `collection`
     * thru `iteratee` and flattening the mapped results. The iteratee is invoked
     * with three arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [n, n];
     * }
     *
     * _.flatMap([1, 2], duplicate);
     * // => [1, 1, 2, 2]
     */
    function flatMap(collection, iteratee) {
      return baseFlatten(map(collection, iteratee), 1);
    }

    /**
     * This method is like `_.flatMap` except that it recursively flattens the
     * mapped results.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [[[n, n]]];
     * }
     *
     * _.flatMapDeep([1, 2], duplicate);
     * // => [1, 1, 2, 2]
     */
    function flatMapDeep(collection, iteratee) {
      return baseFlatten(map(collection, iteratee), INFINITY);
    }

    /**
     * This method is like `_.flatMap` except that it recursively flattens the
     * mapped results up to `depth` times.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {number} [depth=1] The maximum recursion depth.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [[[n, n]]];
     * }
     *
     * _.flatMapDepth([1, 2], duplicate, 2);
     * // => [[1, 1], [2, 2]]
     */
    function flatMapDepth(collection, iteratee, depth) {
      depth = depth === undefined ? 1 : toInteger(depth);
      return baseFlatten(map(collection, iteratee), depth);
    }

    /**
     * Iterates over elements of `collection` and invokes `iteratee` for each element.
     * The iteratee is invoked with three arguments: (value, index|key, collection).
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * **Note:** As with other "Collections" methods, objects with a "length"
     * property are iterated like arrays. To avoid this behavior use `_.forIn`
     * or `_.forOwn` for object iteration.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @alias each
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     * @see _.forEachRight
     * @example
     *
     * _.forEach([1, 2], function(value) {
     *   console.log(value);
     * });
     * // => Logs `1` then `2`.
     *
     * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
     */
    function forEach(collection, iteratee) {
      var func = isArray(collection) ? arrayEach : baseEach;
      return func(collection, getIteratee(iteratee, 3));
    }

    /**
     * This method is like `_.forEach` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @alias eachRight
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     * @see _.forEach
     * @example
     *
     * _.forEachRight([1, 2], function(value) {
     *   console.log(value);
     * });
     * // => Logs `2` then `1`.
     */
    function forEachRight(collection, iteratee) {
      var func = isArray(collection) ? arrayEachRight : baseEachRight;
      return func(collection, getIteratee(iteratee, 3));
    }

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The order of grouped values
     * is determined by the order they occur in `collection`. The corresponding
     * value of each key is an array of elements responsible for generating the
     * key. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.groupBy([6.1, 4.2, 6.3], Math.floor);
     * // => { '4': [4.2], '6': [6.1, 6.3] }
     *
     * // The `_.property` iteratee shorthand.
     * _.groupBy(['one', 'two', 'three'], 'length');
     * // => { '3': ['one', 'two'], '5': ['three'] }
     */
    var groupBy = createAggregator(function(result, value, key) {
      if (hasOwnProperty.call(result, key)) {
        result[key].push(value);
      } else {
        baseAssignValue(result, key, [value]);
      }
    });

    /**
     * Checks if `value` is in `collection`. If `collection` is a string, it's
     * checked for a substring of `value`, otherwise
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * is used for equality comparisons. If `fromIndex` is negative, it's used as
     * the offset from the end of `collection`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object|string} collection The collection to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
     * @returns {boolean} Returns `true` if `value` is found, else `false`.
     * @example
     *
     * _.includes([1, 2, 3], 1);
     * // => true
     *
     * _.includes([1, 2, 3], 1, 2);
     * // => false
     *
     * _.includes({ 'a': 1, 'b': 2 }, 1);
     * // => true
     *
     * _.includes('abcd', 'bc');
     * // => true
     */
    function includes(collection, value, fromIndex, guard) {
      collection = isArrayLike(collection) ? collection : values(collection);
      fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;

      var length = collection.length;
      if (fromIndex < 0) {
        fromIndex = nativeMax(length + fromIndex, 0);
      }
      return isString(collection)
        ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)
        : (!!length && baseIndexOf(collection, value, fromIndex) > -1);
    }

    /**
     * Invokes the method at `path` of each element in `collection`, returning
     * an array of the results of each invoked method. Any additional arguments
     * are provided to each invoked method. If `path` is a function, it's invoked
     * for, and `this` bound to, each element in `collection`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Array|Function|string} path The path of the method to invoke or
     *  the function invoked per iteration.
     * @param {...*} [args] The arguments to invoke each method with.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');
     * // => [[1, 5, 7], [1, 2, 3]]
     *
     * _.invokeMap([123, 456], String.prototype.split, '');
     * // => [['1', '2', '3'], ['4', '5', '6']]
     */
    var invokeMap = baseRest(function(collection, path, args) {
      var index = -1,
          isFunc = typeof path == 'function',
          result = isArrayLike(collection) ? Array(collection.length) : [];

      baseEach(collection, function(value) {
        result[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
      });
      return result;
    });

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The corresponding value of
     * each key is the last element responsible for generating the key. The
     * iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * var array = [
     *   { 'dir': 'left', 'code': 97 },
     *   { 'dir': 'right', 'code': 100 }
     * ];
     *
     * _.keyBy(array, function(o) {
     *   return String.fromCharCode(o.code);
     * });
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     *
     * _.keyBy(array, 'dir');
     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
     */
    var keyBy = createAggregator(function(result, value, key) {
      baseAssignValue(result, key, value);
    });

    /**
     * Creates an array of values by running each element in `collection` thru
     * `iteratee`. The iteratee is invoked with three arguments:
     * (value, index|key, collection).
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
     *
     * The guarded methods are:
     * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
     * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
     * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
     * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * _.map([4, 8], square);
     * // => [16, 64]
     *
     * _.map({ 'a': 4, 'b': 8 }, square);
     * // => [16, 64] (iteration order is not guaranteed)
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' }
     * ];
     *
     * // The `_.property` iteratee shorthand.
     * _.map(users, 'user');
     * // => ['barney', 'fred']
     */
    function map(collection, iteratee) {
      var func = isArray(collection) ? arrayMap : baseMap;
      return func(collection, getIteratee(iteratee, 3));
    }

    /**
     * This method is like `_.sortBy` except that it allows specifying the sort
     * orders of the iteratees to sort by. If `orders` is unspecified, all values
     * are sorted in ascending order. Otherwise, specify an order of "desc" for
     * descending or "asc" for ascending sort order of corresponding values.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]
     *  The iteratees to sort by.
     * @param {string[]} [orders] The sort orders of `iteratees`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'fred',   'age': 48 },
     *   { 'user': 'barney', 'age': 34 },
     *   { 'user': 'fred',   'age': 40 },
     *   { 'user': 'barney', 'age': 36 }
     * ];
     *
     * // Sort by `user` in ascending order and by `age` in descending order.
     * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);
     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
     */
    function orderBy(collection, iteratees, orders, guard) {
      if (collection == null) {
        return [];
      }
      if (!isArray(iteratees)) {
        iteratees = iteratees == null ? [] : [iteratees];
      }
      orders = guard ? undefined : orders;
      if (!isArray(orders)) {
        orders = orders == null ? [] : [orders];
      }
      return baseOrderBy(collection, iteratees, orders);
    }

    /**
     * Creates an array of elements split into two groups, the first of which
     * contains elements `predicate` returns truthy for, the second of which
     * contains elements `predicate` returns falsey for. The predicate is
     * invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the array of grouped elements.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': false },
     *   { 'user': 'fred',    'age': 40, 'active': true },
     *   { 'user': 'pebbles', 'age': 1,  'active': false }
     * ];
     *
     * _.partition(users, function(o) { return o.active; });
     * // => objects for [['fred'], ['barney', 'pebbles']]
     *
     * // The `_.matches` iteratee shorthand.
     * _.partition(users, { 'age': 1, 'active': false });
     * // => objects for [['pebbles'], ['barney', 'fred']]
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.partition(users, ['active', false]);
     * // => objects for [['barney', 'pebbles'], ['fred']]
     *
     * // The `_.property` iteratee shorthand.
     * _.partition(users, 'active');
     * // => objects for [['fred'], ['barney', 'pebbles']]
     */
    var partition = createAggregator(function(result, value, key) {
      result[key ? 0 : 1].push(value);
    }, function() { return [[], []]; });

    /**
     * Reduces `collection` to a value which is the accumulated result of running
     * each element in `collection` thru `iteratee`, where each successive
     * invocation is supplied the return value of the previous. If `accumulator`
     * is not given, the first element of `collection` is used as the initial
     * value. The iteratee is invoked with four arguments:
     * (accumulator, value, index|key, collection).
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.reduce`, `_.reduceRight`, and `_.transform`.
     *
     * The guarded methods are:
     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
     * and `sortBy`
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @returns {*} Returns the accumulated value.
     * @see _.reduceRight
     * @example
     *
     * _.reduce([1, 2], function(sum, n) {
     *   return sum + n;
     * }, 0);
     * // => 3
     *
     * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
     *   (result[value] || (result[value] = [])).push(key);
     *   return result;
     * }, {});
     * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
     */
    function reduce(collection, iteratee, accumulator) {
      var func = isArray(collection) ? arrayReduce : baseReduce,
          initAccum = arguments.length < 3;

      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEach);
    }

    /**
     * This method is like `_.reduce` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @returns {*} Returns the accumulated value.
     * @see _.reduce
     * @example
     *
     * var array = [[0, 1], [2, 3], [4, 5]];
     *
     * _.reduceRight(array, function(flattened, other) {
     *   return flattened.concat(other);
     * }, []);
     * // => [4, 5, 2, 3, 0, 1]
     */
    function reduceRight(collection, iteratee, accumulator) {
      var func = isArray(collection) ? arrayReduceRight : baseReduce,
          initAccum = arguments.length < 3;

      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEachRight);
    }

    /**
     * The opposite of `_.filter`; this method returns the elements of `collection`
     * that `predicate` does **not** return truthy for.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     * @see _.filter
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false },
     *   { 'user': 'fred',   'age': 40, 'active': true }
     * ];
     *
     * _.reject(users, function(o) { return !o.active; });
     * // => objects for ['fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.reject(users, { 'age': 40, 'active': true });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.reject(users, ['active', false]);
     * // => objects for ['fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.reject(users, 'active');
     * // => objects for ['barney']
     */
    function reject(collection, predicate) {
      var func = isArray(collection) ? arrayFilter : baseFilter;
      return func(collection, negate(getIteratee(predicate, 3)));
    }

    /**
     * Gets a random element from `collection`.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to sample.
     * @returns {*} Returns the random element.
     * @example
     *
     * _.sample([1, 2, 3, 4]);
     * // => 2
     */
    function sample(collection) {
      var func = isArray(collection) ? arraySample : baseSample;
      return func(collection);
    }

    /**
     * Gets `n` random elements at unique keys from `collection` up to the
     * size of `collection`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to sample.
     * @param {number} [n=1] The number of elements to sample.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the random elements.
     * @example
     *
     * _.sampleSize([1, 2, 3], 2);
     * // => [3, 1]
     *
     * _.sampleSize([1, 2, 3], 4);
     * // => [2, 3, 1]
     */
    function sampleSize(collection, n, guard) {
      if ((guard ? isIterateeCall(collection, n, guard) : n === undefined)) {
        n = 1;
      } else {
        n = toInteger(n);
      }
      var func = isArray(collection) ? arraySampleSize : baseSampleSize;
      return func(collection, n);
    }

    /**
     * Creates an array of shuffled values, using a version of the
     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     * @example
     *
     * _.shuffle([1, 2, 3, 4]);
     * // => [4, 1, 3, 2]
     */
    function shuffle(collection) {
      var func = isArray(collection) ? arrayShuffle : baseShuffle;
      return func(collection);
    }

    /**
     * Gets the size of `collection` by returning its length for array-like
     * values or the number of own enumerable string keyed properties for objects.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object|string} collection The collection to inspect.
     * @returns {number} Returns the collection size.
     * @example
     *
     * _.size([1, 2, 3]);
     * // => 3
     *
     * _.size({ 'a': 1, 'b': 2 });
     * // => 2
     *
     * _.size('pebbles');
     * // => 7
     */
    function size(collection) {
      if (collection == null) {
        return 0;
      }
      if (isArrayLike(collection)) {
        return isString(collection) ? stringSize(collection) : collection.length;
      }
      var tag = getTag(collection);
      if (tag == mapTag || tag == setTag) {
        return collection.size;
      }
      return baseKeys(collection).length;
    }

    /**
     * Checks if `predicate` returns truthy for **any** element of `collection`.
     * Iteration is stopped once `predicate` returns truthy. The predicate is
     * invoked with three arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     * @example
     *
     * _.some([null, 0, 'yes', false], Boolean);
     * // => true
     *
     * var users = [
     *   { 'user': 'barney', 'active': true },
     *   { 'user': 'fred',   'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.some(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.some(users, ['active', false]);
     * // => true
     *
     * // The `_.property` iteratee shorthand.
     * _.some(users, 'active');
     * // => true
     */
    function some(collection, predicate, guard) {
      var func = isArray(collection) ? arraySome : baseSome;
      if (guard && isIterateeCall(collection, predicate, guard)) {
        predicate = undefined;
      }
      return func(collection, getIteratee(predicate, 3));
    }

    /**
     * Creates an array of elements, sorted in ascending order by the results of
     * running each element in a collection thru each iteratee. This method
     * performs a stable sort, that is, it preserves the original sort order of
     * equal elements. The iteratees are invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {...(Function|Function[])} [iteratees=[_.identity]]
     *  The iteratees to sort by.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'fred',   'age': 48 },
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 30 },
     *   { 'user': 'barney', 'age': 34 }
     * ];
     *
     * _.sortBy(users, [function(o) { return o.user; }]);
     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 30]]
     *
     * _.sortBy(users, ['user', 'age']);
     * // => objects for [['barney', 34], ['barney', 36], ['fred', 30], ['fred', 48]]
     */
    var sortBy = baseRest(function(collection, iteratees) {
      if (collection == null) {
        return [];
      }
      var length = iteratees.length;
      if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
        iteratees = [];
      } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
        iteratees = [iteratees[0]];
      }
      return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
    });

    /*------------------------------------------------------------------------*/

    /**
     * Gets the timestamp of the number of milliseconds that have elapsed since
     * the Unix epoch (1 January 1970 00:00:00 UTC).
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Date
     * @returns {number} Returns the timestamp.
     * @example
     *
     * _.defer(function(stamp) {
     *   console.log(_.now() - stamp);
     * }, _.now());
     * // => Logs the number of milliseconds it took for the deferred invocation.
     */
    var now = ctxNow || function() {
      return root.Date.now();
    };

    /*------------------------------------------------------------------------*/

    /**
     * The opposite of `_.before`; this method creates a function that invokes
     * `func` once it's called `n` or more times.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {number} n The number of calls before `func` is invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var saves = ['profile', 'settings'];
     *
     * var done = _.after(saves.length, function() {
     *   console.log('done saving!');
     * });
     *
     * _.forEach(saves, function(type) {
     *   asyncSave({ 'type': type, 'complete': done });
     * });
     * // => Logs 'done saving!' after the two async saves have completed.
     */
    function after(n, func) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      n = toInteger(n);
      return function() {
        if (--n < 1) {
          return func.apply(this, arguments);
        }
      };
    }

    /**
     * Creates a function that invokes `func`, with up to `n` arguments,
     * ignoring any additional arguments.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to cap arguments for.
     * @param {number} [n=func.length] The arity cap.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new capped function.
     * @example
     *
     * _.map(['6', '8', '10'], _.ary(parseInt, 1));
     * // => [6, 8, 10]
     */
    function ary(func, n, guard) {
      n = guard ? undefined : n;
      n = (func && n == null) ? func.length : n;
      return createWrap(func, WRAP_ARY_FLAG, undefined, undefined, undefined, undefined, n);
    }

    /**
     * Creates a function that invokes `func`, with the `this` binding and arguments
     * of the created function, while it's called less than `n` times. Subsequent
     * calls to the created function return the result of the last `func` invocation.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {number} n The number of calls at which `func` is no longer invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * jQuery(element).on('click', _.before(5, addContactToList));
     * // => Allows adding up to 4 contacts to the list.
     */
    function before(n, func) {
      var result;
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      n = toInteger(n);
      return function() {
        if (--n > 0) {
          result = func.apply(this, arguments);
        }
        if (n <= 1) {
          func = undefined;
        }
        return result;
      };
    }

    /**
     * Creates a function that invokes `func` with the `this` binding of `thisArg`
     * and `partials` prepended to the arguments it receives.
     *
     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for partially applied arguments.
     *
     * **Note:** Unlike native `Function#bind`, this method doesn't set the "length"
     * property of bound functions.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to bind.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * function greet(greeting, punctuation) {
     *   return greeting + ' ' + this.user + punctuation;
     * }
     *
     * var object = { 'user': 'fred' };
     *
     * var bound = _.bind(greet, object, 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * // Bound with placeholders.
     * var bound = _.bind(greet, object, _, '!');
     * bound('hi');
     * // => 'hi fred!'
     */
    var bind = baseRest(function(func, thisArg, partials) {
      var bitmask = WRAP_BIND_FLAG;
      if (partials.length) {
        var holders = replaceHolders(partials, getHolder(bind));
        bitmask |= WRAP_PARTIAL_FLAG;
      }
      return createWrap(func, bitmask, thisArg, partials, holders);
    });

    /**
     * Creates a function that invokes the method at `object[key]` with `partials`
     * prepended to the arguments it receives.
     *
     * This method differs from `_.bind` by allowing bound functions to reference
     * methods that may be redefined or don't yet exist. See
     * [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
     * for more details.
     *
     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * @static
     * @memberOf _
     * @since 0.10.0
     * @category Function
     * @param {Object} object The object to invoke the method on.
     * @param {string} key The key of the method.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var object = {
     *   'user': 'fred',
     *   'greet': function(greeting, punctuation) {
     *     return greeting + ' ' + this.user + punctuation;
     *   }
     * };
     *
     * var bound = _.bindKey(object, 'greet', 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * object.greet = function(greeting, punctuation) {
     *   return greeting + 'ya ' + this.user + punctuation;
     * };
     *
     * bound('!');
     * // => 'hiya fred!'
     *
     * // Bound with placeholders.
     * var bound = _.bindKey(object, 'greet', _, '!');
     * bound('hi');
     * // => 'hiya fred!'
     */
    var bindKey = baseRest(function(object, key, partials) {
      var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
      if (partials.length) {
        var holders = replaceHolders(partials, getHolder(bindKey));
        bitmask |= WRAP_PARTIAL_FLAG;
      }
      return createWrap(key, bitmask, object, partials, holders);
    });

    /**
     * Creates a function that accepts arguments of `func` and either invokes
     * `func` returning its result, if at least `arity` number of arguments have
     * been provided, or returns a function that accepts the remaining `func`
     * arguments, and so on. The arity of `func` may be specified if `func.length`
     * is not sufficient.
     *
     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for provided arguments.
     *
     * **Note:** This method doesn't set the "length" property of curried functions.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curry(abc);
     *
     * curried(1)(2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // Curried with placeholders.
     * curried(1)(_, 3)(2);
     * // => [1, 2, 3]
     */
    function curry(func, arity, guard) {
      arity = guard ? undefined : arity;
      var result = createWrap(func, WRAP_CURRY_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
      result.placeholder = curry.placeholder;
      return result;
    }

    /**
     * This method is like `_.curry` except that arguments are applied to `func`
     * in the manner of `_.partialRight` instead of `_.partial`.
     *
     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for provided arguments.
     *
     * **Note:** This method doesn't set the "length" property of curried functions.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curryRight(abc);
     *
     * curried(3)(2)(1);
     * // => [1, 2, 3]
     *
     * curried(2, 3)(1);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // Curried with placeholders.
     * curried(3)(1, _)(2);
     * // => [1, 2, 3]
     */
    function curryRight(func, arity, guard) {
      arity = guard ? undefined : arity;
      var result = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
      result.placeholder = curryRight.placeholder;
      return result;
    }

    /**
     * Creates a debounced function that delays invoking `func` until after `wait`
     * milliseconds have elapsed since the last time the debounced function was
     * invoked. The debounced function comes with a `cancel` method to cancel
     * delayed `func` invocations and a `flush` method to immediately invoke them.
     * Provide `options` to indicate whether `func` should be invoked on the
     * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
     * with the last arguments provided to the debounced function. Subsequent
     * calls to the debounced function return the result of the last `func`
     * invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is
     * invoked on the trailing edge of the timeout only if the debounced function
     * is invoked more than once during the `wait` timeout.
     *
     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
     *
     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
     * for details over the differences between `_.debounce` and `_.throttle`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to debounce.
     * @param {number} [wait=0] The number of milliseconds to delay.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.leading=false]
     *  Specify invoking on the leading edge of the timeout.
     * @param {number} [options.maxWait]
     *  The maximum time `func` is allowed to be delayed before it's invoked.
     * @param {boolean} [options.trailing=true]
     *  Specify invoking on the trailing edge of the timeout.
     * @returns {Function} Returns the new debounced function.
     * @example
     *
     * // Avoid costly calculations while the window size is in flux.
     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
     *
     * // Invoke `sendMail` when clicked, debouncing subsequent calls.
     * jQuery(element).on('click', _.debounce(sendMail, 300, {
     *   'leading': true,
     *   'trailing': false
     * }));
     *
     * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
     * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
     * var source = new EventSource('/stream');
     * jQuery(source).on('message', debounced);
     *
     * // Cancel the trailing debounced invocation.
     * jQuery(window).on('popstate', debounced.cancel);
     */
    function debounce(func, wait, options) {
      var lastArgs,
          lastThis,
          maxWait,
          result,
          timerId,
          lastCallTime,
          lastInvokeTime = 0,
          leading = false,
          maxing = false,
          trailing = true;

      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      wait = toNumber(wait) || 0;
      if (isObject(options)) {
        leading = !!options.leading;
        maxing = 'maxWait' in options;
        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
        trailing = 'trailing' in options ? !!options.trailing : trailing;
      }

      function invokeFunc(time) {
        var args = lastArgs,
            thisArg = lastThis;

        lastArgs = lastThis = undefined;
        lastInvokeTime = time;
        result = func.apply(thisArg, args);
        return result;
      }

      function leadingEdge(time) {
        // Reset any `maxWait` timer.
        lastInvokeTime = time;
        // Start the timer for the trailing edge.
        timerId = setTimeout(timerExpired, wait);
        // Invoke the leading edge.
        return leading ? invokeFunc(time) : result;
      }

      function remainingWait(time) {
        var timeSinceLastCall = time - lastCallTime,
            timeSinceLastInvoke = time - lastInvokeTime,
            timeWaiting = wait - timeSinceLastCall;

        return maxing
          ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)
          : timeWaiting;
      }

      function shouldInvoke(time) {
        var timeSinceLastCall = time - lastCallTime,
            timeSinceLastInvoke = time - lastInvokeTime;

        // Either this is the first call, activity has stopped and we're at the
        // trailing edge, the system time has gone backwards and we're treating
        // it as the trailing edge, or we've hit the `maxWait` limit.
        return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
          (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
      }

      function timerExpired() {
        var time = now();
        if (shouldInvoke(time)) {
          return trailingEdge(time);
        }
        // Restart the timer.
        timerId = setTimeout(timerExpired, remainingWait(time));
      }

      function trailingEdge(time) {
        timerId = undefined;

        // Only invoke if we have `lastArgs` which means `func` has been
        // debounced at least once.
        if (trailing && lastArgs) {
          return invokeFunc(time);
        }
        lastArgs = lastThis = undefined;
        return result;
      }

      function cancel() {
        if (timerId !== undefined) {
          clearTimeout(timerId);
        }
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = undefined;
      }

      function flush() {
        return timerId === undefined ? result : trailingEdge(now());
      }

      function debounced() {
        var time = now(),
            isInvoking = shouldInvoke(time);

        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time;

        if (isInvoking) {
          if (timerId === undefined) {
            return leadingEdge(lastCallTime);
          }
          if (maxing) {
            // Handle invocations in a tight loop.
            clearTimeout(timerId);
            timerId = setTimeout(timerExpired, wait);
            return invokeFunc(lastCallTime);
          }
        }
        if (timerId === undefined) {
          timerId = setTimeout(timerExpired, wait);
        }
        return result;
      }
      debounced.cancel = cancel;
      debounced.flush = flush;
      return debounced;
    }

    /**
     * Defers invoking the `func` until the current call stack has cleared. Any
     * additional arguments are provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to defer.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.defer(function(text) {
     *   console.log(text);
     * }, 'deferred');
     * // => Logs 'deferred' after one millisecond.
     */
    var defer = baseRest(function(func, args) {
      return baseDelay(func, 1, args);
    });

    /**
     * Invokes `func` after `wait` milliseconds. Any additional arguments are
     * provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.delay(function(text) {
     *   console.log(text);
     * }, 1000, 'later');
     * // => Logs 'later' after one second.
     */
    var delay = baseRest(function(func, wait, args) {
      return baseDelay(func, toNumber(wait) || 0, args);
    });

    /**
     * Creates a function that invokes `func` with arguments reversed.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to flip arguments for.
     * @returns {Function} Returns the new flipped function.
     * @example
     *
     * var flipped = _.flip(function() {
     *   return _.toArray(arguments);
     * });
     *
     * flipped('a', 'b', 'c', 'd');
     * // => ['d', 'c', 'b', 'a']
     */
    function flip(func) {
      return createWrap(func, WRAP_FLIP_FLAG);
    }

    /**
     * Creates a function that memoizes the result of `func`. If `resolver` is
     * provided, it determines the cache key for storing the result based on the
     * arguments provided to the memoized function. By default, the first argument
     * provided to the memoized function is used as the map cache key. The `func`
     * is invoked with the `this` binding of the memoized function.
     *
     * **Note:** The cache is exposed as the `cache` property on the memoized
     * function. Its creation may be customized by replacing the `_.memoize.Cache`
     * constructor with one whose instances implement the
     * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
     * method interface of `clear`, `delete`, `get`, `has`, and `set`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to have its output memoized.
     * @param {Function} [resolver] The function to resolve the cache key.
     * @returns {Function} Returns the new memoized function.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     * var other = { 'c': 3, 'd': 4 };
     *
     * var values = _.memoize(_.values);
     * values(object);
     * // => [1, 2]
     *
     * values(other);
     * // => [3, 4]
     *
     * object.a = 2;
     * values(object);
     * // => [1, 2]
     *
     * // Modify the result cache.
     * values.cache.set(object, ['a', 'b']);
     * values(object);
     * // => ['a', 'b']
     *
     * // Replace `_.memoize.Cache`.
     * _.memoize.Cache = WeakMap;
     */
    function memoize(func, resolver) {
      if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments,
            key = resolver ? resolver.apply(this, args) : args[0],
            cache = memoized.cache;

        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result) || cache;
        return result;
      };
      memoized.cache = new (memoize.Cache || MapCache);
      return memoized;
    }

    // Expose `MapCache`.
    memoize.Cache = MapCache;

    /**
     * Creates a function that negates the result of the predicate `func`. The
     * `func` predicate is invoked with the `this` binding and arguments of the
     * created function.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} predicate The predicate to negate.
     * @returns {Function} Returns the new negated function.
     * @example
     *
     * function isEven(n) {
     *   return n % 2 == 0;
     * }
     *
     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
     * // => [1, 3, 5]
     */
    function negate(predicate) {
      if (typeof predicate != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return function() {
        var args = arguments;
        switch (args.length) {
          case 0: return !predicate.call(this);
          case 1: return !predicate.call(this, args[0]);
          case 2: return !predicate.call(this, args[0], args[1]);
          case 3: return !predicate.call(this, args[0], args[1], args[2]);
        }
        return !predicate.apply(this, args);
      };
    }

    /**
     * Creates a function that is restricted to invoking `func` once. Repeat calls
     * to the function return the value of the first invocation. The `func` is
     * invoked with the `this` binding and arguments of the created function.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var initialize = _.once(createApplication);
     * initialize();
     * initialize();
     * // => `createApplication` is invoked once
     */
    function once(func) {
      return before(2, func);
    }

    /**
     * Creates a function that invokes `func` with its arguments transformed.
     *
     * @static
     * @since 4.0.0
     * @memberOf _
     * @category Function
     * @param {Function} func The function to wrap.
     * @param {...(Function|Function[])} [transforms=[_.identity]]
     *  The argument transforms.
     * @returns {Function} Returns the new function.
     * @example
     *
     * function doubled(n) {
     *   return n * 2;
     * }
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var func = _.overArgs(function(x, y) {
     *   return [x, y];
     * }, [square, doubled]);
     *
     * func(9, 3);
     * // => [81, 6]
     *
     * func(10, 5);
     * // => [100, 10]
     */
    var overArgs = castRest(function(func, transforms) {
      transforms = (transforms.length == 1 && isArray(transforms[0]))
        ? arrayMap(transforms[0], baseUnary(getIteratee()))
        : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));

      var funcsLength = transforms.length;
      return baseRest(function(args) {
        var index = -1,
            length = nativeMin(args.length, funcsLength);

        while (++index < length) {
          args[index] = transforms[index].call(this, args[index]);
        }
        return apply(func, this, args);
      });
    });

    /**
     * Creates a function that invokes `func` with `partials` prepended to the
     * arguments it receives. This method is like `_.bind` except it does **not**
     * alter the `this` binding.
     *
     * The `_.partial.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method doesn't set the "length" property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @since 0.2.0
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * function greet(greeting, name) {
     *   return greeting + ' ' + name;
     * }
     *
     * var sayHelloTo = _.partial(greet, 'hello');
     * sayHelloTo('fred');
     * // => 'hello fred'
     *
     * // Partially applied with placeholders.
     * var greetFred = _.partial(greet, _, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     */
    var partial = baseRest(function(func, partials) {
      var holders = replaceHolders(partials, getHolder(partial));
      return createWrap(func, WRAP_PARTIAL_FLAG, undefined, partials, holders);
    });

    /**
     * This method is like `_.partial` except that partially applied arguments
     * are appended to the arguments it receives.
     *
     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method doesn't set the "length" property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * function greet(greeting, name) {
     *   return greeting + ' ' + name;
     * }
     *
     * var greetFred = _.partialRight(greet, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     *
     * // Partially applied with placeholders.
     * var sayHelloTo = _.partialRight(greet, 'hello', _);
     * sayHelloTo('fred');
     * // => 'hello fred'
     */
    var partialRight = baseRest(function(func, partials) {
      var holders = replaceHolders(partials, getHolder(partialRight));
      return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined, partials, holders);
    });

    /**
     * Creates a function that invokes `func` with arguments arranged according
     * to the specified `indexes` where the argument value at the first index is
     * provided as the first argument, the argument value at the second index is
     * provided as the second argument, and so on.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to rearrange arguments for.
     * @param {...(number|number[])} indexes The arranged argument indexes.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var rearged = _.rearg(function(a, b, c) {
     *   return [a, b, c];
     * }, [2, 0, 1]);
     *
     * rearged('b', 'c', 'a')
     * // => ['a', 'b', 'c']
     */
    var rearg = flatRest(function(func, indexes) {
      return createWrap(func, WRAP_REARG_FLAG, undefined, undefined, undefined, indexes);
    });

    /**
     * Creates a function that invokes `func` with the `this` binding of the
     * created function and arguments from `start` and beyond provided as
     * an array.
     *
     * **Note:** This method is based on the
     * [rest parameter](https://mdn.io/rest_parameters).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.rest(function(what, names) {
     *   return what + ' ' + _.initial(names).join(', ') +
     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
     * });
     *
     * say('hello', 'fred', 'barney', 'pebbles');
     * // => 'hello fred, barney, & pebbles'
     */
    function rest(func, start) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      start = start === undefined ? start : toInteger(start);
      return baseRest(func, start);
    }

    /**
     * Creates a function that invokes `func` with the `this` binding of the
     * create function and an array of arguments much like
     * [`Function#apply`](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.apply).
     *
     * **Note:** This method is based on the
     * [spread operator](https://mdn.io/spread_operator).
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Function
     * @param {Function} func The function to spread arguments over.
     * @param {number} [start=0] The start position of the spread.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.spread(function(who, what) {
     *   return who + ' says ' + what;
     * });
     *
     * say(['fred', 'hello']);
     * // => 'fred says hello'
     *
     * var numbers = Promise.all([
     *   Promise.resolve(40),
     *   Promise.resolve(36)
     * ]);
     *
     * numbers.then(_.spread(function(x, y) {
     *   return x + y;
     * }));
     * // => a Promise of 76
     */
    function spread(func, start) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      start = start == null ? 0 : nativeMax(toInteger(start), 0);
      return baseRest(function(args) {
        var array = args[start],
            otherArgs = castSlice(args, 0, start);

        if (array) {
          arrayPush(otherArgs, array);
        }
        return apply(func, this, otherArgs);
      });
    }

    /**
     * Creates a throttled function that only invokes `func` at most once per
     * every `wait` milliseconds. The throttled function comes with a `cancel`
     * method to cancel delayed `func` invocations and a `flush` method to
     * immediately invoke them. Provide `options` to indicate whether `func`
     * should be invoked on the leading and/or trailing edge of the `wait`
     * timeout. The `func` is invoked with the last arguments provided to the
     * throttled function. Subsequent calls to the throttled function return the
     * result of the last `func` invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is
     * invoked on the trailing edge of the timeout only if the throttled function
     * is invoked more than once during the `wait` timeout.
     *
     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
     *
     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
     * for details over the differences between `_.throttle` and `_.debounce`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to throttle.
     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.leading=true]
     *  Specify invoking on the leading edge of the timeout.
     * @param {boolean} [options.trailing=true]
     *  Specify invoking on the trailing edge of the timeout.
     * @returns {Function} Returns the new throttled function.
     * @example
     *
     * // Avoid excessively updating the position while scrolling.
     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
     *
     * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
     * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
     * jQuery(element).on('click', throttled);
     *
     * // Cancel the trailing throttled invocation.
     * jQuery(window).on('popstate', throttled.cancel);
     */
    function throttle(func, wait, options) {
      var leading = true,
          trailing = true;

      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      if (isObject(options)) {
        leading = 'leading' in options ? !!options.leading : leading;
        trailing = 'trailing' in options ? !!options.trailing : trailing;
      }
      return debounce(func, wait, {
        'leading': leading,
        'maxWait': wait,
        'trailing': trailing
      });
    }

    /**
     * Creates a function that accepts up to one argument, ignoring any
     * additional arguments.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to cap arguments for.
     * @returns {Function} Returns the new capped function.
     * @example
     *
     * _.map(['6', '8', '10'], _.unary(parseInt));
     * // => [6, 8, 10]
     */
    function unary(func) {
      return ary(func, 1);
    }

    /**
     * Creates a function that provides `value` to `wrapper` as its first
     * argument. Any additional arguments provided to the function are appended
     * to those provided to the `wrapper`. The wrapper is invoked with the `this`
     * binding of the created function.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {*} value The value to wrap.
     * @param {Function} [wrapper=identity] The wrapper function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var p = _.wrap(_.escape, function(func, text) {
     *   return '<p>' + func(text) + '</p>';
     * });
     *
     * p('fred, barney, & pebbles');
     * // => '<p>fred, barney, &amp; pebbles</p>'
     */
    function wrap(value, wrapper) {
      return partial(castFunction(wrapper), value);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Casts `value` as an array if it's not one.
     *
     * @static
     * @memberOf _
     * @since 4.4.0
     * @category Lang
     * @param {*} value The value to inspect.
     * @returns {Array} Returns the cast array.
     * @example
     *
     * _.castArray(1);
     * // => [1]
     *
     * _.castArray({ 'a': 1 });
     * // => [{ 'a': 1 }]
     *
     * _.castArray('abc');
     * // => ['abc']
     *
     * _.castArray(null);
     * // => [null]
     *
     * _.castArray(undefined);
     * // => [undefined]
     *
     * _.castArray();
     * // => []
     *
     * var array = [1, 2, 3];
     * console.log(_.castArray(array) === array);
     * // => true
     */
    function castArray() {
      if (!arguments.length) {
        return [];
      }
      var value = arguments[0];
      return isArray(value) ? value : [value];
    }

    /**
     * Creates a shallow clone of `value`.
     *
     * **Note:** This method is loosely based on the
     * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
     * and supports cloning arrays, array buffers, booleans, date objects, maps,
     * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
     * arrays. The own enumerable properties of `arguments` objects are cloned
     * as plain objects. An empty object is returned for uncloneable values such
     * as error objects, functions, DOM nodes, and WeakMaps.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to clone.
     * @returns {*} Returns the cloned value.
     * @see _.cloneDeep
     * @example
     *
     * var objects = [{ 'a': 1 }, { 'b': 2 }];
     *
     * var shallow = _.clone(objects);
     * console.log(shallow[0] === objects[0]);
     * // => true
     */
    function clone(value) {
      return baseClone(value, CLONE_SYMBOLS_FLAG);
    }

    /**
     * This method is like `_.clone` except that it accepts `customizer` which
     * is invoked to produce the cloned value. If `customizer` returns `undefined`,
     * cloning is handled by the method instead. The `customizer` is invoked with
     * up to four arguments; (value [, index|key, object, stack]).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to clone.
     * @param {Function} [customizer] The function to customize cloning.
     * @returns {*} Returns the cloned value.
     * @see _.cloneDeepWith
     * @example
     *
     * function customizer(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(false);
     *   }
     * }
     *
     * var el = _.cloneWith(document.body, customizer);
     *
     * console.log(el === document.body);
     * // => false
     * console.log(el.nodeName);
     * // => 'BODY'
     * console.log(el.childNodes.length);
     * // => 0
     */
    function cloneWith(value, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
    }

    /**
     * This method is like `_.clone` except that it recursively clones `value`.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Lang
     * @param {*} value The value to recursively clone.
     * @returns {*} Returns the deep cloned value.
     * @see _.clone
     * @example
     *
     * var objects = [{ 'a': 1 }, { 'b': 2 }];
     *
     * var deep = _.cloneDeep(objects);
     * console.log(deep[0] === objects[0]);
     * // => false
     */
    function cloneDeep(value) {
      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
    }

    /**
     * This method is like `_.cloneWith` except that it recursively clones `value`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to recursively clone.
     * @param {Function} [customizer] The function to customize cloning.
     * @returns {*} Returns the deep cloned value.
     * @see _.cloneWith
     * @example
     *
     * function customizer(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(true);
     *   }
     * }
     *
     * var el = _.cloneDeepWith(document.body, customizer);
     *
     * console.log(el === document.body);
     * // => false
     * console.log(el.nodeName);
     * // => 'BODY'
     * console.log(el.childNodes.length);
     * // => 20
     */
    function cloneDeepWith(value, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
    }

    /**
     * Checks if `object` conforms to `source` by invoking the predicate
     * properties of `source` with the corresponding property values of `object`.
     *
     * **Note:** This method is equivalent to `_.conforms` when `source` is
     * partially applied.
     *
     * @static
     * @memberOf _
     * @since 4.14.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property predicates to conform to.
     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     *
     * _.conformsTo(object, { 'b': function(n) { return n > 1; } });
     * // => true
     *
     * _.conformsTo(object, { 'b': function(n) { return n > 2; } });
     * // => false
     */
    function conformsTo(object, source) {
      return source == null || baseConformsTo(object, source, keys(source));
    }

    /**
     * Performs a
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * comparison between two values to determine if they are equivalent.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.eq(object, object);
     * // => true
     *
     * _.eq(object, other);
     * // => false
     *
     * _.eq('a', 'a');
     * // => true
     *
     * _.eq('a', Object('a'));
     * // => false
     *
     * _.eq(NaN, NaN);
     * // => true
     */
    function eq(value, other) {
      return value === other || (value !== value && other !== other);
    }

    /**
     * Checks if `value` is greater than `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than `other`,
     *  else `false`.
     * @see _.lt
     * @example
     *
     * _.gt(3, 1);
     * // => true
     *
     * _.gt(3, 3);
     * // => false
     *
     * _.gt(1, 3);
     * // => false
     */
    var gt = createRelationalOperation(baseGt);

    /**
     * Checks if `value` is greater than or equal to `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than or equal to
     *  `other`, else `false`.
     * @see _.lte
     * @example
     *
     * _.gte(3, 1);
     * // => true
     *
     * _.gte(3, 3);
     * // => true
     *
     * _.gte(1, 3);
     * // => false
     */
    var gte = createRelationalOperation(function(value, other) {
      return value >= other;
    });

    /**
     * Checks if `value` is likely an `arguments` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     *  else `false`.
     * @example
     *
     * _.isArguments(function() { return arguments; }());
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */
    var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
        !propertyIsEnumerable.call(value, 'callee');
    };

    /**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array, else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * _.isArray(document.body.children);
     * // => false
     *
     * _.isArray('abc');
     * // => false
     *
     * _.isArray(_.noop);
     * // => false
     */
    var isArray = Array.isArray;

    /**
     * Checks if `value` is classified as an `ArrayBuffer` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
     * @example
     *
     * _.isArrayBuffer(new ArrayBuffer(2));
     * // => true
     *
     * _.isArrayBuffer(new Array(2));
     * // => false
     */
    var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;

    /**
     * Checks if `value` is array-like. A value is considered array-like if it's
     * not a function and has a `value.length` that's an integer greater than or
     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
     * @example
     *
     * _.isArrayLike([1, 2, 3]);
     * // => true
     *
     * _.isArrayLike(document.body.children);
     * // => true
     *
     * _.isArrayLike('abc');
     * // => true
     *
     * _.isArrayLike(_.noop);
     * // => false
     */
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }

    /**
     * This method is like `_.isArrayLike` except that it also checks if `value`
     * is an object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array-like object,
     *  else `false`.
     * @example
     *
     * _.isArrayLikeObject([1, 2, 3]);
     * // => true
     *
     * _.isArrayLikeObject(document.body.children);
     * // => true
     *
     * _.isArrayLikeObject('abc');
     * // => false
     *
     * _.isArrayLikeObject(_.noop);
     * // => false
     */
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }

    /**
     * Checks if `value` is classified as a boolean primitive or object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.
     * @example
     *
     * _.isBoolean(false);
     * // => true
     *
     * _.isBoolean(null);
     * // => false
     */
    function isBoolean(value) {
      return value === true || value === false ||
        (isObjectLike(value) && baseGetTag(value) == boolTag);
    }

    /**
     * Checks if `value` is a buffer.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
     * @example
     *
     * _.isBuffer(new Buffer(2));
     * // => true
     *
     * _.isBuffer(new Uint8Array(2));
     * // => false
     */
    var isBuffer = nativeIsBuffer || stubFalse;

    /**
     * Checks if `value` is classified as a `Date` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
     * @example
     *
     * _.isDate(new Date);
     * // => true
     *
     * _.isDate('Mon April 23 2012');
     * // => false
     */
    var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;

    /**
     * Checks if `value` is likely a DOM element.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
     * @example
     *
     * _.isElement(document.body);
     * // => true
     *
     * _.isElement('<body>');
     * // => false
     */
    function isElement(value) {
      return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
    }

    /**
     * Checks if `value` is an empty object, collection, map, or set.
     *
     * Objects are considered empty if they have no own enumerable string keyed
     * properties.
     *
     * Array-like values such as `arguments` objects, arrays, buffers, strings, or
     * jQuery-like collections are considered empty if they have a `length` of `0`.
     * Similarly, maps and sets are considered empty if they have a `size` of `0`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is empty, else `false`.
     * @example
     *
     * _.isEmpty(null);
     * // => true
     *
     * _.isEmpty(true);
     * // => true
     *
     * _.isEmpty(1);
     * // => true
     *
     * _.isEmpty([1, 2, 3]);
     * // => false
     *
     * _.isEmpty({ 'a': 1 });
     * // => false
     */
    function isEmpty(value) {
      if (value == null) {
        return true;
      }
      if (isArrayLike(value) &&
          (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||
            isBuffer(value) || isTypedArray(value) || isArguments(value))) {
        return !value.length;
      }
      var tag = getTag(value);
      if (tag == mapTag || tag == setTag) {
        return !value.size;
      }
      if (isPrototype(value)) {
        return !baseKeys(value).length;
      }
      for (var key in value) {
        if (hasOwnProperty.call(value, key)) {
          return false;
        }
      }
      return true;
    }

    /**
     * Performs a deep comparison between two values to determine if they are
     * equivalent.
     *
     * **Note:** This method supports comparing arrays, array buffers, booleans,
     * date objects, error objects, maps, numbers, `Object` objects, regexes,
     * sets, strings, symbols, and typed arrays. `Object` objects are compared
     * by their own, not inherited, enumerable properties. Functions and DOM
     * nodes are compared by strict equality, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.isEqual(object, other);
     * // => true
     *
     * object === other;
     * // => false
     */
    function isEqual(value, other) {
      return baseIsEqual(value, other);
    }

    /**
     * This method is like `_.isEqual` except that it accepts `customizer` which
     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
     * are handled by the method instead. The `customizer` is invoked with up to
     * six arguments: (objValue, othValue [, index|key, object, other, stack]).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * function isGreeting(value) {
     *   return /^h(?:i|ello)$/.test(value);
     * }
     *
     * function customizer(objValue, othValue) {
     *   if (isGreeting(objValue) && isGreeting(othValue)) {
     *     return true;
     *   }
     * }
     *
     * var array = ['hello', 'goodbye'];
     * var other = ['hi', 'goodbye'];
     *
     * _.isEqualWith(array, other, customizer);
     * // => true
     */
    function isEqualWith(value, other, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      var result = customizer ? customizer(value, other) : undefined;
      return result === undefined ? baseIsEqual(value, other, undefined, customizer) : !!result;
    }

    /**
     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
     * `SyntaxError`, `TypeError`, or `URIError` object.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
     * @example
     *
     * _.isError(new Error);
     * // => true
     *
     * _.isError(Error);
     * // => false
     */
    function isError(value) {
      if (!isObjectLike(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == errorTag || tag == domExcTag ||
        (typeof value.message == 'string' && typeof value.name == 'string' && !isPlainObject(value));
    }

    /**
     * Checks if `value` is a finite primitive number.
     *
     * **Note:** This method is based on
     * [`Number.isFinite`](https://mdn.io/Number/isFinite).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
     * @example
     *
     * _.isFinite(3);
     * // => true
     *
     * _.isFinite(Number.MIN_VALUE);
     * // => true
     *
     * _.isFinite(Infinity);
     * // => false
     *
     * _.isFinite('3');
     * // => false
     */
    function isFinite(value) {
      return typeof value == 'number' && nativeIsFinite(value);
    }

    /**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a function, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */
    function isFunction(value) {
      if (!isObject(value)) {
        return false;
      }
      // The use of `Object#toString` avoids issues with the `typeof` operator
      // in Safari 9 which returns 'object' for typed arrays and other constructors.
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }

    /**
     * Checks if `value` is an integer.
     *
     * **Note:** This method is based on
     * [`Number.isInteger`](https://mdn.io/Number/isInteger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an integer, else `false`.
     * @example
     *
     * _.isInteger(3);
     * // => true
     *
     * _.isInteger(Number.MIN_VALUE);
     * // => false
     *
     * _.isInteger(Infinity);
     * // => false
     *
     * _.isInteger('3');
     * // => false
     */
    function isInteger(value) {
      return typeof value == 'number' && value == toInteger(value);
    }

    /**
     * Checks if `value` is a valid array-like length.
     *
     * **Note:** This method is loosely based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
     * @example
     *
     * _.isLength(3);
     * // => true
     *
     * _.isLength(Number.MIN_VALUE);
     * // => false
     *
     * _.isLength(Infinity);
     * // => false
     *
     * _.isLength('3');
     * // => false
     */
    function isLength(value) {
      return typeof value == 'number' &&
        value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }

    /**
     * Checks if `value` is the
     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(_.noop);
     * // => true
     *
     * _.isObject(null);
     * // => false
     */
    function isObject(value) {
      var type = typeof value;
      return value != null && (type == 'object' || type == 'function');
    }

    /**
     * Checks if `value` is object-like. A value is object-like if it's not `null`
     * and has a `typeof` result of "object".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
     * @example
     *
     * _.isObjectLike({});
     * // => true
     *
     * _.isObjectLike([1, 2, 3]);
     * // => true
     *
     * _.isObjectLike(_.noop);
     * // => false
     *
     * _.isObjectLike(null);
     * // => false
     */
    function isObjectLike(value) {
      return value != null && typeof value == 'object';
    }

    /**
     * Checks if `value` is classified as a `Map` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
     * @example
     *
     * _.isMap(new Map);
     * // => true
     *
     * _.isMap(new WeakMap);
     * // => false
     */
    var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

    /**
     * Performs a partial deep comparison between `object` and `source` to
     * determine if `object` contains equivalent property values.
     *
     * **Note:** This method is equivalent to `_.matches` when `source` is
     * partially applied.
     *
     * Partial comparisons will match empty array and empty object `source`
     * values against any array or object value, respectively. See `_.isEqual`
     * for a list of supported value comparisons.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     *
     * _.isMatch(object, { 'b': 2 });
     * // => true
     *
     * _.isMatch(object, { 'b': 1 });
     * // => false
     */
    function isMatch(object, source) {
      return object === source || baseIsMatch(object, source, getMatchData(source));
    }

    /**
     * This method is like `_.isMatch` except that it accepts `customizer` which
     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
     * are handled by the method instead. The `customizer` is invoked with five
     * arguments: (objValue, srcValue, index|key, object, source).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     * @example
     *
     * function isGreeting(value) {
     *   return /^h(?:i|ello)$/.test(value);
     * }
     *
     * function customizer(objValue, srcValue) {
     *   if (isGreeting(objValue) && isGreeting(srcValue)) {
     *     return true;
     *   }
     * }
     *
     * var object = { 'greeting': 'hello' };
     * var source = { 'greeting': 'hi' };
     *
     * _.isMatchWith(object, source, customizer);
     * // => true
     */
    function isMatchWith(object, source, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return baseIsMatch(object, source, getMatchData(source), customizer);
    }

    /**
     * Checks if `value` is `NaN`.
     *
     * **Note:** This method is based on
     * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as
     * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for
     * `undefined` and other non-number values.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
     * @example
     *
     * _.isNaN(NaN);
     * // => true
     *
     * _.isNaN(new Number(NaN));
     * // => true
     *
     * isNaN(undefined);
     * // => true
     *
     * _.isNaN(undefined);
     * // => false
     */
    function isNaN(value) {
      // An `NaN` primitive is the only value that is not equal to itself.
      // Perform the `toStringTag` check first to avoid errors with some
      // ActiveX objects in IE.
      return isNumber(value) && value != +value;
    }

    /**
     * Checks if `value` is a pristine native function.
     *
     * **Note:** This method can't reliably detect native functions in the presence
     * of the core-js package because core-js circumvents this kind of detection.
     * Despite multiple requests, the core-js maintainer has made it clear: any
     * attempt to fix the detection will be obstructed. As a result, we're left
     * with little choice but to throw an error. Unfortunately, this also affects
     * packages, like [babel-polyfill](https://www.npmjs.com/package/babel-polyfill),
     * which rely on core-js.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     * @example
     *
     * _.isNative(Array.prototype.push);
     * // => true
     *
     * _.isNative(_);
     * // => false
     */
    function isNative(value) {
      if (isMaskable(value)) {
        throw new Error(CORE_ERROR_TEXT);
      }
      return baseIsNative(value);
    }

    /**
     * Checks if `value` is `null`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
     * @example
     *
     * _.isNull(null);
     * // => true
     *
     * _.isNull(void 0);
     * // => false
     */
    function isNull(value) {
      return value === null;
    }

    /**
     * Checks if `value` is `null` or `undefined`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
     * @example
     *
     * _.isNil(null);
     * // => true
     *
     * _.isNil(void 0);
     * // => true
     *
     * _.isNil(NaN);
     * // => false
     */
    function isNil(value) {
      return value == null;
    }

    /**
     * Checks if `value` is classified as a `Number` primitive or object.
     *
     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
     * classified as numbers, use the `_.isFinite` method.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a number, else `false`.
     * @example
     *
     * _.isNumber(3);
     * // => true
     *
     * _.isNumber(Number.MIN_VALUE);
     * // => true
     *
     * _.isNumber(Infinity);
     * // => true
     *
     * _.isNumber('3');
     * // => false
     */
    function isNumber(value) {
      return typeof value == 'number' ||
        (isObjectLike(value) && baseGetTag(value) == numberTag);
    }

    /**
     * Checks if `value` is a plain object, that is, an object created by the
     * `Object` constructor or one with a `[[Prototype]]` of `null`.
     *
     * @static
     * @memberOf _
     * @since 0.8.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * _.isPlainObject(new Foo);
     * // => false
     *
     * _.isPlainObject([1, 2, 3]);
     * // => false
     *
     * _.isPlainObject({ 'x': 0, 'y': 0 });
     * // => true
     *
     * _.isPlainObject(Object.create(null));
     * // => true
     */
    function isPlainObject(value) {
      if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
        return false;
      }
      var proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
      return typeof Ctor == 'function' && Ctor instanceof Ctor &&
        funcToString.call(Ctor) == objectCtorString;
    }

    /**
     * Checks if `value` is classified as a `RegExp` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
     * @example
     *
     * _.isRegExp(/abc/);
     * // => true
     *
     * _.isRegExp('/abc/');
     * // => false
     */
    var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;

    /**
     * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754
     * double precision number which isn't the result of a rounded unsafe integer.
     *
     * **Note:** This method is based on
     * [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a safe integer, else `false`.
     * @example
     *
     * _.isSafeInteger(3);
     * // => true
     *
     * _.isSafeInteger(Number.MIN_VALUE);
     * // => false
     *
     * _.isSafeInteger(Infinity);
     * // => false
     *
     * _.isSafeInteger('3');
     * // => false
     */
    function isSafeInteger(value) {
      return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
    }

    /**
     * Checks if `value` is classified as a `Set` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
     * @example
     *
     * _.isSet(new Set);
     * // => true
     *
     * _.isSet(new WeakSet);
     * // => false
     */
    var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

    /**
     * Checks if `value` is classified as a `String` primitive or object.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a string, else `false`.
     * @example
     *
     * _.isString('abc');
     * // => true
     *
     * _.isString(1);
     * // => false
     */
    function isString(value) {
      return typeof value == 'string' ||
        (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);
    }

    /**
     * Checks if `value` is classified as a `Symbol` primitive or object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
     * @example
     *
     * _.isSymbol(Symbol.iterator);
     * // => true
     *
     * _.isSymbol('abc');
     * // => false
     */
    function isSymbol(value) {
      return typeof value == 'symbol' ||
        (isObjectLike(value) && baseGetTag(value) == symbolTag);
    }

    /**
     * Checks if `value` is classified as a typed array.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     * @example
     *
     * _.isTypedArray(new Uint8Array);
     * // => true
     *
     * _.isTypedArray([]);
     * // => false
     */
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

    /**
     * Checks if `value` is `undefined`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
     * @example
     *
     * _.isUndefined(void 0);
     * // => true
     *
     * _.isUndefined(null);
     * // => false
     */
    function isUndefined(value) {
      return value === undefined;
    }

    /**
     * Checks if `value` is classified as a `WeakMap` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a weak map, else `false`.
     * @example
     *
     * _.isWeakMap(new WeakMap);
     * // => true
     *
     * _.isWeakMap(new Map);
     * // => false
     */
    function isWeakMap(value) {
      return isObjectLike(value) && getTag(value) == weakMapTag;
    }

    /**
     * Checks if `value` is classified as a `WeakSet` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a weak set, else `false`.
     * @example
     *
     * _.isWeakSet(new WeakSet);
     * // => true
     *
     * _.isWeakSet(new Set);
     * // => false
     */
    function isWeakSet(value) {
      return isObjectLike(value) && baseGetTag(value) == weakSetTag;
    }

    /**
     * Checks if `value` is less than `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than `other`,
     *  else `false`.
     * @see _.gt
     * @example
     *
     * _.lt(1, 3);
     * // => true
     *
     * _.lt(3, 3);
     * // => false
     *
     * _.lt(3, 1);
     * // => false
     */
    var lt = createRelationalOperation(baseLt);

    /**
     * Checks if `value` is less than or equal to `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than or equal to
     *  `other`, else `false`.
     * @see _.gte
     * @example
     *
     * _.lte(1, 3);
     * // => true
     *
     * _.lte(3, 3);
     * // => true
     *
     * _.lte(3, 1);
     * // => false
     */
    var lte = createRelationalOperation(function(value, other) {
      return value <= other;
    });

    /**
     * Converts `value` to an array.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Array} Returns the converted array.
     * @example
     *
     * _.toArray({ 'a': 1, 'b': 2 });
     * // => [1, 2]
     *
     * _.toArray('abc');
     * // => ['a', 'b', 'c']
     *
     * _.toArray(1);
     * // => []
     *
     * _.toArray(null);
     * // => []
     */
    function toArray(value) {
      if (!value) {
        return [];
      }
      if (isArrayLike(value)) {
        return isString(value) ? stringToArray(value) : copyArray(value);
      }
      if (symIterator && value[symIterator]) {
        return iteratorToArray(value[symIterator]());
      }
      var tag = getTag(value),
          func = tag == mapTag ? mapToArray : (tag == setTag ? setToArray : values);

      return func(value);
    }

    /**
     * Converts `value` to a finite number.
     *
     * @static
     * @memberOf _
     * @since 4.12.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted number.
     * @example
     *
     * _.toFinite(3.2);
     * // => 3.2
     *
     * _.toFinite(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toFinite(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toFinite('3.2');
     * // => 3.2
     */
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign = (value < 0 ? -1 : 1);
        return sign * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }

    /**
     * Converts `value` to an integer.
     *
     * **Note:** This method is loosely based on
     * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toInteger(3.2);
     * // => 3
     *
     * _.toInteger(Number.MIN_VALUE);
     * // => 0
     *
     * _.toInteger(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toInteger('3.2');
     * // => 3
     */
    function toInteger(value) {
      var result = toFinite(value),
          remainder = result % 1;

      return result === result ? (remainder ? result - remainder : result) : 0;
    }

    /**
     * Converts `value` to an integer suitable for use as the length of an
     * array-like object.
     *
     * **Note:** This method is based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toLength(3.2);
     * // => 3
     *
     * _.toLength(Number.MIN_VALUE);
     * // => 0
     *
     * _.toLength(Infinity);
     * // => 4294967295
     *
     * _.toLength('3.2');
     * // => 3
     */
    function toLength(value) {
      return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
    }

    /**
     * Converts `value` to a number.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     * @example
     *
     * _.toNumber(3.2);
     * // => 3.2
     *
     * _.toNumber(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toNumber(Infinity);
     * // => Infinity
     *
     * _.toNumber('3.2');
     * // => 3.2
     */
    function toNumber(value) {
      if (typeof value == 'number') {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject(value)) {
        var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
        value = isObject(other) ? (other + '') : other;
      }
      if (typeof value != 'string') {
        return value === 0 ? value : +value;
      }
      value = baseTrim(value);
      var isBinary = reIsBinary.test(value);
      return (isBinary || reIsOctal.test(value))
        ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
        : (reIsBadHex.test(value) ? NAN : +value);
    }

    /**
     * Converts `value` to a plain object flattening inherited enumerable string
     * keyed properties of `value` to own properties of the plain object.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Object} Returns the converted plain object.
     * @example
     *
     * function Foo() {
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.assign({ 'a': 1 }, new Foo);
     * // => { 'a': 1, 'b': 2 }
     *
     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
     * // => { 'a': 1, 'b': 2, 'c': 3 }
     */
    function toPlainObject(value) {
      return copyObject(value, keysIn(value));
    }

    /**
     * Converts `value` to a safe integer. A safe integer can be compared and
     * represented correctly.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toSafeInteger(3.2);
     * // => 3
     *
     * _.toSafeInteger(Number.MIN_VALUE);
     * // => 0
     *
     * _.toSafeInteger(Infinity);
     * // => 9007199254740991
     *
     * _.toSafeInteger('3.2');
     * // => 3
     */
    function toSafeInteger(value) {
      return value
        ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER)
        : (value === 0 ? value : 0);
    }

    /**
     * Converts `value` to a string. An empty string is returned for `null`
     * and `undefined` values. The sign of `-0` is preserved.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.toString(null);
     * // => ''
     *
     * _.toString(-0);
     * // => '-0'
     *
     * _.toString([1, 2, 3]);
     * // => '1,2,3'
     */
    function toString(value) {
      return value == null ? '' : baseToString(value);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Assigns own enumerable string keyed properties of source objects to the
     * destination object. Source objects are applied from left to right.
     * Subsequent sources overwrite property assignments of previous sources.
     *
     * **Note:** This method mutates `object` and is loosely based on
     * [`Object.assign`](https://mdn.io/Object/assign).
     *
     * @static
     * @memberOf _
     * @since 0.10.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.assignIn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * function Bar() {
     *   this.c = 3;
     * }
     *
     * Foo.prototype.b = 2;
     * Bar.prototype.d = 4;
     *
     * _.assign({ 'a': 0 }, new Foo, new Bar);
     * // => { 'a': 1, 'c': 3 }
     */
    var assign = createAssigner(function(object, source) {
      if (isPrototype(source) || isArrayLike(source)) {
        copyObject(source, keys(source), object);
        return;
      }
      for (var key in source) {
        if (hasOwnProperty.call(source, key)) {
          assignValue(object, key, source[key]);
        }
      }
    });

    /**
     * This method is like `_.assign` except that it iterates over own and
     * inherited source properties.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias extend
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.assign
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * function Bar() {
     *   this.c = 3;
     * }
     *
     * Foo.prototype.b = 2;
     * Bar.prototype.d = 4;
     *
     * _.assignIn({ 'a': 0 }, new Foo, new Bar);
     * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }
     */
    var assignIn = createAssigner(function(object, source) {
      copyObject(source, keysIn(source), object);
    });

    /**
     * This method is like `_.assignIn` except that it accepts `customizer`
     * which is invoked to produce the assigned values. If `customizer` returns
     * `undefined`, assignment is handled by the method instead. The `customizer`
     * is invoked with five arguments: (objValue, srcValue, key, object, source).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias extendWith
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @see _.assignWith
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   return _.isUndefined(objValue) ? srcValue : objValue;
     * }
     *
     * var defaults = _.partialRight(_.assignInWith, customizer);
     *
     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */
    var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
      copyObject(source, keysIn(source), object, customizer);
    });

    /**
     * This method is like `_.assign` except that it accepts `customizer`
     * which is invoked to produce the assigned values. If `customizer` returns
     * `undefined`, assignment is handled by the method instead. The `customizer`
     * is invoked with five arguments: (objValue, srcValue, key, object, source).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @see _.assignInWith
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   return _.isUndefined(objValue) ? srcValue : objValue;
     * }
     *
     * var defaults = _.partialRight(_.assignWith, customizer);
     *
     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */
    var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
      copyObject(source, keys(source), object, customizer);
    });

    /**
     * Creates an array of values corresponding to `paths` of `object`.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Array} Returns the picked values.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
     *
     * _.at(object, ['a[0].b.c', 'a[1]']);
     * // => [3, 4]
     */
    var at = flatRest(baseAt);

    /**
     * Creates an object that inherits from the `prototype` object. If a
     * `properties` object is given, its own enumerable string keyed properties
     * are assigned to the created object.
     *
     * @static
     * @memberOf _
     * @since 2.3.0
     * @category Object
     * @param {Object} prototype The object to inherit from.
     * @param {Object} [properties] The properties to assign to the object.
     * @returns {Object} Returns the new object.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * function Circle() {
     *   Shape.call(this);
     * }
     *
     * Circle.prototype = _.create(Shape.prototype, {
     *   'constructor': Circle
     * });
     *
     * var circle = new Circle;
     * circle instanceof Circle;
     * // => true
     *
     * circle instanceof Shape;
     * // => true
     */
    function create(prototype, properties) {
      var result = baseCreate(prototype);
      return properties == null ? result : baseAssign(result, properties);
    }

    /**
     * Assigns own and inherited enumerable string keyed properties of source
     * objects to the destination object for all destination properties that
     * resolve to `undefined`. Source objects are applied from left to right.
     * Once a property is set, additional values of the same property are ignored.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.defaultsDeep
     * @example
     *
     * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */
    var defaults = baseRest(function(object, sources) {
      object = Object(object);

      var index = -1;
      var length = sources.length;
      var guard = length > 2 ? sources[2] : undefined;

      if (guard && isIterateeCall(sources[0], sources[1], guard)) {
        length = 1;
      }

      while (++index < length) {
        var source = sources[index];
        var props = keysIn(source);
        var propsIndex = -1;
        var propsLength = props.length;

        while (++propsIndex < propsLength) {
          var key = props[propsIndex];
          var value = object[key];

          if (value === undefined ||
              (eq(value, objectProto[key]) && !hasOwnProperty.call(object, key))) {
            object[key] = source[key];
          }
        }
      }

      return object;
    });

    /**
     * This method is like `_.defaults` except that it recursively assigns
     * default properties.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.defaults
     * @example
     *
     * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });
     * // => { 'a': { 'b': 2, 'c': 3 } }
     */
    var defaultsDeep = baseRest(function(args) {
      args.push(undefined, customDefaultsMerge);
      return apply(mergeWith, undefined, args);
    });

    /**
     * This method is like `_.find` except that it returns the key of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {string|undefined} Returns the key of the matched element,
     *  else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findKey(users, function(o) { return o.age < 40; });
     * // => 'barney' (iteration order is not guaranteed)
     *
     * // The `_.matches` iteratee shorthand.
     * _.findKey(users, { 'age': 1, 'active': true });
     * // => 'pebbles'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findKey(users, ['active', false]);
     * // => 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.findKey(users, 'active');
     * // => 'barney'
     */
    function findKey(object, predicate) {
      return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
    }

    /**
     * This method is like `_.findKey` except that it iterates over elements of
     * a collection in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {string|undefined} Returns the key of the matched element,
     *  else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findLastKey(users, function(o) { return o.age < 40; });
     * // => returns 'pebbles' assuming `_.findKey` returns 'barney'
     *
     * // The `_.matches` iteratee shorthand.
     * _.findLastKey(users, { 'age': 36, 'active': true });
     * // => 'barney'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findLastKey(users, ['active', false]);
     * // => 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.findLastKey(users, 'active');
     * // => 'pebbles'
     */
    function findLastKey(object, predicate) {
      return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
    }

    /**
     * Iterates over own and inherited enumerable string keyed properties of an
     * object and invokes `iteratee` for each property. The iteratee is invoked
     * with three arguments: (value, key, object). Iteratee functions may exit
     * iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 0.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forInRight
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forIn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).
     */
    function forIn(object, iteratee) {
      return object == null
        ? object
        : baseFor(object, getIteratee(iteratee, 3), keysIn);
    }

    /**
     * This method is like `_.forIn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forIn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forInRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'.
     */
    function forInRight(object, iteratee) {
      return object == null
        ? object
        : baseForRight(object, getIteratee(iteratee, 3), keysIn);
    }

    /**
     * Iterates over own enumerable string keyed properties of an object and
     * invokes `iteratee` for each property. The iteratee is invoked with three
     * arguments: (value, key, object). Iteratee functions may exit iteration
     * early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 0.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forOwnRight
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
     */
    function forOwn(object, iteratee) {
      return object && baseForOwn(object, getIteratee(iteratee, 3));
    }

    /**
     * This method is like `_.forOwn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forOwn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwnRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'.
     */
    function forOwnRight(object, iteratee) {
      return object && baseForOwnRight(object, getIteratee(iteratee, 3));
    }

    /**
     * Creates an array of function property names from own enumerable properties
     * of `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the function names.
     * @see _.functionsIn
     * @example
     *
     * function Foo() {
     *   this.a = _.constant('a');
     *   this.b = _.constant('b');
     * }
     *
     * Foo.prototype.c = _.constant('c');
     *
     * _.functions(new Foo);
     * // => ['a', 'b']
     */
    function functions(object) {
      return object == null ? [] : baseFunctions(object, keys(object));
    }

    /**
     * Creates an array of function property names from own and inherited
     * enumerable properties of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the function names.
     * @see _.functions
     * @example
     *
     * function Foo() {
     *   this.a = _.constant('a');
     *   this.b = _.constant('b');
     * }
     *
     * Foo.prototype.c = _.constant('c');
     *
     * _.functionsIn(new Foo);
     * // => ['a', 'b', 'c']
     */
    function functionsIn(object) {
      return object == null ? [] : baseFunctions(object, keysIn(object));
    }

    /**
     * Gets the value at `path` of `object`. If the resolved value is
     * `undefined`, the `defaultValue` is returned in its place.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.get(object, 'a[0].b.c');
     * // => 3
     *
     * _.get(object, ['a', '0', 'b', 'c']);
     * // => 3
     *
     * _.get(object, 'a.b.c', 'default');
     * // => 'default'
     */
    function get(object, path, defaultValue) {
      var result = object == null ? undefined : baseGet(object, path);
      return result === undefined ? defaultValue : result;
    }

    /**
     * Checks if `path` is a direct property of `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     * @example
     *
     * var object = { 'a': { 'b': 2 } };
     * var other = _.create({ 'a': _.create({ 'b': 2 }) });
     *
     * _.has(object, 'a');
     * // => true
     *
     * _.has(object, 'a.b');
     * // => true
     *
     * _.has(object, ['a', 'b']);
     * // => true
     *
     * _.has(other, 'a');
     * // => false
     */
    function has(object, path) {
      return object != null && hasPath(object, path, baseHas);
    }

    /**
     * Checks if `path` is a direct or inherited property of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     * @example
     *
     * var object = _.create({ 'a': _.create({ 'b': 2 }) });
     *
     * _.hasIn(object, 'a');
     * // => true
     *
     * _.hasIn(object, 'a.b');
     * // => true
     *
     * _.hasIn(object, ['a', 'b']);
     * // => true
     *
     * _.hasIn(object, 'b');
     * // => false
     */
    function hasIn(object, path) {
      return object != null && hasPath(object, path, baseHasIn);
    }

    /**
     * Creates an object composed of the inverted keys and values of `object`.
     * If `object` contains duplicate values, subsequent values overwrite
     * property assignments of previous values.
     *
     * @static
     * @memberOf _
     * @since 0.7.0
     * @category Object
     * @param {Object} object The object to invert.
     * @returns {Object} Returns the new inverted object.
     * @example
     *
     * var object = { 'a': 1, 'b': 2, 'c': 1 };
     *
     * _.invert(object);
     * // => { '1': 'c', '2': 'b' }
     */
    var invert = createInverter(function(result, value, key) {
      if (value != null &&
          typeof value.toString != 'function') {
        value = nativeObjectToString.call(value);
      }

      result[value] = key;
    }, constant(identity));

    /**
     * This method is like `_.invert` except that the inverted object is generated
     * from the results of running each element of `object` thru `iteratee`. The
     * corresponding inverted value of each inverted key is an array of keys
     * responsible for generating the inverted value. The iteratee is invoked
     * with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.1.0
     * @category Object
     * @param {Object} object The object to invert.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Object} Returns the new inverted object.
     * @example
     *
     * var object = { 'a': 1, 'b': 2, 'c': 1 };
     *
     * _.invertBy(object);
     * // => { '1': ['a', 'c'], '2': ['b'] }
     *
     * _.invertBy(object, function(value) {
     *   return 'group' + value;
     * });
     * // => { 'group1': ['a', 'c'], 'group2': ['b'] }
     */
    var invertBy = createInverter(function(result, value, key) {
      if (value != null &&
          typeof value.toString != 'function') {
        value = nativeObjectToString.call(value);
      }

      if (hasOwnProperty.call(result, value)) {
        result[value].push(key);
      } else {
        result[value] = [key];
      }
    }, getIteratee);

    /**
     * Invokes the method at `path` of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the method to invoke.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {*} Returns the result of the invoked method.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };
     *
     * _.invoke(object, 'a[0].b.c.slice', 1, 3);
     * // => [2, 3]
     */
    var invoke = baseRest(baseInvoke);

    /**
     * Creates an array of the own enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects. See the
     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * for more details.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keys(new Foo);
     * // => ['a', 'b'] (iteration order is not guaranteed)
     *
     * _.keys('hi');
     * // => ['0', '1']
     */
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }

    /**
     * Creates an array of the own and inherited enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keysIn(new Foo);
     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
     */
    function keysIn(object) {
      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
    }

    /**
     * The opposite of `_.mapValues`; this method creates an object with the
     * same values as `object` and keys generated by running each own enumerable
     * string keyed property of `object` thru `iteratee`. The iteratee is invoked
     * with three arguments: (value, key, object).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns the new mapped object.
     * @see _.mapValues
     * @example
     *
     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
     *   return key + value;
     * });
     * // => { 'a1': 1, 'b2': 2 }
     */
    function mapKeys(object, iteratee) {
      var result = {};
      iteratee = getIteratee(iteratee, 3);

      baseForOwn(object, function(value, key, object) {
        baseAssignValue(result, iteratee(value, key, object), value);
      });
      return result;
    }

    /**
     * Creates an object with the same keys as `object` and values generated
     * by running each own enumerable string keyed property of `object` thru
     * `iteratee`. The iteratee is invoked with three arguments:
     * (value, key, object).
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns the new mapped object.
     * @see _.mapKeys
     * @example
     *
     * var users = {
     *   'fred':    { 'user': 'fred',    'age': 40 },
     *   'pebbles': { 'user': 'pebbles', 'age': 1 }
     * };
     *
     * _.mapValues(users, function(o) { return o.age; });
     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
     *
     * // The `_.property` iteratee shorthand.
     * _.mapValues(users, 'age');
     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
     */
    function mapValues(object, iteratee) {
      var result = {};
      iteratee = getIteratee(iteratee, 3);

      baseForOwn(object, function(value, key, object) {
        baseAssignValue(result, key, iteratee(value, key, object));
      });
      return result;
    }

    /**
     * This method is like `_.assign` except that it recursively merges own and
     * inherited enumerable string keyed properties of source objects into the
     * destination object. Source properties that resolve to `undefined` are
     * skipped if a destination value exists. Array and plain object properties
     * are merged recursively. Other objects and value types are overridden by
     * assignment. Source objects are applied from left to right. Subsequent
     * sources overwrite property assignments of previous sources.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {
     *   'a': [{ 'b': 2 }, { 'd': 4 }]
     * };
     *
     * var other = {
     *   'a': [{ 'c': 3 }, { 'e': 5 }]
     * };
     *
     * _.merge(object, other);
     * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
     */
    var merge = createAssigner(function(object, source, srcIndex) {
      baseMerge(object, source, srcIndex);
    });

    /**
     * This method is like `_.merge` except that it accepts `customizer` which
     * is invoked to produce the merged values of the destination and source
     * properties. If `customizer` returns `undefined`, merging is handled by the
     * method instead. The `customizer` is invoked with six arguments:
     * (objValue, srcValue, key, object, source, stack).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} customizer The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   if (_.isArray(objValue)) {
     *     return objValue.concat(srcValue);
     *   }
     * }
     *
     * var object = { 'a': [1], 'b': [2] };
     * var other = { 'a': [3], 'b': [4] };
     *
     * _.mergeWith(object, other, customizer);
     * // => { 'a': [1, 3], 'b': [2, 4] }
     */
    var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
      baseMerge(object, source, srcIndex, customizer);
    });

    /**
     * The opposite of `_.pick`; this method creates an object composed of the
     * own and inherited enumerable property paths of `object` that are not omitted.
     *
     * **Note:** This method is considerably slower than `_.pick`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {...(string|string[])} [paths] The property paths to omit.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.omit(object, ['a', 'c']);
     * // => { 'b': '2' }
     */
    var omit = flatRest(function(object, paths) {
      var result = {};
      if (object == null) {
        return result;
      }
      var isDeep = false;
      paths = arrayMap(paths, function(path) {
        path = castPath(path, object);
        isDeep || (isDeep = path.length > 1);
        return path;
      });
      copyObject(object, getAllKeysIn(object), result);
      if (isDeep) {
        result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
      }
      var length = paths.length;
      while (length--) {
        baseUnset(result, paths[length]);
      }
      return result;
    });

    /**
     * The opposite of `_.pickBy`; this method creates an object composed of
     * the own and inherited enumerable string keyed properties of `object` that
     * `predicate` doesn't return truthy for. The predicate is invoked with two
     * arguments: (value, key).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The source object.
     * @param {Function} [predicate=_.identity] The function invoked per property.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.omitBy(object, _.isNumber);
     * // => { 'b': '2' }
     */
    function omitBy(object, predicate) {
      return pickBy(object, negate(getIteratee(predicate)));
    }

    /**
     * Creates an object composed of the picked `object` properties.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.pick(object, ['a', 'c']);
     * // => { 'a': 1, 'c': 3 }
     */
    var pick = flatRest(function(object, paths) {
      return object == null ? {} : basePick(object, paths);
    });

    /**
     * Creates an object composed of the `object` properties `predicate` returns
     * truthy for. The predicate is invoked with two arguments: (value, key).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The source object.
     * @param {Function} [predicate=_.identity] The function invoked per property.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.pickBy(object, _.isNumber);
     * // => { 'a': 1, 'c': 3 }
     */
    function pickBy(object, predicate) {
      if (object == null) {
        return {};
      }
      var props = arrayMap(getAllKeysIn(object), function(prop) {
        return [prop];
      });
      predicate = getIteratee(predicate);
      return basePickBy(object, props, function(value, path) {
        return predicate(value, path[0]);
      });
    }

    /**
     * This method is like `_.get` except that if the resolved value is a
     * function it's invoked with the `this` binding of its parent object and
     * its result is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to resolve.
     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
     *
     * _.result(object, 'a[0].b.c1');
     * // => 3
     *
     * _.result(object, 'a[0].b.c2');
     * // => 4
     *
     * _.result(object, 'a[0].b.c3', 'default');
     * // => 'default'
     *
     * _.result(object, 'a[0].b.c3', _.constant('default'));
     * // => 'default'
     */
    function result(object, path, defaultValue) {
      path = castPath(path, object);

      var index = -1,
          length = path.length;

      // Ensure the loop is entered when path is empty.
      if (!length) {
        length = 1;
        object = undefined;
      }
      while (++index < length) {
        var value = object == null ? undefined : object[toKey(path[index])];
        if (value === undefined) {
          index = length;
          value = defaultValue;
        }
        object = isFunction(value) ? value.call(object) : value;
      }
      return object;
    }

    /**
     * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
     * it's created. Arrays are created for missing index properties while objects
     * are created for all other missing properties. Use `_.setWith` to customize
     * `path` creation.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.set(object, 'a[0].b.c', 4);
     * console.log(object.a[0].b.c);
     * // => 4
     *
     * _.set(object, ['x', '0', 'y', 'z'], 5);
     * console.log(object.x[0].y.z);
     * // => 5
     */
    function set(object, path, value) {
      return object == null ? object : baseSet(object, path, value);
    }

    /**
     * This method is like `_.set` except that it accepts `customizer` which is
     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
     * path creation is handled by the method instead. The `customizer` is invoked
     * with three arguments: (nsValue, key, nsObject).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {};
     *
     * _.setWith(object, '[0][1]', 'a', Object);
     * // => { '0': { '1': 'a' } }
     */
    function setWith(object, path, value, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return object == null ? object : baseSet(object, path, value, customizer);
    }

    /**
     * Creates an array of own enumerable string keyed-value pairs for `object`
     * which can be consumed by `_.fromPairs`. If `object` is a map or set, its
     * entries are returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias entries
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the key-value pairs.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.toPairs(new Foo);
     * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)
     */
    var toPairs = createToPairs(keys);

    /**
     * Creates an array of own and inherited enumerable string keyed-value pairs
     * for `object` which can be consumed by `_.fromPairs`. If `object` is a map
     * or set, its entries are returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias entriesIn
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the key-value pairs.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.toPairsIn(new Foo);
     * // => [['a', 1], ['b', 2], ['c', 3]] (iteration order is not guaranteed)
     */
    var toPairsIn = createToPairs(keysIn);

    /**
     * An alternative to `_.reduce`; this method transforms `object` to a new
     * `accumulator` object which is the result of running each of its own
     * enumerable string keyed properties thru `iteratee`, with each invocation
     * potentially mutating the `accumulator` object. If `accumulator` is not
     * provided, a new object with the same `[[Prototype]]` will be used. The
     * iteratee is invoked with four arguments: (accumulator, value, key, object).
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 1.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The custom accumulator value.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * _.transform([2, 3, 4], function(result, n) {
     *   result.push(n *= n);
     *   return n % 2 == 0;
     * }, []);
     * // => [4, 9]
     *
     * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
     *   (result[value] || (result[value] = [])).push(key);
     * }, {});
     * // => { '1': ['a', 'c'], '2': ['b'] }
     */
    function transform(object, iteratee, accumulator) {
      var isArr = isArray(object),
          isArrLike = isArr || isBuffer(object) || isTypedArray(object);

      iteratee = getIteratee(iteratee, 4);
      if (accumulator == null) {
        var Ctor = object && object.constructor;
        if (isArrLike) {
          accumulator = isArr ? new Ctor : [];
        }
        else if (isObject(object)) {
          accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
        }
        else {
          accumulator = {};
        }
      }
      (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object) {
        return iteratee(accumulator, value, index, object);
      });
      return accumulator;
    }

    /**
     * Removes the property at `path` of `object`.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to unset.
     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 7 } }] };
     * _.unset(object, 'a[0].b.c');
     * // => true
     *
     * console.log(object);
     * // => { 'a': [{ 'b': {} }] };
     *
     * _.unset(object, ['a', '0', 'b', 'c']);
     * // => true
     *
     * console.log(object);
     * // => { 'a': [{ 'b': {} }] };
     */
    function unset(object, path) {
      return object == null ? true : baseUnset(object, path);
    }

    /**
     * This method is like `_.set` except that accepts `updater` to produce the
     * value to set. Use `_.updateWith` to customize `path` creation. The `updater`
     * is invoked with one argument: (value).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {Function} updater The function to produce the updated value.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.update(object, 'a[0].b.c', function(n) { return n * n; });
     * console.log(object.a[0].b.c);
     * // => 9
     *
     * _.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });
     * console.log(object.x[0].y.z);
     * // => 0
     */
    function update(object, path, updater) {
      return object == null ? object : baseUpdate(object, path, castFunction(updater));
    }

    /**
     * This method is like `_.update` except that it accepts `customizer` which is
     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
     * path creation is handled by the method instead. The `customizer` is invoked
     * with three arguments: (nsValue, key, nsObject).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {Function} updater The function to produce the updated value.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {};
     *
     * _.updateWith(object, '[0][1]', _.constant('a'), Object);
     * // => { '0': { '1': 'a' } }
     */
    function updateWith(object, path, updater, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
    }

    /**
     * Creates an array of the own enumerable string keyed property values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.values(new Foo);
     * // => [1, 2] (iteration order is not guaranteed)
     *
     * _.values('hi');
     * // => ['h', 'i']
     */
    function values(object) {
      return object == null ? [] : baseValues(object, keys(object));
    }

    /**
     * Creates an array of the own and inherited enumerable string keyed property
     * values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.valuesIn(new Foo);
     * // => [1, 2, 3] (iteration order is not guaranteed)
     */
    function valuesIn(object) {
      return object == null ? [] : baseValues(object, keysIn(object));
    }

    /*------------------------------------------------------------------------*/

    /**
     * Clamps `number` within the inclusive `lower` and `upper` bounds.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Number
     * @param {number} number The number to clamp.
     * @param {number} [lower] The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the clamped number.
     * @example
     *
     * _.clamp(-10, -5, 5);
     * // => -5
     *
     * _.clamp(10, -5, 5);
     * // => 5
     */
    function clamp(number, lower, upper) {
      if (upper === undefined) {
        upper = lower;
        lower = undefined;
      }
      if (upper !== undefined) {
        upper = toNumber(upper);
        upper = upper === upper ? upper : 0;
      }
      if (lower !== undefined) {
        lower = toNumber(lower);
        lower = lower === lower ? lower : 0;
      }
      return baseClamp(toNumber(number), lower, upper);
    }

    /**
     * Checks if `n` is between `start` and up to, but not including, `end`. If
     * `end` is not specified, it's set to `start` with `start` then set to `0`.
     * If `start` is greater than `end` the params are swapped to support
     * negative ranges.
     *
     * @static
     * @memberOf _
     * @since 3.3.0
     * @category Number
     * @param {number} number The number to check.
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
     * @see _.range, _.rangeRight
     * @example
     *
     * _.inRange(3, 2, 4);
     * // => true
     *
     * _.inRange(4, 8);
     * // => true
     *
     * _.inRange(4, 2);
     * // => false
     *
     * _.inRange(2, 2);
     * // => false
     *
     * _.inRange(1.2, 2);
     * // => true
     *
     * _.inRange(5.2, 4);
     * // => false
     *
     * _.inRange(-3, -2, -6);
     * // => true
     */
    function inRange(number, start, end) {
      start = toFinite(start);
      if (end === undefined) {
        end = start;
        start = 0;
      } else {
        end = toFinite(end);
      }
      number = toNumber(number);
      return baseInRange(number, start, end);
    }

    /**
     * Produces a random number between the inclusive `lower` and `upper` bounds.
     * If only one argument is provided a number between `0` and the given number
     * is returned. If `floating` is `true`, or either `lower` or `upper` are
     * floats, a floating-point number is returned instead of an integer.
     *
     * **Note:** JavaScript follows the IEEE-754 standard for resolving
     * floating-point values which can produce unexpected results.
     *
     * @static
     * @memberOf _
     * @since 0.7.0
     * @category Number
     * @param {number} [lower=0] The lower bound.
     * @param {number} [upper=1] The upper bound.
     * @param {boolean} [floating] Specify returning a floating-point number.
     * @returns {number} Returns the random number.
     * @example
     *
     * _.random(0, 5);
     * // => an integer between 0 and 5
     *
     * _.random(5);
     * // => also an integer between 0 and 5
     *
     * _.random(5, true);
     * // => a floating-point number between 0 and 5
     *
     * _.random(1.2, 5.2);
     * // => a floating-point number between 1.2 and 5.2
     */
    function random(lower, upper, floating) {
      if (floating && typeof floating != 'boolean' && isIterateeCall(lower, upper, floating)) {
        upper = floating = undefined;
      }
      if (floating === undefined) {
        if (typeof upper == 'boolean') {
          floating = upper;
          upper = undefined;
        }
        else if (typeof lower == 'boolean') {
          floating = lower;
          lower = undefined;
        }
      }
      if (lower === undefined && upper === undefined) {
        lower = 0;
        upper = 1;
      }
      else {
        lower = toFinite(lower);
        if (upper === undefined) {
          upper = lower;
          lower = 0;
        } else {
          upper = toFinite(upper);
        }
      }
      if (lower > upper) {
        var temp = lower;
        lower = upper;
        upper = temp;
      }
      if (floating || lower % 1 || upper % 1) {
        var rand = nativeRandom();
        return nativeMin(lower + (rand * (upper - lower + freeParseFloat('1e-' + ((rand + '').length - 1)))), upper);
      }
      return baseRandom(lower, upper);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the camel cased string.
     * @example
     *
     * _.camelCase('Foo Bar');
     * // => 'fooBar'
     *
     * _.camelCase('--foo-bar--');
     * // => 'fooBar'
     *
     * _.camelCase('__FOO_BAR__');
     * // => 'fooBar'
     */
    var camelCase = createCompounder(function(result, word, index) {
      word = word.toLowerCase();
      return result + (index ? capitalize(word) : word);
    });

    /**
     * Converts the first character of `string` to upper case and the remaining
     * to lower case.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to capitalize.
     * @returns {string} Returns the capitalized string.
     * @example
     *
     * _.capitalize('FRED');
     * // => 'Fred'
     */
    function capitalize(string) {
      return upperFirst(toString(string).toLowerCase());
    }

    /**
     * Deburrs `string` by converting
     * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
     * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
     * letters to basic Latin letters and removing
     * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to deburr.
     * @returns {string} Returns the deburred string.
     * @example
     *
     * _.deburr('déjà vu');
     * // => 'deja vu'
     */
    function deburr(string) {
      string = toString(string);
      return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');
    }

    /**
     * Checks if `string` ends with the given target string.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {string} [target] The string to search for.
     * @param {number} [position=string.length] The position to search up to.
     * @returns {boolean} Returns `true` if `string` ends with `target`,
     *  else `false`.
     * @example
     *
     * _.endsWith('abc', 'c');
     * // => true
     *
     * _.endsWith('abc', 'b');
     * // => false
     *
     * _.endsWith('abc', 'b', 2);
     * // => true
     */
    function endsWith(string, target, position) {
      string = toString(string);
      target = baseToString(target);

      var length = string.length;
      position = position === undefined
        ? length
        : baseClamp(toInteger(position), 0, length);

      var end = position;
      position -= target.length;
      return position >= 0 && string.slice(position, end) == target;
    }

    /**
     * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
     * corresponding HTML entities.
     *
     * **Note:** No other characters are escaped. To escape additional
     * characters use a third-party library like [_he_](https://mths.be/he).
     *
     * Though the ">" character is escaped for symmetry, characters like
     * ">" and "/" don't need escaping in HTML and have no special meaning
     * unless they're part of a tag or unquoted attribute value. See
     * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
     * (under "semi-related fun fact") for more details.
     *
     * When working with HTML you should always
     * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
     * XSS vectors.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escape('fred, barney, & pebbles');
     * // => 'fred, barney, &amp; pebbles'
     */
    function escape(string) {
      string = toString(string);
      return (string && reHasUnescapedHtml.test(string))
        ? string.replace(reUnescapedHtml, escapeHtmlChar)
        : string;
    }

    /**
     * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+",
     * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escapeRegExp('[lodash](https://lodash.com/)');
     * // => '\[lodash\]\(https://lodash\.com/\)'
     */
    function escapeRegExp(string) {
      string = toString(string);
      return (string && reHasRegExpChar.test(string))
        ? string.replace(reRegExpChar, '\\$&')
        : string;
    }

    /**
     * Converts `string` to
     * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the kebab cased string.
     * @example
     *
     * _.kebabCase('Foo Bar');
     * // => 'foo-bar'
     *
     * _.kebabCase('fooBar');
     * // => 'foo-bar'
     *
     * _.kebabCase('__FOO_BAR__');
     * // => 'foo-bar'
     */
    var kebabCase = createCompounder(function(result, word, index) {
      return result + (index ? '-' : '') + word.toLowerCase();
    });

    /**
     * Converts `string`, as space separated words, to lower case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the lower cased string.
     * @example
     *
     * _.lowerCase('--Foo-Bar--');
     * // => 'foo bar'
     *
     * _.lowerCase('fooBar');
     * // => 'foo bar'
     *
     * _.lowerCase('__FOO_BAR__');
     * // => 'foo bar'
     */
    var lowerCase = createCompounder(function(result, word, index) {
      return result + (index ? ' ' : '') + word.toLowerCase();
    });

    /**
     * Converts the first character of `string` to lower case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.lowerFirst('Fred');
     * // => 'fred'
     *
     * _.lowerFirst('FRED');
     * // => 'fRED'
     */
    var lowerFirst = createCaseFirst('toLowerCase');

    /**
     * Pads `string` on the left and right sides if it's shorter than `length`.
     * Padding characters are truncated if they can't be evenly divided by `length`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.pad('abc', 8);
     * // => '  abc   '
     *
     * _.pad('abc', 8, '_-');
     * // => '_-abc_-_'
     *
     * _.pad('abc', 3);
     * // => 'abc'
     */
    function pad(string, length, chars) {
      string = toString(string);
      length = toInteger(length);

      var strLength = length ? stringSize(string) : 0;
      if (!length || strLength >= length) {
        return string;
      }
      var mid = (length - strLength) / 2;
      return (
        createPadding(nativeFloor(mid), chars) +
        string +
        createPadding(nativeCeil(mid), chars)
      );
    }

    /**
     * Pads `string` on the right side if it's shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padEnd('abc', 6);
     * // => 'abc   '
     *
     * _.padEnd('abc', 6, '_-');
     * // => 'abc_-_'
     *
     * _.padEnd('abc', 3);
     * // => 'abc'
     */
    function padEnd(string, length, chars) {
      string = toString(string);
      length = toInteger(length);

      var strLength = length ? stringSize(string) : 0;
      return (length && strLength < length)
        ? (string + createPadding(length - strLength, chars))
        : string;
    }

    /**
     * Pads `string` on the left side if it's shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padStart('abc', 6);
     * // => '   abc'
     *
     * _.padStart('abc', 6, '_-');
     * // => '_-_abc'
     *
     * _.padStart('abc', 3);
     * // => 'abc'
     */
    function padStart(string, length, chars) {
      string = toString(string);
      length = toInteger(length);

      var strLength = length ? stringSize(string) : 0;
      return (length && strLength < length)
        ? (createPadding(length - strLength, chars) + string)
        : string;
    }

    /**
     * Converts `string` to an integer of the specified radix. If `radix` is
     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a
     * hexadecimal, in which case a `radix` of `16` is used.
     *
     * **Note:** This method aligns with the
     * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category String
     * @param {string} string The string to convert.
     * @param {number} [radix=10] The radix to interpret `value` by.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.parseInt('08');
     * // => 8
     *
     * _.map(['6', '08', '10'], _.parseInt);
     * // => [6, 8, 10]
     */
    function parseInt(string, radix, guard) {
      if (guard || radix == null) {
        radix = 0;
      } else if (radix) {
        radix = +radix;
      }
      return nativeParseInt(toString(string).replace(reTrimStart, ''), radix || 0);
    }

    /**
     * Repeats the given string `n` times.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to repeat.
     * @param {number} [n=1] The number of times to repeat the string.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the repeated string.
     * @example
     *
     * _.repeat('*', 3);
     * // => '***'
     *
     * _.repeat('abc', 2);
     * // => 'abcabc'
     *
     * _.repeat('abc', 0);
     * // => ''
     */
    function repeat(string, n, guard) {
      if ((guard ? isIterateeCall(string, n, guard) : n === undefined)) {
        n = 1;
      } else {
        n = toInteger(n);
      }
      return baseRepeat(toString(string), n);
    }

    /**
     * Replaces matches for `pattern` in `string` with `replacement`.
     *
     * **Note:** This method is based on
     * [`String#replace`](https://mdn.io/String/replace).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to modify.
     * @param {RegExp|string} pattern The pattern to replace.
     * @param {Function|string} replacement The match replacement.
     * @returns {string} Returns the modified string.
     * @example
     *
     * _.replace('Hi Fred', 'Fred', 'Barney');
     * // => 'Hi Barney'
     */
    function replace() {
      var args = arguments,
          string = toString(args[0]);

      return args.length < 3 ? string : string.replace(args[1], args[2]);
    }

    /**
     * Converts `string` to
     * [snake case](https://en.wikipedia.org/wiki/Snake_case).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the snake cased string.
     * @example
     *
     * _.snakeCase('Foo Bar');
     * // => 'foo_bar'
     *
     * _.snakeCase('fooBar');
     * // => 'foo_bar'
     *
     * _.snakeCase('--FOO-BAR--');
     * // => 'foo_bar'
     */
    var snakeCase = createCompounder(function(result, word, index) {
      return result + (index ? '_' : '') + word.toLowerCase();
    });

    /**
     * Splits `string` by `separator`.
     *
     * **Note:** This method is based on
     * [`String#split`](https://mdn.io/String/split).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to split.
     * @param {RegExp|string} separator The separator pattern to split by.
     * @param {number} [limit] The length to truncate results to.
     * @returns {Array} Returns the string segments.
     * @example
     *
     * _.split('a-b-c', '-', 2);
     * // => ['a', 'b']
     */
    function split(string, separator, limit) {
      if (limit && typeof limit != 'number' && isIterateeCall(string, separator, limit)) {
        separator = limit = undefined;
      }
      limit = limit === undefined ? MAX_ARRAY_LENGTH : limit >>> 0;
      if (!limit) {
        return [];
      }
      string = toString(string);
      if (string && (
            typeof separator == 'string' ||
            (separator != null && !isRegExp(separator))
          )) {
        separator = baseToString(separator);
        if (!separator && hasUnicode(string)) {
          return castSlice(stringToArray(string), 0, limit);
        }
      }
      return string.split(separator, limit);
    }

    /**
     * Converts `string` to
     * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
     *
     * @static
     * @memberOf _
     * @since 3.1.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the start cased string.
     * @example
     *
     * _.startCase('--foo-bar--');
     * // => 'Foo Bar'
     *
     * _.startCase('fooBar');
     * // => 'Foo Bar'
     *
     * _.startCase('__FOO_BAR__');
     * // => 'FOO BAR'
     */
    var startCase = createCompounder(function(result, word, index) {
      return result + (index ? ' ' : '') + upperFirst(word);
    });

    /**
     * Checks if `string` starts with the given target string.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {string} [target] The string to search for.
     * @param {number} [position=0] The position to search from.
     * @returns {boolean} Returns `true` if `string` starts with `target`,
     *  else `false`.
     * @example
     *
     * _.startsWith('abc', 'a');
     * // => true
     *
     * _.startsWith('abc', 'b');
     * // => false
     *
     * _.startsWith('abc', 'b', 1);
     * // => true
     */
    function startsWith(string, target, position) {
      string = toString(string);
      position = position == null
        ? 0
        : baseClamp(toInteger(position), 0, string.length);

      target = baseToString(target);
      return string.slice(position, position + target.length) == target;
    }

    /**
     * Creates a compiled template function that can interpolate data properties
     * in "interpolate" delimiters, HTML-escape interpolated data properties in
     * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
     * properties may be accessed as free variables in the template. If a setting
     * object is given, it takes precedence over `_.templateSettings` values.
     *
     * **Note:** In the development build `_.template` utilizes
     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
     * for easier debugging.
     *
     * For more information on precompiling templates see
     * [lodash's custom builds documentation](https://lodash.com/custom-builds).
     *
     * For more information on Chrome extension sandboxes see
     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category String
     * @param {string} [string=''] The template string.
     * @param {Object} [options={}] The options object.
     * @param {RegExp} [options.escape=_.templateSettings.escape]
     *  The HTML "escape" delimiter.
     * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
     *  The "evaluate" delimiter.
     * @param {Object} [options.imports=_.templateSettings.imports]
     *  An object to import into the template as free variables.
     * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
     *  The "interpolate" delimiter.
     * @param {string} [options.sourceURL='lodash.templateSources[n]']
     *  The sourceURL of the compiled template.
     * @param {string} [options.variable='obj']
     *  The data object variable name.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the compiled template function.
     * @example
     *
     * // Use the "interpolate" delimiter to create a compiled template.
     * var compiled = _.template('hello <%= user %>!');
     * compiled({ 'user': 'fred' });
     * // => 'hello fred!'
     *
     * // Use the HTML "escape" delimiter to escape data property values.
     * var compiled = _.template('<b><%- value %></b>');
     * compiled({ 'value': '<script>' });
     * // => '<b>&lt;script&gt;</b>'
     *
     * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // Use the internal `print` function in "evaluate" delimiters.
     * var compiled = _.template('<% print("hello " + user); %>!');
     * compiled({ 'user': 'barney' });
     * // => 'hello barney!'
     *
     * // Use the ES template literal delimiter as an "interpolate" delimiter.
     * // Disable support by replacing the "interpolate" delimiter.
     * var compiled = _.template('hello ${ user }!');
     * compiled({ 'user': 'pebbles' });
     * // => 'hello pebbles!'
     *
     * // Use backslashes to treat delimiters as plain text.
     * var compiled = _.template('<%= "\\<%- value %\\>" %>');
     * compiled({ 'value': 'ignored' });
     * // => '<%- value %>'
     *
     * // Use the `imports` option to import `jQuery` as `jq`.
     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // Use the `sourceURL` option to specify a custom sourceURL for the template.
     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
     * compiled(data);
     * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
     *
     * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
     * compiled.source;
     * // => function(data) {
     * //   var __t, __p = '';
     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
     * //   return __p;
     * // }
     *
     * // Use custom template delimiters.
     * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
     * var compiled = _.template('hello {{ user }}!');
     * compiled({ 'user': 'mustache' });
     * // => 'hello mustache!'
     *
     * // Use the `source` property to inline compiled templates for meaningful
     * // line numbers in error messages and stack traces.
     * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
     *   var JST = {\
     *     "main": ' + _.template(mainText).source + '\
     *   };\
     * ');
     */
    function template(string, options, guard) {
      // Based on John Resig's `tmpl` implementation
      // (http://ejohn.org/blog/javascript-micro-templating/)
      // and Laura Doktorova's doT.js (https://github.com/olado/doT).
      var settings = lodash.templateSettings;

      if (guard && isIterateeCall(string, options, guard)) {
        options = undefined;
      }
      string = toString(string);
      options = assignInWith({}, options, settings, customDefaultsAssignIn);

      var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn),
          importsKeys = keys(imports),
          importsValues = baseValues(imports, importsKeys);

      var isEscaping,
          isEvaluating,
          index = 0,
          interpolate = options.interpolate || reNoMatch,
          source = "__p += '";

      // Compile the regexp to match each delimiter.
      var reDelimiters = RegExp(
        (options.escape || reNoMatch).source + '|' +
        interpolate.source + '|' +
        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
        (options.evaluate || reNoMatch).source + '|$'
      , 'g');

      // Use a sourceURL for easier debugging.
      // The sourceURL gets injected into the source that's eval-ed, so be careful
      // to normalize all kinds of whitespace, so e.g. newlines (and unicode versions of it) can't sneak in
      // and escape the comment, thus injecting code that gets evaled.
      var sourceURL = '//# sourceURL=' +
        (hasOwnProperty.call(options, 'sourceURL')
          ? (options.sourceURL + '').replace(/\s/g, ' ')
          : ('lodash.templateSources[' + (++templateCounter) + ']')
        ) + '\n';

      string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
        interpolateValue || (interpolateValue = esTemplateValue);

        // Escape characters that can't be included in string literals.
        source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);

        // Replace delimiters with snippets.
        if (escapeValue) {
          isEscaping = true;
          source += "' +\n__e(" + escapeValue + ") +\n'";
        }
        if (evaluateValue) {
          isEvaluating = true;
          source += "';\n" + evaluateValue + ";\n__p += '";
        }
        if (interpolateValue) {
          source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
        }
        index = offset + match.length;

        // The JS engine embedded in Adobe products needs `match` returned in
        // order to produce the correct `offset` value.
        return match;
      });

      source += "';\n";

      // If `variable` is not specified wrap a with-statement around the generated
      // code to add the data object to the top of the scope chain.
      var variable = hasOwnProperty.call(options, 'variable') && options.variable;
      if (!variable) {
        source = 'with (obj) {\n' + source + '\n}\n';
      }
      // Throw an error if a forbidden character was found in `variable`, to prevent
      // potential command injection attacks.
      else if (reForbiddenIdentifierChars.test(variable)) {
        throw new Error(INVALID_TEMPL_VAR_ERROR_TEXT);
      }

      // Cleanup code by stripping empty strings.
      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
        .replace(reEmptyStringMiddle, '$1')
        .replace(reEmptyStringTrailing, '$1;');

      // Frame code as the function body.
      source = 'function(' + (variable || 'obj') + ') {\n' +
        (variable
          ? ''
          : 'obj || (obj = {});\n'
        ) +
        "var __t, __p = ''" +
        (isEscaping
           ? ', __e = _.escape'
           : ''
        ) +
        (isEvaluating
          ? ', __j = Array.prototype.join;\n' +
            "function print() { __p += __j.call(arguments, '') }\n"
          : ';\n'
        ) +
        source +
        'return __p\n}';

      var result = attempt(function() {
        return Function(importsKeys, sourceURL + 'return ' + source)
          .apply(undefined, importsValues);
      });

      // Provide the compiled function's source by its `toString` method or
      // the `source` property as a convenience for inlining compiled templates.
      result.source = source;
      if (isError(result)) {
        throw result;
      }
      return result;
    }

    /**
     * Converts `string`, as a whole, to lower case just like
     * [String#toLowerCase](https://mdn.io/toLowerCase).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the lower cased string.
     * @example
     *
     * _.toLower('--Foo-Bar--');
     * // => '--foo-bar--'
     *
     * _.toLower('fooBar');
     * // => 'foobar'
     *
     * _.toLower('__FOO_BAR__');
     * // => '__foo_bar__'
     */
    function toLower(value) {
      return toString(value).toLowerCase();
    }

    /**
     * Converts `string`, as a whole, to upper case just like
     * [String#toUpperCase](https://mdn.io/toUpperCase).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the upper cased string.
     * @example
     *
     * _.toUpper('--foo-bar--');
     * // => '--FOO-BAR--'
     *
     * _.toUpper('fooBar');
     * // => 'FOOBAR'
     *
     * _.toUpper('__foo_bar__');
     * // => '__FOO_BAR__'
     */
    function toUpper(value) {
      return toString(value).toUpperCase();
    }

    /**
     * Removes leading and trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trim('  abc  ');
     * // => 'abc'
     *
     * _.trim('-_-abc-_-', '_-');
     * // => 'abc'
     *
     * _.map(['  foo  ', '  bar  '], _.trim);
     * // => ['foo', 'bar']
     */
    function trim(string, chars, guard) {
      string = toString(string);
      if (string && (guard || chars === undefined)) {
        return baseTrim(string);
      }
      if (!string || !(chars = baseToString(chars))) {
        return string;
      }
      var strSymbols = stringToArray(string),
          chrSymbols = stringToArray(chars),
          start = charsStartIndex(strSymbols, chrSymbols),
          end = charsEndIndex(strSymbols, chrSymbols) + 1;

      return castSlice(strSymbols, start, end).join('');
    }

    /**
     * Removes trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimEnd('  abc  ');
     * // => '  abc'
     *
     * _.trimEnd('-_-abc-_-', '_-');
     * // => '-_-abc'
     */
    function trimEnd(string, chars, guard) {
      string = toString(string);
      if (string && (guard || chars === undefined)) {
        return string.slice(0, trimmedEndIndex(string) + 1);
      }
      if (!string || !(chars = baseToString(chars))) {
        return string;
      }
      var strSymbols = stringToArray(string),
          end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;

      return castSlice(strSymbols, 0, end).join('');
    }

    /**
     * Removes leading whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimStart('  abc  ');
     * // => 'abc  '
     *
     * _.trimStart('-_-abc-_-', '_-');
     * // => 'abc-_-'
     */
    function trimStart(string, chars, guard) {
      string = toString(string);
      if (string && (guard || chars === undefined)) {
        return string.replace(reTrimStart, '');
      }
      if (!string || !(chars = baseToString(chars))) {
        return string;
      }
      var strSymbols = stringToArray(string),
          start = charsStartIndex(strSymbols, stringToArray(chars));

      return castSlice(strSymbols, start).join('');
    }

    /**
     * Truncates `string` if it's longer than the given maximum string length.
     * The last characters of the truncated string are replaced with the omission
     * string which defaults to "...".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to truncate.
     * @param {Object} [options={}] The options object.
     * @param {number} [options.length=30] The maximum string length.
     * @param {string} [options.omission='...'] The string to indicate text is omitted.
     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
     * @returns {string} Returns the truncated string.
     * @example
     *
     * _.truncate('hi-diddly-ho there, neighborino');
     * // => 'hi-diddly-ho there, neighbo...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': ' '
     * });
     * // => 'hi-diddly-ho there,...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': /,? +/
     * });
     * // => 'hi-diddly-ho there...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'omission': ' [...]'
     * });
     * // => 'hi-diddly-ho there, neig [...]'
     */
    function truncate(string, options) {
      var length = DEFAULT_TRUNC_LENGTH,
          omission = DEFAULT_TRUNC_OMISSION;

      if (isObject(options)) {
        var separator = 'separator' in options ? options.separator : separator;
        length = 'length' in options ? toInteger(options.length) : length;
        omission = 'omission' in options ? baseToString(options.omission) : omission;
      }
      string = toString(string);

      var strLength = string.length;
      if (hasUnicode(string)) {
        var strSymbols = stringToArray(string);
        strLength = strSymbols.length;
      }
      if (length >= strLength) {
        return string;
      }
      var end = length - stringSize(omission);
      if (end < 1) {
        return omission;
      }
      var result = strSymbols
        ? castSlice(strSymbols, 0, end).join('')
        : string.slice(0, end);

      if (separator === undefined) {
        return result + omission;
      }
      if (strSymbols) {
        end += (result.length - end);
      }
      if (isRegExp(separator)) {
        if (string.slice(end).search(separator)) {
          var match,
              substring = result;

          if (!separator.global) {
            separator = RegExp(separator.source, toString(reFlags.exec(separator)) + 'g');
          }
          separator.lastIndex = 0;
          while ((match = separator.exec(substring))) {
            var newEnd = match.index;
          }
          result = result.slice(0, newEnd === undefined ? end : newEnd);
        }
      } else if (string.indexOf(baseToString(separator), end) != end) {
        var index = result.lastIndexOf(separator);
        if (index > -1) {
          result = result.slice(0, index);
        }
      }
      return result + omission;
    }

    /**
     * The inverse of `_.escape`; this method converts the HTML entities
     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to
     * their corresponding characters.
     *
     * **Note:** No other HTML entities are unescaped. To unescape additional
     * HTML entities use a third-party library like [_he_](https://mths.be/he).
     *
     * @static
     * @memberOf _
     * @since 0.6.0
     * @category String
     * @param {string} [string=''] The string to unescape.
     * @returns {string} Returns the unescaped string.
     * @example
     *
     * _.unescape('fred, barney, &amp; pebbles');
     * // => 'fred, barney, & pebbles'
     */
    function unescape(string) {
      string = toString(string);
      return (string && reHasEscapedHtml.test(string))
        ? string.replace(reEscapedHtml, unescapeHtmlChar)
        : string;
    }

    /**
     * Converts `string`, as space separated words, to upper case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the upper cased string.
     * @example
     *
     * _.upperCase('--foo-bar');
     * // => 'FOO BAR'
     *
     * _.upperCase('fooBar');
     * // => 'FOO BAR'
     *
     * _.upperCase('__foo_bar__');
     * // => 'FOO BAR'
     */
    var upperCase = createCompounder(function(result, word, index) {
      return result + (index ? ' ' : '') + word.toUpperCase();
    });

    /**
     * Converts the first character of `string` to upper case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.upperFirst('fred');
     * // => 'Fred'
     *
     * _.upperFirst('FRED');
     * // => 'FRED'
     */
    var upperFirst = createCaseFirst('toUpperCase');

    /**
     * Splits `string` into an array of its words.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {RegExp|string} [pattern] The pattern to match words.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the words of `string`.
     * @example
     *
     * _.words('fred, barney, & pebbles');
     * // => ['fred', 'barney', 'pebbles']
     *
     * _.words('fred, barney, & pebbles', /[^, ]+/g);
     * // => ['fred', 'barney', '&', 'pebbles']
     */
    function words(string, pattern, guard) {
      string = toString(string);
      pattern = guard ? undefined : pattern;

      if (pattern === undefined) {
        return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
      }
      return string.match(pattern) || [];
    }

    /*------------------------------------------------------------------------*/

    /**
     * Attempts to invoke `func`, returning either the result or the caught error
     * object. Any additional arguments are provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Function} func The function to attempt.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {*} Returns the `func` result or error object.
     * @example
     *
     * // Avoid throwing errors for invalid selectors.
     * var elements = _.attempt(function(selector) {
     *   return document.querySelectorAll(selector);
     * }, '>_>');
     *
     * if (_.isError(elements)) {
     *   elements = [];
     * }
     */
    var attempt = baseRest(function(func, args) {
      try {
        return apply(func, undefined, args);
      } catch (e) {
        return isError(e) ? e : new Error(e);
      }
    });

    /**
     * Binds methods of an object to the object itself, overwriting the existing
     * method.
     *
     * **Note:** This method doesn't set the "length" property of bound functions.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {Object} object The object to bind and assign the bound methods to.
     * @param {...(string|string[])} methodNames The object method names to bind.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var view = {
     *   'label': 'docs',
     *   'click': function() {
     *     console.log('clicked ' + this.label);
     *   }
     * };
     *
     * _.bindAll(view, ['click']);
     * jQuery(element).on('click', view.click);
     * // => Logs 'clicked docs' when clicked.
     */
    var bindAll = flatRest(function(object, methodNames) {
      arrayEach(methodNames, function(key) {
        key = toKey(key);
        baseAssignValue(object, key, bind(object[key], object));
      });
      return object;
    });

    /**
     * Creates a function that iterates over `pairs` and invokes the corresponding
     * function of the first predicate to return truthy. The predicate-function
     * pairs are invoked with the `this` binding and arguments of the created
     * function.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {Array} pairs The predicate-function pairs.
     * @returns {Function} Returns the new composite function.
     * @example
     *
     * var func = _.cond([
     *   [_.matches({ 'a': 1 }),           _.constant('matches A')],
     *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],
     *   [_.stubTrue,                      _.constant('no match')]
     * ]);
     *
     * func({ 'a': 1, 'b': 2 });
     * // => 'matches A'
     *
     * func({ 'a': 0, 'b': 1 });
     * // => 'matches B'
     *
     * func({ 'a': '1', 'b': '2' });
     * // => 'no match'
     */
    function cond(pairs) {
      var length = pairs == null ? 0 : pairs.length,
          toIteratee = getIteratee();

      pairs = !length ? [] : arrayMap(pairs, function(pair) {
        if (typeof pair[1] != 'function') {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        return [toIteratee(pair[0]), pair[1]];
      });

      return baseRest(function(args) {
        var index = -1;
        while (++index < length) {
          var pair = pairs[index];
          if (apply(pair[0], this, args)) {
            return apply(pair[1], this, args);
          }
        }
      });
    }

    /**
     * Creates a function that invokes the predicate properties of `source` with
     * the corresponding property values of a given object, returning `true` if
     * all predicates return truthy, else `false`.
     *
     * **Note:** The created function is equivalent to `_.conformsTo` with
     * `source` partially applied.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {Object} source The object of property predicates to conform to.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 2, 'b': 1 },
     *   { 'a': 1, 'b': 2 }
     * ];
     *
     * _.filter(objects, _.conforms({ 'b': function(n) { return n > 1; } }));
     * // => [{ 'a': 1, 'b': 2 }]
     */
    function conforms(source) {
      return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
    }

    /**
     * Creates a function that returns `value`.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Util
     * @param {*} value The value to return from the new function.
     * @returns {Function} Returns the new constant function.
     * @example
     *
     * var objects = _.times(2, _.constant({ 'a': 1 }));
     *
     * console.log(objects);
     * // => [{ 'a': 1 }, { 'a': 1 }]
     *
     * console.log(objects[0] === objects[1]);
     * // => true
     */
    function constant(value) {
      return function() {
        return value;
      };
    }

    /**
     * Checks `value` to determine whether a default value should be returned in
     * its place. The `defaultValue` is returned if `value` is `NaN`, `null`,
     * or `undefined`.
     *
     * @static
     * @memberOf _
     * @since 4.14.0
     * @category Util
     * @param {*} value The value to check.
     * @param {*} defaultValue The default value.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * _.defaultTo(1, 10);
     * // => 1
     *
     * _.defaultTo(undefined, 10);
     * // => 10
     */
    function defaultTo(value, defaultValue) {
      return (value == null || value !== value) ? defaultValue : value;
    }

    /**
     * Creates a function that returns the result of invoking the given functions
     * with the `this` binding of the created function, where each successive
     * invocation is supplied the return value of the previous.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {...(Function|Function[])} [funcs] The functions to invoke.
     * @returns {Function} Returns the new composite function.
     * @see _.flowRight
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flow([_.add, square]);
     * addSquare(1, 2);
     * // => 9
     */
    var flow = createFlow();

    /**
     * This method is like `_.flow` except that it creates a function that
     * invokes the given functions from right to left.
     *
     * @static
     * @since 3.0.0
     * @memberOf _
     * @category Util
     * @param {...(Function|Function[])} [funcs] The functions to invoke.
     * @returns {Function} Returns the new composite function.
     * @see _.flow
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flowRight([square, _.add]);
     * addSquare(1, 2);
     * // => 9
     */
    var flowRight = createFlow(true);

    /**
     * This method returns the first argument it receives.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {*} value Any value.
     * @returns {*} Returns `value`.
     * @example
     *
     * var object = { 'a': 1 };
     *
     * console.log(_.identity(object) === object);
     * // => true
     */
    function identity(value) {
      return value;
    }

    /**
     * Creates a function that invokes `func` with the arguments of the created
     * function. If `func` is a property name, the created function returns the
     * property value for a given element. If `func` is an array or object, the
     * created function returns `true` for elements that contain the equivalent
     * source properties, otherwise it returns `false`.
     *
     * @static
     * @since 4.0.0
     * @memberOf _
     * @category Util
     * @param {*} [func=_.identity] The value to convert to a callback.
     * @returns {Function} Returns the callback.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));
     * // => [{ 'user': 'barney', 'age': 36, 'active': true }]
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.filter(users, _.iteratee(['user', 'fred']));
     * // => [{ 'user': 'fred', 'age': 40 }]
     *
     * // The `_.property` iteratee shorthand.
     * _.map(users, _.iteratee('user'));
     * // => ['barney', 'fred']
     *
     * // Create custom iteratee shorthands.
     * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {
     *   return !_.isRegExp(func) ? iteratee(func) : function(string) {
     *     return func.test(string);
     *   };
     * });
     *
     * _.filter(['abc', 'def'], /ef/);
     * // => ['def']
     */
    function iteratee(func) {
      return baseIteratee(typeof func == 'function' ? func : baseClone(func, CLONE_DEEP_FLAG));
    }

    /**
     * Creates a function that performs a partial deep comparison between a given
     * object and `source`, returning `true` if the given object has equivalent
     * property values, else `false`.
     *
     * **Note:** The created function is equivalent to `_.isMatch` with `source`
     * partially applied.
     *
     * Partial comparisons will match empty array and empty object `source`
     * values against any array or object value, respectively. See `_.isEqual`
     * for a list of supported value comparisons.
     *
     * **Note:** Multiple values can be checked by combining several matchers
     * using `_.overSome`
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 1, 'b': 2, 'c': 3 },
     *   { 'a': 4, 'b': 5, 'c': 6 }
     * ];
     *
     * _.filter(objects, _.matches({ 'a': 4, 'c': 6 }));
     * // => [{ 'a': 4, 'b': 5, 'c': 6 }]
     *
     * // Checking for several possible values
     * _.filter(objects, _.overSome([_.matches({ 'a': 1 }), _.matches({ 'a': 4 })]));
     * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]
     */
    function matches(source) {
      return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
    }

    /**
     * Creates a function that performs a partial deep comparison between the
     * value at `path` of a given object to `srcValue`, returning `true` if the
     * object value is equivalent, else `false`.
     *
     * **Note:** Partial comparisons will match empty array and empty object
     * `srcValue` values against any array or object value, respectively. See
     * `_.isEqual` for a list of supported value comparisons.
     *
     * **Note:** Multiple values can be checked by combining several matchers
     * using `_.overSome`
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Util
     * @param {Array|string} path The path of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 1, 'b': 2, 'c': 3 },
     *   { 'a': 4, 'b': 5, 'c': 6 }
     * ];
     *
     * _.find(objects, _.matchesProperty('a', 4));
     * // => { 'a': 4, 'b': 5, 'c': 6 }
     *
     * // Checking for several possible values
     * _.filter(objects, _.overSome([_.matchesProperty('a', 1), _.matchesProperty('a', 4)]));
     * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]
     */
    function matchesProperty(path, srcValue) {
      return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
    }

    /**
     * Creates a function that invokes the method at `path` of a given object.
     * Any additional arguments are provided to the invoked method.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Util
     * @param {Array|string} path The path of the method to invoke.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Function} Returns the new invoker function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': _.constant(2) } },
     *   { 'a': { 'b': _.constant(1) } }
     * ];
     *
     * _.map(objects, _.method('a.b'));
     * // => [2, 1]
     *
     * _.map(objects, _.method(['a', 'b']));
     * // => [2, 1]
     */
    var method = baseRest(function(path, args) {
      return function(object) {
        return baseInvoke(object, path, args);
      };
    });

    /**
     * The opposite of `_.method`; this method creates a function that invokes
     * the method at a given path of `object`. Any additional arguments are
     * provided to the invoked method.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Util
     * @param {Object} object The object to query.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Function} Returns the new invoker function.
     * @example
     *
     * var array = _.times(3, _.constant),
     *     object = { 'a': array, 'b': array, 'c': array };
     *
     * _.map(['a[2]', 'c[0]'], _.methodOf(object));
     * // => [2, 0]
     *
     * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
     * // => [2, 0]
     */
    var methodOf = baseRest(function(object, args) {
      return function(path) {
        return baseInvoke(object, path, args);
      };
    });

    /**
     * Adds all own enumerable string keyed function properties of a source
     * object to the destination object. If `object` is a function, then methods
     * are added to its prototype as well.
     *
     * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
     * avoid conflicts caused by modifying the original.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {Function|Object} [object=lodash] The destination object.
     * @param {Object} source The object of functions to add.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.chain=true] Specify whether mixins are chainable.
     * @returns {Function|Object} Returns `object`.
     * @example
     *
     * function vowels(string) {
     *   return _.filter(string, function(v) {
     *     return /[aeiou]/i.test(v);
     *   });
     * }
     *
     * _.mixin({ 'vowels': vowels });
     * _.vowels('fred');
     * // => ['e']
     *
     * _('fred').vowels().value();
     * // => ['e']
     *
     * _.mixin({ 'vowels': vowels }, { 'chain': false });
     * _('fred').vowels();
     * // => ['e']
     */
    function mixin(object, source, options) {
      var props = keys(source),
          methodNames = baseFunctions(source, props);

      if (options == null &&
          !(isObject(source) && (methodNames.length || !props.length))) {
        options = source;
        source = object;
        object = this;
        methodNames = baseFunctions(source, keys(source));
      }
      var chain = !(isObject(options) && 'chain' in options) || !!options.chain,
          isFunc = isFunction(object);

      arrayEach(methodNames, function(methodName) {
        var func = source[methodName];
        object[methodName] = func;
        if (isFunc) {
          object.prototype[methodName] = function() {
            var chainAll = this.__chain__;
            if (chain || chainAll) {
              var result = object(this.__wrapped__),
                  actions = result.__actions__ = copyArray(this.__actions__);

              actions.push({ 'func': func, 'args': arguments, 'thisArg': object });
              result.__chain__ = chainAll;
              return result;
            }
            return func.apply(object, arrayPush([this.value()], arguments));
          };
        }
      });

      return object;
    }

    /**
     * Reverts the `_` variable to its previous value and returns a reference to
     * the `lodash` function.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @returns {Function} Returns the `lodash` function.
     * @example
     *
     * var lodash = _.noConflict();
     */
    function noConflict() {
      if (root._ === this) {
        root._ = oldDash;
      }
      return this;
    }

    /**
     * This method returns `undefined`.
     *
     * @static
     * @memberOf _
     * @since 2.3.0
     * @category Util
     * @example
     *
     * _.times(2, _.noop);
     * // => [undefined, undefined]
     */
    function noop() {
      // No operation performed.
    }

    /**
     * Creates a function that gets the argument at index `n`. If `n` is negative,
     * the nth argument from the end is returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {number} [n=0] The index of the argument to return.
     * @returns {Function} Returns the new pass-thru function.
     * @example
     *
     * var func = _.nthArg(1);
     * func('a', 'b', 'c', 'd');
     * // => 'b'
     *
     * var func = _.nthArg(-2);
     * func('a', 'b', 'c', 'd');
     * // => 'c'
     */
    function nthArg(n) {
      n = toInteger(n);
      return baseRest(function(args) {
        return baseNth(args, n);
      });
    }

    /**
     * Creates a function that invokes `iteratees` with the arguments it receives
     * and returns their results.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [iteratees=[_.identity]]
     *  The iteratees to invoke.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.over([Math.max, Math.min]);
     *
     * func(1, 2, 3, 4);
     * // => [4, 1]
     */
    var over = createOver(arrayMap);

    /**
     * Creates a function that checks if **all** of the `predicates` return
     * truthy when invoked with the arguments it receives.
     *
     * Following shorthands are possible for providing predicates.
     * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.
     * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [predicates=[_.identity]]
     *  The predicates to check.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.overEvery([Boolean, isFinite]);
     *
     * func('1');
     * // => true
     *
     * func(null);
     * // => false
     *
     * func(NaN);
     * // => false
     */
    var overEvery = createOver(arrayEvery);

    /**
     * Creates a function that checks if **any** of the `predicates` return
     * truthy when invoked with the arguments it receives.
     *
     * Following shorthands are possible for providing predicates.
     * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.
     * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [predicates=[_.identity]]
     *  The predicates to check.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.overSome([Boolean, isFinite]);
     *
     * func('1');
     * // => true
     *
     * func(null);
     * // => true
     *
     * func(NaN);
     * // => false
     *
     * var matchesFunc = _.overSome([{ 'a': 1 }, { 'a': 2 }])
     * var matchesPropertyFunc = _.overSome([['a', 1], ['a', 2]])
     */
    var overSome = createOver(arraySome);

    /**
     * Creates a function that returns the value at `path` of a given object.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Util
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new accessor function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': 2 } },
     *   { 'a': { 'b': 1 } }
     * ];
     *
     * _.map(objects, _.property('a.b'));
     * // => [2, 1]
     *
     * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
     * // => [1, 2]
     */
    function property(path) {
      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
    }

    /**
     * The opposite of `_.property`; this method creates a function that returns
     * the value at a given path of `object`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Object} object The object to query.
     * @returns {Function} Returns the new accessor function.
     * @example
     *
     * var array = [0, 1, 2],
     *     object = { 'a': array, 'b': array, 'c': array };
     *
     * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
     * // => [2, 0]
     *
     * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
     * // => [2, 0]
     */
    function propertyOf(object) {
      return function(path) {
        return object == null ? undefined : baseGet(object, path);
      };
    }

    /**
     * Creates an array of numbers (positive and/or negative) progressing from
     * `start` up to, but not including, `end`. A step of `-1` is used if a negative
     * `start` is specified without an `end` or `step`. If `end` is not specified,
     * it's set to `start` with `start` then set to `0`.
     *
     * **Note:** JavaScript follows the IEEE-754 standard for resolving
     * floating-point values which can produce unexpected results.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns the range of numbers.
     * @see _.inRange, _.rangeRight
     * @example
     *
     * _.range(4);
     * // => [0, 1, 2, 3]
     *
     * _.range(-4);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 5);
     * // => [1, 2, 3, 4]
     *
     * _.range(0, 20, 5);
     * // => [0, 5, 10, 15]
     *
     * _.range(0, -4, -1);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.range(0);
     * // => []
     */
    var range = createRange();

    /**
     * This method is like `_.range` except that it populates values in
     * descending order.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns the range of numbers.
     * @see _.inRange, _.range
     * @example
     *
     * _.rangeRight(4);
     * // => [3, 2, 1, 0]
     *
     * _.rangeRight(-4);
     * // => [-3, -2, -1, 0]
     *
     * _.rangeRight(1, 5);
     * // => [4, 3, 2, 1]
     *
     * _.rangeRight(0, 20, 5);
     * // => [15, 10, 5, 0]
     *
     * _.rangeRight(0, -4, -1);
     * // => [-3, -2, -1, 0]
     *
     * _.rangeRight(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.rangeRight(0);
     * // => []
     */
    var rangeRight = createRange(true);

    /**
     * This method returns a new empty array.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {Array} Returns the new empty array.
     * @example
     *
     * var arrays = _.times(2, _.stubArray);
     *
     * console.log(arrays);
     * // => [[], []]
     *
     * console.log(arrays[0] === arrays[1]);
     * // => false
     */
    function stubArray() {
      return [];
    }

    /**
     * This method returns `false`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `false`.
     * @example
     *
     * _.times(2, _.stubFalse);
     * // => [false, false]
     */
    function stubFalse() {
      return false;
    }

    /**
     * This method returns a new empty object.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {Object} Returns the new empty object.
     * @example
     *
     * var objects = _.times(2, _.stubObject);
     *
     * console.log(objects);
     * // => [{}, {}]
     *
     * console.log(objects[0] === objects[1]);
     * // => false
     */
    function stubObject() {
      return {};
    }

    /**
     * This method returns an empty string.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {string} Returns the empty string.
     * @example
     *
     * _.times(2, _.stubString);
     * // => ['', '']
     */
    function stubString() {
      return '';
    }

    /**
     * This method returns `true`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `true`.
     * @example
     *
     * _.times(2, _.stubTrue);
     * // => [true, true]
     */
    function stubTrue() {
      return true;
    }

    /**
     * Invokes the iteratee `n` times, returning an array of the results of
     * each invocation. The iteratee is invoked with one argument; (index).
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {number} n The number of times to invoke `iteratee`.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * _.times(3, String);
     * // => ['0', '1', '2']
     *
     *  _.times(4, _.constant(0));
     * // => [0, 0, 0, 0]
     */
    function times(n, iteratee) {
      n = toInteger(n);
      if (n < 1 || n > MAX_SAFE_INTEGER) {
        return [];
      }
      var index = MAX_ARRAY_LENGTH,
          length = nativeMin(n, MAX_ARRAY_LENGTH);

      iteratee = getIteratee(iteratee);
      n -= MAX_ARRAY_LENGTH;

      var result = baseTimes(length, iteratee);
      while (++index < n) {
        iteratee(index);
      }
      return result;
    }

    /**
     * Converts `value` to a property path array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {*} value The value to convert.
     * @returns {Array} Returns the new property path array.
     * @example
     *
     * _.toPath('a.b.c');
     * // => ['a', 'b', 'c']
     *
     * _.toPath('a[0].b.c');
     * // => ['a', '0', 'b', 'c']
     */
    function toPath(value) {
      if (isArray(value)) {
        return arrayMap(value, toKey);
      }
      return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
    }

    /**
     * Generates a unique ID. If `prefix` is given, the ID is appended to it.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {string} [prefix=''] The value to prefix the ID with.
     * @returns {string} Returns the unique ID.
     * @example
     *
     * _.uniqueId('contact_');
     * // => 'contact_104'
     *
     * _.uniqueId();
     * // => '105'
     */
    function uniqueId(prefix) {
      var id = ++idCounter;
      return toString(prefix) + id;
    }

    /*------------------------------------------------------------------------*/

    /**
     * Adds two numbers.
     *
     * @static
     * @memberOf _
     * @since 3.4.0
     * @category Math
     * @param {number} augend The first number in an addition.
     * @param {number} addend The second number in an addition.
     * @returns {number} Returns the total.
     * @example
     *
     * _.add(6, 4);
     * // => 10
     */
    var add = createMathOperation(function(augend, addend) {
      return augend + addend;
    }, 0);

    /**
     * Computes `number` rounded up to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round up.
     * @param {number} [precision=0] The precision to round up to.
     * @returns {number} Returns the rounded up number.
     * @example
     *
     * _.ceil(4.006);
     * // => 5
     *
     * _.ceil(6.004, 2);
     * // => 6.01
     *
     * _.ceil(6040, -2);
     * // => 6100
     */
    var ceil = createRound('ceil');

    /**
     * Divide two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {number} dividend The first number in a division.
     * @param {number} divisor The second number in a division.
     * @returns {number} Returns the quotient.
     * @example
     *
     * _.divide(6, 4);
     * // => 1.5
     */
    var divide = createMathOperation(function(dividend, divisor) {
      return dividend / divisor;
    }, 1);

    /**
     * Computes `number` rounded down to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round down.
     * @param {number} [precision=0] The precision to round down to.
     * @returns {number} Returns the rounded down number.
     * @example
     *
     * _.floor(4.006);
     * // => 4
     *
     * _.floor(0.046, 2);
     * // => 0.04
     *
     * _.floor(4060, -2);
     * // => 4000
     */
    var floor = createRound('floor');

    /**
     * Computes the maximum value of `array`. If `array` is empty or falsey,
     * `undefined` is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * _.max([4, 2, 8, 6]);
     * // => 8
     *
     * _.max([]);
     * // => undefined
     */
    function max(array) {
      return (array && array.length)
        ? baseExtremum(array, identity, baseGt)
        : undefined;
    }

    /**
     * This method is like `_.max` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * the value is ranked. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * var objects = [{ 'n': 1 }, { 'n': 2 }];
     *
     * _.maxBy(objects, function(o) { return o.n; });
     * // => { 'n': 2 }
     *
     * // The `_.property` iteratee shorthand.
     * _.maxBy(objects, 'n');
     * // => { 'n': 2 }
     */
    function maxBy(array, iteratee) {
      return (array && array.length)
        ? baseExtremum(array, getIteratee(iteratee, 2), baseGt)
        : undefined;
    }

    /**
     * Computes the mean of the values in `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {number} Returns the mean.
     * @example
     *
     * _.mean([4, 2, 8, 6]);
     * // => 5
     */
    function mean(array) {
      return baseMean(array, identity);
    }

    /**
     * This method is like `_.mean` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the value to be averaged.
     * The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the mean.
     * @example
     *
     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
     *
     * _.meanBy(objects, function(o) { return o.n; });
     * // => 5
     *
     * // The `_.property` iteratee shorthand.
     * _.meanBy(objects, 'n');
     * // => 5
     */
    function meanBy(array, iteratee) {
      return baseMean(array, getIteratee(iteratee, 2));
    }

    /**
     * Computes the minimum value of `array`. If `array` is empty or falsey,
     * `undefined` is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * _.min([4, 2, 8, 6]);
     * // => 2
     *
     * _.min([]);
     * // => undefined
     */
    function min(array) {
      return (array && array.length)
        ? baseExtremum(array, identity, baseLt)
        : undefined;
    }

    /**
     * This method is like `_.min` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * the value is ranked. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * var objects = [{ 'n': 1 }, { 'n': 2 }];
     *
     * _.minBy(objects, function(o) { return o.n; });
     * // => { 'n': 1 }
     *
     * // The `_.property` iteratee shorthand.
     * _.minBy(objects, 'n');
     * // => { 'n': 1 }
     */
    function minBy(array, iteratee) {
      return (array && array.length)
        ? baseExtremum(array, getIteratee(iteratee, 2), baseLt)
        : undefined;
    }

    /**
     * Multiply two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {number} multiplier The first number in a multiplication.
     * @param {number} multiplicand The second number in a multiplication.
     * @returns {number} Returns the product.
     * @example
     *
     * _.multiply(6, 4);
     * // => 24
     */
    var multiply = createMathOperation(function(multiplier, multiplicand) {
      return multiplier * multiplicand;
    }, 1);

    /**
     * Computes `number` rounded to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round.
     * @param {number} [precision=0] The precision to round to.
     * @returns {number} Returns the rounded number.
     * @example
     *
     * _.round(4.006);
     * // => 4
     *
     * _.round(4.006, 2);
     * // => 4.01
     *
     * _.round(4060, -2);
     * // => 4100
     */
    var round = createRound('round');

    /**
     * Subtract two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {number} minuend The first number in a subtraction.
     * @param {number} subtrahend The second number in a subtraction.
     * @returns {number} Returns the difference.
     * @example
     *
     * _.subtract(6, 4);
     * // => 2
     */
    var subtract = createMathOperation(function(minuend, subtrahend) {
      return minuend - subtrahend;
    }, 0);

    /**
     * Computes the sum of the values in `array`.
     *
     * @static
     * @memberOf _
     * @since 3.4.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {number} Returns the sum.
     * @example
     *
     * _.sum([4, 2, 8, 6]);
     * // => 20
     */
    function sum(array) {
      return (array && array.length)
        ? baseSum(array, identity)
        : 0;
    }

    /**
     * This method is like `_.sum` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the value to be summed.
     * The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the sum.
     * @example
     *
     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
     *
     * _.sumBy(objects, function(o) { return o.n; });
     * // => 20
     *
     * // The `_.property` iteratee shorthand.
     * _.sumBy(objects, 'n');
     * // => 20
     */
    function sumBy(array, iteratee) {
      return (array && array.length)
        ? baseSum(array, getIteratee(iteratee, 2))
        : 0;
    }

    /*------------------------------------------------------------------------*/

    // Add methods that return wrapped values in chain sequences.
    lodash.after = after;
    lodash.ary = ary;
    lodash.assign = assign;
    lodash.assignIn = assignIn;
    lodash.assignInWith = assignInWith;
    lodash.assignWith = assignWith;
    lodash.at = at;
    lodash.before = before;
    lodash.bind = bind;
    lodash.bindAll = bindAll;
    lodash.bindKey = bindKey;
    lodash.castArray = castArray;
    lodash.chain = chain;
    lodash.chunk = chunk;
    lodash.compact = compact;
    lodash.concat = concat;
    lodash.cond = cond;
    lodash.conforms = conforms;
    lodash.constant = constant;
    lodash.countBy = countBy;
    lodash.create = create;
    lodash.curry = curry;
    lodash.curryRight = curryRight;
    lodash.debounce = debounce;
    lodash.defaults = defaults;
    lodash.defaultsDeep = defaultsDeep;
    lodash.defer = defer;
    lodash.delay = delay;
    lodash.difference = difference;
    lodash.differenceBy = differenceBy;
    lodash.differenceWith = differenceWith;
    lodash.drop = drop;
    lodash.dropRight = dropRight;
    lodash.dropRightWhile = dropRightWhile;
    lodash.dropWhile = dropWhile;
    lodash.fill = fill;
    lodash.filter = filter;
    lodash.flatMap = flatMap;
    lodash.flatMapDeep = flatMapDeep;
    lodash.flatMapDepth = flatMapDepth;
    lodash.flatten = flatten;
    lodash.flattenDeep = flattenDeep;
    lodash.flattenDepth = flattenDepth;
    lodash.flip = flip;
    lodash.flow = flow;
    lodash.flowRight = flowRight;
    lodash.fromPairs = fromPairs;
    lodash.functions = functions;
    lodash.functionsIn = functionsIn;
    lodash.groupBy = groupBy;
    lodash.initial = initial;
    lodash.intersection = intersection;
    lodash.intersectionBy = intersectionBy;
    lodash.intersectionWith = intersectionWith;
    lodash.invert = invert;
    lodash.invertBy = invertBy;
    lodash.invokeMap = invokeMap;
    lodash.iteratee = iteratee;
    lodash.keyBy = keyBy;
    lodash.keys = keys;
    lodash.keysIn = keysIn;
    lodash.map = map;
    lodash.mapKeys = mapKeys;
    lodash.mapValues = mapValues;
    lodash.matches = matches;
    lodash.matchesProperty = matchesProperty;
    lodash.memoize = memoize;
    lodash.merge = merge;
    lodash.mergeWith = mergeWith;
    lodash.method = method;
    lodash.methodOf = methodOf;
    lodash.mixin = mixin;
    lodash.negate = negate;
    lodash.nthArg = nthArg;
    lodash.omit = omit;
    lodash.omitBy = omitBy;
    lodash.once = once;
    lodash.orderBy = orderBy;
    lodash.over = over;
    lodash.overArgs = overArgs;
    lodash.overEvery = overEvery;
    lodash.overSome = overSome;
    lodash.partial = partial;
    lodash.partialRight = partialRight;
    lodash.partition = partition;
    lodash.pick = pick;
    lodash.pickBy = pickBy;
    lodash.property = property;
    lodash.propertyOf = propertyOf;
    lodash.pull = pull;
    lodash.pullAll = pullAll;
    lodash.pullAllBy = pullAllBy;
    lodash.pullAllWith = pullAllWith;
    lodash.pullAt = pullAt;
    lodash.range = range;
    lodash.rangeRight = rangeRight;
    lodash.rearg = rearg;
    lodash.reject = reject;
    lodash.remove = remove;
    lodash.rest = rest;
    lodash.reverse = reverse;
    lodash.sampleSize = sampleSize;
    lodash.set = set;
    lodash.setWith = setWith;
    lodash.shuffle = shuffle;
    lodash.slice = slice;
    lodash.sortBy = sortBy;
    lodash.sortedUniq = sortedUniq;
    lodash.sortedUniqBy = sortedUniqBy;
    lodash.split = split;
    lodash.spread = spread;
    lodash.tail = tail;
    lodash.take = take;
    lodash.takeRight = takeRight;
    lodash.takeRightWhile = takeRightWhile;
    lodash.takeWhile = takeWhile;
    lodash.tap = tap;
    lodash.throttle = throttle;
    lodash.thru = thru;
    lodash.toArray = toArray;
    lodash.toPairs = toPairs;
    lodash.toPairsIn = toPairsIn;
    lodash.toPath = toPath;
    lodash.toPlainObject = toPlainObject;
    lodash.transform = transform;
    lodash.unary = unary;
    lodash.union = union;
    lodash.unionBy = unionBy;
    lodash.unionWith = unionWith;
    lodash.uniq = uniq;
    lodash.uniqBy = uniqBy;
    lodash.uniqWith = uniqWith;
    lodash.unset = unset;
    lodash.unzip = unzip;
    lodash.unzipWith = unzipWith;
    lodash.update = update;
    lodash.updateWith = updateWith;
    lodash.values = values;
    lodash.valuesIn = valuesIn;
    lodash.without = without;
    lodash.words = words;
    lodash.wrap = wrap;
    lodash.xor = xor;
    lodash.xorBy = xorBy;
    lodash.xorWith = xorWith;
    lodash.zip = zip;
    lodash.zipObject = zipObject;
    lodash.zipObjectDeep = zipObjectDeep;
    lodash.zipWith = zipWith;

    // Add aliases.
    lodash.entries = toPairs;
    lodash.entriesIn = toPairsIn;
    lodash.extend = assignIn;
    lodash.extendWith = assignInWith;

    // Add methods to `lodash.prototype`.
    mixin(lodash, lodash);

    /*------------------------------------------------------------------------*/

    // Add methods that return unwrapped values in chain sequences.
    lodash.add = add;
    lodash.attempt = attempt;
    lodash.camelCase = camelCase;
    lodash.capitalize = capitalize;
    lodash.ceil = ceil;
    lodash.clamp = clamp;
    lodash.clone = clone;
    lodash.cloneDeep = cloneDeep;
    lodash.cloneDeepWith = cloneDeepWith;
    lodash.cloneWith = cloneWith;
    lodash.conformsTo = conformsTo;
    lodash.deburr = deburr;
    lodash.defaultTo = defaultTo;
    lodash.divide = divide;
    lodash.endsWith = endsWith;
    lodash.eq = eq;
    lodash.escape = escape;
    lodash.escapeRegExp = escapeRegExp;
    lodash.every = every;
    lodash.find = find;
    lodash.findIndex = findIndex;
    lodash.findKey = findKey;
    lodash.findLast = findLast;
    lodash.findLastIndex = findLastIndex;
    lodash.findLastKey = findLastKey;
    lodash.floor = floor;
    lodash.forEach = forEach;
    lodash.forEachRight = forEachRight;
    lodash.forIn = forIn;
    lodash.forInRight = forInRight;
    lodash.forOwn = forOwn;
    lodash.forOwnRight = forOwnRight;
    lodash.get = get;
    lodash.gt = gt;
    lodash.gte = gte;
    lodash.has = has;
    lodash.hasIn = hasIn;
    lodash.head = head;
    lodash.identity = identity;
    lodash.includes = includes;
    lodash.indexOf = indexOf;
    lodash.inRange = inRange;
    lodash.invoke = invoke;
    lodash.isArguments = isArguments;
    lodash.isArray = isArray;
    lodash.isArrayBuffer = isArrayBuffer;
    lodash.isArrayLike = isArrayLike;
    lodash.isArrayLikeObject = isArrayLikeObject;
    lodash.isBoolean = isBoolean;
    lodash.isBuffer = isBuffer;
    lodash.isDate = isDate;
    lodash.isElement = isElement;
    lodash.isEmpty = isEmpty;
    lodash.isEqual = isEqual;
    lodash.isEqualWith = isEqualWith;
    lodash.isError = isError;
    lodash.isFinite = isFinite;
    lodash.isFunction = isFunction;
    lodash.isInteger = isInteger;
    lodash.isLength = isLength;
    lodash.isMap = isMap;
    lodash.isMatch = isMatch;
    lodash.isMatchWith = isMatchWith;
    lodash.isNaN = isNaN;
    lodash.isNative = isNative;
    lodash.isNil = isNil;
    lodash.isNull = isNull;
    lodash.isNumber = isNumber;
    lodash.isObject = isObject;
    lodash.isObjectLike = isObjectLike;
    lodash.isPlainObject = isPlainObject;
    lodash.isRegExp = isRegExp;
    lodash.isSafeInteger = isSafeInteger;
    lodash.isSet = isSet;
    lodash.isString = isString;
    lodash.isSymbol = isSymbol;
    lodash.isTypedArray = isTypedArray;
    lodash.isUndefined = isUndefined;
    lodash.isWeakMap = isWeakMap;
    lodash.isWeakSet = isWeakSet;
    lodash.join = join;
    lodash.kebabCase = kebabCase;
    lodash.last = last;
    lodash.lastIndexOf = lastIndexOf;
    lodash.lowerCase = lowerCase;
    lodash.lowerFirst = lowerFirst;
    lodash.lt = lt;
    lodash.lte = lte;
    lodash.max = max;
    lodash.maxBy = maxBy;
    lodash.mean = mean;
    lodash.meanBy = meanBy;
    lodash.min = min;
    lodash.minBy = minBy;
    lodash.stubArray = stubArray;
    lodash.stubFalse = stubFalse;
    lodash.stubObject = stubObject;
    lodash.stubString = stubString;
    lodash.stubTrue = stubTrue;
    lodash.multiply = multiply;
    lodash.nth = nth;
    lodash.noConflict = noConflict;
    lodash.noop = noop;
    lodash.now = now;
    lodash.pad = pad;
    lodash.padEnd = padEnd;
    lodash.padStart = padStart;
    lodash.parseInt = parseInt;
    lodash.random = random;
    lodash.reduce = reduce;
    lodash.reduceRight = reduceRight;
    lodash.repeat = repeat;
    lodash.replace = replace;
    lodash.result = result;
    lodash.round = round;
    lodash.runInContext = runInContext;
    lodash.sample = sample;
    lodash.size = size;
    lodash.snakeCase = snakeCase;
    lodash.some = some;
    lodash.sortedIndex = sortedIndex;
    lodash.sortedIndexBy = sortedIndexBy;
    lodash.sortedIndexOf = sortedIndexOf;
    lodash.sortedLastIndex = sortedLastIndex;
    lodash.sortedLastIndexBy = sortedLastIndexBy;
    lodash.sortedLastIndexOf = sortedLastIndexOf;
    lodash.startCase = startCase;
    lodash.startsWith = startsWith;
    lodash.subtract = subtract;
    lodash.sum = sum;
    lodash.sumBy = sumBy;
    lodash.template = template;
    lodash.times = times;
    lodash.toFinite = toFinite;
    lodash.toInteger = toInteger;
    lodash.toLength = toLength;
    lodash.toLower = toLower;
    lodash.toNumber = toNumber;
    lodash.toSafeInteger = toSafeInteger;
    lodash.toString = toString;
    lodash.toUpper = toUpper;
    lodash.trim = trim;
    lodash.trimEnd = trimEnd;
    lodash.trimStart = trimStart;
    lodash.truncate = truncate;
    lodash.unescape = unescape;
    lodash.uniqueId = uniqueId;
    lodash.upperCase = upperCase;
    lodash.upperFirst = upperFirst;

    // Add aliases.
    lodash.each = forEach;
    lodash.eachRight = forEachRight;
    lodash.first = head;

    mixin(lodash, (function() {
      var source = {};
      baseForOwn(lodash, function(func, methodName) {
        if (!hasOwnProperty.call(lodash.prototype, methodName)) {
          source[methodName] = func;
        }
      });
      return source;
    }()), { 'chain': false });

    /*------------------------------------------------------------------------*/

    /**
     * The semantic version number.
     *
     * @static
     * @memberOf _
     * @type {string}
     */
    lodash.VERSION = VERSION;

    // Assign default placeholders.
    arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {
      lodash[methodName].placeholder = lodash;
    });

    // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
    arrayEach(['drop', 'take'], function(methodName, index) {
      LazyWrapper.prototype[methodName] = function(n) {
        n = n === undefined ? 1 : nativeMax(toInteger(n), 0);

        var result = (this.__filtered__ && !index)
          ? new LazyWrapper(this)
          : this.clone();

        if (result.__filtered__) {
          result.__takeCount__ = nativeMin(n, result.__takeCount__);
        } else {
          result.__views__.push({
            'size': nativeMin(n, MAX_ARRAY_LENGTH),
            'type': methodName + (result.__dir__ < 0 ? 'Right' : '')
          });
        }
        return result;
      };

      LazyWrapper.prototype[methodName + 'Right'] = function(n) {
        return this.reverse()[methodName](n).reverse();
      };
    });

    // Add `LazyWrapper` methods that accept an `iteratee` value.
    arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {
      var type = index + 1,
          isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;

      LazyWrapper.prototype[methodName] = function(iteratee) {
        var result = this.clone();
        result.__iteratees__.push({
          'iteratee': getIteratee(iteratee, 3),
          'type': type
        });
        result.__filtered__ = result.__filtered__ || isFilter;
        return result;
      };
    });

    // Add `LazyWrapper` methods for `_.head` and `_.last`.
    arrayEach(['head', 'last'], function(methodName, index) {
      var takeName = 'take' + (index ? 'Right' : '');

      LazyWrapper.prototype[methodName] = function() {
        return this[takeName](1).value()[0];
      };
    });

    // Add `LazyWrapper` methods for `_.initial` and `_.tail`.
    arrayEach(['initial', 'tail'], function(methodName, index) {
      var dropName = 'drop' + (index ? '' : 'Right');

      LazyWrapper.prototype[methodName] = function() {
        return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
      };
    });

    LazyWrapper.prototype.compact = function() {
      return this.filter(identity);
    };

    LazyWrapper.prototype.find = function(predicate) {
      return this.filter(predicate).head();
    };

    LazyWrapper.prototype.findLast = function(predicate) {
      return this.reverse().find(predicate);
    };

    LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
      if (typeof path == 'function') {
        return new LazyWrapper(this);
      }
      return this.map(function(value) {
        return baseInvoke(value, path, args);
      });
    });

    LazyWrapper.prototype.reject = function(predicate) {
      return this.filter(negate(getIteratee(predicate)));
    };

    LazyWrapper.prototype.slice = function(start, end) {
      start = toInteger(start);

      var result = this;
      if (result.__filtered__ && (start > 0 || end < 0)) {
        return new LazyWrapper(result);
      }
      if (start < 0) {
        result = result.takeRight(-start);
      } else if (start) {
        result = result.drop(start);
      }
      if (end !== undefined) {
        end = toInteger(end);
        result = end < 0 ? result.dropRight(-end) : result.take(end - start);
      }
      return result;
    };

    LazyWrapper.prototype.takeRightWhile = function(predicate) {
      return this.reverse().takeWhile(predicate).reverse();
    };

    LazyWrapper.prototype.toArray = function() {
      return this.take(MAX_ARRAY_LENGTH);
    };

    // Add `LazyWrapper` methods to `lodash.prototype`.
    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
      var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName),
          isTaker = /^(?:head|last)$/.test(methodName),
          lodashFunc = lodash[isTaker ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName],
          retUnwrapped = isTaker || /^find/.test(methodName);

      if (!lodashFunc) {
        return;
      }
      lodash.prototype[methodName] = function() {
        var value = this.__wrapped__,
            args = isTaker ? [1] : arguments,
            isLazy = value instanceof LazyWrapper,
            iteratee = args[0],
            useLazy = isLazy || isArray(value);

        var interceptor = function(value) {
          var result = lodashFunc.apply(lodash, arrayPush([value], args));
          return (isTaker && chainAll) ? result[0] : result;
        };

        if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {
          // Avoid lazy use if the iteratee has a "length" value other than `1`.
          isLazy = useLazy = false;
        }
        var chainAll = this.__chain__,
            isHybrid = !!this.__actions__.length,
            isUnwrapped = retUnwrapped && !chainAll,
            onlyLazy = isLazy && !isHybrid;

        if (!retUnwrapped && useLazy) {
          value = onlyLazy ? value : new LazyWrapper(this);
          var result = func.apply(value, args);
          result.__actions__.push({ 'func': thru, 'args': [interceptor], 'thisArg': undefined });
          return new LodashWrapper(result, chainAll);
        }
        if (isUnwrapped && onlyLazy) {
          return func.apply(this, args);
        }
        result = this.thru(interceptor);
        return isUnwrapped ? (isTaker ? result.value()[0] : result.value()) : result;
      };
    });

    // Add `Array` methods to `lodash.prototype`.
    arrayEach(['pop', 'push', 'shift', 'sort', 'splice', 'unshift'], function(methodName) {
      var func = arrayProto[methodName],
          chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
          retUnwrapped = /^(?:pop|shift)$/.test(methodName);

      lodash.prototype[methodName] = function() {
        var args = arguments;
        if (retUnwrapped && !this.__chain__) {
          var value = this.value();
          return func.apply(isArray(value) ? value : [], args);
        }
        return this[chainName](function(value) {
          return func.apply(isArray(value) ? value : [], args);
        });
      };
    });

    // Map minified method names to their real names.
    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
      var lodashFunc = lodash[methodName];
      if (lodashFunc) {
        var key = lodashFunc.name + '';
        if (!hasOwnProperty.call(realNames, key)) {
          realNames[key] = [];
        }
        realNames[key].push({ 'name': methodName, 'func': lodashFunc });
      }
    });

    realNames[createHybrid(undefined, WRAP_BIND_KEY_FLAG).name] = [{
      'name': 'wrapper',
      'func': undefined
    }];

    // Add methods to `LazyWrapper`.
    LazyWrapper.prototype.clone = lazyClone;
    LazyWrapper.prototype.reverse = lazyReverse;
    LazyWrapper.prototype.value = lazyValue;

    // Add chain sequence methods to the `lodash` wrapper.
    lodash.prototype.at = wrapperAt;
    lodash.prototype.chain = wrapperChain;
    lodash.prototype.commit = wrapperCommit;
    lodash.prototype.next = wrapperNext;
    lodash.prototype.plant = wrapperPlant;
    lodash.prototype.reverse = wrapperReverse;
    lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;

    // Add lazy aliases.
    lodash.prototype.first = lodash.prototype.head;

    if (symIterator) {
      lodash.prototype[symIterator] = wrapperToIterator;
    }
    return lodash;
  });

  /*--------------------------------------------------------------------------*/

  // Export lodash.
  var _ = runInContext();

  // Some AMD build optimizers, like r.js, check for condition patterns like:
  if (true) {
    // Expose Lodash on the global object to prevent errors when Lodash is
    // loaded by a script tag in the presence of an AMD loader.
    // See http://requirejs.org/docs/errors.html#mismatch for more details.
    // Use `_.noConflict` to remove Lodash from the global object.
    root._ = _;

    // Define as an anonymous module so, through path mapping, it can be
    // referenced as the "underscore" module.
    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
      return _;
    }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  }
  // Check for `exports` after `define` in case a build optimizer adds it.
  else {}
}.call(this));


/***/ }),

/***/ "./resources/css/app.css":
/*!*******************************!*\
  !*** ./resources/css/app.css ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/***/ ((module) => {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "./node_modules/swiper/modules/navigation/navigation.min.css":
/*!*******************************************************************!*\
  !*** ./node_modules/swiper/modules/navigation/navigation.min.css ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../../style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _css_loader_dist_cjs_js_clonedRuleSet_9_use_1_postcss_loader_dist_cjs_js_clonedRuleSet_9_use_2_navigation_min_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !!../../../css-loader/dist/cjs.js??clonedRuleSet-9.use[1]!../../../postcss-loader/dist/cjs.js??clonedRuleSet-9.use[2]!./navigation.min.css */ "./node_modules/css-loader/dist/cjs.js??clonedRuleSet-9.use[1]!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9.use[2]!./node_modules/swiper/modules/navigation/navigation.min.css");

            

var options = {};

options.insert = "head";
options.singleton = false;

var update = _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_css_loader_dist_cjs_js_clonedRuleSet_9_use_1_postcss_loader_dist_cjs_js_clonedRuleSet_9_use_2_navigation_min_css__WEBPACK_IMPORTED_MODULE_1__["default"], options);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_css_loader_dist_cjs_js_clonedRuleSet_9_use_1_postcss_loader_dist_cjs_js_clonedRuleSet_9_use_2_navigation_min_css__WEBPACK_IMPORTED_MODULE_1__["default"].locals || {});

/***/ }),

/***/ "./node_modules/swiper/modules/pagination/pagination.min.css":
/*!*******************************************************************!*\
  !*** ./node_modules/swiper/modules/pagination/pagination.min.css ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../../style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _css_loader_dist_cjs_js_clonedRuleSet_9_use_1_postcss_loader_dist_cjs_js_clonedRuleSet_9_use_2_pagination_min_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !!../../../css-loader/dist/cjs.js??clonedRuleSet-9.use[1]!../../../postcss-loader/dist/cjs.js??clonedRuleSet-9.use[2]!./pagination.min.css */ "./node_modules/css-loader/dist/cjs.js??clonedRuleSet-9.use[1]!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9.use[2]!./node_modules/swiper/modules/pagination/pagination.min.css");

            

var options = {};

options.insert = "head";
options.singleton = false;

var update = _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_css_loader_dist_cjs_js_clonedRuleSet_9_use_1_postcss_loader_dist_cjs_js_clonedRuleSet_9_use_2_pagination_min_css__WEBPACK_IMPORTED_MODULE_1__["default"], options);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_css_loader_dist_cjs_js_clonedRuleSet_9_use_1_postcss_loader_dist_cjs_js_clonedRuleSet_9_use_2_pagination_min_css__WEBPACK_IMPORTED_MODULE_1__["default"].locals || {});

/***/ }),

/***/ "./node_modules/swiper/swiper.min.css":
/*!********************************************!*\
  !*** ./node_modules/swiper/swiper.min.css ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _css_loader_dist_cjs_js_clonedRuleSet_9_use_1_postcss_loader_dist_cjs_js_clonedRuleSet_9_use_2_swiper_min_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !!../css-loader/dist/cjs.js??clonedRuleSet-9.use[1]!../postcss-loader/dist/cjs.js??clonedRuleSet-9.use[2]!./swiper.min.css */ "./node_modules/css-loader/dist/cjs.js??clonedRuleSet-9.use[1]!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9.use[2]!./node_modules/swiper/swiper.min.css");

            

var options = {};

options.insert = "head";
options.singleton = false;

var update = _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_css_loader_dist_cjs_js_clonedRuleSet_9_use_1_postcss_loader_dist_cjs_js_clonedRuleSet_9_use_2_swiper_min_css__WEBPACK_IMPORTED_MODULE_1__["default"], options);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_css_loader_dist_cjs_js_clonedRuleSet_9_use_1_postcss_loader_dist_cjs_js_clonedRuleSet_9_use_2_swiper_min_css__WEBPACK_IMPORTED_MODULE_1__["default"].locals || {});

/***/ }),

/***/ "./node_modules/style-loader/dist/cjs.js!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-9.use[1]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9.use[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/Card.vue?vue&type=style&index=0&id=b9bc2c0a&lang=css":
/*!***************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/style-loader/dist/cjs.js!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-9.use[1]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9.use[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/Card.vue?vue&type=style&index=0&id=b9bc2c0a&lang=css ***!
  \***************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_clonedRuleSet_9_use_1_node_modules_vue_loader_dist_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_9_use_2_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_Card_vue_vue_type_style_index_0_id_b9bc2c0a_lang_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !!../../../node_modules/css-loader/dist/cjs.js??clonedRuleSet-9.use[1]!../../../node_modules/vue-loader/dist/stylePostLoader.js!../../../node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9.use[2]!../../../node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./Card.vue?vue&type=style&index=0&id=b9bc2c0a&lang=css */ "./node_modules/css-loader/dist/cjs.js??clonedRuleSet-9.use[1]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9.use[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/Card.vue?vue&type=style&index=0&id=b9bc2c0a&lang=css");

            

var options = {};

options.insert = "head";
options.singleton = false;

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_clonedRuleSet_9_use_1_node_modules_vue_loader_dist_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_9_use_2_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_Card_vue_vue_type_style_index_0_id_b9bc2c0a_lang_css__WEBPACK_IMPORTED_MODULE_1__["default"], options);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_clonedRuleSet_9_use_1_node_modules_vue_loader_dist_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_9_use_2_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_Card_vue_vue_type_style_index_0_id_b9bc2c0a_lang_css__WEBPACK_IMPORTED_MODULE_1__["default"].locals || {});

/***/ }),

/***/ "./node_modules/style-loader/dist/cjs.js!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-9.use[1]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9.use[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/categories/Dropdowncontent.vue?vue&type=style&index=0&id=6d946540&lang=css":
/*!*************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/style-loader/dist/cjs.js!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-9.use[1]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9.use[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/categories/Dropdowncontent.vue?vue&type=style&index=0&id=6d946540&lang=css ***!
  \*************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_clonedRuleSet_9_use_1_node_modules_vue_loader_dist_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_9_use_2_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_Dropdowncontent_vue_vue_type_style_index_0_id_6d946540_lang_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !!../../../../node_modules/css-loader/dist/cjs.js??clonedRuleSet-9.use[1]!../../../../node_modules/vue-loader/dist/stylePostLoader.js!../../../../node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9.use[2]!../../../../node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./Dropdowncontent.vue?vue&type=style&index=0&id=6d946540&lang=css */ "./node_modules/css-loader/dist/cjs.js??clonedRuleSet-9.use[1]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9.use[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/categories/Dropdowncontent.vue?vue&type=style&index=0&id=6d946540&lang=css");

            

var options = {};

options.insert = "head";
options.singleton = false;

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_clonedRuleSet_9_use_1_node_modules_vue_loader_dist_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_9_use_2_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_Dropdowncontent_vue_vue_type_style_index_0_id_6d946540_lang_css__WEBPACK_IMPORTED_MODULE_1__["default"], options);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_clonedRuleSet_9_use_1_node_modules_vue_loader_dist_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_9_use_2_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_Dropdowncontent_vue_vue_type_style_index_0_id_6d946540_lang_css__WEBPACK_IMPORTED_MODULE_1__["default"].locals || {});

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var isOldIE = function isOldIE() {
  var memo;
  return function memorize() {
    if (typeof memo === 'undefined') {
      // Test for IE <= 9 as proposed by Browserhacks
      // @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
      // Tests for existence of standard globals is to allow style-loader
      // to operate correctly into non-standard environments
      // @see https://github.com/webpack-contrib/style-loader/issues/177
      memo = Boolean(window && document && document.all && !window.atob);
    }

    return memo;
  };
}();

var getTarget = function getTarget() {
  var memo = {};
  return function memorize(target) {
    if (typeof memo[target] === 'undefined') {
      var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself

      if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
        try {
          // This will throw an exception if access to iframe is blocked
          // due to cross-origin restrictions
          styleTarget = styleTarget.contentDocument.head;
        } catch (e) {
          // istanbul ignore next
          styleTarget = null;
        }
      }

      memo[target] = styleTarget;
    }

    return memo[target];
  };
}();

var stylesInDom = [];

function getIndexByIdentifier(identifier) {
  var result = -1;

  for (var i = 0; i < stylesInDom.length; i++) {
    if (stylesInDom[i].identifier === identifier) {
      result = i;
      break;
    }
  }

  return result;
}

function modulesToDom(list, options) {
  var idCountMap = {};
  var identifiers = [];

  for (var i = 0; i < list.length; i++) {
    var item = list[i];
    var id = options.base ? item[0] + options.base : item[0];
    var count = idCountMap[id] || 0;
    var identifier = "".concat(id, " ").concat(count);
    idCountMap[id] = count + 1;
    var index = getIndexByIdentifier(identifier);
    var obj = {
      css: item[1],
      media: item[2],
      sourceMap: item[3]
    };

    if (index !== -1) {
      stylesInDom[index].references++;
      stylesInDom[index].updater(obj);
    } else {
      stylesInDom.push({
        identifier: identifier,
        updater: addStyle(obj, options),
        references: 1
      });
    }

    identifiers.push(identifier);
  }

  return identifiers;
}

function insertStyleElement(options) {
  var style = document.createElement('style');
  var attributes = options.attributes || {};

  if (typeof attributes.nonce === 'undefined') {
    var nonce =  true ? __webpack_require__.nc : 0;

    if (nonce) {
      attributes.nonce = nonce;
    }
  }

  Object.keys(attributes).forEach(function (key) {
    style.setAttribute(key, attributes[key]);
  });

  if (typeof options.insert === 'function') {
    options.insert(style);
  } else {
    var target = getTarget(options.insert || 'head');

    if (!target) {
      throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
    }

    target.appendChild(style);
  }

  return style;
}

function removeStyleElement(style) {
  // istanbul ignore if
  if (style.parentNode === null) {
    return false;
  }

  style.parentNode.removeChild(style);
}
/* istanbul ignore next  */


var replaceText = function replaceText() {
  var textStore = [];
  return function replace(index, replacement) {
    textStore[index] = replacement;
    return textStore.filter(Boolean).join('\n');
  };
}();

function applyToSingletonTag(style, index, remove, obj) {
  var css = remove ? '' : obj.media ? "@media ".concat(obj.media, " {").concat(obj.css, "}") : obj.css; // For old IE

  /* istanbul ignore if  */

  if (style.styleSheet) {
    style.styleSheet.cssText = replaceText(index, css);
  } else {
    var cssNode = document.createTextNode(css);
    var childNodes = style.childNodes;

    if (childNodes[index]) {
      style.removeChild(childNodes[index]);
    }

    if (childNodes.length) {
      style.insertBefore(cssNode, childNodes[index]);
    } else {
      style.appendChild(cssNode);
    }
  }
}

function applyToTag(style, options, obj) {
  var css = obj.css;
  var media = obj.media;
  var sourceMap = obj.sourceMap;

  if (media) {
    style.setAttribute('media', media);
  } else {
    style.removeAttribute('media');
  }

  if (sourceMap && typeof btoa !== 'undefined') {
    css += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), " */");
  } // For old IE

  /* istanbul ignore if  */


  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    while (style.firstChild) {
      style.removeChild(style.firstChild);
    }

    style.appendChild(document.createTextNode(css));
  }
}

var singleton = null;
var singletonCounter = 0;

function addStyle(obj, options) {
  var style;
  var update;
  var remove;

  if (options.singleton) {
    var styleIndex = singletonCounter++;
    style = singleton || (singleton = insertStyleElement(options));
    update = applyToSingletonTag.bind(null, style, styleIndex, false);
    remove = applyToSingletonTag.bind(null, style, styleIndex, true);
  } else {
    style = insertStyleElement(options);
    update = applyToTag.bind(null, style, options);

    remove = function remove() {
      removeStyleElement(style);
    };
  }

  update(obj);
  return function updateStyle(newObj) {
    if (newObj) {
      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {
        return;
      }

      update(obj = newObj);
    } else {
      remove();
    }
  };
}

module.exports = function (list, options) {
  options = options || {}; // Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
  // tags it will allow on a page

  if (!options.singleton && typeof options.singleton !== 'boolean') {
    options.singleton = isOldIE();
  }

  list = list || [];
  var lastIdentifiers = modulesToDom(list, options);
  return function update(newList) {
    newList = newList || [];

    if (Object.prototype.toString.call(newList) !== '[object Array]') {
      return;
    }

    for (var i = 0; i < lastIdentifiers.length; i++) {
      var identifier = lastIdentifiers[i];
      var index = getIndexByIdentifier(identifier);
      stylesInDom[index].references--;
    }

    var newLastIdentifiers = modulesToDom(newList, options);

    for (var _i = 0; _i < lastIdentifiers.length; _i++) {
      var _identifier = lastIdentifiers[_i];

      var _index = getIndexByIdentifier(_identifier);

      if (stylesInDom[_index].references === 0) {
        stylesInDom[_index].updater();

        stylesInDom.splice(_index, 1);
      }
    }

    lastIdentifiers = newLastIdentifiers;
  };
};

/***/ }),

/***/ "./node_modules/vue-loader/dist/exportHelper.js":
/*!******************************************************!*\
  !*** ./node_modules/vue-loader/dist/exportHelper.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
// runtime helper for setting properties on components
// in a tree-shakable way
exports["default"] = (sfc, props) => {
    const target = sfc.__vccOpts || sfc;
    for (const [key, val] of props) {
        target[key] = val;
    }
    return target;
};


/***/ }),

/***/ "./resources/js/components/Card.vue":
/*!******************************************!*\
  !*** ./resources/js/components/Card.vue ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Card_vue_vue_type_template_id_b9bc2c0a__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Card.vue?vue&type=template&id=b9bc2c0a */ "./resources/js/components/Card.vue?vue&type=template&id=b9bc2c0a");
/* harmony import */ var _Card_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Card.vue?vue&type=script&lang=js */ "./resources/js/components/Card.vue?vue&type=script&lang=js");
/* harmony import */ var _Card_vue_vue_type_style_index_0_id_b9bc2c0a_lang_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Card.vue?vue&type=style&index=0&id=b9bc2c0a&lang=css */ "./resources/js/components/Card.vue?vue&type=style&index=0&id=b9bc2c0a&lang=css");
/* harmony import */ var F_Projects_my_web_portfolio_node_modules_vue_loader_dist_exportHelper_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./node_modules/vue-loader/dist/exportHelper.js */ "./node_modules/vue-loader/dist/exportHelper.js");




;


const __exports__ = /*#__PURE__*/(0,F_Projects_my_web_portfolio_node_modules_vue_loader_dist_exportHelper_js__WEBPACK_IMPORTED_MODULE_3__["default"])(_Card_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_1__["default"], [['render',_Card_vue_vue_type_template_id_b9bc2c0a__WEBPACK_IMPORTED_MODULE_0__.render],['__file',"resources/js/components/Card.vue"]])
/* hot reload */
if (false) {}


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__exports__);

/***/ }),

/***/ "./resources/js/components/Flashmessage.vue":
/*!**************************************************!*\
  !*** ./resources/js/components/Flashmessage.vue ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Flashmessage_vue_vue_type_template_id_4cfe5afc__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Flashmessage.vue?vue&type=template&id=4cfe5afc */ "./resources/js/components/Flashmessage.vue?vue&type=template&id=4cfe5afc");
/* harmony import */ var _Flashmessage_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Flashmessage.vue?vue&type=script&lang=js */ "./resources/js/components/Flashmessage.vue?vue&type=script&lang=js");
/* harmony import */ var F_Projects_my_web_portfolio_node_modules_vue_loader_dist_exportHelper_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./node_modules/vue-loader/dist/exportHelper.js */ "./node_modules/vue-loader/dist/exportHelper.js");




;
const __exports__ = /*#__PURE__*/(0,F_Projects_my_web_portfolio_node_modules_vue_loader_dist_exportHelper_js__WEBPACK_IMPORTED_MODULE_2__["default"])(_Flashmessage_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_1__["default"], [['render',_Flashmessage_vue_vue_type_template_id_4cfe5afc__WEBPACK_IMPORTED_MODULE_0__.render],['__file',"resources/js/components/Flashmessage.vue"]])
/* hot reload */
if (false) {}


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__exports__);

/***/ }),

/***/ "./resources/js/components/categories/Dropdown.vue":
/*!*********************************************************!*\
  !*** ./resources/js/components/categories/Dropdown.vue ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Dropdown_vue_vue_type_template_id_13f3326e__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Dropdown.vue?vue&type=template&id=13f3326e */ "./resources/js/components/categories/Dropdown.vue?vue&type=template&id=13f3326e");
/* harmony import */ var _Dropdown_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Dropdown.vue?vue&type=script&lang=js */ "./resources/js/components/categories/Dropdown.vue?vue&type=script&lang=js");
/* harmony import */ var F_Projects_my_web_portfolio_node_modules_vue_loader_dist_exportHelper_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./node_modules/vue-loader/dist/exportHelper.js */ "./node_modules/vue-loader/dist/exportHelper.js");




;
const __exports__ = /*#__PURE__*/(0,F_Projects_my_web_portfolio_node_modules_vue_loader_dist_exportHelper_js__WEBPACK_IMPORTED_MODULE_2__["default"])(_Dropdown_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_1__["default"], [['render',_Dropdown_vue_vue_type_template_id_13f3326e__WEBPACK_IMPORTED_MODULE_0__.render],['__file',"resources/js/components/categories/Dropdown.vue"]])
/* hot reload */
if (false) {}


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__exports__);

/***/ }),

/***/ "./resources/js/components/categories/Dropdowncontent.vue":
/*!****************************************************************!*\
  !*** ./resources/js/components/categories/Dropdowncontent.vue ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Dropdowncontent_vue_vue_type_template_id_6d946540__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Dropdowncontent.vue?vue&type=template&id=6d946540 */ "./resources/js/components/categories/Dropdowncontent.vue?vue&type=template&id=6d946540");
/* harmony import */ var _Dropdowncontent_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Dropdowncontent.vue?vue&type=script&lang=js */ "./resources/js/components/categories/Dropdowncontent.vue?vue&type=script&lang=js");
/* harmony import */ var _Dropdowncontent_vue_vue_type_style_index_0_id_6d946540_lang_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Dropdowncontent.vue?vue&type=style&index=0&id=6d946540&lang=css */ "./resources/js/components/categories/Dropdowncontent.vue?vue&type=style&index=0&id=6d946540&lang=css");
/* harmony import */ var F_Projects_my_web_portfolio_node_modules_vue_loader_dist_exportHelper_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./node_modules/vue-loader/dist/exportHelper.js */ "./node_modules/vue-loader/dist/exportHelper.js");




;


const __exports__ = /*#__PURE__*/(0,F_Projects_my_web_portfolio_node_modules_vue_loader_dist_exportHelper_js__WEBPACK_IMPORTED_MODULE_3__["default"])(_Dropdowncontent_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_1__["default"], [['render',_Dropdowncontent_vue_vue_type_template_id_6d946540__WEBPACK_IMPORTED_MODULE_0__.render],['__file',"resources/js/components/categories/Dropdowncontent.vue"]])
/* hot reload */
if (false) {}


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__exports__);

/***/ }),

/***/ "./resources/js/components/categories/Dropdownitems.vue":
/*!**************************************************************!*\
  !*** ./resources/js/components/categories/Dropdownitems.vue ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Dropdownitems_vue_vue_type_template_id_64b8fcc7__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Dropdownitems.vue?vue&type=template&id=64b8fcc7 */ "./resources/js/components/categories/Dropdownitems.vue?vue&type=template&id=64b8fcc7");
/* harmony import */ var _Dropdownitems_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Dropdownitems.vue?vue&type=script&lang=js */ "./resources/js/components/categories/Dropdownitems.vue?vue&type=script&lang=js");
/* harmony import */ var F_Projects_my_web_portfolio_node_modules_vue_loader_dist_exportHelper_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./node_modules/vue-loader/dist/exportHelper.js */ "./node_modules/vue-loader/dist/exportHelper.js");




;
const __exports__ = /*#__PURE__*/(0,F_Projects_my_web_portfolio_node_modules_vue_loader_dist_exportHelper_js__WEBPACK_IMPORTED_MODULE_2__["default"])(_Dropdownitems_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_1__["default"], [['render',_Dropdownitems_vue_vue_type_template_id_64b8fcc7__WEBPACK_IMPORTED_MODULE_0__.render],['__file',"resources/js/components/categories/Dropdownitems.vue"]])
/* hot reload */
if (false) {}


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__exports__);

/***/ }),

/***/ "./resources/js/components/darkcomponents/Svglogodark.vue":
/*!****************************************************************!*\
  !*** ./resources/js/components/darkcomponents/Svglogodark.vue ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Svglogodark_vue_vue_type_template_id_0c63f626__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Svglogodark.vue?vue&type=template&id=0c63f626 */ "./resources/js/components/darkcomponents/Svglogodark.vue?vue&type=template&id=0c63f626");
/* harmony import */ var _Svglogodark_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Svglogodark.vue?vue&type=script&lang=js */ "./resources/js/components/darkcomponents/Svglogodark.vue?vue&type=script&lang=js");
/* harmony import */ var F_Projects_my_web_portfolio_node_modules_vue_loader_dist_exportHelper_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./node_modules/vue-loader/dist/exportHelper.js */ "./node_modules/vue-loader/dist/exportHelper.js");




;
const __exports__ = /*#__PURE__*/(0,F_Projects_my_web_portfolio_node_modules_vue_loader_dist_exportHelper_js__WEBPACK_IMPORTED_MODULE_2__["default"])(_Svglogodark_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_1__["default"], [['render',_Svglogodark_vue_vue_type_template_id_0c63f626__WEBPACK_IMPORTED_MODULE_0__.render],['__file',"resources/js/components/darkcomponents/Svglogodark.vue"]])
/* hot reload */
if (false) {}


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__exports__);

/***/ }),

/***/ "./resources/js/components/darkcomponents/Svgnewsletterdark.vue":
/*!**********************************************************************!*\
  !*** ./resources/js/components/darkcomponents/Svgnewsletterdark.vue ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Svgnewsletterdark_vue_vue_type_template_id_aaffc20a__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Svgnewsletterdark.vue?vue&type=template&id=aaffc20a */ "./resources/js/components/darkcomponents/Svgnewsletterdark.vue?vue&type=template&id=aaffc20a");
/* harmony import */ var _Svgnewsletterdark_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Svgnewsletterdark.vue?vue&type=script&lang=js */ "./resources/js/components/darkcomponents/Svgnewsletterdark.vue?vue&type=script&lang=js");
/* harmony import */ var F_Projects_my_web_portfolio_node_modules_vue_loader_dist_exportHelper_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./node_modules/vue-loader/dist/exportHelper.js */ "./node_modules/vue-loader/dist/exportHelper.js");




;
const __exports__ = /*#__PURE__*/(0,F_Projects_my_web_portfolio_node_modules_vue_loader_dist_exportHelper_js__WEBPACK_IMPORTED_MODULE_2__["default"])(_Svgnewsletterdark_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_1__["default"], [['render',_Svgnewsletterdark_vue_vue_type_template_id_aaffc20a__WEBPACK_IMPORTED_MODULE_0__.render],['__file',"resources/js/components/darkcomponents/Svgnewsletterdark.vue"]])
/* hot reload */
if (false) {}


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__exports__);

/***/ }),

/***/ "./resources/js/components/darkcomponents/Switchdark.vue":
/*!***************************************************************!*\
  !*** ./resources/js/components/darkcomponents/Switchdark.vue ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Switchdark_vue_vue_type_template_id_069fc572__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Switchdark.vue?vue&type=template&id=069fc572 */ "./resources/js/components/darkcomponents/Switchdark.vue?vue&type=template&id=069fc572");
/* harmony import */ var _Switchdark_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Switchdark.vue?vue&type=script&lang=js */ "./resources/js/components/darkcomponents/Switchdark.vue?vue&type=script&lang=js");
/* harmony import */ var F_Projects_my_web_portfolio_node_modules_vue_loader_dist_exportHelper_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./node_modules/vue-loader/dist/exportHelper.js */ "./node_modules/vue-loader/dist/exportHelper.js");




;
const __exports__ = /*#__PURE__*/(0,F_Projects_my_web_portfolio_node_modules_vue_loader_dist_exportHelper_js__WEBPACK_IMPORTED_MODULE_2__["default"])(_Switchdark_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_1__["default"], [['render',_Switchdark_vue_vue_type_template_id_069fc572__WEBPACK_IMPORTED_MODULE_0__.render],['__file',"resources/js/components/darkcomponents/Switchdark.vue"]])
/* hot reload */
if (false) {}


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__exports__);

/***/ }),

/***/ "./resources/js/components/devto/Swiperimg.vue":
/*!*****************************************************!*\
  !*** ./resources/js/components/devto/Swiperimg.vue ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Swiperimg_vue_vue_type_template_id_28a22cb1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Swiperimg.vue?vue&type=template&id=28a22cb1 */ "./resources/js/components/devto/Swiperimg.vue?vue&type=template&id=28a22cb1");
/* harmony import */ var _Swiperimg_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Swiperimg.vue?vue&type=script&lang=js */ "./resources/js/components/devto/Swiperimg.vue?vue&type=script&lang=js");
/* harmony import */ var F_Projects_my_web_portfolio_node_modules_vue_loader_dist_exportHelper_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./node_modules/vue-loader/dist/exportHelper.js */ "./node_modules/vue-loader/dist/exportHelper.js");




;
const __exports__ = /*#__PURE__*/(0,F_Projects_my_web_portfolio_node_modules_vue_loader_dist_exportHelper_js__WEBPACK_IMPORTED_MODULE_2__["default"])(_Swiperimg_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_1__["default"], [['render',_Swiperimg_vue_vue_type_template_id_28a22cb1__WEBPACK_IMPORTED_MODULE_0__.render],['__file',"resources/js/components/devto/Swiperimg.vue"]])
/* hot reload */
if (false) {}


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__exports__);

/***/ }),

/***/ "./resources/js/components/devto/Swiperslides.vue":
/*!********************************************************!*\
  !*** ./resources/js/components/devto/Swiperslides.vue ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Swiperslides_vue_vue_type_template_id_6225d6e4__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Swiperslides.vue?vue&type=template&id=6225d6e4 */ "./resources/js/components/devto/Swiperslides.vue?vue&type=template&id=6225d6e4");
/* harmony import */ var _Swiperslides_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Swiperslides.vue?vue&type=script&lang=js */ "./resources/js/components/devto/Swiperslides.vue?vue&type=script&lang=js");
/* harmony import */ var F_Projects_my_web_portfolio_node_modules_vue_loader_dist_exportHelper_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./node_modules/vue-loader/dist/exportHelper.js */ "./node_modules/vue-loader/dist/exportHelper.js");




;
const __exports__ = /*#__PURE__*/(0,F_Projects_my_web_portfolio_node_modules_vue_loader_dist_exportHelper_js__WEBPACK_IMPORTED_MODULE_2__["default"])(_Swiperslides_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_1__["default"], [['render',_Swiperslides_vue_vue_type_template_id_6225d6e4__WEBPACK_IMPORTED_MODULE_0__.render],['__file',"resources/js/components/devto/Swiperslides.vue"]])
/* hot reload */
if (false) {}


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__exports__);

/***/ }),

/***/ "./resources/js/components/devto/Swiperslidescontent.vue":
/*!***************************************************************!*\
  !*** ./resources/js/components/devto/Swiperslidescontent.vue ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Swiperslidescontent_vue_vue_type_template_id_68f6b0c5__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Swiperslidescontent.vue?vue&type=template&id=68f6b0c5 */ "./resources/js/components/devto/Swiperslidescontent.vue?vue&type=template&id=68f6b0c5");
/* harmony import */ var _Swiperslidescontent_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Swiperslidescontent.vue?vue&type=script&lang=js */ "./resources/js/components/devto/Swiperslidescontent.vue?vue&type=script&lang=js");
/* harmony import */ var F_Projects_my_web_portfolio_node_modules_vue_loader_dist_exportHelper_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./node_modules/vue-loader/dist/exportHelper.js */ "./node_modules/vue-loader/dist/exportHelper.js");




;
const __exports__ = /*#__PURE__*/(0,F_Projects_my_web_portfolio_node_modules_vue_loader_dist_exportHelper_js__WEBPACK_IMPORTED_MODULE_2__["default"])(_Swiperslidescontent_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_1__["default"], [['render',_Swiperslidescontent_vue_vue_type_template_id_68f6b0c5__WEBPACK_IMPORTED_MODULE_0__.render],['__file',"resources/js/components/devto/Swiperslidescontent.vue"]])
/* hot reload */
if (false) {}


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__exports__);

/***/ }),

/***/ "./resources/js/components/devto/Swiperslidesitems.vue":
/*!*************************************************************!*\
  !*** ./resources/js/components/devto/Swiperslidesitems.vue ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Swiperslidesitems_vue_vue_type_template_id_00d2658c__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Swiperslidesitems.vue?vue&type=template&id=00d2658c */ "./resources/js/components/devto/Swiperslidesitems.vue?vue&type=template&id=00d2658c");
/* harmony import */ var _Swiperslidesitems_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Swiperslidesitems.vue?vue&type=script&lang=js */ "./resources/js/components/devto/Swiperslidesitems.vue?vue&type=script&lang=js");
/* harmony import */ var F_Projects_my_web_portfolio_node_modules_vue_loader_dist_exportHelper_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./node_modules/vue-loader/dist/exportHelper.js */ "./node_modules/vue-loader/dist/exportHelper.js");




;
const __exports__ = /*#__PURE__*/(0,F_Projects_my_web_portfolio_node_modules_vue_loader_dist_exportHelper_js__WEBPACK_IMPORTED_MODULE_2__["default"])(_Swiperslidesitems_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_1__["default"], [['render',_Swiperslidesitems_vue_vue_type_template_id_00d2658c__WEBPACK_IMPORTED_MODULE_0__.render],['__file',"resources/js/components/devto/Swiperslidesitems.vue"]])
/* hot reload */
if (false) {}


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__exports__);

/***/ }),

/***/ "./resources/js/components/Card.vue?vue&type=script&lang=js":
/*!******************************************************************!*\
  !*** ./resources/js/components/Card.vue?vue&type=script&lang=js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_Card_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_0__["default"])
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_Card_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!../../../node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./Card.vue?vue&type=script&lang=js */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/Card.vue?vue&type=script&lang=js");
 

/***/ }),

/***/ "./resources/js/components/Flashmessage.vue?vue&type=script&lang=js":
/*!**************************************************************************!*\
  !*** ./resources/js/components/Flashmessage.vue?vue&type=script&lang=js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_Flashmessage_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_0__["default"])
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_Flashmessage_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!../../../node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./Flashmessage.vue?vue&type=script&lang=js */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/Flashmessage.vue?vue&type=script&lang=js");
 

/***/ }),

/***/ "./resources/js/components/categories/Dropdown.vue?vue&type=script&lang=js":
/*!*********************************************************************************!*\
  !*** ./resources/js/components/categories/Dropdown.vue?vue&type=script&lang=js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_Dropdown_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_0__["default"])
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_Dropdown_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!../../../../node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./Dropdown.vue?vue&type=script&lang=js */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/categories/Dropdown.vue?vue&type=script&lang=js");
 

/***/ }),

/***/ "./resources/js/components/categories/Dropdowncontent.vue?vue&type=script&lang=js":
/*!****************************************************************************************!*\
  !*** ./resources/js/components/categories/Dropdowncontent.vue?vue&type=script&lang=js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_Dropdowncontent_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_0__["default"])
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_Dropdowncontent_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!../../../../node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./Dropdowncontent.vue?vue&type=script&lang=js */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/categories/Dropdowncontent.vue?vue&type=script&lang=js");
 

/***/ }),

/***/ "./resources/js/components/categories/Dropdownitems.vue?vue&type=script&lang=js":
/*!**************************************************************************************!*\
  !*** ./resources/js/components/categories/Dropdownitems.vue?vue&type=script&lang=js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_Dropdownitems_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_0__["default"])
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_Dropdownitems_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!../../../../node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./Dropdownitems.vue?vue&type=script&lang=js */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/categories/Dropdownitems.vue?vue&type=script&lang=js");
 

/***/ }),

/***/ "./resources/js/components/darkcomponents/Svglogodark.vue?vue&type=script&lang=js":
/*!****************************************************************************************!*\
  !*** ./resources/js/components/darkcomponents/Svglogodark.vue?vue&type=script&lang=js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_Svglogodark_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_0__["default"])
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_Svglogodark_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!../../../../node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./Svglogodark.vue?vue&type=script&lang=js */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/darkcomponents/Svglogodark.vue?vue&type=script&lang=js");
 

/***/ }),

/***/ "./resources/js/components/darkcomponents/Svgnewsletterdark.vue?vue&type=script&lang=js":
/*!**********************************************************************************************!*\
  !*** ./resources/js/components/darkcomponents/Svgnewsletterdark.vue?vue&type=script&lang=js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_Svgnewsletterdark_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_0__["default"])
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_Svgnewsletterdark_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!../../../../node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./Svgnewsletterdark.vue?vue&type=script&lang=js */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/darkcomponents/Svgnewsletterdark.vue?vue&type=script&lang=js");
 

/***/ }),

/***/ "./resources/js/components/darkcomponents/Switchdark.vue?vue&type=script&lang=js":
/*!***************************************************************************************!*\
  !*** ./resources/js/components/darkcomponents/Switchdark.vue?vue&type=script&lang=js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_Switchdark_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_0__["default"])
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_Switchdark_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!../../../../node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./Switchdark.vue?vue&type=script&lang=js */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/darkcomponents/Switchdark.vue?vue&type=script&lang=js");
 

/***/ }),

/***/ "./resources/js/components/devto/Swiperimg.vue?vue&type=script&lang=js":
/*!*****************************************************************************!*\
  !*** ./resources/js/components/devto/Swiperimg.vue?vue&type=script&lang=js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_Swiperimg_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_0__["default"])
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_Swiperimg_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!../../../../node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./Swiperimg.vue?vue&type=script&lang=js */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/devto/Swiperimg.vue?vue&type=script&lang=js");
 

/***/ }),

/***/ "./resources/js/components/devto/Swiperslides.vue?vue&type=script&lang=js":
/*!********************************************************************************!*\
  !*** ./resources/js/components/devto/Swiperslides.vue?vue&type=script&lang=js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_Swiperslides_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_0__["default"])
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_Swiperslides_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!../../../../node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./Swiperslides.vue?vue&type=script&lang=js */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/devto/Swiperslides.vue?vue&type=script&lang=js");
 

/***/ }),

/***/ "./resources/js/components/devto/Swiperslidescontent.vue?vue&type=script&lang=js":
/*!***************************************************************************************!*\
  !*** ./resources/js/components/devto/Swiperslidescontent.vue?vue&type=script&lang=js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_Swiperslidescontent_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_0__["default"])
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_Swiperslidescontent_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!../../../../node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./Swiperslidescontent.vue?vue&type=script&lang=js */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/devto/Swiperslidescontent.vue?vue&type=script&lang=js");
 

/***/ }),

/***/ "./resources/js/components/devto/Swiperslidesitems.vue?vue&type=script&lang=js":
/*!*************************************************************************************!*\
  !*** ./resources/js/components/devto/Swiperslidesitems.vue?vue&type=script&lang=js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_Swiperslidesitems_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_0__["default"])
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_Swiperslidesitems_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!../../../../node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./Swiperslidesitems.vue?vue&type=script&lang=js */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/devto/Swiperslidesitems.vue?vue&type=script&lang=js");
 

/***/ }),

/***/ "./resources/js/components/Card.vue?vue&type=template&id=b9bc2c0a":
/*!************************************************************************!*\
  !*** ./resources/js/components/Card.vue?vue&type=template&id=b9bc2c0a ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_Card_vue_vue_type_template_id_b9bc2c0a__WEBPACK_IMPORTED_MODULE_0__.render)
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_Card_vue_vue_type_template_id_b9bc2c0a__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!../../../node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!../../../node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./Card.vue?vue&type=template&id=b9bc2c0a */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/Card.vue?vue&type=template&id=b9bc2c0a");


/***/ }),

/***/ "./resources/js/components/Flashmessage.vue?vue&type=template&id=4cfe5afc":
/*!********************************************************************************!*\
  !*** ./resources/js/components/Flashmessage.vue?vue&type=template&id=4cfe5afc ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_Flashmessage_vue_vue_type_template_id_4cfe5afc__WEBPACK_IMPORTED_MODULE_0__.render)
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_Flashmessage_vue_vue_type_template_id_4cfe5afc__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!../../../node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!../../../node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./Flashmessage.vue?vue&type=template&id=4cfe5afc */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/Flashmessage.vue?vue&type=template&id=4cfe5afc");


/***/ }),

/***/ "./resources/js/components/categories/Dropdown.vue?vue&type=template&id=13f3326e":
/*!***************************************************************************************!*\
  !*** ./resources/js/components/categories/Dropdown.vue?vue&type=template&id=13f3326e ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_Dropdown_vue_vue_type_template_id_13f3326e__WEBPACK_IMPORTED_MODULE_0__.render)
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_Dropdown_vue_vue_type_template_id_13f3326e__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!../../../../node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!../../../../node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./Dropdown.vue?vue&type=template&id=13f3326e */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/categories/Dropdown.vue?vue&type=template&id=13f3326e");


/***/ }),

/***/ "./resources/js/components/categories/Dropdowncontent.vue?vue&type=template&id=6d946540":
/*!**********************************************************************************************!*\
  !*** ./resources/js/components/categories/Dropdowncontent.vue?vue&type=template&id=6d946540 ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_Dropdowncontent_vue_vue_type_template_id_6d946540__WEBPACK_IMPORTED_MODULE_0__.render)
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_Dropdowncontent_vue_vue_type_template_id_6d946540__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!../../../../node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!../../../../node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./Dropdowncontent.vue?vue&type=template&id=6d946540 */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/categories/Dropdowncontent.vue?vue&type=template&id=6d946540");


/***/ }),

/***/ "./resources/js/components/categories/Dropdownitems.vue?vue&type=template&id=64b8fcc7":
/*!********************************************************************************************!*\
  !*** ./resources/js/components/categories/Dropdownitems.vue?vue&type=template&id=64b8fcc7 ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_Dropdownitems_vue_vue_type_template_id_64b8fcc7__WEBPACK_IMPORTED_MODULE_0__.render)
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_Dropdownitems_vue_vue_type_template_id_64b8fcc7__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!../../../../node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!../../../../node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./Dropdownitems.vue?vue&type=template&id=64b8fcc7 */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/categories/Dropdownitems.vue?vue&type=template&id=64b8fcc7");


/***/ }),

/***/ "./resources/js/components/darkcomponents/Svglogodark.vue?vue&type=template&id=0c63f626":
/*!**********************************************************************************************!*\
  !*** ./resources/js/components/darkcomponents/Svglogodark.vue?vue&type=template&id=0c63f626 ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_Svglogodark_vue_vue_type_template_id_0c63f626__WEBPACK_IMPORTED_MODULE_0__.render)
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_Svglogodark_vue_vue_type_template_id_0c63f626__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!../../../../node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!../../../../node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./Svglogodark.vue?vue&type=template&id=0c63f626 */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/darkcomponents/Svglogodark.vue?vue&type=template&id=0c63f626");


/***/ }),

/***/ "./resources/js/components/darkcomponents/Svgnewsletterdark.vue?vue&type=template&id=aaffc20a":
/*!****************************************************************************************************!*\
  !*** ./resources/js/components/darkcomponents/Svgnewsletterdark.vue?vue&type=template&id=aaffc20a ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_Svgnewsletterdark_vue_vue_type_template_id_aaffc20a__WEBPACK_IMPORTED_MODULE_0__.render)
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_Svgnewsletterdark_vue_vue_type_template_id_aaffc20a__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!../../../../node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!../../../../node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./Svgnewsletterdark.vue?vue&type=template&id=aaffc20a */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/darkcomponents/Svgnewsletterdark.vue?vue&type=template&id=aaffc20a");


/***/ }),

/***/ "./resources/js/components/darkcomponents/Switchdark.vue?vue&type=template&id=069fc572":
/*!*********************************************************************************************!*\
  !*** ./resources/js/components/darkcomponents/Switchdark.vue?vue&type=template&id=069fc572 ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_Switchdark_vue_vue_type_template_id_069fc572__WEBPACK_IMPORTED_MODULE_0__.render)
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_Switchdark_vue_vue_type_template_id_069fc572__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!../../../../node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!../../../../node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./Switchdark.vue?vue&type=template&id=069fc572 */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/darkcomponents/Switchdark.vue?vue&type=template&id=069fc572");


/***/ }),

/***/ "./resources/js/components/devto/Swiperimg.vue?vue&type=template&id=28a22cb1":
/*!***********************************************************************************!*\
  !*** ./resources/js/components/devto/Swiperimg.vue?vue&type=template&id=28a22cb1 ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_Swiperimg_vue_vue_type_template_id_28a22cb1__WEBPACK_IMPORTED_MODULE_0__.render)
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_Swiperimg_vue_vue_type_template_id_28a22cb1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!../../../../node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!../../../../node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./Swiperimg.vue?vue&type=template&id=28a22cb1 */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/devto/Swiperimg.vue?vue&type=template&id=28a22cb1");


/***/ }),

/***/ "./resources/js/components/devto/Swiperslides.vue?vue&type=template&id=6225d6e4":
/*!**************************************************************************************!*\
  !*** ./resources/js/components/devto/Swiperslides.vue?vue&type=template&id=6225d6e4 ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_Swiperslides_vue_vue_type_template_id_6225d6e4__WEBPACK_IMPORTED_MODULE_0__.render)
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_Swiperslides_vue_vue_type_template_id_6225d6e4__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!../../../../node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!../../../../node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./Swiperslides.vue?vue&type=template&id=6225d6e4 */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/devto/Swiperslides.vue?vue&type=template&id=6225d6e4");


/***/ }),

/***/ "./resources/js/components/devto/Swiperslidescontent.vue?vue&type=template&id=68f6b0c5":
/*!*********************************************************************************************!*\
  !*** ./resources/js/components/devto/Swiperslidescontent.vue?vue&type=template&id=68f6b0c5 ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_Swiperslidescontent_vue_vue_type_template_id_68f6b0c5__WEBPACK_IMPORTED_MODULE_0__.render)
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_Swiperslidescontent_vue_vue_type_template_id_68f6b0c5__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!../../../../node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!../../../../node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./Swiperslidescontent.vue?vue&type=template&id=68f6b0c5 */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/devto/Swiperslidescontent.vue?vue&type=template&id=68f6b0c5");


/***/ }),

/***/ "./resources/js/components/devto/Swiperslidesitems.vue?vue&type=template&id=00d2658c":
/*!*******************************************************************************************!*\
  !*** ./resources/js/components/devto/Swiperslidesitems.vue?vue&type=template&id=00d2658c ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_Swiperslidesitems_vue_vue_type_template_id_00d2658c__WEBPACK_IMPORTED_MODULE_0__.render)
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_Swiperslidesitems_vue_vue_type_template_id_00d2658c__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!../../../../node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!../../../../node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./Swiperslidesitems.vue?vue&type=template&id=00d2658c */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/devto/Swiperslidesitems.vue?vue&type=template&id=00d2658c");


/***/ }),

/***/ "./resources/js/components/Card.vue?vue&type=style&index=0&id=b9bc2c0a&lang=css":
/*!**************************************************************************************!*\
  !*** ./resources/js/components/Card.vue?vue&type=style&index=0&id=b9bc2c0a&lang=css ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_style_loader_dist_cjs_js_node_modules_css_loader_dist_cjs_js_clonedRuleSet_9_use_1_node_modules_vue_loader_dist_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_9_use_2_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_Card_vue_vue_type_style_index_0_id_b9bc2c0a_lang_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/style-loader/dist/cjs.js!../../../node_modules/css-loader/dist/cjs.js??clonedRuleSet-9.use[1]!../../../node_modules/vue-loader/dist/stylePostLoader.js!../../../node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9.use[2]!../../../node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./Card.vue?vue&type=style&index=0&id=b9bc2c0a&lang=css */ "./node_modules/style-loader/dist/cjs.js!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-9.use[1]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9.use[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/Card.vue?vue&type=style&index=0&id=b9bc2c0a&lang=css");


/***/ }),

/***/ "./resources/js/components/categories/Dropdowncontent.vue?vue&type=style&index=0&id=6d946540&lang=css":
/*!************************************************************************************************************!*\
  !*** ./resources/js/components/categories/Dropdowncontent.vue?vue&type=style&index=0&id=6d946540&lang=css ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_style_loader_dist_cjs_js_node_modules_css_loader_dist_cjs_js_clonedRuleSet_9_use_1_node_modules_vue_loader_dist_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_9_use_2_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_Dropdowncontent_vue_vue_type_style_index_0_id_6d946540_lang_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../node_modules/style-loader/dist/cjs.js!../../../../node_modules/css-loader/dist/cjs.js??clonedRuleSet-9.use[1]!../../../../node_modules/vue-loader/dist/stylePostLoader.js!../../../../node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9.use[2]!../../../../node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./Dropdowncontent.vue?vue&type=style&index=0&id=6d946540&lang=css */ "./node_modules/style-loader/dist/cjs.js!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-9.use[1]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9.use[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/categories/Dropdowncontent.vue?vue&type=style&index=0&id=6d946540&lang=css");


/***/ }),

/***/ "./node_modules/vue/dist/vue.esm-bundler.js":
/*!**************************************************!*\
  !*** ./node_modules/vue/dist/vue.esm-bundler.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BaseTransition": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.BaseTransition),
/* harmony export */   "Comment": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Comment),
/* harmony export */   "EffectScope": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.EffectScope),
/* harmony export */   "Fragment": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Fragment),
/* harmony export */   "KeepAlive": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.KeepAlive),
/* harmony export */   "ReactiveEffect": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.ReactiveEffect),
/* harmony export */   "Static": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Static),
/* harmony export */   "Suspense": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Suspense),
/* harmony export */   "Teleport": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Teleport),
/* harmony export */   "Text": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Text),
/* harmony export */   "Transition": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Transition),
/* harmony export */   "TransitionGroup": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.TransitionGroup),
/* harmony export */   "VueElement": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.VueElement),
/* harmony export */   "callWithAsyncErrorHandling": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.callWithAsyncErrorHandling),
/* harmony export */   "callWithErrorHandling": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.callWithErrorHandling),
/* harmony export */   "camelize": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.camelize),
/* harmony export */   "capitalize": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.capitalize),
/* harmony export */   "cloneVNode": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.cloneVNode),
/* harmony export */   "compatUtils": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.compatUtils),
/* harmony export */   "computed": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.computed),
/* harmony export */   "createApp": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createApp),
/* harmony export */   "createBlock": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createBlock),
/* harmony export */   "createCommentVNode": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode),
/* harmony export */   "createElementBlock": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createElementBlock),
/* harmony export */   "createElementVNode": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createElementVNode),
/* harmony export */   "createHydrationRenderer": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createHydrationRenderer),
/* harmony export */   "createPropsRestProxy": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createPropsRestProxy),
/* harmony export */   "createRenderer": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createRenderer),
/* harmony export */   "createSSRApp": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createSSRApp),
/* harmony export */   "createSlots": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createSlots),
/* harmony export */   "createStaticVNode": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createStaticVNode),
/* harmony export */   "createTextVNode": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createTextVNode),
/* harmony export */   "createVNode": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createVNode),
/* harmony export */   "customRef": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.customRef),
/* harmony export */   "defineAsyncComponent": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineAsyncComponent),
/* harmony export */   "defineComponent": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineComponent),
/* harmony export */   "defineCustomElement": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineCustomElement),
/* harmony export */   "defineEmits": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineEmits),
/* harmony export */   "defineExpose": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineExpose),
/* harmony export */   "defineProps": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineProps),
/* harmony export */   "defineSSRCustomElement": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineSSRCustomElement),
/* harmony export */   "devtools": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.devtools),
/* harmony export */   "effect": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.effect),
/* harmony export */   "effectScope": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.effectScope),
/* harmony export */   "getCurrentInstance": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.getCurrentInstance),
/* harmony export */   "getCurrentScope": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.getCurrentScope),
/* harmony export */   "getTransitionRawChildren": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.getTransitionRawChildren),
/* harmony export */   "guardReactiveProps": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.guardReactiveProps),
/* harmony export */   "h": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.h),
/* harmony export */   "handleError": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.handleError),
/* harmony export */   "hydrate": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.hydrate),
/* harmony export */   "initCustomFormatter": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.initCustomFormatter),
/* harmony export */   "initDirectivesForSSR": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.initDirectivesForSSR),
/* harmony export */   "inject": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.inject),
/* harmony export */   "isMemoSame": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isMemoSame),
/* harmony export */   "isProxy": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isProxy),
/* harmony export */   "isReactive": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isReactive),
/* harmony export */   "isReadonly": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isReadonly),
/* harmony export */   "isRef": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isRef),
/* harmony export */   "isRuntimeOnly": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isRuntimeOnly),
/* harmony export */   "isShallow": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isShallow),
/* harmony export */   "isVNode": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isVNode),
/* harmony export */   "markRaw": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.markRaw),
/* harmony export */   "mergeDefaults": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.mergeDefaults),
/* harmony export */   "mergeProps": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.mergeProps),
/* harmony export */   "nextTick": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.nextTick),
/* harmony export */   "normalizeClass": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.normalizeClass),
/* harmony export */   "normalizeProps": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.normalizeProps),
/* harmony export */   "normalizeStyle": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.normalizeStyle),
/* harmony export */   "onActivated": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onActivated),
/* harmony export */   "onBeforeMount": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onBeforeMount),
/* harmony export */   "onBeforeUnmount": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onBeforeUnmount),
/* harmony export */   "onBeforeUpdate": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onBeforeUpdate),
/* harmony export */   "onDeactivated": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onDeactivated),
/* harmony export */   "onErrorCaptured": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onErrorCaptured),
/* harmony export */   "onMounted": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onMounted),
/* harmony export */   "onRenderTracked": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onRenderTracked),
/* harmony export */   "onRenderTriggered": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onRenderTriggered),
/* harmony export */   "onScopeDispose": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onScopeDispose),
/* harmony export */   "onServerPrefetch": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onServerPrefetch),
/* harmony export */   "onUnmounted": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onUnmounted),
/* harmony export */   "onUpdated": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onUpdated),
/* harmony export */   "openBlock": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.openBlock),
/* harmony export */   "popScopeId": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.popScopeId),
/* harmony export */   "provide": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.provide),
/* harmony export */   "proxyRefs": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.proxyRefs),
/* harmony export */   "pushScopeId": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.pushScopeId),
/* harmony export */   "queuePostFlushCb": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.queuePostFlushCb),
/* harmony export */   "reactive": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.reactive),
/* harmony export */   "readonly": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.readonly),
/* harmony export */   "ref": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.ref),
/* harmony export */   "registerRuntimeCompiler": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.registerRuntimeCompiler),
/* harmony export */   "render": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.render),
/* harmony export */   "renderList": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.renderList),
/* harmony export */   "renderSlot": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.renderSlot),
/* harmony export */   "resolveComponent": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.resolveComponent),
/* harmony export */   "resolveDirective": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.resolveDirective),
/* harmony export */   "resolveDynamicComponent": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.resolveDynamicComponent),
/* harmony export */   "resolveFilter": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.resolveFilter),
/* harmony export */   "resolveTransitionHooks": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.resolveTransitionHooks),
/* harmony export */   "setBlockTracking": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.setBlockTracking),
/* harmony export */   "setDevtoolsHook": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.setDevtoolsHook),
/* harmony export */   "setTransitionHooks": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.setTransitionHooks),
/* harmony export */   "shallowReactive": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.shallowReactive),
/* harmony export */   "shallowReadonly": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly),
/* harmony export */   "shallowRef": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.shallowRef),
/* harmony export */   "ssrContextKey": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.ssrContextKey),
/* harmony export */   "ssrUtils": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.ssrUtils),
/* harmony export */   "stop": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.stop),
/* harmony export */   "toDisplayString": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.toDisplayString),
/* harmony export */   "toHandlerKey": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.toHandlerKey),
/* harmony export */   "toHandlers": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.toHandlers),
/* harmony export */   "toRaw": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.toRaw),
/* harmony export */   "toRef": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.toRef),
/* harmony export */   "toRefs": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.toRefs),
/* harmony export */   "transformVNodeArgs": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.transformVNodeArgs),
/* harmony export */   "triggerRef": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.triggerRef),
/* harmony export */   "unref": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.unref),
/* harmony export */   "useAttrs": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.useAttrs),
/* harmony export */   "useCssModule": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.useCssModule),
/* harmony export */   "useCssVars": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.useCssVars),
/* harmony export */   "useSSRContext": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.useSSRContext),
/* harmony export */   "useSlots": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.useSlots),
/* harmony export */   "useTransitionState": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.useTransitionState),
/* harmony export */   "vModelCheckbox": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.vModelCheckbox),
/* harmony export */   "vModelDynamic": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.vModelDynamic),
/* harmony export */   "vModelRadio": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.vModelRadio),
/* harmony export */   "vModelSelect": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.vModelSelect),
/* harmony export */   "vModelText": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.vModelText),
/* harmony export */   "vShow": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.vShow),
/* harmony export */   "version": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.version),
/* harmony export */   "warn": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.warn),
/* harmony export */   "watch": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.watch),
/* harmony export */   "watchEffect": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.watchEffect),
/* harmony export */   "watchPostEffect": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.watchPostEffect),
/* harmony export */   "watchSyncEffect": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.watchSyncEffect),
/* harmony export */   "withAsyncContext": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withAsyncContext),
/* harmony export */   "withCtx": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withCtx),
/* harmony export */   "withDefaults": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withDefaults),
/* harmony export */   "withDirectives": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withDirectives),
/* harmony export */   "withKeys": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withKeys),
/* harmony export */   "withMemo": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withMemo),
/* harmony export */   "withModifiers": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withModifiers),
/* harmony export */   "withScopeId": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withScopeId),
/* harmony export */   "compile": () => (/* binding */ compileToFunction)
/* harmony export */ });
/* harmony import */ var _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vue/runtime-dom */ "./node_modules/@vue/runtime-dom/dist/runtime-dom.esm-bundler.js");
/* harmony import */ var _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @vue/runtime-dom */ "./node_modules/@vue/runtime-core/dist/runtime-core.esm-bundler.js");
/* harmony import */ var _vue_compiler_dom__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @vue/compiler-dom */ "./node_modules/@vue/compiler-dom/dist/compiler-dom.esm-bundler.js");
/* harmony import */ var _vue_shared__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @vue/shared */ "./node_modules/vue/node_modules/@vue/shared/dist/shared.esm-bundler.js");






function initDev() {
    {
        (0,_vue_runtime_dom__WEBPACK_IMPORTED_MODULE_2__.initCustomFormatter)();
    }
}

// This entry is the "full-build" that includes both the runtime
if ((true)) {
    initDev();
}
const compileCache = Object.create(null);
function compileToFunction(template, options) {
    if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(template)) {
        if (template.nodeType) {
            template = template.innerHTML;
        }
        else {
            ( true) && (0,_vue_runtime_dom__WEBPACK_IMPORTED_MODULE_2__.warn)(`invalid template option: `, template);
            return _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP;
        }
    }
    const key = template;
    const cached = compileCache[key];
    if (cached) {
        return cached;
    }
    if (template[0] === '#') {
        const el = document.querySelector(template);
        if (( true) && !el) {
            (0,_vue_runtime_dom__WEBPACK_IMPORTED_MODULE_2__.warn)(`Template element not found or is empty: ${template}`);
        }
        // __UNSAFE__
        // Reason: potential execution of JS expressions in in-DOM template.
        // The user must make sure the in-DOM template is trusted. If it's rendered
        // by the server, the template should not contain any user data.
        template = el ? el.innerHTML : ``;
    }
    const { code } = (0,_vue_compiler_dom__WEBPACK_IMPORTED_MODULE_3__.compile)(template, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({
        hoistStatic: true,
        onError: ( true) ? onError : 0,
        onWarn: ( true) ? e => onError(e, true) : 0
    }, options));
    function onError(err, asWarning = false) {
        const message = asWarning
            ? err.message
            : `Template compilation error: ${err.message}`;
        const codeFrame = err.loc &&
            (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.generateCodeFrame)(template, err.loc.start.offset, err.loc.end.offset);
        (0,_vue_runtime_dom__WEBPACK_IMPORTED_MODULE_2__.warn)(codeFrame ? `${message}\n${codeFrame}` : message);
    }
    // The wildcard import results in a huge object with every export
    // with keys that cannot be mangled, and can be quite heavy size-wise.
    // In the global build we know `Vue` is available globally so we can avoid
    // the wildcard object.
    const render = (new Function('Vue', code)(_vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__));
    render._rc = true;
    return (compileCache[key] = render);
}
(0,_vue_runtime_dom__WEBPACK_IMPORTED_MODULE_2__.registerRuntimeCompiler)(compileToFunction);




/***/ }),

/***/ "./node_modules/vue/node_modules/@vue/shared/dist/shared.esm-bundler.js":
/*!******************************************************************************!*\
  !*** ./node_modules/vue/node_modules/@vue/shared/dist/shared.esm-bundler.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EMPTY_ARR": () => (/* binding */ EMPTY_ARR),
/* harmony export */   "EMPTY_OBJ": () => (/* binding */ EMPTY_OBJ),
/* harmony export */   "NO": () => (/* binding */ NO),
/* harmony export */   "NOOP": () => (/* binding */ NOOP),
/* harmony export */   "PatchFlagNames": () => (/* binding */ PatchFlagNames),
/* harmony export */   "camelize": () => (/* binding */ camelize),
/* harmony export */   "capitalize": () => (/* binding */ capitalize),
/* harmony export */   "def": () => (/* binding */ def),
/* harmony export */   "escapeHtml": () => (/* binding */ escapeHtml),
/* harmony export */   "escapeHtmlComment": () => (/* binding */ escapeHtmlComment),
/* harmony export */   "extend": () => (/* binding */ extend),
/* harmony export */   "generateCodeFrame": () => (/* binding */ generateCodeFrame),
/* harmony export */   "getGlobalThis": () => (/* binding */ getGlobalThis),
/* harmony export */   "hasChanged": () => (/* binding */ hasChanged),
/* harmony export */   "hasOwn": () => (/* binding */ hasOwn),
/* harmony export */   "hyphenate": () => (/* binding */ hyphenate),
/* harmony export */   "includeBooleanAttr": () => (/* binding */ includeBooleanAttr),
/* harmony export */   "invokeArrayFns": () => (/* binding */ invokeArrayFns),
/* harmony export */   "isArray": () => (/* binding */ isArray),
/* harmony export */   "isBooleanAttr": () => (/* binding */ isBooleanAttr),
/* harmony export */   "isBuiltInDirective": () => (/* binding */ isBuiltInDirective),
/* harmony export */   "isDate": () => (/* binding */ isDate),
/* harmony export */   "isFunction": () => (/* binding */ isFunction),
/* harmony export */   "isGloballyWhitelisted": () => (/* binding */ isGloballyWhitelisted),
/* harmony export */   "isHTMLTag": () => (/* binding */ isHTMLTag),
/* harmony export */   "isIntegerKey": () => (/* binding */ isIntegerKey),
/* harmony export */   "isKnownHtmlAttr": () => (/* binding */ isKnownHtmlAttr),
/* harmony export */   "isKnownSvgAttr": () => (/* binding */ isKnownSvgAttr),
/* harmony export */   "isMap": () => (/* binding */ isMap),
/* harmony export */   "isModelListener": () => (/* binding */ isModelListener),
/* harmony export */   "isNoUnitNumericStyleProp": () => (/* binding */ isNoUnitNumericStyleProp),
/* harmony export */   "isObject": () => (/* binding */ isObject),
/* harmony export */   "isOn": () => (/* binding */ isOn),
/* harmony export */   "isPlainObject": () => (/* binding */ isPlainObject),
/* harmony export */   "isPromise": () => (/* binding */ isPromise),
/* harmony export */   "isReservedProp": () => (/* binding */ isReservedProp),
/* harmony export */   "isSSRSafeAttrName": () => (/* binding */ isSSRSafeAttrName),
/* harmony export */   "isSVGTag": () => (/* binding */ isSVGTag),
/* harmony export */   "isSet": () => (/* binding */ isSet),
/* harmony export */   "isSpecialBooleanAttr": () => (/* binding */ isSpecialBooleanAttr),
/* harmony export */   "isString": () => (/* binding */ isString),
/* harmony export */   "isSymbol": () => (/* binding */ isSymbol),
/* harmony export */   "isVoidTag": () => (/* binding */ isVoidTag),
/* harmony export */   "looseEqual": () => (/* binding */ looseEqual),
/* harmony export */   "looseIndexOf": () => (/* binding */ looseIndexOf),
/* harmony export */   "makeMap": () => (/* binding */ makeMap),
/* harmony export */   "normalizeClass": () => (/* binding */ normalizeClass),
/* harmony export */   "normalizeProps": () => (/* binding */ normalizeProps),
/* harmony export */   "normalizeStyle": () => (/* binding */ normalizeStyle),
/* harmony export */   "objectToString": () => (/* binding */ objectToString),
/* harmony export */   "parseStringStyle": () => (/* binding */ parseStringStyle),
/* harmony export */   "propsToAttrMap": () => (/* binding */ propsToAttrMap),
/* harmony export */   "remove": () => (/* binding */ remove),
/* harmony export */   "slotFlagsText": () => (/* binding */ slotFlagsText),
/* harmony export */   "stringifyStyle": () => (/* binding */ stringifyStyle),
/* harmony export */   "toDisplayString": () => (/* binding */ toDisplayString),
/* harmony export */   "toHandlerKey": () => (/* binding */ toHandlerKey),
/* harmony export */   "toNumber": () => (/* binding */ toNumber),
/* harmony export */   "toRawType": () => (/* binding */ toRawType),
/* harmony export */   "toTypeString": () => (/* binding */ toTypeString)
/* harmony export */ });
/**
 * Make a map and return a function for checking if a key
 * is in that map.
 * IMPORTANT: all calls of this function must be prefixed with
 * \/\*#\_\_PURE\_\_\*\/
 * So that rollup can tree-shake them if necessary.
 */
function makeMap(str, expectsLowerCase) {
    const map = Object.create(null);
    const list = str.split(',');
    for (let i = 0; i < list.length; i++) {
        map[list[i]] = true;
    }
    return expectsLowerCase ? val => !!map[val.toLowerCase()] : val => !!map[val];
}

/**
 * dev only flag -> name mapping
 */
const PatchFlagNames = {
    [1 /* TEXT */]: `TEXT`,
    [2 /* CLASS */]: `CLASS`,
    [4 /* STYLE */]: `STYLE`,
    [8 /* PROPS */]: `PROPS`,
    [16 /* FULL_PROPS */]: `FULL_PROPS`,
    [32 /* HYDRATE_EVENTS */]: `HYDRATE_EVENTS`,
    [64 /* STABLE_FRAGMENT */]: `STABLE_FRAGMENT`,
    [128 /* KEYED_FRAGMENT */]: `KEYED_FRAGMENT`,
    [256 /* UNKEYED_FRAGMENT */]: `UNKEYED_FRAGMENT`,
    [512 /* NEED_PATCH */]: `NEED_PATCH`,
    [1024 /* DYNAMIC_SLOTS */]: `DYNAMIC_SLOTS`,
    [2048 /* DEV_ROOT_FRAGMENT */]: `DEV_ROOT_FRAGMENT`,
    [-1 /* HOISTED */]: `HOISTED`,
    [-2 /* BAIL */]: `BAIL`
};

/**
 * Dev only
 */
const slotFlagsText = {
    [1 /* STABLE */]: 'STABLE',
    [2 /* DYNAMIC */]: 'DYNAMIC',
    [3 /* FORWARDED */]: 'FORWARDED'
};

const GLOBALS_WHITE_LISTED = 'Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,' +
    'decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,' +
    'Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt';
const isGloballyWhitelisted = /*#__PURE__*/ makeMap(GLOBALS_WHITE_LISTED);

const range = 2;
function generateCodeFrame(source, start = 0, end = source.length) {
    // Split the content into individual lines but capture the newline sequence
    // that separated each line. This is important because the actual sequence is
    // needed to properly take into account the full line length for offset
    // comparison
    let lines = source.split(/(\r?\n)/);
    // Separate the lines and newline sequences into separate arrays for easier referencing
    const newlineSequences = lines.filter((_, idx) => idx % 2 === 1);
    lines = lines.filter((_, idx) => idx % 2 === 0);
    let count = 0;
    const res = [];
    for (let i = 0; i < lines.length; i++) {
        count +=
            lines[i].length +
                ((newlineSequences[i] && newlineSequences[i].length) || 0);
        if (count >= start) {
            for (let j = i - range; j <= i + range || end > count; j++) {
                if (j < 0 || j >= lines.length)
                    continue;
                const line = j + 1;
                res.push(`${line}${' '.repeat(Math.max(3 - String(line).length, 0))}|  ${lines[j]}`);
                const lineLength = lines[j].length;
                const newLineSeqLength = (newlineSequences[j] && newlineSequences[j].length) || 0;
                if (j === i) {
                    // push underline
                    const pad = start - (count - (lineLength + newLineSeqLength));
                    const length = Math.max(1, end > count ? lineLength - pad : end - start);
                    res.push(`   |  ` + ' '.repeat(pad) + '^'.repeat(length));
                }
                else if (j > i) {
                    if (end > count) {
                        const length = Math.max(Math.min(end - count, lineLength), 1);
                        res.push(`   |  ` + '^'.repeat(length));
                    }
                    count += lineLength + newLineSeqLength;
                }
            }
            break;
        }
    }
    return res.join('\n');
}

/**
 * On the client we only need to offer special cases for boolean attributes that
 * have different names from their corresponding dom properties:
 * - itemscope -> N/A
 * - allowfullscreen -> allowFullscreen
 * - formnovalidate -> formNoValidate
 * - ismap -> isMap
 * - nomodule -> noModule
 * - novalidate -> noValidate
 * - readonly -> readOnly
 */
const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
const isSpecialBooleanAttr = /*#__PURE__*/ makeMap(specialBooleanAttrs);
/**
 * The full list is needed during SSR to produce the correct initial markup.
 */
const isBooleanAttr = /*#__PURE__*/ makeMap(specialBooleanAttrs +
    `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,` +
    `loop,open,required,reversed,scoped,seamless,` +
    `checked,muted,multiple,selected`);
/**
 * Boolean attributes should be included if the value is truthy or ''.
 * e.g. `<select multiple>` compiles to `{ multiple: '' }`
 */
function includeBooleanAttr(value) {
    return !!value || value === '';
}
const unsafeAttrCharRE = /[>/="'\u0009\u000a\u000c\u0020]/;
const attrValidationCache = {};
function isSSRSafeAttrName(name) {
    if (attrValidationCache.hasOwnProperty(name)) {
        return attrValidationCache[name];
    }
    const isUnsafe = unsafeAttrCharRE.test(name);
    if (isUnsafe) {
        console.error(`unsafe attribute name: ${name}`);
    }
    return (attrValidationCache[name] = !isUnsafe);
}
const propsToAttrMap = {
    acceptCharset: 'accept-charset',
    className: 'class',
    htmlFor: 'for',
    httpEquiv: 'http-equiv'
};
/**
 * CSS properties that accept plain numbers
 */
const isNoUnitNumericStyleProp = /*#__PURE__*/ makeMap(`animation-iteration-count,border-image-outset,border-image-slice,` +
    `border-image-width,box-flex,box-flex-group,box-ordinal-group,column-count,` +
    `columns,flex,flex-grow,flex-positive,flex-shrink,flex-negative,flex-order,` +
    `grid-row,grid-row-end,grid-row-span,grid-row-start,grid-column,` +
    `grid-column-end,grid-column-span,grid-column-start,font-weight,line-clamp,` +
    `line-height,opacity,order,orphans,tab-size,widows,z-index,zoom,` +
    // SVG
    `fill-opacity,flood-opacity,stop-opacity,stroke-dasharray,stroke-dashoffset,` +
    `stroke-miterlimit,stroke-opacity,stroke-width`);
/**
 * Known attributes, this is used for stringification of runtime static nodes
 * so that we don't stringify bindings that cannot be set from HTML.
 * Don't also forget to allow `data-*` and `aria-*`!
 * Generated from https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes
 */
const isKnownHtmlAttr = /*#__PURE__*/ makeMap(`accept,accept-charset,accesskey,action,align,allow,alt,async,` +
    `autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,` +
    `border,buffered,capture,challenge,charset,checked,cite,class,code,` +
    `codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,` +
    `coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,` +
    `disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,` +
    `formaction,formenctype,formmethod,formnovalidate,formtarget,headers,` +
    `height,hidden,high,href,hreflang,http-equiv,icon,id,importance,integrity,` +
    `ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,` +
    `manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,` +
    `open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,` +
    `referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,` +
    `selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,` +
    `start,step,style,summary,tabindex,target,title,translate,type,usemap,` +
    `value,width,wrap`);
/**
 * Generated from https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute
 */
const isKnownSvgAttr = /*#__PURE__*/ makeMap(`xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,` +
    `arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,` +
    `baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,` +
    `clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,` +
    `color-interpolation-filters,color-profile,color-rendering,` +
    `contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,` +
    `descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,` +
    `dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,` +
    `fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,` +
    `font-family,font-size,font-size-adjust,font-stretch,font-style,` +
    `font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,` +
    `glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,` +
    `gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,` +
    `horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,` +
    `k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,` +
    `lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,` +
    `marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,` +
    `mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,` +
    `name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,` +
    `overflow,overline-position,overline-thickness,panose-1,paint-order,path,` +
    `pathLength,patternContentUnits,patternTransform,patternUnits,ping,` +
    `pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,` +
    `preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,` +
    `rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,` +
    `restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,` +
    `specularConstant,specularExponent,speed,spreadMethod,startOffset,` +
    `stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,` +
    `strikethrough-position,strikethrough-thickness,string,stroke,` +
    `stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,` +
    `stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,` +
    `systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,` +
    `text-decoration,text-rendering,textLength,to,transform,transform-origin,` +
    `type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,` +
    `unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,` +
    `v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,` +
    `vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,` +
    `writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,` +
    `xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xml:base,xml:lang,` +
    `xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan`);

function normalizeStyle(value) {
    if (isArray(value)) {
        const res = {};
        for (let i = 0; i < value.length; i++) {
            const item = value[i];
            const normalized = isString(item)
                ? parseStringStyle(item)
                : normalizeStyle(item);
            if (normalized) {
                for (const key in normalized) {
                    res[key] = normalized[key];
                }
            }
        }
        return res;
    }
    else if (isString(value)) {
        return value;
    }
    else if (isObject(value)) {
        return value;
    }
}
const listDelimiterRE = /;(?![^(]*\))/g;
const propertyDelimiterRE = /:(.+)/;
function parseStringStyle(cssText) {
    const ret = {};
    cssText.split(listDelimiterRE).forEach(item => {
        if (item) {
            const tmp = item.split(propertyDelimiterRE);
            tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
        }
    });
    return ret;
}
function stringifyStyle(styles) {
    let ret = '';
    if (!styles || isString(styles)) {
        return ret;
    }
    for (const key in styles) {
        const value = styles[key];
        const normalizedKey = key.startsWith(`--`) ? key : hyphenate(key);
        if (isString(value) ||
            (typeof value === 'number' && isNoUnitNumericStyleProp(normalizedKey))) {
            // only render valid values
            ret += `${normalizedKey}:${value};`;
        }
    }
    return ret;
}
function normalizeClass(value) {
    let res = '';
    if (isString(value)) {
        res = value;
    }
    else if (isArray(value)) {
        for (let i = 0; i < value.length; i++) {
            const normalized = normalizeClass(value[i]);
            if (normalized) {
                res += normalized + ' ';
            }
        }
    }
    else if (isObject(value)) {
        for (const name in value) {
            if (value[name]) {
                res += name + ' ';
            }
        }
    }
    return res.trim();
}
function normalizeProps(props) {
    if (!props)
        return null;
    let { class: klass, style } = props;
    if (klass && !isString(klass)) {
        props.class = normalizeClass(klass);
    }
    if (style) {
        props.style = normalizeStyle(style);
    }
    return props;
}

// These tag configs are shared between compiler-dom and runtime-dom, so they
// https://developer.mozilla.org/en-US/docs/Web/HTML/Element
const HTML_TAGS = 'html,body,base,head,link,meta,style,title,address,article,aside,footer,' +
    'header,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,' +
    'figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,' +
    'data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,' +
    'time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,' +
    'canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,' +
    'th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,' +
    'option,output,progress,select,textarea,details,dialog,menu,' +
    'summary,template,blockquote,iframe,tfoot';
// https://developer.mozilla.org/en-US/docs/Web/SVG/Element
const SVG_TAGS = 'svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,' +
    'defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,' +
    'feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,' +
    'feDistanceLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,' +
    'feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,' +
    'fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,' +
    'foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,' +
    'mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,' +
    'polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,' +
    'text,textPath,title,tspan,unknown,use,view';
const VOID_TAGS = 'area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr';
/**
 * Compiler only.
 * Do NOT use in runtime code paths unless behind `(process.env.NODE_ENV !== 'production')` flag.
 */
const isHTMLTag = /*#__PURE__*/ makeMap(HTML_TAGS);
/**
 * Compiler only.
 * Do NOT use in runtime code paths unless behind `(process.env.NODE_ENV !== 'production')` flag.
 */
const isSVGTag = /*#__PURE__*/ makeMap(SVG_TAGS);
/**
 * Compiler only.
 * Do NOT use in runtime code paths unless behind `(process.env.NODE_ENV !== 'production')` flag.
 */
const isVoidTag = /*#__PURE__*/ makeMap(VOID_TAGS);

const escapeRE = /["'&<>]/;
function escapeHtml(string) {
    const str = '' + string;
    const match = escapeRE.exec(str);
    if (!match) {
        return str;
    }
    let html = '';
    let escaped;
    let index;
    let lastIndex = 0;
    for (index = match.index; index < str.length; index++) {
        switch (str.charCodeAt(index)) {
            case 34: // "
                escaped = '&quot;';
                break;
            case 38: // &
                escaped = '&amp;';
                break;
            case 39: // '
                escaped = '&#39;';
                break;
            case 60: // <
                escaped = '&lt;';
                break;
            case 62: // >
                escaped = '&gt;';
                break;
            default:
                continue;
        }
        if (lastIndex !== index) {
            html += str.slice(lastIndex, index);
        }
        lastIndex = index + 1;
        html += escaped;
    }
    return lastIndex !== index ? html + str.slice(lastIndex, index) : html;
}
// https://www.w3.org/TR/html52/syntax.html#comments
const commentStripRE = /^-?>|<!--|-->|--!>|<!-$/g;
function escapeHtmlComment(src) {
    return src.replace(commentStripRE, '');
}

function looseCompareArrays(a, b) {
    if (a.length !== b.length)
        return false;
    let equal = true;
    for (let i = 0; equal && i < a.length; i++) {
        equal = looseEqual(a[i], b[i]);
    }
    return equal;
}
function looseEqual(a, b) {
    if (a === b)
        return true;
    let aValidType = isDate(a);
    let bValidType = isDate(b);
    if (aValidType || bValidType) {
        return aValidType && bValidType ? a.getTime() === b.getTime() : false;
    }
    aValidType = isArray(a);
    bValidType = isArray(b);
    if (aValidType || bValidType) {
        return aValidType && bValidType ? looseCompareArrays(a, b) : false;
    }
    aValidType = isObject(a);
    bValidType = isObject(b);
    if (aValidType || bValidType) {
        /* istanbul ignore if: this if will probably never be called */
        if (!aValidType || !bValidType) {
            return false;
        }
        const aKeysCount = Object.keys(a).length;
        const bKeysCount = Object.keys(b).length;
        if (aKeysCount !== bKeysCount) {
            return false;
        }
        for (const key in a) {
            const aHasKey = a.hasOwnProperty(key);
            const bHasKey = b.hasOwnProperty(key);
            if ((aHasKey && !bHasKey) ||
                (!aHasKey && bHasKey) ||
                !looseEqual(a[key], b[key])) {
                return false;
            }
        }
    }
    return String(a) === String(b);
}
function looseIndexOf(arr, val) {
    return arr.findIndex(item => looseEqual(item, val));
}

/**
 * For converting {{ interpolation }} values to displayed strings.
 * @private
 */
const toDisplayString = (val) => {
    return isString(val)
        ? val
        : val == null
            ? ''
            : isArray(val) ||
                (isObject(val) &&
                    (val.toString === objectToString || !isFunction(val.toString)))
                ? JSON.stringify(val, replacer, 2)
                : String(val);
};
const replacer = (_key, val) => {
    // can't use isRef here since @vue/shared has no deps
    if (val && val.__v_isRef) {
        return replacer(_key, val.value);
    }
    else if (isMap(val)) {
        return {
            [`Map(${val.size})`]: [...val.entries()].reduce((entries, [key, val]) => {
                entries[`${key} =>`] = val;
                return entries;
            }, {})
        };
    }
    else if (isSet(val)) {
        return {
            [`Set(${val.size})`]: [...val.values()]
        };
    }
    else if (isObject(val) && !isArray(val) && !isPlainObject(val)) {
        return String(val);
    }
    return val;
};

const EMPTY_OBJ = ( true)
    ? Object.freeze({})
    : 0;
const EMPTY_ARR = ( true) ? Object.freeze([]) : 0;
const NOOP = () => { };
/**
 * Always return false.
 */
const NO = () => false;
const onRE = /^on[^a-z]/;
const isOn = (key) => onRE.test(key);
const isModelListener = (key) => key.startsWith('onUpdate:');
const extend = Object.assign;
const remove = (arr, el) => {
    const i = arr.indexOf(el);
    if (i > -1) {
        arr.splice(i, 1);
    }
};
const hasOwnProperty = Object.prototype.hasOwnProperty;
const hasOwn = (val, key) => hasOwnProperty.call(val, key);
const isArray = Array.isArray;
const isMap = (val) => toTypeString(val) === '[object Map]';
const isSet = (val) => toTypeString(val) === '[object Set]';
const isDate = (val) => val instanceof Date;
const isFunction = (val) => typeof val === 'function';
const isString = (val) => typeof val === 'string';
const isSymbol = (val) => typeof val === 'symbol';
const isObject = (val) => val !== null && typeof val === 'object';
const isPromise = (val) => {
    return isObject(val) && isFunction(val.then) && isFunction(val.catch);
};
const objectToString = Object.prototype.toString;
const toTypeString = (value) => objectToString.call(value);
const toRawType = (value) => {
    // extract "RawType" from strings like "[object RawType]"
    return toTypeString(value).slice(8, -1);
};
const isPlainObject = (val) => toTypeString(val) === '[object Object]';
const isIntegerKey = (key) => isString(key) &&
    key !== 'NaN' &&
    key[0] !== '-' &&
    '' + parseInt(key, 10) === key;
const isReservedProp = /*#__PURE__*/ makeMap(
// the leading comma is intentional so empty string "" is also included
',key,ref,ref_for,ref_key,' +
    'onVnodeBeforeMount,onVnodeMounted,' +
    'onVnodeBeforeUpdate,onVnodeUpdated,' +
    'onVnodeBeforeUnmount,onVnodeUnmounted');
const isBuiltInDirective = /*#__PURE__*/ makeMap('bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo');
const cacheStringFunction = (fn) => {
    const cache = Object.create(null);
    return ((str) => {
        const hit = cache[str];
        return hit || (cache[str] = fn(str));
    });
};
const camelizeRE = /-(\w)/g;
/**
 * @private
 */
const camelize = cacheStringFunction((str) => {
    return str.replace(camelizeRE, (_, c) => (c ? c.toUpperCase() : ''));
});
const hyphenateRE = /\B([A-Z])/g;
/**
 * @private
 */
const hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, '-$1').toLowerCase());
/**
 * @private
 */
const capitalize = cacheStringFunction((str) => str.charAt(0).toUpperCase() + str.slice(1));
/**
 * @private
 */
const toHandlerKey = cacheStringFunction((str) => str ? `on${capitalize(str)}` : ``);
// compare whether a value has changed, accounting for NaN.
const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
const invokeArrayFns = (fns, arg) => {
    for (let i = 0; i < fns.length; i++) {
        fns[i](arg);
    }
};
const def = (obj, key, value) => {
    Object.defineProperty(obj, key, {
        configurable: true,
        enumerable: false,
        value
    });
};
const toNumber = (val) => {
    const n = parseFloat(val);
    return isNaN(n) ? val : n;
};
let _globalThis;
const getGlobalThis = () => {
    return (_globalThis ||
        (_globalThis =
            typeof globalThis !== 'undefined'
                ? globalThis
                : typeof self !== 'undefined'
                    ? self
                    : typeof window !== 'undefined'
                        ? window
                        : typeof __webpack_require__.g !== 'undefined'
                            ? __webpack_require__.g
                            : {}));
};




/***/ }),

/***/ "./node_modules/dom7/dom7.esm.js":
/*!***************************************!*\
  !*** ./node_modules/dom7/dom7.esm.js ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "$": () => (/* binding */ $),
/* harmony export */   "add": () => (/* binding */ add),
/* harmony export */   "addClass": () => (/* binding */ addClass),
/* harmony export */   "animate": () => (/* binding */ animate),
/* harmony export */   "animationEnd": () => (/* binding */ animationEnd),
/* harmony export */   "append": () => (/* binding */ append),
/* harmony export */   "appendTo": () => (/* binding */ appendTo),
/* harmony export */   "attr": () => (/* binding */ attr),
/* harmony export */   "blur": () => (/* binding */ blur),
/* harmony export */   "change": () => (/* binding */ change),
/* harmony export */   "children": () => (/* binding */ children),
/* harmony export */   "click": () => (/* binding */ click),
/* harmony export */   "closest": () => (/* binding */ closest),
/* harmony export */   "css": () => (/* binding */ css),
/* harmony export */   "data": () => (/* binding */ data),
/* harmony export */   "dataset": () => (/* binding */ dataset),
/* harmony export */   "detach": () => (/* binding */ detach),
/* harmony export */   "each": () => (/* binding */ each),
/* harmony export */   "empty": () => (/* binding */ empty),
/* harmony export */   "eq": () => (/* binding */ eq),
/* harmony export */   "filter": () => (/* binding */ filter),
/* harmony export */   "find": () => (/* binding */ find),
/* harmony export */   "focus": () => (/* binding */ focus),
/* harmony export */   "focusin": () => (/* binding */ focusin),
/* harmony export */   "focusout": () => (/* binding */ focusout),
/* harmony export */   "hasClass": () => (/* binding */ hasClass),
/* harmony export */   "height": () => (/* binding */ height),
/* harmony export */   "hide": () => (/* binding */ hide),
/* harmony export */   "html": () => (/* binding */ html),
/* harmony export */   "index": () => (/* binding */ index),
/* harmony export */   "insertAfter": () => (/* binding */ insertAfter),
/* harmony export */   "insertBefore": () => (/* binding */ insertBefore),
/* harmony export */   "is": () => (/* binding */ is),
/* harmony export */   "keydown": () => (/* binding */ keydown),
/* harmony export */   "keypress": () => (/* binding */ keypress),
/* harmony export */   "keyup": () => (/* binding */ keyup),
/* harmony export */   "mousedown": () => (/* binding */ mousedown),
/* harmony export */   "mouseenter": () => (/* binding */ mouseenter),
/* harmony export */   "mouseleave": () => (/* binding */ mouseleave),
/* harmony export */   "mousemove": () => (/* binding */ mousemove),
/* harmony export */   "mouseout": () => (/* binding */ mouseout),
/* harmony export */   "mouseover": () => (/* binding */ mouseover),
/* harmony export */   "mouseup": () => (/* binding */ mouseup),
/* harmony export */   "next": () => (/* binding */ next),
/* harmony export */   "nextAll": () => (/* binding */ nextAll),
/* harmony export */   "off": () => (/* binding */ off),
/* harmony export */   "offset": () => (/* binding */ offset),
/* harmony export */   "on": () => (/* binding */ on),
/* harmony export */   "once": () => (/* binding */ once),
/* harmony export */   "outerHeight": () => (/* binding */ outerHeight),
/* harmony export */   "outerWidth": () => (/* binding */ outerWidth),
/* harmony export */   "parent": () => (/* binding */ parent),
/* harmony export */   "parents": () => (/* binding */ parents),
/* harmony export */   "prepend": () => (/* binding */ prepend),
/* harmony export */   "prependTo": () => (/* binding */ prependTo),
/* harmony export */   "prev": () => (/* binding */ prev),
/* harmony export */   "prevAll": () => (/* binding */ prevAll),
/* harmony export */   "prop": () => (/* binding */ prop),
/* harmony export */   "remove": () => (/* binding */ remove),
/* harmony export */   "removeAttr": () => (/* binding */ removeAttr),
/* harmony export */   "removeClass": () => (/* binding */ removeClass),
/* harmony export */   "removeData": () => (/* binding */ removeData),
/* harmony export */   "resize": () => (/* binding */ resize),
/* harmony export */   "scroll": () => (/* binding */ scroll),
/* harmony export */   "scrollLeft": () => (/* binding */ scrollLeft),
/* harmony export */   "scrollTo": () => (/* binding */ scrollTo),
/* harmony export */   "scrollTop": () => (/* binding */ scrollTop),
/* harmony export */   "show": () => (/* binding */ show),
/* harmony export */   "siblings": () => (/* binding */ siblings),
/* harmony export */   "stop": () => (/* binding */ stop),
/* harmony export */   "styles": () => (/* binding */ styles),
/* harmony export */   "submit": () => (/* binding */ submit),
/* harmony export */   "text": () => (/* binding */ text),
/* harmony export */   "toggleClass": () => (/* binding */ toggleClass),
/* harmony export */   "touchend": () => (/* binding */ touchend),
/* harmony export */   "touchmove": () => (/* binding */ touchmove),
/* harmony export */   "touchstart": () => (/* binding */ touchstart),
/* harmony export */   "transform": () => (/* binding */ transform),
/* harmony export */   "transition": () => (/* binding */ transition),
/* harmony export */   "transitionEnd": () => (/* binding */ transitionEnd),
/* harmony export */   "trigger": () => (/* binding */ trigger),
/* harmony export */   "val": () => (/* binding */ val),
/* harmony export */   "value": () => (/* binding */ value),
/* harmony export */   "width": () => (/* binding */ width)
/* harmony export */ });
/* harmony import */ var ssr_window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ssr-window */ "./node_modules/ssr-window/ssr-window.esm.js");
/**
 * Dom7 4.0.4
 * Minimalistic JavaScript library for DOM manipulation, with a jQuery-compatible API
 * https://framework7.io/docs/dom7.html
 *
 * Copyright 2022, Vladimir Kharlampidi
 *
 * Licensed under MIT
 *
 * Released on: January 11, 2022
 */


/* eslint-disable no-proto */
function makeReactive(obj) {
  const proto = obj.__proto__;
  Object.defineProperty(obj, '__proto__', {
    get() {
      return proto;
    },

    set(value) {
      proto.__proto__ = value;
    }

  });
}

class Dom7 extends Array {
  constructor(items) {
    if (typeof items === 'number') {
      super(items);
    } else {
      super(...(items || []));
      makeReactive(this);
    }
  }

}

function arrayFlat(arr = []) {
  const res = [];
  arr.forEach(el => {
    if (Array.isArray(el)) {
      res.push(...arrayFlat(el));
    } else {
      res.push(el);
    }
  });
  return res;
}
function arrayFilter(arr, callback) {
  return Array.prototype.filter.call(arr, callback);
}
function arrayUnique(arr) {
  const uniqueArray = [];

  for (let i = 0; i < arr.length; i += 1) {
    if (uniqueArray.indexOf(arr[i]) === -1) uniqueArray.push(arr[i]);
  }

  return uniqueArray;
}
function toCamelCase(string) {
  return string.toLowerCase().replace(/-(.)/g, (match, group) => group.toUpperCase());
}

// eslint-disable-next-line

function qsa(selector, context) {
  if (typeof selector !== 'string') {
    return [selector];
  }

  const a = [];
  const res = context.querySelectorAll(selector);

  for (let i = 0; i < res.length; i += 1) {
    a.push(res[i]);
  }

  return a;
}

function $(selector, context) {
  const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();
  const document = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getDocument)();
  let arr = [];

  if (!context && selector instanceof Dom7) {
    return selector;
  }

  if (!selector) {
    return new Dom7(arr);
  }

  if (typeof selector === 'string') {
    const html = selector.trim();

    if (html.indexOf('<') >= 0 && html.indexOf('>') >= 0) {
      let toCreate = 'div';
      if (html.indexOf('<li') === 0) toCreate = 'ul';
      if (html.indexOf('<tr') === 0) toCreate = 'tbody';
      if (html.indexOf('<td') === 0 || html.indexOf('<th') === 0) toCreate = 'tr';
      if (html.indexOf('<tbody') === 0) toCreate = 'table';
      if (html.indexOf('<option') === 0) toCreate = 'select';
      const tempParent = document.createElement(toCreate);
      tempParent.innerHTML = html;

      for (let i = 0; i < tempParent.childNodes.length; i += 1) {
        arr.push(tempParent.childNodes[i]);
      }
    } else {
      arr = qsa(selector.trim(), context || document);
    } // arr = qsa(selector, document);

  } else if (selector.nodeType || selector === window || selector === document) {
    arr.push(selector);
  } else if (Array.isArray(selector)) {
    if (selector instanceof Dom7) return selector;
    arr = selector;
  }

  return new Dom7(arrayUnique(arr));
}

$.fn = Dom7.prototype;

// eslint-disable-next-line

function addClass(...classes) {
  const classNames = arrayFlat(classes.map(c => c.split(' ')));
  this.forEach(el => {
    el.classList.add(...classNames);
  });
  return this;
}

function removeClass(...classes) {
  const classNames = arrayFlat(classes.map(c => c.split(' ')));
  this.forEach(el => {
    el.classList.remove(...classNames);
  });
  return this;
}

function toggleClass(...classes) {
  const classNames = arrayFlat(classes.map(c => c.split(' ')));
  this.forEach(el => {
    classNames.forEach(className => {
      el.classList.toggle(className);
    });
  });
}

function hasClass(...classes) {
  const classNames = arrayFlat(classes.map(c => c.split(' ')));
  return arrayFilter(this, el => {
    return classNames.filter(className => el.classList.contains(className)).length > 0;
  }).length > 0;
}

function attr(attrs, value) {
  if (arguments.length === 1 && typeof attrs === 'string') {
    // Get attr
    if (this[0]) return this[0].getAttribute(attrs);
    return undefined;
  } // Set attrs


  for (let i = 0; i < this.length; i += 1) {
    if (arguments.length === 2) {
      // String
      this[i].setAttribute(attrs, value);
    } else {
      // Object
      for (const attrName in attrs) {
        this[i][attrName] = attrs[attrName];
        this[i].setAttribute(attrName, attrs[attrName]);
      }
    }
  }

  return this;
}

function removeAttr(attr) {
  for (let i = 0; i < this.length; i += 1) {
    this[i].removeAttribute(attr);
  }

  return this;
}

function prop(props, value) {
  if (arguments.length === 1 && typeof props === 'string') {
    // Get prop
    if (this[0]) return this[0][props];
  } else {
    // Set props
    for (let i = 0; i < this.length; i += 1) {
      if (arguments.length === 2) {
        // String
        this[i][props] = value;
      } else {
        // Object
        for (const propName in props) {
          this[i][propName] = props[propName];
        }
      }
    }

    return this;
  }

  return this;
}

function data(key, value) {
  let el;

  if (typeof value === 'undefined') {
    el = this[0];
    if (!el) return undefined; // Get value

    if (el.dom7ElementDataStorage && key in el.dom7ElementDataStorage) {
      return el.dom7ElementDataStorage[key];
    }

    const dataKey = el.getAttribute(`data-${key}`);

    if (dataKey) {
      return dataKey;
    }

    return undefined;
  } // Set value


  for (let i = 0; i < this.length; i += 1) {
    el = this[i];
    if (!el.dom7ElementDataStorage) el.dom7ElementDataStorage = {};
    el.dom7ElementDataStorage[key] = value;
  }

  return this;
}

function removeData(key) {
  for (let i = 0; i < this.length; i += 1) {
    const el = this[i];

    if (el.dom7ElementDataStorage && el.dom7ElementDataStorage[key]) {
      el.dom7ElementDataStorage[key] = null;
      delete el.dom7ElementDataStorage[key];
    }
  }
}

function dataset() {
  const el = this[0];
  if (!el) return undefined;
  const dataset = {}; // eslint-disable-line

  if (el.dataset) {
    for (const dataKey in el.dataset) {
      dataset[dataKey] = el.dataset[dataKey];
    }
  } else {
    for (let i = 0; i < el.attributes.length; i += 1) {
      const attr = el.attributes[i];

      if (attr.name.indexOf('data-') >= 0) {
        dataset[toCamelCase(attr.name.split('data-')[1])] = attr.value;
      }
    }
  }

  for (const key in dataset) {
    if (dataset[key] === 'false') dataset[key] = false;else if (dataset[key] === 'true') dataset[key] = true;else if (parseFloat(dataset[key]) === dataset[key] * 1) dataset[key] *= 1;
  }

  return dataset;
}

function val(value) {
  if (typeof value === 'undefined') {
    // get value
    const el = this[0];
    if (!el) return undefined;

    if (el.multiple && el.nodeName.toLowerCase() === 'select') {
      const values = [];

      for (let i = 0; i < el.selectedOptions.length; i += 1) {
        values.push(el.selectedOptions[i].value);
      }

      return values;
    }

    return el.value;
  } // set value


  for (let i = 0; i < this.length; i += 1) {
    const el = this[i];

    if (Array.isArray(value) && el.multiple && el.nodeName.toLowerCase() === 'select') {
      for (let j = 0; j < el.options.length; j += 1) {
        el.options[j].selected = value.indexOf(el.options[j].value) >= 0;
      }
    } else {
      el.value = value;
    }
  }

  return this;
}

function value(value) {
  return this.val(value);
}

function transform(transform) {
  for (let i = 0; i < this.length; i += 1) {
    this[i].style.transform = transform;
  }

  return this;
}

function transition(duration) {
  for (let i = 0; i < this.length; i += 1) {
    this[i].style.transitionDuration = typeof duration !== 'string' ? `${duration}ms` : duration;
  }

  return this;
}

function on(...args) {
  let [eventType, targetSelector, listener, capture] = args;

  if (typeof args[1] === 'function') {
    [eventType, listener, capture] = args;
    targetSelector = undefined;
  }

  if (!capture) capture = false;

  function handleLiveEvent(e) {
    const target = e.target;
    if (!target) return;
    const eventData = e.target.dom7EventData || [];

    if (eventData.indexOf(e) < 0) {
      eventData.unshift(e);
    }

    if ($(target).is(targetSelector)) listener.apply(target, eventData);else {
      const parents = $(target).parents(); // eslint-disable-line

      for (let k = 0; k < parents.length; k += 1) {
        if ($(parents[k]).is(targetSelector)) listener.apply(parents[k], eventData);
      }
    }
  }

  function handleEvent(e) {
    const eventData = e && e.target ? e.target.dom7EventData || [] : [];

    if (eventData.indexOf(e) < 0) {
      eventData.unshift(e);
    }

    listener.apply(this, eventData);
  }

  const events = eventType.split(' ');
  let j;

  for (let i = 0; i < this.length; i += 1) {
    const el = this[i];

    if (!targetSelector) {
      for (j = 0; j < events.length; j += 1) {
        const event = events[j];
        if (!el.dom7Listeners) el.dom7Listeners = {};
        if (!el.dom7Listeners[event]) el.dom7Listeners[event] = [];
        el.dom7Listeners[event].push({
          listener,
          proxyListener: handleEvent
        });
        el.addEventListener(event, handleEvent, capture);
      }
    } else {
      // Live events
      for (j = 0; j < events.length; j += 1) {
        const event = events[j];
        if (!el.dom7LiveListeners) el.dom7LiveListeners = {};
        if (!el.dom7LiveListeners[event]) el.dom7LiveListeners[event] = [];
        el.dom7LiveListeners[event].push({
          listener,
          proxyListener: handleLiveEvent
        });
        el.addEventListener(event, handleLiveEvent, capture);
      }
    }
  }

  return this;
}

function off(...args) {
  let [eventType, targetSelector, listener, capture] = args;

  if (typeof args[1] === 'function') {
    [eventType, listener, capture] = args;
    targetSelector = undefined;
  }

  if (!capture) capture = false;
  const events = eventType.split(' ');

  for (let i = 0; i < events.length; i += 1) {
    const event = events[i];

    for (let j = 0; j < this.length; j += 1) {
      const el = this[j];
      let handlers;

      if (!targetSelector && el.dom7Listeners) {
        handlers = el.dom7Listeners[event];
      } else if (targetSelector && el.dom7LiveListeners) {
        handlers = el.dom7LiveListeners[event];
      }

      if (handlers && handlers.length) {
        for (let k = handlers.length - 1; k >= 0; k -= 1) {
          const handler = handlers[k];

          if (listener && handler.listener === listener) {
            el.removeEventListener(event, handler.proxyListener, capture);
            handlers.splice(k, 1);
          } else if (listener && handler.listener && handler.listener.dom7proxy && handler.listener.dom7proxy === listener) {
            el.removeEventListener(event, handler.proxyListener, capture);
            handlers.splice(k, 1);
          } else if (!listener) {
            el.removeEventListener(event, handler.proxyListener, capture);
            handlers.splice(k, 1);
          }
        }
      }
    }
  }

  return this;
}

function once(...args) {
  const dom = this;
  let [eventName, targetSelector, listener, capture] = args;

  if (typeof args[1] === 'function') {
    [eventName, listener, capture] = args;
    targetSelector = undefined;
  }

  function onceHandler(...eventArgs) {
    listener.apply(this, eventArgs);
    dom.off(eventName, targetSelector, onceHandler, capture);

    if (onceHandler.dom7proxy) {
      delete onceHandler.dom7proxy;
    }
  }

  onceHandler.dom7proxy = listener;
  return dom.on(eventName, targetSelector, onceHandler, capture);
}

function trigger(...args) {
  const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();
  const events = args[0].split(' ');
  const eventData = args[1];

  for (let i = 0; i < events.length; i += 1) {
    const event = events[i];

    for (let j = 0; j < this.length; j += 1) {
      const el = this[j];

      if (window.CustomEvent) {
        const evt = new window.CustomEvent(event, {
          detail: eventData,
          bubbles: true,
          cancelable: true
        });
        el.dom7EventData = args.filter((data, dataIndex) => dataIndex > 0);
        el.dispatchEvent(evt);
        el.dom7EventData = [];
        delete el.dom7EventData;
      }
    }
  }

  return this;
}

function transitionEnd(callback) {
  const dom = this;

  function fireCallBack(e) {
    if (e.target !== this) return;
    callback.call(this, e);
    dom.off('transitionend', fireCallBack);
  }

  if (callback) {
    dom.on('transitionend', fireCallBack);
  }

  return this;
}

function animationEnd(callback) {
  const dom = this;

  function fireCallBack(e) {
    if (e.target !== this) return;
    callback.call(this, e);
    dom.off('animationend', fireCallBack);
  }

  if (callback) {
    dom.on('animationend', fireCallBack);
  }

  return this;
}

function width() {
  const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();

  if (this[0] === window) {
    return window.innerWidth;
  }

  if (this.length > 0) {
    return parseFloat(this.css('width'));
  }

  return null;
}

function outerWidth(includeMargins) {
  if (this.length > 0) {
    if (includeMargins) {
      const styles = this.styles();
      return this[0].offsetWidth + parseFloat(styles.getPropertyValue('margin-right')) + parseFloat(styles.getPropertyValue('margin-left'));
    }

    return this[0].offsetWidth;
  }

  return null;
}

function height() {
  const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();

  if (this[0] === window) {
    return window.innerHeight;
  }

  if (this.length > 0) {
    return parseFloat(this.css('height'));
  }

  return null;
}

function outerHeight(includeMargins) {
  if (this.length > 0) {
    if (includeMargins) {
      const styles = this.styles();
      return this[0].offsetHeight + parseFloat(styles.getPropertyValue('margin-top')) + parseFloat(styles.getPropertyValue('margin-bottom'));
    }

    return this[0].offsetHeight;
  }

  return null;
}

function offset() {
  if (this.length > 0) {
    const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();
    const document = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getDocument)();
    const el = this[0];
    const box = el.getBoundingClientRect();
    const body = document.body;
    const clientTop = el.clientTop || body.clientTop || 0;
    const clientLeft = el.clientLeft || body.clientLeft || 0;
    const scrollTop = el === window ? window.scrollY : el.scrollTop;
    const scrollLeft = el === window ? window.scrollX : el.scrollLeft;
    return {
      top: box.top + scrollTop - clientTop,
      left: box.left + scrollLeft - clientLeft
    };
  }

  return null;
}

function hide() {
  for (let i = 0; i < this.length; i += 1) {
    this[i].style.display = 'none';
  }

  return this;
}

function show() {
  const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();

  for (let i = 0; i < this.length; i += 1) {
    const el = this[i];

    if (el.style.display === 'none') {
      el.style.display = '';
    }

    if (window.getComputedStyle(el, null).getPropertyValue('display') === 'none') {
      // Still not visible
      el.style.display = 'block';
    }
  }

  return this;
}

function styles() {
  const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();
  if (this[0]) return window.getComputedStyle(this[0], null);
  return {};
}

function css(props, value) {
  const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();
  let i;

  if (arguments.length === 1) {
    if (typeof props === 'string') {
      // .css('width')
      if (this[0]) return window.getComputedStyle(this[0], null).getPropertyValue(props);
    } else {
      // .css({ width: '100px' })
      for (i = 0; i < this.length; i += 1) {
        for (const prop in props) {
          this[i].style[prop] = props[prop];
        }
      }

      return this;
    }
  }

  if (arguments.length === 2 && typeof props === 'string') {
    // .css('width', '100px')
    for (i = 0; i < this.length; i += 1) {
      this[i].style[props] = value;
    }

    return this;
  }

  return this;
}

function each(callback) {
  if (!callback) return this;
  this.forEach((el, index) => {
    callback.apply(el, [el, index]);
  });
  return this;
}

function filter(callback) {
  const result = arrayFilter(this, callback);
  return $(result);
}

function html(html) {
  if (typeof html === 'undefined') {
    return this[0] ? this[0].innerHTML : null;
  }

  for (let i = 0; i < this.length; i += 1) {
    this[i].innerHTML = html;
  }

  return this;
}

function text(text) {
  if (typeof text === 'undefined') {
    return this[0] ? this[0].textContent.trim() : null;
  }

  for (let i = 0; i < this.length; i += 1) {
    this[i].textContent = text;
  }

  return this;
}

function is(selector) {
  const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();
  const document = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getDocument)();
  const el = this[0];
  let compareWith;
  let i;
  if (!el || typeof selector === 'undefined') return false;

  if (typeof selector === 'string') {
    if (el.matches) return el.matches(selector);
    if (el.webkitMatchesSelector) return el.webkitMatchesSelector(selector);
    if (el.msMatchesSelector) return el.msMatchesSelector(selector);
    compareWith = $(selector);

    for (i = 0; i < compareWith.length; i += 1) {
      if (compareWith[i] === el) return true;
    }

    return false;
  }

  if (selector === document) {
    return el === document;
  }

  if (selector === window) {
    return el === window;
  }

  if (selector.nodeType || selector instanceof Dom7) {
    compareWith = selector.nodeType ? [selector] : selector;

    for (i = 0; i < compareWith.length; i += 1) {
      if (compareWith[i] === el) return true;
    }

    return false;
  }

  return false;
}

function index() {
  let child = this[0];
  let i;

  if (child) {
    i = 0; // eslint-disable-next-line

    while ((child = child.previousSibling) !== null) {
      if (child.nodeType === 1) i += 1;
    }

    return i;
  }

  return undefined;
}

function eq(index) {
  if (typeof index === 'undefined') return this;
  const length = this.length;

  if (index > length - 1) {
    return $([]);
  }

  if (index < 0) {
    const returnIndex = length + index;
    if (returnIndex < 0) return $([]);
    return $([this[returnIndex]]);
  }

  return $([this[index]]);
}

function append(...els) {
  let newChild;
  const document = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getDocument)();

  for (let k = 0; k < els.length; k += 1) {
    newChild = els[k];

    for (let i = 0; i < this.length; i += 1) {
      if (typeof newChild === 'string') {
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = newChild;

        while (tempDiv.firstChild) {
          this[i].appendChild(tempDiv.firstChild);
        }
      } else if (newChild instanceof Dom7) {
        for (let j = 0; j < newChild.length; j += 1) {
          this[i].appendChild(newChild[j]);
        }
      } else {
        this[i].appendChild(newChild);
      }
    }
  }

  return this;
}

function appendTo(parent) {
  $(parent).append(this);
  return this;
}

function prepend(newChild) {
  const document = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getDocument)();
  let i;
  let j;

  for (i = 0; i < this.length; i += 1) {
    if (typeof newChild === 'string') {
      const tempDiv = document.createElement('div');
      tempDiv.innerHTML = newChild;

      for (j = tempDiv.childNodes.length - 1; j >= 0; j -= 1) {
        this[i].insertBefore(tempDiv.childNodes[j], this[i].childNodes[0]);
      }
    } else if (newChild instanceof Dom7) {
      for (j = 0; j < newChild.length; j += 1) {
        this[i].insertBefore(newChild[j], this[i].childNodes[0]);
      }
    } else {
      this[i].insertBefore(newChild, this[i].childNodes[0]);
    }
  }

  return this;
}

function prependTo(parent) {
  $(parent).prepend(this);
  return this;
}

function insertBefore(selector) {
  const before = $(selector);

  for (let i = 0; i < this.length; i += 1) {
    if (before.length === 1) {
      before[0].parentNode.insertBefore(this[i], before[0]);
    } else if (before.length > 1) {
      for (let j = 0; j < before.length; j += 1) {
        before[j].parentNode.insertBefore(this[i].cloneNode(true), before[j]);
      }
    }
  }
}

function insertAfter(selector) {
  const after = $(selector);

  for (let i = 0; i < this.length; i += 1) {
    if (after.length === 1) {
      after[0].parentNode.insertBefore(this[i], after[0].nextSibling);
    } else if (after.length > 1) {
      for (let j = 0; j < after.length; j += 1) {
        after[j].parentNode.insertBefore(this[i].cloneNode(true), after[j].nextSibling);
      }
    }
  }
}

function next(selector) {
  if (this.length > 0) {
    if (selector) {
      if (this[0].nextElementSibling && $(this[0].nextElementSibling).is(selector)) {
        return $([this[0].nextElementSibling]);
      }

      return $([]);
    }

    if (this[0].nextElementSibling) return $([this[0].nextElementSibling]);
    return $([]);
  }

  return $([]);
}

function nextAll(selector) {
  const nextEls = [];
  let el = this[0];
  if (!el) return $([]);

  while (el.nextElementSibling) {
    const next = el.nextElementSibling; // eslint-disable-line

    if (selector) {
      if ($(next).is(selector)) nextEls.push(next);
    } else nextEls.push(next);

    el = next;
  }

  return $(nextEls);
}

function prev(selector) {
  if (this.length > 0) {
    const el = this[0];

    if (selector) {
      if (el.previousElementSibling && $(el.previousElementSibling).is(selector)) {
        return $([el.previousElementSibling]);
      }

      return $([]);
    }

    if (el.previousElementSibling) return $([el.previousElementSibling]);
    return $([]);
  }

  return $([]);
}

function prevAll(selector) {
  const prevEls = [];
  let el = this[0];
  if (!el) return $([]);

  while (el.previousElementSibling) {
    const prev = el.previousElementSibling; // eslint-disable-line

    if (selector) {
      if ($(prev).is(selector)) prevEls.push(prev);
    } else prevEls.push(prev);

    el = prev;
  }

  return $(prevEls);
}

function siblings(selector) {
  return this.nextAll(selector).add(this.prevAll(selector));
}

function parent(selector) {
  const parents = []; // eslint-disable-line

  for (let i = 0; i < this.length; i += 1) {
    if (this[i].parentNode !== null) {
      if (selector) {
        if ($(this[i].parentNode).is(selector)) parents.push(this[i].parentNode);
      } else {
        parents.push(this[i].parentNode);
      }
    }
  }

  return $(parents);
}

function parents(selector) {
  const parents = []; // eslint-disable-line

  for (let i = 0; i < this.length; i += 1) {
    let parent = this[i].parentNode; // eslint-disable-line

    while (parent) {
      if (selector) {
        if ($(parent).is(selector)) parents.push(parent);
      } else {
        parents.push(parent);
      }

      parent = parent.parentNode;
    }
  }

  return $(parents);
}

function closest(selector) {
  let closest = this; // eslint-disable-line

  if (typeof selector === 'undefined') {
    return $([]);
  }

  if (!closest.is(selector)) {
    closest = closest.parents(selector).eq(0);
  }

  return closest;
}

function find(selector) {
  const foundElements = [];

  for (let i = 0; i < this.length; i += 1) {
    const found = this[i].querySelectorAll(selector);

    for (let j = 0; j < found.length; j += 1) {
      foundElements.push(found[j]);
    }
  }

  return $(foundElements);
}

function children(selector) {
  const children = []; // eslint-disable-line

  for (let i = 0; i < this.length; i += 1) {
    const childNodes = this[i].children;

    for (let j = 0; j < childNodes.length; j += 1) {
      if (!selector || $(childNodes[j]).is(selector)) {
        children.push(childNodes[j]);
      }
    }
  }

  return $(children);
}

function remove() {
  for (let i = 0; i < this.length; i += 1) {
    if (this[i].parentNode) this[i].parentNode.removeChild(this[i]);
  }

  return this;
}

function detach() {
  return this.remove();
}

function add(...els) {
  const dom = this;
  let i;
  let j;

  for (i = 0; i < els.length; i += 1) {
    const toAdd = $(els[i]);

    for (j = 0; j < toAdd.length; j += 1) {
      dom.push(toAdd[j]);
    }
  }

  return dom;
}

function empty() {
  for (let i = 0; i < this.length; i += 1) {
    const el = this[i];

    if (el.nodeType === 1) {
      for (let j = 0; j < el.childNodes.length; j += 1) {
        if (el.childNodes[j].parentNode) {
          el.childNodes[j].parentNode.removeChild(el.childNodes[j]);
        }
      }

      el.textContent = '';
    }
  }

  return this;
}

// eslint-disable-next-line

function scrollTo(...args) {
  const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();
  let [left, top, duration, easing, callback] = args;

  if (args.length === 4 && typeof easing === 'function') {
    callback = easing;
    [left, top, duration, callback, easing] = args;
  }

  if (typeof easing === 'undefined') easing = 'swing';
  return this.each(function animate() {
    const el = this;
    let currentTop;
    let currentLeft;
    let maxTop;
    let maxLeft;
    let newTop;
    let newLeft;
    let scrollTop; // eslint-disable-line

    let scrollLeft; // eslint-disable-line

    let animateTop = top > 0 || top === 0;
    let animateLeft = left > 0 || left === 0;

    if (typeof easing === 'undefined') {
      easing = 'swing';
    }

    if (animateTop) {
      currentTop = el.scrollTop;

      if (!duration) {
        el.scrollTop = top;
      }
    }

    if (animateLeft) {
      currentLeft = el.scrollLeft;

      if (!duration) {
        el.scrollLeft = left;
      }
    }

    if (!duration) return;

    if (animateTop) {
      maxTop = el.scrollHeight - el.offsetHeight;
      newTop = Math.max(Math.min(top, maxTop), 0);
    }

    if (animateLeft) {
      maxLeft = el.scrollWidth - el.offsetWidth;
      newLeft = Math.max(Math.min(left, maxLeft), 0);
    }

    let startTime = null;
    if (animateTop && newTop === currentTop) animateTop = false;
    if (animateLeft && newLeft === currentLeft) animateLeft = false;

    function render(time = new Date().getTime()) {
      if (startTime === null) {
        startTime = time;
      }

      const progress = Math.max(Math.min((time - startTime) / duration, 1), 0);
      const easeProgress = easing === 'linear' ? progress : 0.5 - Math.cos(progress * Math.PI) / 2;
      let done;
      if (animateTop) scrollTop = currentTop + easeProgress * (newTop - currentTop);
      if (animateLeft) scrollLeft = currentLeft + easeProgress * (newLeft - currentLeft);

      if (animateTop && newTop > currentTop && scrollTop >= newTop) {
        el.scrollTop = newTop;
        done = true;
      }

      if (animateTop && newTop < currentTop && scrollTop <= newTop) {
        el.scrollTop = newTop;
        done = true;
      }

      if (animateLeft && newLeft > currentLeft && scrollLeft >= newLeft) {
        el.scrollLeft = newLeft;
        done = true;
      }

      if (animateLeft && newLeft < currentLeft && scrollLeft <= newLeft) {
        el.scrollLeft = newLeft;
        done = true;
      }

      if (done) {
        if (callback) callback();
        return;
      }

      if (animateTop) el.scrollTop = scrollTop;
      if (animateLeft) el.scrollLeft = scrollLeft;
      window.requestAnimationFrame(render);
    }

    window.requestAnimationFrame(render);
  });
} // scrollTop(top, duration, easing, callback) {


function scrollTop(...args) {
  let [top, duration, easing, callback] = args;

  if (args.length === 3 && typeof easing === 'function') {
    [top, duration, callback, easing] = args;
  }

  const dom = this;

  if (typeof top === 'undefined') {
    if (dom.length > 0) return dom[0].scrollTop;
    return null;
  }

  return dom.scrollTo(undefined, top, duration, easing, callback);
}

function scrollLeft(...args) {
  let [left, duration, easing, callback] = args;

  if (args.length === 3 && typeof easing === 'function') {
    [left, duration, callback, easing] = args;
  }

  const dom = this;

  if (typeof left === 'undefined') {
    if (dom.length > 0) return dom[0].scrollLeft;
    return null;
  }

  return dom.scrollTo(left, undefined, duration, easing, callback);
}

// eslint-disable-next-line

function animate(initialProps, initialParams) {
  const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();
  const els = this;
  const a = {
    props: Object.assign({}, initialProps),
    params: Object.assign({
      duration: 300,
      easing: 'swing' // or 'linear'

      /* Callbacks
      begin(elements)
      complete(elements)
      progress(elements, complete, remaining, start, tweenValue)
      */

    }, initialParams),
    elements: els,
    animating: false,
    que: [],

    easingProgress(easing, progress) {
      if (easing === 'swing') {
        return 0.5 - Math.cos(progress * Math.PI) / 2;
      }

      if (typeof easing === 'function') {
        return easing(progress);
      }

      return progress;
    },

    stop() {
      if (a.frameId) {
        window.cancelAnimationFrame(a.frameId);
      }

      a.animating = false;
      a.elements.each(el => {
        const element = el;
        delete element.dom7AnimateInstance;
      });
      a.que = [];
    },

    done(complete) {
      a.animating = false;
      a.elements.each(el => {
        const element = el;
        delete element.dom7AnimateInstance;
      });
      if (complete) complete(els);

      if (a.que.length > 0) {
        const que = a.que.shift();
        a.animate(que[0], que[1]);
      }
    },

    animate(props, params) {
      if (a.animating) {
        a.que.push([props, params]);
        return a;
      }

      const elements = []; // Define & Cache Initials & Units

      a.elements.each((el, index) => {
        let initialFullValue;
        let initialValue;
        let unit;
        let finalValue;
        let finalFullValue;
        if (!el.dom7AnimateInstance) a.elements[index].dom7AnimateInstance = a;
        elements[index] = {
          container: el
        };
        Object.keys(props).forEach(prop => {
          initialFullValue = window.getComputedStyle(el, null).getPropertyValue(prop).replace(',', '.');
          initialValue = parseFloat(initialFullValue);
          unit = initialFullValue.replace(initialValue, '');
          finalValue = parseFloat(props[prop]);
          finalFullValue = props[prop] + unit;
          elements[index][prop] = {
            initialFullValue,
            initialValue,
            unit,
            finalValue,
            finalFullValue,
            currentValue: initialValue
          };
        });
      });
      let startTime = null;
      let time;
      let elementsDone = 0;
      let propsDone = 0;
      let done;
      let began = false;
      a.animating = true;

      function render() {
        time = new Date().getTime();
        let progress;
        let easeProgress; // let el;

        if (!began) {
          began = true;
          if (params.begin) params.begin(els);
        }

        if (startTime === null) {
          startTime = time;
        }

        if (params.progress) {
          // eslint-disable-next-line
          params.progress(els, Math.max(Math.min((time - startTime) / params.duration, 1), 0), startTime + params.duration - time < 0 ? 0 : startTime + params.duration - time, startTime);
        }

        elements.forEach(element => {
          const el = element;
          if (done || el.done) return;
          Object.keys(props).forEach(prop => {
            if (done || el.done) return;
            progress = Math.max(Math.min((time - startTime) / params.duration, 1), 0);
            easeProgress = a.easingProgress(params.easing, progress);
            const {
              initialValue,
              finalValue,
              unit
            } = el[prop];
            el[prop].currentValue = initialValue + easeProgress * (finalValue - initialValue);
            const currentValue = el[prop].currentValue;

            if (finalValue > initialValue && currentValue >= finalValue || finalValue < initialValue && currentValue <= finalValue) {
              el.container.style[prop] = finalValue + unit;
              propsDone += 1;

              if (propsDone === Object.keys(props).length) {
                el.done = true;
                elementsDone += 1;
              }

              if (elementsDone === elements.length) {
                done = true;
              }
            }

            if (done) {
              a.done(params.complete);
              return;
            }

            el.container.style[prop] = currentValue + unit;
          });
        });
        if (done) return; // Then call

        a.frameId = window.requestAnimationFrame(render);
      }

      a.frameId = window.requestAnimationFrame(render);
      return a;
    }

  };

  if (a.elements.length === 0) {
    return els;
  }

  let animateInstance;

  for (let i = 0; i < a.elements.length; i += 1) {
    if (a.elements[i].dom7AnimateInstance) {
      animateInstance = a.elements[i].dom7AnimateInstance;
    } else a.elements[i].dom7AnimateInstance = a;
  }

  if (!animateInstance) {
    animateInstance = a;
  }

  if (initialProps === 'stop') {
    animateInstance.stop();
  } else {
    animateInstance.animate(a.props, a.params);
  }

  return els;
}

function stop() {
  const els = this;

  for (let i = 0; i < els.length; i += 1) {
    if (els[i].dom7AnimateInstance) {
      els[i].dom7AnimateInstance.stop();
    }
  }
}

const noTrigger = 'resize scroll'.split(' ');

function shortcut(name) {
  function eventHandler(...args) {
    if (typeof args[0] === 'undefined') {
      for (let i = 0; i < this.length; i += 1) {
        if (noTrigger.indexOf(name) < 0) {
          if (name in this[i]) this[i][name]();else {
            $(this[i]).trigger(name);
          }
        }
      }

      return this;
    }

    return this.on(name, ...args);
  }

  return eventHandler;
}

const click = shortcut('click');
const blur = shortcut('blur');
const focus = shortcut('focus');
const focusin = shortcut('focusin');
const focusout = shortcut('focusout');
const keyup = shortcut('keyup');
const keydown = shortcut('keydown');
const keypress = shortcut('keypress');
const submit = shortcut('submit');
const change = shortcut('change');
const mousedown = shortcut('mousedown');
const mousemove = shortcut('mousemove');
const mouseup = shortcut('mouseup');
const mouseenter = shortcut('mouseenter');
const mouseleave = shortcut('mouseleave');
const mouseout = shortcut('mouseout');
const mouseover = shortcut('mouseover');
const touchstart = shortcut('touchstart');
const touchend = shortcut('touchend');
const touchmove = shortcut('touchmove');
const resize = shortcut('resize');
const scroll = shortcut('scroll');

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ($);



/***/ }),

/***/ "./node_modules/ssr-window/ssr-window.esm.js":
/*!***************************************************!*\
  !*** ./node_modules/ssr-window/ssr-window.esm.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "extend": () => (/* binding */ extend),
/* harmony export */   "getDocument": () => (/* binding */ getDocument),
/* harmony export */   "getWindow": () => (/* binding */ getWindow),
/* harmony export */   "ssrDocument": () => (/* binding */ ssrDocument),
/* harmony export */   "ssrWindow": () => (/* binding */ ssrWindow)
/* harmony export */ });
/**
 * SSR Window 4.0.2
 * Better handling for window object in SSR environment
 * https://github.com/nolimits4web/ssr-window
 *
 * Copyright 2021, Vladimir Kharlampidi
 *
 * Licensed under MIT
 *
 * Released on: December 13, 2021
 */
/* eslint-disable no-param-reassign */
function isObject(obj) {
    return (obj !== null &&
        typeof obj === 'object' &&
        'constructor' in obj &&
        obj.constructor === Object);
}
function extend(target = {}, src = {}) {
    Object.keys(src).forEach((key) => {
        if (typeof target[key] === 'undefined')
            target[key] = src[key];
        else if (isObject(src[key]) &&
            isObject(target[key]) &&
            Object.keys(src[key]).length > 0) {
            extend(target[key], src[key]);
        }
    });
}

const ssrDocument = {
    body: {},
    addEventListener() { },
    removeEventListener() { },
    activeElement: {
        blur() { },
        nodeName: '',
    },
    querySelector() {
        return null;
    },
    querySelectorAll() {
        return [];
    },
    getElementById() {
        return null;
    },
    createEvent() {
        return {
            initEvent() { },
        };
    },
    createElement() {
        return {
            children: [],
            childNodes: [],
            style: {},
            setAttribute() { },
            getElementsByTagName() {
                return [];
            },
        };
    },
    createElementNS() {
        return {};
    },
    importNode() {
        return null;
    },
    location: {
        hash: '',
        host: '',
        hostname: '',
        href: '',
        origin: '',
        pathname: '',
        protocol: '',
        search: '',
    },
};
function getDocument() {
    const doc = typeof document !== 'undefined' ? document : {};
    extend(doc, ssrDocument);
    return doc;
}

const ssrWindow = {
    document: ssrDocument,
    navigator: {
        userAgent: '',
    },
    location: {
        hash: '',
        host: '',
        hostname: '',
        href: '',
        origin: '',
        pathname: '',
        protocol: '',
        search: '',
    },
    history: {
        replaceState() { },
        pushState() { },
        go() { },
        back() { },
    },
    CustomEvent: function CustomEvent() {
        return this;
    },
    addEventListener() { },
    removeEventListener() { },
    getComputedStyle() {
        return {
            getPropertyValue() {
                return '';
            },
        };
    },
    Image() { },
    Date() { },
    screen: {},
    setTimeout() { },
    clearTimeout() { },
    matchMedia() {
        return {};
    },
    requestAnimationFrame(callback) {
        if (typeof setTimeout === 'undefined') {
            callback();
            return null;
        }
        return setTimeout(callback, 0);
    },
    cancelAnimationFrame(id) {
        if (typeof setTimeout === 'undefined') {
            return;
        }
        clearTimeout(id);
    },
};
function getWindow() {
    const win = typeof window !== 'undefined' ? window : {};
    extend(win, ssrWindow);
    return win;
}




/***/ }),

/***/ "./node_modules/swiper/core/breakpoints/getBreakpoint.js":
/*!***************************************************************!*\
  !*** ./node_modules/swiper/core/breakpoints/getBreakpoint.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getBreakpoint)
/* harmony export */ });
/* harmony import */ var ssr_window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ssr-window */ "./node_modules/ssr-window/ssr-window.esm.js");

function getBreakpoint(breakpoints, base, containerEl) {
  if (base === void 0) {
    base = 'window';
  }

  if (!breakpoints || base === 'container' && !containerEl) return undefined;
  let breakpoint = false;
  const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();
  const currentHeight = base === 'window' ? window.innerHeight : containerEl.clientHeight;
  const points = Object.keys(breakpoints).map(point => {
    if (typeof point === 'string' && point.indexOf('@') === 0) {
      const minRatio = parseFloat(point.substr(1));
      const value = currentHeight * minRatio;
      return {
        value,
        point
      };
    }

    return {
      value: point,
      point
    };
  });
  points.sort((a, b) => parseInt(a.value, 10) - parseInt(b.value, 10));

  for (let i = 0; i < points.length; i += 1) {
    const {
      point,
      value
    } = points[i];

    if (base === 'window') {
      if (window.matchMedia(`(min-width: ${value}px)`).matches) {
        breakpoint = point;
      }
    } else if (value <= containerEl.clientWidth) {
      breakpoint = point;
    }
  }

  return breakpoint || 'max';
}

/***/ }),

/***/ "./node_modules/swiper/core/breakpoints/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/swiper/core/breakpoints/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _setBreakpoint_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./setBreakpoint.js */ "./node_modules/swiper/core/breakpoints/setBreakpoint.js");
/* harmony import */ var _getBreakpoint_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getBreakpoint.js */ "./node_modules/swiper/core/breakpoints/getBreakpoint.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  setBreakpoint: _setBreakpoint_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  getBreakpoint: _getBreakpoint_js__WEBPACK_IMPORTED_MODULE_1__["default"]
});

/***/ }),

/***/ "./node_modules/swiper/core/breakpoints/setBreakpoint.js":
/*!***************************************************************!*\
  !*** ./node_modules/swiper/core/breakpoints/setBreakpoint.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ setBreakpoint)
/* harmony export */ });
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/swiper/shared/utils.js");


const isGridEnabled = (swiper, params) => {
  return swiper.grid && params.grid && params.grid.rows > 1;
};

function setBreakpoint() {
  const swiper = this;
  const {
    activeIndex,
    initialized,
    loopedSlides = 0,
    params,
    $el
  } = swiper;
  const breakpoints = params.breakpoints;
  if (!breakpoints || breakpoints && Object.keys(breakpoints).length === 0) return; // Get breakpoint for window width and update parameters

  const breakpoint = swiper.getBreakpoint(breakpoints, swiper.params.breakpointsBase, swiper.el);
  if (!breakpoint || swiper.currentBreakpoint === breakpoint) return;
  const breakpointOnlyParams = breakpoint in breakpoints ? breakpoints[breakpoint] : undefined;
  const breakpointParams = breakpointOnlyParams || swiper.originalParams;
  const wasMultiRow = isGridEnabled(swiper, params);
  const isMultiRow = isGridEnabled(swiper, breakpointParams);
  const wasEnabled = params.enabled;

  if (wasMultiRow && !isMultiRow) {
    $el.removeClass(`${params.containerModifierClass}grid ${params.containerModifierClass}grid-column`);
    swiper.emitContainerClasses();
  } else if (!wasMultiRow && isMultiRow) {
    $el.addClass(`${params.containerModifierClass}grid`);

    if (breakpointParams.grid.fill && breakpointParams.grid.fill === 'column' || !breakpointParams.grid.fill && params.grid.fill === 'column') {
      $el.addClass(`${params.containerModifierClass}grid-column`);
    }

    swiper.emitContainerClasses();
  }

  const directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction;
  const needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);

  if (directionChanged && initialized) {
    swiper.changeDirection();
  }

  (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_0__.extend)(swiper.params, breakpointParams);
  const isEnabled = swiper.params.enabled;
  Object.assign(swiper, {
    allowTouchMove: swiper.params.allowTouchMove,
    allowSlideNext: swiper.params.allowSlideNext,
    allowSlidePrev: swiper.params.allowSlidePrev
  });

  if (wasEnabled && !isEnabled) {
    swiper.disable();
  } else if (!wasEnabled && isEnabled) {
    swiper.enable();
  }

  swiper.currentBreakpoint = breakpoint;
  swiper.emit('_beforeBreakpoint', breakpointParams);

  if (needsReLoop && initialized) {
    swiper.loopDestroy();
    swiper.loopCreate();
    swiper.updateSlides();
    swiper.slideTo(activeIndex - loopedSlides + swiper.loopedSlides, 0, false);
  }

  swiper.emit('breakpoint', breakpointParams);
}

/***/ }),

/***/ "./node_modules/swiper/core/check-overflow/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/swiper/core/check-overflow/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function checkOverflow() {
  const swiper = this;
  const {
    isLocked: wasLocked,
    params
  } = swiper;
  const {
    slidesOffsetBefore
  } = params;

  if (slidesOffsetBefore) {
    const lastSlideIndex = swiper.slides.length - 1;
    const lastSlideRightEdge = swiper.slidesGrid[lastSlideIndex] + swiper.slidesSizesGrid[lastSlideIndex] + slidesOffsetBefore * 2;
    swiper.isLocked = swiper.size > lastSlideRightEdge;
  } else {
    swiper.isLocked = swiper.snapGrid.length === 1;
  }

  if (params.allowSlideNext === true) {
    swiper.allowSlideNext = !swiper.isLocked;
  }

  if (params.allowSlidePrev === true) {
    swiper.allowSlidePrev = !swiper.isLocked;
  }

  if (wasLocked && wasLocked !== swiper.isLocked) {
    swiper.isEnd = false;
  }

  if (wasLocked !== swiper.isLocked) {
    swiper.emit(swiper.isLocked ? 'lock' : 'unlock');
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  checkOverflow
});

/***/ }),

/***/ "./node_modules/swiper/core/classes/addClasses.js":
/*!********************************************************!*\
  !*** ./node_modules/swiper/core/classes/addClasses.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ addClasses)
/* harmony export */ });
function prepareClasses(entries, prefix) {
  const resultClasses = [];
  entries.forEach(item => {
    if (typeof item === 'object') {
      Object.keys(item).forEach(classNames => {
        if (item[classNames]) {
          resultClasses.push(prefix + classNames);
        }
      });
    } else if (typeof item === 'string') {
      resultClasses.push(prefix + item);
    }
  });
  return resultClasses;
}

function addClasses() {
  const swiper = this;
  const {
    classNames,
    params,
    rtl,
    $el,
    device,
    support
  } = swiper; // prettier-ignore

  const suffixes = prepareClasses(['initialized', params.direction, {
    'pointer-events': !support.touch
  }, {
    'free-mode': swiper.params.freeMode && params.freeMode.enabled
  }, {
    'autoheight': params.autoHeight
  }, {
    'rtl': rtl
  }, {
    'grid': params.grid && params.grid.rows > 1
  }, {
    'grid-column': params.grid && params.grid.rows > 1 && params.grid.fill === 'column'
  }, {
    'android': device.android
  }, {
    'ios': device.ios
  }, {
    'css-mode': params.cssMode
  }, {
    'centered': params.cssMode && params.centeredSlides
  }], params.containerModifierClass);
  classNames.push(...suffixes);
  $el.addClass([...classNames].join(' '));
  swiper.emitContainerClasses();
}

/***/ }),

/***/ "./node_modules/swiper/core/classes/index.js":
/*!***************************************************!*\
  !*** ./node_modules/swiper/core/classes/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _addClasses_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./addClasses.js */ "./node_modules/swiper/core/classes/addClasses.js");
/* harmony import */ var _removeClasses_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./removeClasses.js */ "./node_modules/swiper/core/classes/removeClasses.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  addClasses: _addClasses_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  removeClasses: _removeClasses_js__WEBPACK_IMPORTED_MODULE_1__["default"]
});

/***/ }),

/***/ "./node_modules/swiper/core/classes/removeClasses.js":
/*!***********************************************************!*\
  !*** ./node_modules/swiper/core/classes/removeClasses.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ removeClasses)
/* harmony export */ });
function removeClasses() {
  const swiper = this;
  const {
    $el,
    classNames
  } = swiper;
  $el.removeClass(classNames.join(' '));
  swiper.emitContainerClasses();
}

/***/ }),

/***/ "./node_modules/swiper/core/core.js":
/*!******************************************!*\
  !*** ./node_modules/swiper/core/core.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var ssr_window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ssr-window */ "./node_modules/ssr-window/ssr-window.esm.js");
/* harmony import */ var _shared_dom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/dom.js */ "./node_modules/swiper/shared/dom.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/utils.js */ "./node_modules/swiper/shared/utils.js");
/* harmony import */ var _shared_get_support_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../shared/get-support.js */ "./node_modules/swiper/shared/get-support.js");
/* harmony import */ var _shared_get_device_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../shared/get-device.js */ "./node_modules/swiper/shared/get-device.js");
/* harmony import */ var _shared_get_browser_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../shared/get-browser.js */ "./node_modules/swiper/shared/get-browser.js");
/* harmony import */ var _modules_resize_resize_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./modules/resize/resize.js */ "./node_modules/swiper/core/modules/resize/resize.js");
/* harmony import */ var _modules_observer_observer_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./modules/observer/observer.js */ "./node_modules/swiper/core/modules/observer/observer.js");
/* harmony import */ var _events_emitter_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./events-emitter.js */ "./node_modules/swiper/core/events-emitter.js");
/* harmony import */ var _update_index_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./update/index.js */ "./node_modules/swiper/core/update/index.js");
/* harmony import */ var _translate_index_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./translate/index.js */ "./node_modules/swiper/core/translate/index.js");
/* harmony import */ var _transition_index_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./transition/index.js */ "./node_modules/swiper/core/transition/index.js");
/* harmony import */ var _slide_index_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./slide/index.js */ "./node_modules/swiper/core/slide/index.js");
/* harmony import */ var _loop_index_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./loop/index.js */ "./node_modules/swiper/core/loop/index.js");
/* harmony import */ var _grab_cursor_index_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./grab-cursor/index.js */ "./node_modules/swiper/core/grab-cursor/index.js");
/* harmony import */ var _events_index_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./events/index.js */ "./node_modules/swiper/core/events/index.js");
/* harmony import */ var _breakpoints_index_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./breakpoints/index.js */ "./node_modules/swiper/core/breakpoints/index.js");
/* harmony import */ var _classes_index_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./classes/index.js */ "./node_modules/swiper/core/classes/index.js");
/* harmony import */ var _images_index_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./images/index.js */ "./node_modules/swiper/core/images/index.js");
/* harmony import */ var _check_overflow_index_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./check-overflow/index.js */ "./node_modules/swiper/core/check-overflow/index.js");
/* harmony import */ var _defaults_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./defaults.js */ "./node_modules/swiper/core/defaults.js");
/* harmony import */ var _moduleExtendParams_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./moduleExtendParams.js */ "./node_modules/swiper/core/moduleExtendParams.js");
/* eslint no-param-reassign: "off" */






















const prototypes = {
  eventsEmitter: _events_emitter_js__WEBPACK_IMPORTED_MODULE_8__["default"],
  update: _update_index_js__WEBPACK_IMPORTED_MODULE_9__["default"],
  translate: _translate_index_js__WEBPACK_IMPORTED_MODULE_10__["default"],
  transition: _transition_index_js__WEBPACK_IMPORTED_MODULE_11__["default"],
  slide: _slide_index_js__WEBPACK_IMPORTED_MODULE_12__["default"],
  loop: _loop_index_js__WEBPACK_IMPORTED_MODULE_13__["default"],
  grabCursor: _grab_cursor_index_js__WEBPACK_IMPORTED_MODULE_14__["default"],
  events: _events_index_js__WEBPACK_IMPORTED_MODULE_15__["default"],
  breakpoints: _breakpoints_index_js__WEBPACK_IMPORTED_MODULE_16__["default"],
  checkOverflow: _check_overflow_index_js__WEBPACK_IMPORTED_MODULE_19__["default"],
  classes: _classes_index_js__WEBPACK_IMPORTED_MODULE_17__["default"],
  images: _images_index_js__WEBPACK_IMPORTED_MODULE_18__["default"]
};
const extendedDefaults = {};

class Swiper {
  constructor() {
    let el;
    let params;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    if (args.length === 1 && args[0].constructor && Object.prototype.toString.call(args[0]).slice(8, -1) === 'Object') {
      params = args[0];
    } else {
      [el, params] = args;
    }

    if (!params) params = {};
    params = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.extend)({}, params);
    if (el && !params.el) params.el = el;

    if (params.el && (0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_1__["default"])(params.el).length > 1) {
      const swipers = [];
      (0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_1__["default"])(params.el).each(containerEl => {
        const newParams = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.extend)({}, params, {
          el: containerEl
        });
        swipers.push(new Swiper(newParams));
      });
      return swipers;
    } // Swiper Instance


    const swiper = this;
    swiper.__swiper__ = true;
    swiper.support = (0,_shared_get_support_js__WEBPACK_IMPORTED_MODULE_3__.getSupport)();
    swiper.device = (0,_shared_get_device_js__WEBPACK_IMPORTED_MODULE_4__.getDevice)({
      userAgent: params.userAgent
    });
    swiper.browser = (0,_shared_get_browser_js__WEBPACK_IMPORTED_MODULE_5__.getBrowser)();
    swiper.eventsListeners = {};
    swiper.eventsAnyListeners = [];
    swiper.modules = [...swiper.__modules__];

    if (params.modules && Array.isArray(params.modules)) {
      swiper.modules.push(...params.modules);
    }

    const allModulesParams = {};
    swiper.modules.forEach(mod => {
      mod({
        swiper,
        extendParams: (0,_moduleExtendParams_js__WEBPACK_IMPORTED_MODULE_21__["default"])(params, allModulesParams),
        on: swiper.on.bind(swiper),
        once: swiper.once.bind(swiper),
        off: swiper.off.bind(swiper),
        emit: swiper.emit.bind(swiper)
      });
    }); // Extend defaults with modules params

    const swiperParams = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.extend)({}, _defaults_js__WEBPACK_IMPORTED_MODULE_20__["default"], allModulesParams); // Extend defaults with passed params

    swiper.params = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.extend)({}, swiperParams, extendedDefaults, params);
    swiper.originalParams = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.extend)({}, swiper.params);
    swiper.passedParams = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.extend)({}, params); // add event listeners

    if (swiper.params && swiper.params.on) {
      Object.keys(swiper.params.on).forEach(eventName => {
        swiper.on(eventName, swiper.params.on[eventName]);
      });
    }

    if (swiper.params && swiper.params.onAny) {
      swiper.onAny(swiper.params.onAny);
    } // Save Dom lib


    swiper.$ = _shared_dom_js__WEBPACK_IMPORTED_MODULE_1__["default"]; // Extend Swiper

    Object.assign(swiper, {
      enabled: swiper.params.enabled,
      el,
      // Classes
      classNames: [],
      // Slides
      slides: (0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_1__["default"])(),
      slidesGrid: [],
      snapGrid: [],
      slidesSizesGrid: [],

      // isDirection
      isHorizontal() {
        return swiper.params.direction === 'horizontal';
      },

      isVertical() {
        return swiper.params.direction === 'vertical';
      },

      // Indexes
      activeIndex: 0,
      realIndex: 0,
      //
      isBeginning: true,
      isEnd: false,
      // Props
      translate: 0,
      previousTranslate: 0,
      progress: 0,
      velocity: 0,
      animating: false,
      // Locks
      allowSlideNext: swiper.params.allowSlideNext,
      allowSlidePrev: swiper.params.allowSlidePrev,
      // Touch Events
      touchEvents: function touchEvents() {
        const touch = ['touchstart', 'touchmove', 'touchend', 'touchcancel'];
        const desktop = ['pointerdown', 'pointermove', 'pointerup'];
        swiper.touchEventsTouch = {
          start: touch[0],
          move: touch[1],
          end: touch[2],
          cancel: touch[3]
        };
        swiper.touchEventsDesktop = {
          start: desktop[0],
          move: desktop[1],
          end: desktop[2]
        };
        return swiper.support.touch || !swiper.params.simulateTouch ? swiper.touchEventsTouch : swiper.touchEventsDesktop;
      }(),
      touchEventsData: {
        isTouched: undefined,
        isMoved: undefined,
        allowTouchCallbacks: undefined,
        touchStartTime: undefined,
        isScrolling: undefined,
        currentTranslate: undefined,
        startTranslate: undefined,
        allowThresholdMove: undefined,
        // Form elements to match
        focusableElements: swiper.params.focusableElements,
        // Last click time
        lastClickTime: (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.now)(),
        clickTimeout: undefined,
        // Velocities
        velocities: [],
        allowMomentumBounce: undefined,
        isTouchEvent: undefined,
        startMoving: undefined
      },
      // Clicks
      allowClick: true,
      // Touches
      allowTouchMove: swiper.params.allowTouchMove,
      touches: {
        startX: 0,
        startY: 0,
        currentX: 0,
        currentY: 0,
        diff: 0
      },
      // Images
      imagesToLoad: [],
      imagesLoaded: 0
    });
    swiper.emit('_swiper'); // Init

    if (swiper.params.init) {
      swiper.init();
    } // Return app instance


    return swiper;
  }

  enable() {
    const swiper = this;
    if (swiper.enabled) return;
    swiper.enabled = true;

    if (swiper.params.grabCursor) {
      swiper.setGrabCursor();
    }

    swiper.emit('enable');
  }

  disable() {
    const swiper = this;
    if (!swiper.enabled) return;
    swiper.enabled = false;

    if (swiper.params.grabCursor) {
      swiper.unsetGrabCursor();
    }

    swiper.emit('disable');
  }

  setProgress(progress, speed) {
    const swiper = this;
    progress = Math.min(Math.max(progress, 0), 1);
    const min = swiper.minTranslate();
    const max = swiper.maxTranslate();
    const current = (max - min) * progress + min;
    swiper.translateTo(current, typeof speed === 'undefined' ? 0 : speed);
    swiper.updateActiveIndex();
    swiper.updateSlidesClasses();
  }

  emitContainerClasses() {
    const swiper = this;
    if (!swiper.params._emitClasses || !swiper.el) return;
    const cls = swiper.el.className.split(' ').filter(className => {
      return className.indexOf('swiper') === 0 || className.indexOf(swiper.params.containerModifierClass) === 0;
    });
    swiper.emit('_containerClasses', cls.join(' '));
  }

  getSlideClasses(slideEl) {
    const swiper = this;
    return slideEl.className.split(' ').filter(className => {
      return className.indexOf('swiper-slide') === 0 || className.indexOf(swiper.params.slideClass) === 0;
    }).join(' ');
  }

  emitSlidesClasses() {
    const swiper = this;
    if (!swiper.params._emitClasses || !swiper.el) return;
    const updates = [];
    swiper.slides.each(slideEl => {
      const classNames = swiper.getSlideClasses(slideEl);
      updates.push({
        slideEl,
        classNames
      });
      swiper.emit('_slideClass', slideEl, classNames);
    });
    swiper.emit('_slideClasses', updates);
  }

  slidesPerViewDynamic(view, exact) {
    if (view === void 0) {
      view = 'current';
    }

    if (exact === void 0) {
      exact = false;
    }

    const swiper = this;
    const {
      params,
      slides,
      slidesGrid,
      slidesSizesGrid,
      size: swiperSize,
      activeIndex
    } = swiper;
    let spv = 1;

    if (params.centeredSlides) {
      let slideSize = slides[activeIndex].swiperSlideSize;
      let breakLoop;

      for (let i = activeIndex + 1; i < slides.length; i += 1) {
        if (slides[i] && !breakLoop) {
          slideSize += slides[i].swiperSlideSize;
          spv += 1;
          if (slideSize > swiperSize) breakLoop = true;
        }
      }

      for (let i = activeIndex - 1; i >= 0; i -= 1) {
        if (slides[i] && !breakLoop) {
          slideSize += slides[i].swiperSlideSize;
          spv += 1;
          if (slideSize > swiperSize) breakLoop = true;
        }
      }
    } else {
      // eslint-disable-next-line
      if (view === 'current') {
        for (let i = activeIndex + 1; i < slides.length; i += 1) {
          const slideInView = exact ? slidesGrid[i] + slidesSizesGrid[i] - slidesGrid[activeIndex] < swiperSize : slidesGrid[i] - slidesGrid[activeIndex] < swiperSize;

          if (slideInView) {
            spv += 1;
          }
        }
      } else {
        // previous
        for (let i = activeIndex - 1; i >= 0; i -= 1) {
          const slideInView = slidesGrid[activeIndex] - slidesGrid[i] < swiperSize;

          if (slideInView) {
            spv += 1;
          }
        }
      }
    }

    return spv;
  }

  update() {
    const swiper = this;
    if (!swiper || swiper.destroyed) return;
    const {
      snapGrid,
      params
    } = swiper; // Breakpoints

    if (params.breakpoints) {
      swiper.setBreakpoint();
    }

    swiper.updateSize();
    swiper.updateSlides();
    swiper.updateProgress();
    swiper.updateSlidesClasses();

    function setTranslate() {
      const translateValue = swiper.rtlTranslate ? swiper.translate * -1 : swiper.translate;
      const newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());
      swiper.setTranslate(newTranslate);
      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();
    }

    let translated;

    if (swiper.params.freeMode && swiper.params.freeMode.enabled) {
      setTranslate();

      if (swiper.params.autoHeight) {
        swiper.updateAutoHeight();
      }
    } else {
      if ((swiper.params.slidesPerView === 'auto' || swiper.params.slidesPerView > 1) && swiper.isEnd && !swiper.params.centeredSlides) {
        translated = swiper.slideTo(swiper.slides.length - 1, 0, false, true);
      } else {
        translated = swiper.slideTo(swiper.activeIndex, 0, false, true);
      }

      if (!translated) {
        setTranslate();
      }
    }

    if (params.watchOverflow && snapGrid !== swiper.snapGrid) {
      swiper.checkOverflow();
    }

    swiper.emit('update');
  }

  changeDirection(newDirection, needUpdate) {
    if (needUpdate === void 0) {
      needUpdate = true;
    }

    const swiper = this;
    const currentDirection = swiper.params.direction;

    if (!newDirection) {
      // eslint-disable-next-line
      newDirection = currentDirection === 'horizontal' ? 'vertical' : 'horizontal';
    }

    if (newDirection === currentDirection || newDirection !== 'horizontal' && newDirection !== 'vertical') {
      return swiper;
    }

    swiper.$el.removeClass(`${swiper.params.containerModifierClass}${currentDirection}`).addClass(`${swiper.params.containerModifierClass}${newDirection}`);
    swiper.emitContainerClasses();
    swiper.params.direction = newDirection;
    swiper.slides.each(slideEl => {
      if (newDirection === 'vertical') {
        slideEl.style.width = '';
      } else {
        slideEl.style.height = '';
      }
    });
    swiper.emit('changeDirection');
    if (needUpdate) swiper.update();
    return swiper;
  }

  mount(el) {
    const swiper = this;
    if (swiper.mounted) return true; // Find el

    const $el = (0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_1__["default"])(el || swiper.params.el);
    el = $el[0];

    if (!el) {
      return false;
    }

    el.swiper = swiper;

    const getWrapperSelector = () => {
      return `.${(swiper.params.wrapperClass || '').trim().split(' ').join('.')}`;
    };

    const getWrapper = () => {
      if (el && el.shadowRoot && el.shadowRoot.querySelector) {
        const res = (0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_1__["default"])(el.shadowRoot.querySelector(getWrapperSelector())); // Children needs to return slot items

        res.children = options => $el.children(options);

        return res;
      }

      return $el.children(getWrapperSelector());
    }; // Find Wrapper


    let $wrapperEl = getWrapper();

    if ($wrapperEl.length === 0 && swiper.params.createElements) {
      const document = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getDocument)();
      const wrapper = document.createElement('div');
      $wrapperEl = (0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_1__["default"])(wrapper);
      wrapper.className = swiper.params.wrapperClass;
      $el.append(wrapper);
      $el.children(`.${swiper.params.slideClass}`).each(slideEl => {
        $wrapperEl.append(slideEl);
      });
    }

    Object.assign(swiper, {
      $el,
      el,
      $wrapperEl,
      wrapperEl: $wrapperEl[0],
      mounted: true,
      // RTL
      rtl: el.dir.toLowerCase() === 'rtl' || $el.css('direction') === 'rtl',
      rtlTranslate: swiper.params.direction === 'horizontal' && (el.dir.toLowerCase() === 'rtl' || $el.css('direction') === 'rtl'),
      wrongRTL: $wrapperEl.css('display') === '-webkit-box'
    });
    return true;
  }

  init(el) {
    const swiper = this;
    if (swiper.initialized) return swiper;
    const mounted = swiper.mount(el);
    if (mounted === false) return swiper;
    swiper.emit('beforeInit'); // Set breakpoint

    if (swiper.params.breakpoints) {
      swiper.setBreakpoint();
    } // Add Classes


    swiper.addClasses(); // Create loop

    if (swiper.params.loop) {
      swiper.loopCreate();
    } // Update size


    swiper.updateSize(); // Update slides

    swiper.updateSlides();

    if (swiper.params.watchOverflow) {
      swiper.checkOverflow();
    } // Set Grab Cursor


    if (swiper.params.grabCursor && swiper.enabled) {
      swiper.setGrabCursor();
    }

    if (swiper.params.preloadImages) {
      swiper.preloadImages();
    } // Slide To Initial Slide


    if (swiper.params.loop) {
      swiper.slideTo(swiper.params.initialSlide + swiper.loopedSlides, 0, swiper.params.runCallbacksOnInit, false, true);
    } else {
      swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit, false, true);
    } // Attach events


    swiper.attachEvents(); // Init Flag

    swiper.initialized = true; // Emit

    swiper.emit('init');
    swiper.emit('afterInit');
    return swiper;
  }

  destroy(deleteInstance, cleanStyles) {
    if (deleteInstance === void 0) {
      deleteInstance = true;
    }

    if (cleanStyles === void 0) {
      cleanStyles = true;
    }

    const swiper = this;
    const {
      params,
      $el,
      $wrapperEl,
      slides
    } = swiper;

    if (typeof swiper.params === 'undefined' || swiper.destroyed) {
      return null;
    }

    swiper.emit('beforeDestroy'); // Init Flag

    swiper.initialized = false; // Detach events

    swiper.detachEvents(); // Destroy loop

    if (params.loop) {
      swiper.loopDestroy();
    } // Cleanup styles


    if (cleanStyles) {
      swiper.removeClasses();
      $el.removeAttr('style');
      $wrapperEl.removeAttr('style');

      if (slides && slides.length) {
        slides.removeClass([params.slideVisibleClass, params.slideActiveClass, params.slideNextClass, params.slidePrevClass].join(' ')).removeAttr('style').removeAttr('data-swiper-slide-index');
      }
    }

    swiper.emit('destroy'); // Detach emitter events

    Object.keys(swiper.eventsListeners).forEach(eventName => {
      swiper.off(eventName);
    });

    if (deleteInstance !== false) {
      swiper.$el[0].swiper = null;
      (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.deleteProps)(swiper);
    }

    swiper.destroyed = true;
    return null;
  }

  static extendDefaults(newDefaults) {
    (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.extend)(extendedDefaults, newDefaults);
  }

  static get extendedDefaults() {
    return extendedDefaults;
  }

  static get defaults() {
    return _defaults_js__WEBPACK_IMPORTED_MODULE_20__["default"];
  }

  static installModule(mod) {
    if (!Swiper.prototype.__modules__) Swiper.prototype.__modules__ = [];
    const modules = Swiper.prototype.__modules__;

    if (typeof mod === 'function' && modules.indexOf(mod) < 0) {
      modules.push(mod);
    }
  }

  static use(module) {
    if (Array.isArray(module)) {
      module.forEach(m => Swiper.installModule(m));
      return Swiper;
    }

    Swiper.installModule(module);
    return Swiper;
  }

}

Object.keys(prototypes).forEach(prototypeGroup => {
  Object.keys(prototypes[prototypeGroup]).forEach(protoMethod => {
    Swiper.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];
  });
});
Swiper.use([_modules_resize_resize_js__WEBPACK_IMPORTED_MODULE_6__["default"], _modules_observer_observer_js__WEBPACK_IMPORTED_MODULE_7__["default"]]);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Swiper);

/***/ }),

/***/ "./node_modules/swiper/core/defaults.js":
/*!**********************************************!*\
  !*** ./node_modules/swiper/core/defaults.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  init: true,
  direction: 'horizontal',
  touchEventsTarget: 'wrapper',
  initialSlide: 0,
  speed: 300,
  cssMode: false,
  updateOnWindowResize: true,
  resizeObserver: true,
  nested: false,
  createElements: false,
  enabled: true,
  focusableElements: 'input, select, option, textarea, button, video, label',
  // Overrides
  width: null,
  height: null,
  //
  preventInteractionOnTransition: false,
  // ssr
  userAgent: null,
  url: null,
  // To support iOS's swipe-to-go-back gesture (when being used in-app).
  edgeSwipeDetection: false,
  edgeSwipeThreshold: 20,
  // Autoheight
  autoHeight: false,
  // Set wrapper width
  setWrapperSize: false,
  // Virtual Translate
  virtualTranslate: false,
  // Effects
  effect: 'slide',
  // 'slide' or 'fade' or 'cube' or 'coverflow' or 'flip'
  // Breakpoints
  breakpoints: undefined,
  breakpointsBase: 'window',
  // Slides grid
  spaceBetween: 0,
  slidesPerView: 1,
  slidesPerGroup: 1,
  slidesPerGroupSkip: 0,
  slidesPerGroupAuto: false,
  centeredSlides: false,
  centeredSlidesBounds: false,
  slidesOffsetBefore: 0,
  // in px
  slidesOffsetAfter: 0,
  // in px
  normalizeSlideIndex: true,
  centerInsufficientSlides: false,
  // Disable swiper and hide navigation when container not overflow
  watchOverflow: true,
  // Round length
  roundLengths: false,
  // Touches
  touchRatio: 1,
  touchAngle: 45,
  simulateTouch: true,
  shortSwipes: true,
  longSwipes: true,
  longSwipesRatio: 0.5,
  longSwipesMs: 300,
  followFinger: true,
  allowTouchMove: true,
  threshold: 0,
  touchMoveStopPropagation: false,
  touchStartPreventDefault: true,
  touchStartForcePreventDefault: false,
  touchReleaseOnEdges: false,
  // Unique Navigation Elements
  uniqueNavElements: true,
  // Resistance
  resistance: true,
  resistanceRatio: 0.85,
  // Progress
  watchSlidesProgress: false,
  // Cursor
  grabCursor: false,
  // Clicks
  preventClicks: true,
  preventClicksPropagation: true,
  slideToClickedSlide: false,
  // Images
  preloadImages: true,
  updateOnImagesReady: true,
  // loop
  loop: false,
  loopAdditionalSlides: 0,
  loopedSlides: null,
  loopFillGroupWithBlank: false,
  loopPreventsSlide: true,
  // rewind
  rewind: false,
  // Swiping/no swiping
  allowSlidePrev: true,
  allowSlideNext: true,
  swipeHandler: null,
  // '.swipe-handler',
  noSwiping: true,
  noSwipingClass: 'swiper-no-swiping',
  noSwipingSelector: null,
  // Passive Listeners
  passiveListeners: true,
  maxBackfaceHiddenSlides: 10,
  // NS
  containerModifierClass: 'swiper-',
  // NEW
  slideClass: 'swiper-slide',
  slideBlankClass: 'swiper-slide-invisible-blank',
  slideActiveClass: 'swiper-slide-active',
  slideDuplicateActiveClass: 'swiper-slide-duplicate-active',
  slideVisibleClass: 'swiper-slide-visible',
  slideDuplicateClass: 'swiper-slide-duplicate',
  slideNextClass: 'swiper-slide-next',
  slideDuplicateNextClass: 'swiper-slide-duplicate-next',
  slidePrevClass: 'swiper-slide-prev',
  slideDuplicatePrevClass: 'swiper-slide-duplicate-prev',
  wrapperClass: 'swiper-wrapper',
  // Callbacks
  runCallbacksOnInit: true,
  // Internals
  _emitClasses: false
});

/***/ }),

/***/ "./node_modules/swiper/core/events-emitter.js":
/*!****************************************************!*\
  !*** ./node_modules/swiper/core/events-emitter.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* eslint-disable no-underscore-dangle */
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  on(events, handler, priority) {
    const self = this;
    if (typeof handler !== 'function') return self;
    const method = priority ? 'unshift' : 'push';
    events.split(' ').forEach(event => {
      if (!self.eventsListeners[event]) self.eventsListeners[event] = [];
      self.eventsListeners[event][method](handler);
    });
    return self;
  },

  once(events, handler, priority) {
    const self = this;
    if (typeof handler !== 'function') return self;

    function onceHandler() {
      self.off(events, onceHandler);

      if (onceHandler.__emitterProxy) {
        delete onceHandler.__emitterProxy;
      }

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      handler.apply(self, args);
    }

    onceHandler.__emitterProxy = handler;
    return self.on(events, onceHandler, priority);
  },

  onAny(handler, priority) {
    const self = this;
    if (typeof handler !== 'function') return self;
    const method = priority ? 'unshift' : 'push';

    if (self.eventsAnyListeners.indexOf(handler) < 0) {
      self.eventsAnyListeners[method](handler);
    }

    return self;
  },

  offAny(handler) {
    const self = this;
    if (!self.eventsAnyListeners) return self;
    const index = self.eventsAnyListeners.indexOf(handler);

    if (index >= 0) {
      self.eventsAnyListeners.splice(index, 1);
    }

    return self;
  },

  off(events, handler) {
    const self = this;
    if (!self.eventsListeners) return self;
    events.split(' ').forEach(event => {
      if (typeof handler === 'undefined') {
        self.eventsListeners[event] = [];
      } else if (self.eventsListeners[event]) {
        self.eventsListeners[event].forEach((eventHandler, index) => {
          if (eventHandler === handler || eventHandler.__emitterProxy && eventHandler.__emitterProxy === handler) {
            self.eventsListeners[event].splice(index, 1);
          }
        });
      }
    });
    return self;
  },

  emit() {
    const self = this;
    if (!self.eventsListeners) return self;
    let events;
    let data;
    let context;

    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    if (typeof args[0] === 'string' || Array.isArray(args[0])) {
      events = args[0];
      data = args.slice(1, args.length);
      context = self;
    } else {
      events = args[0].events;
      data = args[0].data;
      context = args[0].context || self;
    }

    data.unshift(context);
    const eventsArray = Array.isArray(events) ? events : events.split(' ');
    eventsArray.forEach(event => {
      if (self.eventsAnyListeners && self.eventsAnyListeners.length) {
        self.eventsAnyListeners.forEach(eventHandler => {
          eventHandler.apply(context, [event, ...data]);
        });
      }

      if (self.eventsListeners && self.eventsListeners[event]) {
        self.eventsListeners[event].forEach(eventHandler => {
          eventHandler.apply(context, data);
        });
      }
    });
    return self;
  }

});

/***/ }),

/***/ "./node_modules/swiper/core/events/index.js":
/*!**************************************************!*\
  !*** ./node_modules/swiper/core/events/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var ssr_window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ssr-window */ "./node_modules/ssr-window/ssr-window.esm.js");
/* harmony import */ var _onTouchStart_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./onTouchStart.js */ "./node_modules/swiper/core/events/onTouchStart.js");
/* harmony import */ var _onTouchMove_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./onTouchMove.js */ "./node_modules/swiper/core/events/onTouchMove.js");
/* harmony import */ var _onTouchEnd_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./onTouchEnd.js */ "./node_modules/swiper/core/events/onTouchEnd.js");
/* harmony import */ var _onResize_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./onResize.js */ "./node_modules/swiper/core/events/onResize.js");
/* harmony import */ var _onClick_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./onClick.js */ "./node_modules/swiper/core/events/onClick.js");
/* harmony import */ var _onScroll_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./onScroll.js */ "./node_modules/swiper/core/events/onScroll.js");







let dummyEventAttached = false;

function dummyEventListener() {}

const events = (swiper, method) => {
  const document = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getDocument)();
  const {
    params,
    touchEvents,
    el,
    wrapperEl,
    device,
    support
  } = swiper;
  const capture = !!params.nested;
  const domMethod = method === 'on' ? 'addEventListener' : 'removeEventListener';
  const swiperMethod = method; // Touch Events

  if (!support.touch) {
    el[domMethod](touchEvents.start, swiper.onTouchStart, false);
    document[domMethod](touchEvents.move, swiper.onTouchMove, capture);
    document[domMethod](touchEvents.end, swiper.onTouchEnd, false);
  } else {
    const passiveListener = touchEvents.start === 'touchstart' && support.passiveListener && params.passiveListeners ? {
      passive: true,
      capture: false
    } : false;
    el[domMethod](touchEvents.start, swiper.onTouchStart, passiveListener);
    el[domMethod](touchEvents.move, swiper.onTouchMove, support.passiveListener ? {
      passive: false,
      capture
    } : capture);
    el[domMethod](touchEvents.end, swiper.onTouchEnd, passiveListener);

    if (touchEvents.cancel) {
      el[domMethod](touchEvents.cancel, swiper.onTouchEnd, passiveListener);
    }
  } // Prevent Links Clicks


  if (params.preventClicks || params.preventClicksPropagation) {
    el[domMethod]('click', swiper.onClick, true);
  }

  if (params.cssMode) {
    wrapperEl[domMethod]('scroll', swiper.onScroll);
  } // Resize handler


  if (params.updateOnWindowResize) {
    swiper[swiperMethod](device.ios || device.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate', _onResize_js__WEBPACK_IMPORTED_MODULE_4__["default"], true);
  } else {
    swiper[swiperMethod]('observerUpdate', _onResize_js__WEBPACK_IMPORTED_MODULE_4__["default"], true);
  }
};

function attachEvents() {
  const swiper = this;
  const document = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getDocument)();
  const {
    params,
    support
  } = swiper;
  swiper.onTouchStart = _onTouchStart_js__WEBPACK_IMPORTED_MODULE_1__["default"].bind(swiper);
  swiper.onTouchMove = _onTouchMove_js__WEBPACK_IMPORTED_MODULE_2__["default"].bind(swiper);
  swiper.onTouchEnd = _onTouchEnd_js__WEBPACK_IMPORTED_MODULE_3__["default"].bind(swiper);

  if (params.cssMode) {
    swiper.onScroll = _onScroll_js__WEBPACK_IMPORTED_MODULE_6__["default"].bind(swiper);
  }

  swiper.onClick = _onClick_js__WEBPACK_IMPORTED_MODULE_5__["default"].bind(swiper);

  if (support.touch && !dummyEventAttached) {
    document.addEventListener('touchstart', dummyEventListener);
    dummyEventAttached = true;
  }

  events(swiper, 'on');
}

function detachEvents() {
  const swiper = this;
  events(swiper, 'off');
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  attachEvents,
  detachEvents
});

/***/ }),

/***/ "./node_modules/swiper/core/events/onClick.js":
/*!****************************************************!*\
  !*** ./node_modules/swiper/core/events/onClick.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ onClick)
/* harmony export */ });
function onClick(e) {
  const swiper = this;
  if (!swiper.enabled) return;

  if (!swiper.allowClick) {
    if (swiper.params.preventClicks) e.preventDefault();

    if (swiper.params.preventClicksPropagation && swiper.animating) {
      e.stopPropagation();
      e.stopImmediatePropagation();
    }
  }
}

/***/ }),

/***/ "./node_modules/swiper/core/events/onResize.js":
/*!*****************************************************!*\
  !*** ./node_modules/swiper/core/events/onResize.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ onResize)
/* harmony export */ });
function onResize() {
  const swiper = this;
  const {
    params,
    el
  } = swiper;
  if (el && el.offsetWidth === 0) return; // Breakpoints

  if (params.breakpoints) {
    swiper.setBreakpoint();
  } // Save locks


  const {
    allowSlideNext,
    allowSlidePrev,
    snapGrid
  } = swiper; // Disable locks on resize

  swiper.allowSlideNext = true;
  swiper.allowSlidePrev = true;
  swiper.updateSize();
  swiper.updateSlides();
  swiper.updateSlidesClasses();

  if ((params.slidesPerView === 'auto' || params.slidesPerView > 1) && swiper.isEnd && !swiper.isBeginning && !swiper.params.centeredSlides) {
    swiper.slideTo(swiper.slides.length - 1, 0, false, true);
  } else {
    swiper.slideTo(swiper.activeIndex, 0, false, true);
  }

  if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {
    swiper.autoplay.run();
  } // Return locks after resize


  swiper.allowSlidePrev = allowSlidePrev;
  swiper.allowSlideNext = allowSlideNext;

  if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) {
    swiper.checkOverflow();
  }
}

/***/ }),

/***/ "./node_modules/swiper/core/events/onScroll.js":
/*!*****************************************************!*\
  !*** ./node_modules/swiper/core/events/onScroll.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ onScroll)
/* harmony export */ });
function onScroll() {
  const swiper = this;
  const {
    wrapperEl,
    rtlTranslate,
    enabled
  } = swiper;
  if (!enabled) return;
  swiper.previousTranslate = swiper.translate;

  if (swiper.isHorizontal()) {
    swiper.translate = -wrapperEl.scrollLeft;
  } else {
    swiper.translate = -wrapperEl.scrollTop;
  } // eslint-disable-next-line


  if (swiper.translate === -0) swiper.translate = 0;
  swiper.updateActiveIndex();
  swiper.updateSlidesClasses();
  let newProgress;
  const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();

  if (translatesDiff === 0) {
    newProgress = 0;
  } else {
    newProgress = (swiper.translate - swiper.minTranslate()) / translatesDiff;
  }

  if (newProgress !== swiper.progress) {
    swiper.updateProgress(rtlTranslate ? -swiper.translate : swiper.translate);
  }

  swiper.emit('setTranslate', swiper.translate, false);
}

/***/ }),

/***/ "./node_modules/swiper/core/events/onTouchEnd.js":
/*!*******************************************************!*\
  !*** ./node_modules/swiper/core/events/onTouchEnd.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ onTouchEnd)
/* harmony export */ });
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/swiper/shared/utils.js");

function onTouchEnd(event) {
  const swiper = this;
  const data = swiper.touchEventsData;
  const {
    params,
    touches,
    rtlTranslate: rtl,
    slidesGrid,
    enabled
  } = swiper;
  if (!enabled) return;
  let e = event;
  if (e.originalEvent) e = e.originalEvent;

  if (data.allowTouchCallbacks) {
    swiper.emit('touchEnd', e);
  }

  data.allowTouchCallbacks = false;

  if (!data.isTouched) {
    if (data.isMoved && params.grabCursor) {
      swiper.setGrabCursor(false);
    }

    data.isMoved = false;
    data.startMoving = false;
    return;
  } // Return Grab Cursor


  if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
    swiper.setGrabCursor(false);
  } // Time diff


  const touchEndTime = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_0__.now)();
  const timeDiff = touchEndTime - data.touchStartTime; // Tap, doubleTap, Click

  if (swiper.allowClick) {
    const pathTree = e.path || e.composedPath && e.composedPath();
    swiper.updateClickedSlide(pathTree && pathTree[0] || e.target);
    swiper.emit('tap click', e);

    if (timeDiff < 300 && touchEndTime - data.lastClickTime < 300) {
      swiper.emit('doubleTap doubleClick', e);
    }
  }

  data.lastClickTime = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_0__.now)();
  (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_0__.nextTick)(() => {
    if (!swiper.destroyed) swiper.allowClick = true;
  });

  if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 || data.currentTranslate === data.startTranslate) {
    data.isTouched = false;
    data.isMoved = false;
    data.startMoving = false;
    return;
  }

  data.isTouched = false;
  data.isMoved = false;
  data.startMoving = false;
  let currentPos;

  if (params.followFinger) {
    currentPos = rtl ? swiper.translate : -swiper.translate;
  } else {
    currentPos = -data.currentTranslate;
  }

  if (params.cssMode) {
    return;
  }

  if (swiper.params.freeMode && params.freeMode.enabled) {
    swiper.freeMode.onTouchEnd({
      currentPos
    });
    return;
  } // Find current slide


  let stopIndex = 0;
  let groupSize = swiper.slidesSizesGrid[0];

  for (let i = 0; i < slidesGrid.length; i += i < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup) {
    const increment = i < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;

    if (typeof slidesGrid[i + increment] !== 'undefined') {
      if (currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + increment]) {
        stopIndex = i;
        groupSize = slidesGrid[i + increment] - slidesGrid[i];
      }
    } else if (currentPos >= slidesGrid[i]) {
      stopIndex = i;
      groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];
    }
  }

  let rewindFirstIndex = null;
  let rewindLastIndex = null;

  if (params.rewind) {
    if (swiper.isBeginning) {
      rewindLastIndex = swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;
    } else if (swiper.isEnd) {
      rewindFirstIndex = 0;
    }
  } // Find current slide size


  const ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;
  const increment = stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;

  if (timeDiff > params.longSwipesMs) {
    // Long touches
    if (!params.longSwipes) {
      swiper.slideTo(swiper.activeIndex);
      return;
    }

    if (swiper.swipeDirection === 'next') {
      if (ratio >= params.longSwipesRatio) swiper.slideTo(params.rewind && swiper.isEnd ? rewindFirstIndex : stopIndex + increment);else swiper.slideTo(stopIndex);
    }

    if (swiper.swipeDirection === 'prev') {
      if (ratio > 1 - params.longSwipesRatio) {
        swiper.slideTo(stopIndex + increment);
      } else if (rewindLastIndex !== null && ratio < 0 && Math.abs(ratio) > params.longSwipesRatio) {
        swiper.slideTo(rewindLastIndex);
      } else {
        swiper.slideTo(stopIndex);
      }
    }
  } else {
    // Short swipes
    if (!params.shortSwipes) {
      swiper.slideTo(swiper.activeIndex);
      return;
    }

    const isNavButtonTarget = swiper.navigation && (e.target === swiper.navigation.nextEl || e.target === swiper.navigation.prevEl);

    if (!isNavButtonTarget) {
      if (swiper.swipeDirection === 'next') {
        swiper.slideTo(rewindFirstIndex !== null ? rewindFirstIndex : stopIndex + increment);
      }

      if (swiper.swipeDirection === 'prev') {
        swiper.slideTo(rewindLastIndex !== null ? rewindLastIndex : stopIndex);
      }
    } else if (e.target === swiper.navigation.nextEl) {
      swiper.slideTo(stopIndex + increment);
    } else {
      swiper.slideTo(stopIndex);
    }
  }
}

/***/ }),

/***/ "./node_modules/swiper/core/events/onTouchMove.js":
/*!********************************************************!*\
  !*** ./node_modules/swiper/core/events/onTouchMove.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ onTouchMove)
/* harmony export */ });
/* harmony import */ var ssr_window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ssr-window */ "./node_modules/ssr-window/ssr-window.esm.js");
/* harmony import */ var _shared_dom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/dom.js */ "./node_modules/swiper/shared/dom.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/swiper/shared/utils.js");



function onTouchMove(event) {
  const document = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getDocument)();
  const swiper = this;
  const data = swiper.touchEventsData;
  const {
    params,
    touches,
    rtlTranslate: rtl,
    enabled
  } = swiper;
  if (!enabled) return;
  let e = event;
  if (e.originalEvent) e = e.originalEvent;

  if (!data.isTouched) {
    if (data.startMoving && data.isScrolling) {
      swiper.emit('touchMoveOpposite', e);
    }

    return;
  }

  if (data.isTouchEvent && e.type !== 'touchmove') return;
  const targetTouch = e.type === 'touchmove' && e.targetTouches && (e.targetTouches[0] || e.changedTouches[0]);
  const pageX = e.type === 'touchmove' ? targetTouch.pageX : e.pageX;
  const pageY = e.type === 'touchmove' ? targetTouch.pageY : e.pageY;

  if (e.preventedByNestedSwiper) {
    touches.startX = pageX;
    touches.startY = pageY;
    return;
  }

  if (!swiper.allowTouchMove) {
    if (!(0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_1__["default"])(e.target).is(data.focusableElements)) {
      swiper.allowClick = false;
    }

    if (data.isTouched) {
      Object.assign(touches, {
        startX: pageX,
        startY: pageY,
        currentX: pageX,
        currentY: pageY
      });
      data.touchStartTime = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.now)();
    }

    return;
  }

  if (data.isTouchEvent && params.touchReleaseOnEdges && !params.loop) {
    if (swiper.isVertical()) {
      // Vertical
      if (pageY < touches.startY && swiper.translate <= swiper.maxTranslate() || pageY > touches.startY && swiper.translate >= swiper.minTranslate()) {
        data.isTouched = false;
        data.isMoved = false;
        return;
      }
    } else if (pageX < touches.startX && swiper.translate <= swiper.maxTranslate() || pageX > touches.startX && swiper.translate >= swiper.minTranslate()) {
      return;
    }
  }

  if (data.isTouchEvent && document.activeElement) {
    if (e.target === document.activeElement && (0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_1__["default"])(e.target).is(data.focusableElements)) {
      data.isMoved = true;
      swiper.allowClick = false;
      return;
    }
  }

  if (data.allowTouchCallbacks) {
    swiper.emit('touchMove', e);
  }

  if (e.targetTouches && e.targetTouches.length > 1) return;
  touches.currentX = pageX;
  touches.currentY = pageY;
  const diffX = touches.currentX - touches.startX;
  const diffY = touches.currentY - touches.startY;
  if (swiper.params.threshold && Math.sqrt(diffX ** 2 + diffY ** 2) < swiper.params.threshold) return;

  if (typeof data.isScrolling === 'undefined') {
    let touchAngle;

    if (swiper.isHorizontal() && touches.currentY === touches.startY || swiper.isVertical() && touches.currentX === touches.startX) {
      data.isScrolling = false;
    } else {
      // eslint-disable-next-line
      if (diffX * diffX + diffY * diffY >= 25) {
        touchAngle = Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180 / Math.PI;
        data.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : 90 - touchAngle > params.touchAngle;
      }
    }
  }

  if (data.isScrolling) {
    swiper.emit('touchMoveOpposite', e);
  }

  if (typeof data.startMoving === 'undefined') {
    if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) {
      data.startMoving = true;
    }
  }

  if (data.isScrolling) {
    data.isTouched = false;
    return;
  }

  if (!data.startMoving) {
    return;
  }

  swiper.allowClick = false;

  if (!params.cssMode && e.cancelable) {
    e.preventDefault();
  }

  if (params.touchMoveStopPropagation && !params.nested) {
    e.stopPropagation();
  }

  if (!data.isMoved) {
    if (params.loop && !params.cssMode) {
      swiper.loopFix();
    }

    data.startTranslate = swiper.getTranslate();
    swiper.setTransition(0);

    if (swiper.animating) {
      swiper.$wrapperEl.trigger('webkitTransitionEnd transitionend');
    }

    data.allowMomentumBounce = false; // Grab Cursor

    if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
      swiper.setGrabCursor(true);
    }

    swiper.emit('sliderFirstMove', e);
  }

  swiper.emit('sliderMove', e);
  data.isMoved = true;
  let diff = swiper.isHorizontal() ? diffX : diffY;
  touches.diff = diff;
  diff *= params.touchRatio;
  if (rtl) diff = -diff;
  swiper.swipeDirection = diff > 0 ? 'prev' : 'next';
  data.currentTranslate = diff + data.startTranslate;
  let disableParentSwiper = true;
  let resistanceRatio = params.resistanceRatio;

  if (params.touchReleaseOnEdges) {
    resistanceRatio = 0;
  }

  if (diff > 0 && data.currentTranslate > swiper.minTranslate()) {
    disableParentSwiper = false;
    if (params.resistance) data.currentTranslate = swiper.minTranslate() - 1 + (-swiper.minTranslate() + data.startTranslate + diff) ** resistanceRatio;
  } else if (diff < 0 && data.currentTranslate < swiper.maxTranslate()) {
    disableParentSwiper = false;
    if (params.resistance) data.currentTranslate = swiper.maxTranslate() + 1 - (swiper.maxTranslate() - data.startTranslate - diff) ** resistanceRatio;
  }

  if (disableParentSwiper) {
    e.preventedByNestedSwiper = true;
  } // Directions locks


  if (!swiper.allowSlideNext && swiper.swipeDirection === 'next' && data.currentTranslate < data.startTranslate) {
    data.currentTranslate = data.startTranslate;
  }

  if (!swiper.allowSlidePrev && swiper.swipeDirection === 'prev' && data.currentTranslate > data.startTranslate) {
    data.currentTranslate = data.startTranslate;
  }

  if (!swiper.allowSlidePrev && !swiper.allowSlideNext) {
    data.currentTranslate = data.startTranslate;
  } // Threshold


  if (params.threshold > 0) {
    if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {
      if (!data.allowThresholdMove) {
        data.allowThresholdMove = true;
        touches.startX = touches.currentX;
        touches.startY = touches.currentY;
        data.currentTranslate = data.startTranslate;
        touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;
        return;
      }
    } else {
      data.currentTranslate = data.startTranslate;
      return;
    }
  }

  if (!params.followFinger || params.cssMode) return; // Update active index in free mode

  if (params.freeMode && params.freeMode.enabled && swiper.freeMode || params.watchSlidesProgress) {
    swiper.updateActiveIndex();
    swiper.updateSlidesClasses();
  }

  if (swiper.params.freeMode && params.freeMode.enabled && swiper.freeMode) {
    swiper.freeMode.onTouchMove();
  } // Update progress


  swiper.updateProgress(data.currentTranslate); // Update translate

  swiper.setTranslate(data.currentTranslate);
}

/***/ }),

/***/ "./node_modules/swiper/core/events/onTouchStart.js":
/*!*********************************************************!*\
  !*** ./node_modules/swiper/core/events/onTouchStart.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ onTouchStart)
/* harmony export */ });
/* harmony import */ var ssr_window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ssr-window */ "./node_modules/ssr-window/ssr-window.esm.js");
/* harmony import */ var _shared_dom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/dom.js */ "./node_modules/swiper/shared/dom.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/swiper/shared/utils.js");


 // Modified from https://stackoverflow.com/questions/54520554/custom-element-getrootnode-closest-function-crossing-multiple-parent-shadowd

function closestElement(selector, base) {
  if (base === void 0) {
    base = this;
  }

  function __closestFrom(el) {
    if (!el || el === (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getDocument)() || el === (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)()) return null;
    if (el.assignedSlot) el = el.assignedSlot;
    const found = el.closest(selector);
    return found || __closestFrom(el.getRootNode().host);
  }

  return __closestFrom(base);
}

function onTouchStart(event) {
  const swiper = this;
  const document = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getDocument)();
  const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();
  const data = swiper.touchEventsData;
  const {
    params,
    touches,
    enabled
  } = swiper;
  if (!enabled) return;

  if (swiper.animating && params.preventInteractionOnTransition) {
    return;
  }

  if (!swiper.animating && params.cssMode && params.loop) {
    swiper.loopFix();
  }

  let e = event;
  if (e.originalEvent) e = e.originalEvent;
  let $targetEl = (0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_1__["default"])(e.target);

  if (params.touchEventsTarget === 'wrapper') {
    if (!$targetEl.closest(swiper.wrapperEl).length) return;
  }

  data.isTouchEvent = e.type === 'touchstart';
  if (!data.isTouchEvent && 'which' in e && e.which === 3) return;
  if (!data.isTouchEvent && 'button' in e && e.button > 0) return;
  if (data.isTouched && data.isMoved) return; // change target el for shadow root component

  const swipingClassHasValue = !!params.noSwipingClass && params.noSwipingClass !== '';

  if (swipingClassHasValue && e.target && e.target.shadowRoot && event.path && event.path[0]) {
    $targetEl = (0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_1__["default"])(event.path[0]);
  }

  const noSwipingSelector = params.noSwipingSelector ? params.noSwipingSelector : `.${params.noSwipingClass}`;
  const isTargetShadow = !!(e.target && e.target.shadowRoot); // use closestElement for shadow root element to get the actual closest for nested shadow root element

  if (params.noSwiping && (isTargetShadow ? closestElement(noSwipingSelector, e.target) : $targetEl.closest(noSwipingSelector)[0])) {
    swiper.allowClick = true;
    return;
  }

  if (params.swipeHandler) {
    if (!$targetEl.closest(params.swipeHandler)[0]) return;
  }

  touches.currentX = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
  touches.currentY = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
  const startX = touches.currentX;
  const startY = touches.currentY; // Do NOT start if iOS edge swipe is detected. Otherwise iOS app cannot swipe-to-go-back anymore

  const edgeSwipeDetection = params.edgeSwipeDetection || params.iOSEdgeSwipeDetection;
  const edgeSwipeThreshold = params.edgeSwipeThreshold || params.iOSEdgeSwipeThreshold;

  if (edgeSwipeDetection && (startX <= edgeSwipeThreshold || startX >= window.innerWidth - edgeSwipeThreshold)) {
    if (edgeSwipeDetection === 'prevent') {
      event.preventDefault();
    } else {
      return;
    }
  }

  Object.assign(data, {
    isTouched: true,
    isMoved: false,
    allowTouchCallbacks: true,
    isScrolling: undefined,
    startMoving: undefined
  });
  touches.startX = startX;
  touches.startY = startY;
  data.touchStartTime = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.now)();
  swiper.allowClick = true;
  swiper.updateSize();
  swiper.swipeDirection = undefined;
  if (params.threshold > 0) data.allowThresholdMove = false;

  if (e.type !== 'touchstart') {
    let preventDefault = true;

    if ($targetEl.is(data.focusableElements)) {
      preventDefault = false;

      if ($targetEl[0].nodeName === 'SELECT') {
        data.isTouched = false;
      }
    }

    if (document.activeElement && (0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_1__["default"])(document.activeElement).is(data.focusableElements) && document.activeElement !== $targetEl[0]) {
      document.activeElement.blur();
    }

    const shouldPreventDefault = preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;

    if ((params.touchStartForcePreventDefault || shouldPreventDefault) && !$targetEl[0].isContentEditable) {
      e.preventDefault();
    }
  }

  if (swiper.params.freeMode && swiper.params.freeMode.enabled && swiper.freeMode && swiper.animating && !params.cssMode) {
    swiper.freeMode.onTouchStart();
  }

  swiper.emit('touchStart', e);
}

/***/ }),

/***/ "./node_modules/swiper/core/grab-cursor/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/swiper/core/grab-cursor/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _setGrabCursor_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./setGrabCursor.js */ "./node_modules/swiper/core/grab-cursor/setGrabCursor.js");
/* harmony import */ var _unsetGrabCursor_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./unsetGrabCursor.js */ "./node_modules/swiper/core/grab-cursor/unsetGrabCursor.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  setGrabCursor: _setGrabCursor_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  unsetGrabCursor: _unsetGrabCursor_js__WEBPACK_IMPORTED_MODULE_1__["default"]
});

/***/ }),

/***/ "./node_modules/swiper/core/grab-cursor/setGrabCursor.js":
/*!***************************************************************!*\
  !*** ./node_modules/swiper/core/grab-cursor/setGrabCursor.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ setGrabCursor)
/* harmony export */ });
function setGrabCursor(moving) {
  const swiper = this;
  if (swiper.support.touch || !swiper.params.simulateTouch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) return;
  const el = swiper.params.touchEventsTarget === 'container' ? swiper.el : swiper.wrapperEl;
  el.style.cursor = 'move';
  el.style.cursor = moving ? '-webkit-grabbing' : '-webkit-grab';
  el.style.cursor = moving ? '-moz-grabbin' : '-moz-grab';
  el.style.cursor = moving ? 'grabbing' : 'grab';
}

/***/ }),

/***/ "./node_modules/swiper/core/grab-cursor/unsetGrabCursor.js":
/*!*****************************************************************!*\
  !*** ./node_modules/swiper/core/grab-cursor/unsetGrabCursor.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ unsetGrabCursor)
/* harmony export */ });
function unsetGrabCursor() {
  const swiper = this;

  if (swiper.support.touch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) {
    return;
  }

  swiper[swiper.params.touchEventsTarget === 'container' ? 'el' : 'wrapperEl'].style.cursor = '';
}

/***/ }),

/***/ "./node_modules/swiper/core/images/index.js":
/*!**************************************************!*\
  !*** ./node_modules/swiper/core/images/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _loadImage_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./loadImage.js */ "./node_modules/swiper/core/images/loadImage.js");
/* harmony import */ var _preloadImages_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./preloadImages.js */ "./node_modules/swiper/core/images/preloadImages.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  loadImage: _loadImage_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  preloadImages: _preloadImages_js__WEBPACK_IMPORTED_MODULE_1__["default"]
});

/***/ }),

/***/ "./node_modules/swiper/core/images/loadImage.js":
/*!******************************************************!*\
  !*** ./node_modules/swiper/core/images/loadImage.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ loadImage)
/* harmony export */ });
/* harmony import */ var ssr_window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ssr-window */ "./node_modules/ssr-window/ssr-window.esm.js");
/* harmony import */ var _shared_dom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/dom.js */ "./node_modules/swiper/shared/dom.js");


function loadImage(imageEl, src, srcset, sizes, checkForComplete, callback) {
  const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();
  let image;

  function onReady() {
    if (callback) callback();
  }

  const isPicture = (0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_1__["default"])(imageEl).parent('picture')[0];

  if (!isPicture && (!imageEl.complete || !checkForComplete)) {
    if (src) {
      image = new window.Image();
      image.onload = onReady;
      image.onerror = onReady;

      if (sizes) {
        image.sizes = sizes;
      }

      if (srcset) {
        image.srcset = srcset;
      }

      if (src) {
        image.src = src;
      }
    } else {
      onReady();
    }
  } else {
    // image already loaded...
    onReady();
  }
}

/***/ }),

/***/ "./node_modules/swiper/core/images/preloadImages.js":
/*!**********************************************************!*\
  !*** ./node_modules/swiper/core/images/preloadImages.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ preloadImages)
/* harmony export */ });
function preloadImages() {
  const swiper = this;
  swiper.imagesToLoad = swiper.$el.find('img');

  function onReady() {
    if (typeof swiper === 'undefined' || swiper === null || !swiper || swiper.destroyed) return;
    if (swiper.imagesLoaded !== undefined) swiper.imagesLoaded += 1;

    if (swiper.imagesLoaded === swiper.imagesToLoad.length) {
      if (swiper.params.updateOnImagesReady) swiper.update();
      swiper.emit('imagesReady');
    }
  }

  for (let i = 0; i < swiper.imagesToLoad.length; i += 1) {
    const imageEl = swiper.imagesToLoad[i];
    swiper.loadImage(imageEl, imageEl.currentSrc || imageEl.getAttribute('src'), imageEl.srcset || imageEl.getAttribute('srcset'), imageEl.sizes || imageEl.getAttribute('sizes'), true, onReady);
  }
}

/***/ }),

/***/ "./node_modules/swiper/core/loop/index.js":
/*!************************************************!*\
  !*** ./node_modules/swiper/core/loop/index.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _loopCreate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./loopCreate.js */ "./node_modules/swiper/core/loop/loopCreate.js");
/* harmony import */ var _loopFix_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./loopFix.js */ "./node_modules/swiper/core/loop/loopFix.js");
/* harmony import */ var _loopDestroy_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./loopDestroy.js */ "./node_modules/swiper/core/loop/loopDestroy.js");



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  loopCreate: _loopCreate_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  loopFix: _loopFix_js__WEBPACK_IMPORTED_MODULE_1__["default"],
  loopDestroy: _loopDestroy_js__WEBPACK_IMPORTED_MODULE_2__["default"]
});

/***/ }),

/***/ "./node_modules/swiper/core/loop/loopCreate.js":
/*!*****************************************************!*\
  !*** ./node_modules/swiper/core/loop/loopCreate.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ loopCreate)
/* harmony export */ });
/* harmony import */ var ssr_window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ssr-window */ "./node_modules/ssr-window/ssr-window.esm.js");
/* harmony import */ var _shared_dom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/dom.js */ "./node_modules/swiper/shared/dom.js");


function loopCreate() {
  const swiper = this;
  const document = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getDocument)();
  const {
    params,
    $wrapperEl
  } = swiper; // Remove duplicated slides

  const $selector = $wrapperEl.children().length > 0 ? (0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_1__["default"])($wrapperEl.children()[0].parentNode) : $wrapperEl;
  $selector.children(`.${params.slideClass}.${params.slideDuplicateClass}`).remove();
  let slides = $selector.children(`.${params.slideClass}`);

  if (params.loopFillGroupWithBlank) {
    const blankSlidesNum = params.slidesPerGroup - slides.length % params.slidesPerGroup;

    if (blankSlidesNum !== params.slidesPerGroup) {
      for (let i = 0; i < blankSlidesNum; i += 1) {
        const blankNode = (0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_1__["default"])(document.createElement('div')).addClass(`${params.slideClass} ${params.slideBlankClass}`);
        $selector.append(blankNode);
      }

      slides = $selector.children(`.${params.slideClass}`);
    }
  }

  if (params.slidesPerView === 'auto' && !params.loopedSlides) params.loopedSlides = slides.length;
  swiper.loopedSlides = Math.ceil(parseFloat(params.loopedSlides || params.slidesPerView, 10));
  swiper.loopedSlides += params.loopAdditionalSlides;

  if (swiper.loopedSlides > slides.length) {
    swiper.loopedSlides = slides.length;
  }

  const prependSlides = [];
  const appendSlides = [];
  slides.each((el, index) => {
    const slide = (0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_1__["default"])(el);

    if (index < swiper.loopedSlides) {
      appendSlides.push(el);
    }

    if (index < slides.length && index >= slides.length - swiper.loopedSlides) {
      prependSlides.push(el);
    }

    slide.attr('data-swiper-slide-index', index);
  });

  for (let i = 0; i < appendSlides.length; i += 1) {
    $selector.append((0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_1__["default"])(appendSlides[i].cloneNode(true)).addClass(params.slideDuplicateClass));
  }

  for (let i = prependSlides.length - 1; i >= 0; i -= 1) {
    $selector.prepend((0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_1__["default"])(prependSlides[i].cloneNode(true)).addClass(params.slideDuplicateClass));
  }
}

/***/ }),

/***/ "./node_modules/swiper/core/loop/loopDestroy.js":
/*!******************************************************!*\
  !*** ./node_modules/swiper/core/loop/loopDestroy.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ loopDestroy)
/* harmony export */ });
function loopDestroy() {
  const swiper = this;
  const {
    $wrapperEl,
    params,
    slides
  } = swiper;
  $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass},.${params.slideClass}.${params.slideBlankClass}`).remove();
  slides.removeAttr('data-swiper-slide-index');
}

/***/ }),

/***/ "./node_modules/swiper/core/loop/loopFix.js":
/*!**************************************************!*\
  !*** ./node_modules/swiper/core/loop/loopFix.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ loopFix)
/* harmony export */ });
function loopFix() {
  const swiper = this;
  swiper.emit('beforeLoopFix');
  const {
    activeIndex,
    slides,
    loopedSlides,
    allowSlidePrev,
    allowSlideNext,
    snapGrid,
    rtlTranslate: rtl
  } = swiper;
  let newIndex;
  swiper.allowSlidePrev = true;
  swiper.allowSlideNext = true;
  const snapTranslate = -snapGrid[activeIndex];
  const diff = snapTranslate - swiper.getTranslate(); // Fix For Negative Oversliding

  if (activeIndex < loopedSlides) {
    newIndex = slides.length - loopedSlides * 3 + activeIndex;
    newIndex += loopedSlides;
    const slideChanged = swiper.slideTo(newIndex, 0, false, true);

    if (slideChanged && diff !== 0) {
      swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
    }
  } else if (activeIndex >= slides.length - loopedSlides) {
    // Fix For Positive Oversliding
    newIndex = -slides.length + activeIndex + loopedSlides;
    newIndex += loopedSlides;
    const slideChanged = swiper.slideTo(newIndex, 0, false, true);

    if (slideChanged && diff !== 0) {
      swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
    }
  }

  swiper.allowSlidePrev = allowSlidePrev;
  swiper.allowSlideNext = allowSlideNext;
  swiper.emit('loopFix');
}

/***/ }),

/***/ "./node_modules/swiper/core/moduleExtendParams.js":
/*!********************************************************!*\
  !*** ./node_modules/swiper/core/moduleExtendParams.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ moduleExtendParams)
/* harmony export */ });
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shared/utils.js */ "./node_modules/swiper/shared/utils.js");

function moduleExtendParams(params, allModulesParams) {
  return function extendParams(obj) {
    if (obj === void 0) {
      obj = {};
    }

    const moduleParamName = Object.keys(obj)[0];
    const moduleParams = obj[moduleParamName];

    if (typeof moduleParams !== 'object' || moduleParams === null) {
      (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_0__.extend)(allModulesParams, obj);
      return;
    }

    if (['navigation', 'pagination', 'scrollbar'].indexOf(moduleParamName) >= 0 && params[moduleParamName] === true) {
      params[moduleParamName] = {
        auto: true
      };
    }

    if (!(moduleParamName in params && 'enabled' in moduleParams)) {
      (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_0__.extend)(allModulesParams, obj);
      return;
    }

    if (params[moduleParamName] === true) {
      params[moduleParamName] = {
        enabled: true
      };
    }

    if (typeof params[moduleParamName] === 'object' && !('enabled' in params[moduleParamName])) {
      params[moduleParamName].enabled = true;
    }

    if (!params[moduleParamName]) params[moduleParamName] = {
      enabled: false
    };
    (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_0__.extend)(allModulesParams, obj);
  };
}

/***/ }),

/***/ "./node_modules/swiper/core/modules/observer/observer.js":
/*!***************************************************************!*\
  !*** ./node_modules/swiper/core/modules/observer/observer.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Observer)
/* harmony export */ });
/* harmony import */ var ssr_window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ssr-window */ "./node_modules/ssr-window/ssr-window.esm.js");

function Observer(_ref) {
  let {
    swiper,
    extendParams,
    on,
    emit
  } = _ref;
  const observers = [];
  const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();

  const attach = function (target, options) {
    if (options === void 0) {
      options = {};
    }

    const ObserverFunc = window.MutationObserver || window.WebkitMutationObserver;
    const observer = new ObserverFunc(mutations => {
      // The observerUpdate event should only be triggered
      // once despite the number of mutations.  Additional
      // triggers are redundant and are very costly
      if (mutations.length === 1) {
        emit('observerUpdate', mutations[0]);
        return;
      }

      const observerUpdate = function observerUpdate() {
        emit('observerUpdate', mutations[0]);
      };

      if (window.requestAnimationFrame) {
        window.requestAnimationFrame(observerUpdate);
      } else {
        window.setTimeout(observerUpdate, 0);
      }
    });
    observer.observe(target, {
      attributes: typeof options.attributes === 'undefined' ? true : options.attributes,
      childList: typeof options.childList === 'undefined' ? true : options.childList,
      characterData: typeof options.characterData === 'undefined' ? true : options.characterData
    });
    observers.push(observer);
  };

  const init = () => {
    if (!swiper.params.observer) return;

    if (swiper.params.observeParents) {
      const containerParents = swiper.$el.parents();

      for (let i = 0; i < containerParents.length; i += 1) {
        attach(containerParents[i]);
      }
    } // Observe container


    attach(swiper.$el[0], {
      childList: swiper.params.observeSlideChildren
    }); // Observe wrapper

    attach(swiper.$wrapperEl[0], {
      attributes: false
    });
  };

  const destroy = () => {
    observers.forEach(observer => {
      observer.disconnect();
    });
    observers.splice(0, observers.length);
  };

  extendParams({
    observer: false,
    observeParents: false,
    observeSlideChildren: false
  });
  on('init', init);
  on('destroy', destroy);
}

/***/ }),

/***/ "./node_modules/swiper/core/modules/resize/resize.js":
/*!***********************************************************!*\
  !*** ./node_modules/swiper/core/modules/resize/resize.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Resize)
/* harmony export */ });
/* harmony import */ var ssr_window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ssr-window */ "./node_modules/ssr-window/ssr-window.esm.js");

function Resize(_ref) {
  let {
    swiper,
    on,
    emit
  } = _ref;
  const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();
  let observer = null;
  let animationFrame = null;

  const resizeHandler = () => {
    if (!swiper || swiper.destroyed || !swiper.initialized) return;
    emit('beforeResize');
    emit('resize');
  };

  const createObserver = () => {
    if (!swiper || swiper.destroyed || !swiper.initialized) return;
    observer = new ResizeObserver(entries => {
      animationFrame = window.requestAnimationFrame(() => {
        const {
          width,
          height
        } = swiper;
        let newWidth = width;
        let newHeight = height;
        entries.forEach(_ref2 => {
          let {
            contentBoxSize,
            contentRect,
            target
          } = _ref2;
          if (target && target !== swiper.el) return;
          newWidth = contentRect ? contentRect.width : (contentBoxSize[0] || contentBoxSize).inlineSize;
          newHeight = contentRect ? contentRect.height : (contentBoxSize[0] || contentBoxSize).blockSize;
        });

        if (newWidth !== width || newHeight !== height) {
          resizeHandler();
        }
      });
    });
    observer.observe(swiper.el);
  };

  const removeObserver = () => {
    if (animationFrame) {
      window.cancelAnimationFrame(animationFrame);
    }

    if (observer && observer.unobserve && swiper.el) {
      observer.unobserve(swiper.el);
      observer = null;
    }
  };

  const orientationChangeHandler = () => {
    if (!swiper || swiper.destroyed || !swiper.initialized) return;
    emit('orientationchange');
  };

  on('init', () => {
    if (swiper.params.resizeObserver && typeof window.ResizeObserver !== 'undefined') {
      createObserver();
      return;
    }

    window.addEventListener('resize', resizeHandler);
    window.addEventListener('orientationchange', orientationChangeHandler);
  });
  on('destroy', () => {
    removeObserver();
    window.removeEventListener('resize', resizeHandler);
    window.removeEventListener('orientationchange', orientationChangeHandler);
  });
}

/***/ }),

/***/ "./node_modules/swiper/core/slide/index.js":
/*!*************************************************!*\
  !*** ./node_modules/swiper/core/slide/index.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _slideTo_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./slideTo.js */ "./node_modules/swiper/core/slide/slideTo.js");
/* harmony import */ var _slideToLoop_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./slideToLoop.js */ "./node_modules/swiper/core/slide/slideToLoop.js");
/* harmony import */ var _slideNext_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./slideNext.js */ "./node_modules/swiper/core/slide/slideNext.js");
/* harmony import */ var _slidePrev_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./slidePrev.js */ "./node_modules/swiper/core/slide/slidePrev.js");
/* harmony import */ var _slideReset_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./slideReset.js */ "./node_modules/swiper/core/slide/slideReset.js");
/* harmony import */ var _slideToClosest_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./slideToClosest.js */ "./node_modules/swiper/core/slide/slideToClosest.js");
/* harmony import */ var _slideToClickedSlide_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./slideToClickedSlide.js */ "./node_modules/swiper/core/slide/slideToClickedSlide.js");







/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  slideTo: _slideTo_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  slideToLoop: _slideToLoop_js__WEBPACK_IMPORTED_MODULE_1__["default"],
  slideNext: _slideNext_js__WEBPACK_IMPORTED_MODULE_2__["default"],
  slidePrev: _slidePrev_js__WEBPACK_IMPORTED_MODULE_3__["default"],
  slideReset: _slideReset_js__WEBPACK_IMPORTED_MODULE_4__["default"],
  slideToClosest: _slideToClosest_js__WEBPACK_IMPORTED_MODULE_5__["default"],
  slideToClickedSlide: _slideToClickedSlide_js__WEBPACK_IMPORTED_MODULE_6__["default"]
});

/***/ }),

/***/ "./node_modules/swiper/core/slide/slideNext.js":
/*!*****************************************************!*\
  !*** ./node_modules/swiper/core/slide/slideNext.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ slideNext)
/* harmony export */ });
/* eslint no-unused-vars: "off" */
function slideNext(speed, runCallbacks, internal) {
  if (speed === void 0) {
    speed = this.params.speed;
  }

  if (runCallbacks === void 0) {
    runCallbacks = true;
  }

  const swiper = this;
  const {
    animating,
    enabled,
    params
  } = swiper;
  if (!enabled) return swiper;
  let perGroup = params.slidesPerGroup;

  if (params.slidesPerView === 'auto' && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {
    perGroup = Math.max(swiper.slidesPerViewDynamic('current', true), 1);
  }

  const increment = swiper.activeIndex < params.slidesPerGroupSkip ? 1 : perGroup;

  if (params.loop) {
    if (animating && params.loopPreventsSlide) return false;
    swiper.loopFix(); // eslint-disable-next-line

    swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
  }

  if (params.rewind && swiper.isEnd) {
    return swiper.slideTo(0, speed, runCallbacks, internal);
  }

  return swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);
}

/***/ }),

/***/ "./node_modules/swiper/core/slide/slidePrev.js":
/*!*****************************************************!*\
  !*** ./node_modules/swiper/core/slide/slidePrev.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ slidePrev)
/* harmony export */ });
/* eslint no-unused-vars: "off" */
function slidePrev(speed, runCallbacks, internal) {
  if (speed === void 0) {
    speed = this.params.speed;
  }

  if (runCallbacks === void 0) {
    runCallbacks = true;
  }

  const swiper = this;
  const {
    params,
    animating,
    snapGrid,
    slidesGrid,
    rtlTranslate,
    enabled
  } = swiper;
  if (!enabled) return swiper;

  if (params.loop) {
    if (animating && params.loopPreventsSlide) return false;
    swiper.loopFix(); // eslint-disable-next-line

    swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
  }

  const translate = rtlTranslate ? swiper.translate : -swiper.translate;

  function normalize(val) {
    if (val < 0) return -Math.floor(Math.abs(val));
    return Math.floor(val);
  }

  const normalizedTranslate = normalize(translate);
  const normalizedSnapGrid = snapGrid.map(val => normalize(val));
  let prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];

  if (typeof prevSnap === 'undefined' && params.cssMode) {
    let prevSnapIndex;
    snapGrid.forEach((snap, snapIndex) => {
      if (normalizedTranslate >= snap) {
        // prevSnap = snap;
        prevSnapIndex = snapIndex;
      }
    });

    if (typeof prevSnapIndex !== 'undefined') {
      prevSnap = snapGrid[prevSnapIndex > 0 ? prevSnapIndex - 1 : prevSnapIndex];
    }
  }

  let prevIndex = 0;

  if (typeof prevSnap !== 'undefined') {
    prevIndex = slidesGrid.indexOf(prevSnap);
    if (prevIndex < 0) prevIndex = swiper.activeIndex - 1;

    if (params.slidesPerView === 'auto' && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {
      prevIndex = prevIndex - swiper.slidesPerViewDynamic('previous', true) + 1;
      prevIndex = Math.max(prevIndex, 0);
    }
  }

  if (params.rewind && swiper.isBeginning) {
    const lastIndex = swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;
    return swiper.slideTo(lastIndex, speed, runCallbacks, internal);
  }

  return swiper.slideTo(prevIndex, speed, runCallbacks, internal);
}

/***/ }),

/***/ "./node_modules/swiper/core/slide/slideReset.js":
/*!******************************************************!*\
  !*** ./node_modules/swiper/core/slide/slideReset.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ slideReset)
/* harmony export */ });
/* eslint no-unused-vars: "off" */
function slideReset(speed, runCallbacks, internal) {
  if (speed === void 0) {
    speed = this.params.speed;
  }

  if (runCallbacks === void 0) {
    runCallbacks = true;
  }

  const swiper = this;
  return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);
}

/***/ }),

/***/ "./node_modules/swiper/core/slide/slideTo.js":
/*!***************************************************!*\
  !*** ./node_modules/swiper/core/slide/slideTo.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ slideTo)
/* harmony export */ });
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/swiper/shared/utils.js");

function slideTo(index, speed, runCallbacks, internal, initial) {
  if (index === void 0) {
    index = 0;
  }

  if (speed === void 0) {
    speed = this.params.speed;
  }

  if (runCallbacks === void 0) {
    runCallbacks = true;
  }

  if (typeof index !== 'number' && typeof index !== 'string') {
    throw new Error(`The 'index' argument cannot have type other than 'number' or 'string'. [${typeof index}] given.`);
  }

  if (typeof index === 'string') {
    /**
     * The `index` argument converted from `string` to `number`.
     * @type {number}
     */
    const indexAsNumber = parseInt(index, 10);
    /**
     * Determines whether the `index` argument is a valid `number`
     * after being converted from the `string` type.
     * @type {boolean}
     */

    const isValidNumber = isFinite(indexAsNumber);

    if (!isValidNumber) {
      throw new Error(`The passed-in 'index' (string) couldn't be converted to 'number'. [${index}] given.`);
    } // Knowing that the converted `index` is a valid number,
    // we can update the original argument's value.


    index = indexAsNumber;
  }

  const swiper = this;
  let slideIndex = index;
  if (slideIndex < 0) slideIndex = 0;
  const {
    params,
    snapGrid,
    slidesGrid,
    previousIndex,
    activeIndex,
    rtlTranslate: rtl,
    wrapperEl,
    enabled
  } = swiper;

  if (swiper.animating && params.preventInteractionOnTransition || !enabled && !internal && !initial) {
    return false;
  }

  const skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);
  let snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);
  if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;

  if ((activeIndex || params.initialSlide || 0) === (previousIndex || 0) && runCallbacks) {
    swiper.emit('beforeSlideChangeStart');
  }

  const translate = -snapGrid[snapIndex]; // Update progress

  swiper.updateProgress(translate); // Normalize slideIndex

  if (params.normalizeSlideIndex) {
    for (let i = 0; i < slidesGrid.length; i += 1) {
      const normalizedTranslate = -Math.floor(translate * 100);
      const normalizedGrid = Math.floor(slidesGrid[i] * 100);
      const normalizedGridNext = Math.floor(slidesGrid[i + 1] * 100);

      if (typeof slidesGrid[i + 1] !== 'undefined') {
        if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext - (normalizedGridNext - normalizedGrid) / 2) {
          slideIndex = i;
        } else if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext) {
          slideIndex = i + 1;
        }
      } else if (normalizedTranslate >= normalizedGrid) {
        slideIndex = i;
      }
    }
  } // Directions locks


  if (swiper.initialized && slideIndex !== activeIndex) {
    if (!swiper.allowSlideNext && translate < swiper.translate && translate < swiper.minTranslate()) {
      return false;
    }

    if (!swiper.allowSlidePrev && translate > swiper.translate && translate > swiper.maxTranslate()) {
      if ((activeIndex || 0) !== slideIndex) return false;
    }
  }

  let direction;
  if (slideIndex > activeIndex) direction = 'next';else if (slideIndex < activeIndex) direction = 'prev';else direction = 'reset'; // Update Index

  if (rtl && -translate === swiper.translate || !rtl && translate === swiper.translate) {
    swiper.updateActiveIndex(slideIndex); // Update Height

    if (params.autoHeight) {
      swiper.updateAutoHeight();
    }

    swiper.updateSlidesClasses();

    if (params.effect !== 'slide') {
      swiper.setTranslate(translate);
    }

    if (direction !== 'reset') {
      swiper.transitionStart(runCallbacks, direction);
      swiper.transitionEnd(runCallbacks, direction);
    }

    return false;
  }

  if (params.cssMode) {
    const isH = swiper.isHorizontal();
    const t = rtl ? translate : -translate;

    if (speed === 0) {
      const isVirtual = swiper.virtual && swiper.params.virtual.enabled;

      if (isVirtual) {
        swiper.wrapperEl.style.scrollSnapType = 'none';
        swiper._immediateVirtual = true;
      }

      wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;

      if (isVirtual) {
        requestAnimationFrame(() => {
          swiper.wrapperEl.style.scrollSnapType = '';
          swiper._swiperImmediateVirtual = false;
        });
      }
    } else {
      if (!swiper.support.smoothScroll) {
        (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_0__.animateCSSModeScroll)({
          swiper,
          targetPosition: t,
          side: isH ? 'left' : 'top'
        });
        return true;
      }

      wrapperEl.scrollTo({
        [isH ? 'left' : 'top']: t,
        behavior: 'smooth'
      });
    }

    return true;
  }

  swiper.setTransition(speed);
  swiper.setTranslate(translate);
  swiper.updateActiveIndex(slideIndex);
  swiper.updateSlidesClasses();
  swiper.emit('beforeTransitionStart', speed, internal);
  swiper.transitionStart(runCallbacks, direction);

  if (speed === 0) {
    swiper.transitionEnd(runCallbacks, direction);
  } else if (!swiper.animating) {
    swiper.animating = true;

    if (!swiper.onSlideToWrapperTransitionEnd) {
      swiper.onSlideToWrapperTransitionEnd = function transitionEnd(e) {
        if (!swiper || swiper.destroyed) return;
        if (e.target !== this) return;
        swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);
        swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);
        swiper.onSlideToWrapperTransitionEnd = null;
        delete swiper.onSlideToWrapperTransitionEnd;
        swiper.transitionEnd(runCallbacks, direction);
      };
    }

    swiper.$wrapperEl[0].addEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);
    swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);
  }

  return true;
}

/***/ }),

/***/ "./node_modules/swiper/core/slide/slideToClickedSlide.js":
/*!***************************************************************!*\
  !*** ./node_modules/swiper/core/slide/slideToClickedSlide.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ slideToClickedSlide)
/* harmony export */ });
/* harmony import */ var _shared_dom_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/dom.js */ "./node_modules/swiper/shared/dom.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/swiper/shared/utils.js");


function slideToClickedSlide() {
  const swiper = this;
  const {
    params,
    $wrapperEl
  } = swiper;
  const slidesPerView = params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : params.slidesPerView;
  let slideToIndex = swiper.clickedIndex;
  let realIndex;

  if (params.loop) {
    if (swiper.animating) return;
    realIndex = parseInt((0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_0__["default"])(swiper.clickedSlide).attr('data-swiper-slide-index'), 10);

    if (params.centeredSlides) {
      if (slideToIndex < swiper.loopedSlides - slidesPerView / 2 || slideToIndex > swiper.slides.length - swiper.loopedSlides + slidesPerView / 2) {
        swiper.loopFix();
        slideToIndex = $wrapperEl.children(`.${params.slideClass}[data-swiper-slide-index="${realIndex}"]:not(.${params.slideDuplicateClass})`).eq(0).index();
        (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.nextTick)(() => {
          swiper.slideTo(slideToIndex);
        });
      } else {
        swiper.slideTo(slideToIndex);
      }
    } else if (slideToIndex > swiper.slides.length - slidesPerView) {
      swiper.loopFix();
      slideToIndex = $wrapperEl.children(`.${params.slideClass}[data-swiper-slide-index="${realIndex}"]:not(.${params.slideDuplicateClass})`).eq(0).index();
      (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.nextTick)(() => {
        swiper.slideTo(slideToIndex);
      });
    } else {
      swiper.slideTo(slideToIndex);
    }
  } else {
    swiper.slideTo(slideToIndex);
  }
}

/***/ }),

/***/ "./node_modules/swiper/core/slide/slideToClosest.js":
/*!**********************************************************!*\
  !*** ./node_modules/swiper/core/slide/slideToClosest.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ slideToClosest)
/* harmony export */ });
/* eslint no-unused-vars: "off" */
function slideToClosest(speed, runCallbacks, internal, threshold) {
  if (speed === void 0) {
    speed = this.params.speed;
  }

  if (runCallbacks === void 0) {
    runCallbacks = true;
  }

  if (threshold === void 0) {
    threshold = 0.5;
  }

  const swiper = this;
  let index = swiper.activeIndex;
  const skip = Math.min(swiper.params.slidesPerGroupSkip, index);
  const snapIndex = skip + Math.floor((index - skip) / swiper.params.slidesPerGroup);
  const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;

  if (translate >= swiper.snapGrid[snapIndex]) {
    // The current translate is on or after the current snap index, so the choice
    // is between the current index and the one after it.
    const currentSnap = swiper.snapGrid[snapIndex];
    const nextSnap = swiper.snapGrid[snapIndex + 1];

    if (translate - currentSnap > (nextSnap - currentSnap) * threshold) {
      index += swiper.params.slidesPerGroup;
    }
  } else {
    // The current translate is before the current snap index, so the choice
    // is between the current index and the one before it.
    const prevSnap = swiper.snapGrid[snapIndex - 1];
    const currentSnap = swiper.snapGrid[snapIndex];

    if (translate - prevSnap <= (currentSnap - prevSnap) * threshold) {
      index -= swiper.params.slidesPerGroup;
    }
  }

  index = Math.max(index, 0);
  index = Math.min(index, swiper.slidesGrid.length - 1);
  return swiper.slideTo(index, speed, runCallbacks, internal);
}

/***/ }),

/***/ "./node_modules/swiper/core/slide/slideToLoop.js":
/*!*******************************************************!*\
  !*** ./node_modules/swiper/core/slide/slideToLoop.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ slideToLoop)
/* harmony export */ });
function slideToLoop(index, speed, runCallbacks, internal) {
  if (index === void 0) {
    index = 0;
  }

  if (speed === void 0) {
    speed = this.params.speed;
  }

  if (runCallbacks === void 0) {
    runCallbacks = true;
  }

  const swiper = this;
  let newIndex = index;

  if (swiper.params.loop) {
    newIndex += swiper.loopedSlides;
  }

  return swiper.slideTo(newIndex, speed, runCallbacks, internal);
}

/***/ }),

/***/ "./node_modules/swiper/core/transition/index.js":
/*!******************************************************!*\
  !*** ./node_modules/swiper/core/transition/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _setTransition_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./setTransition.js */ "./node_modules/swiper/core/transition/setTransition.js");
/* harmony import */ var _transitionStart_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./transitionStart.js */ "./node_modules/swiper/core/transition/transitionStart.js");
/* harmony import */ var _transitionEnd_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./transitionEnd.js */ "./node_modules/swiper/core/transition/transitionEnd.js");



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  setTransition: _setTransition_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  transitionStart: _transitionStart_js__WEBPACK_IMPORTED_MODULE_1__["default"],
  transitionEnd: _transitionEnd_js__WEBPACK_IMPORTED_MODULE_2__["default"]
});

/***/ }),

/***/ "./node_modules/swiper/core/transition/setTransition.js":
/*!**************************************************************!*\
  !*** ./node_modules/swiper/core/transition/setTransition.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ setTransition)
/* harmony export */ });
function setTransition(duration, byController) {
  const swiper = this;

  if (!swiper.params.cssMode) {
    swiper.$wrapperEl.transition(duration);
  }

  swiper.emit('setTransition', duration, byController);
}

/***/ }),

/***/ "./node_modules/swiper/core/transition/transitionEmit.js":
/*!***************************************************************!*\
  !*** ./node_modules/swiper/core/transition/transitionEmit.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ transitionEmit)
/* harmony export */ });
function transitionEmit(_ref) {
  let {
    swiper,
    runCallbacks,
    direction,
    step
  } = _ref;
  const {
    activeIndex,
    previousIndex
  } = swiper;
  let dir = direction;

  if (!dir) {
    if (activeIndex > previousIndex) dir = 'next';else if (activeIndex < previousIndex) dir = 'prev';else dir = 'reset';
  }

  swiper.emit(`transition${step}`);

  if (runCallbacks && activeIndex !== previousIndex) {
    if (dir === 'reset') {
      swiper.emit(`slideResetTransition${step}`);
      return;
    }

    swiper.emit(`slideChangeTransition${step}`);

    if (dir === 'next') {
      swiper.emit(`slideNextTransition${step}`);
    } else {
      swiper.emit(`slidePrevTransition${step}`);
    }
  }
}

/***/ }),

/***/ "./node_modules/swiper/core/transition/transitionEnd.js":
/*!**************************************************************!*\
  !*** ./node_modules/swiper/core/transition/transitionEnd.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ transitionEnd)
/* harmony export */ });
/* harmony import */ var _transitionEmit_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./transitionEmit.js */ "./node_modules/swiper/core/transition/transitionEmit.js");

function transitionEnd(runCallbacks, direction) {
  if (runCallbacks === void 0) {
    runCallbacks = true;
  }

  const swiper = this;
  const {
    params
  } = swiper;
  swiper.animating = false;
  if (params.cssMode) return;
  swiper.setTransition(0);
  (0,_transitionEmit_js__WEBPACK_IMPORTED_MODULE_0__["default"])({
    swiper,
    runCallbacks,
    direction,
    step: 'End'
  });
}

/***/ }),

/***/ "./node_modules/swiper/core/transition/transitionStart.js":
/*!****************************************************************!*\
  !*** ./node_modules/swiper/core/transition/transitionStart.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ transitionStart)
/* harmony export */ });
/* harmony import */ var _transitionEmit_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./transitionEmit.js */ "./node_modules/swiper/core/transition/transitionEmit.js");

function transitionStart(runCallbacks, direction) {
  if (runCallbacks === void 0) {
    runCallbacks = true;
  }

  const swiper = this;
  const {
    params
  } = swiper;
  if (params.cssMode) return;

  if (params.autoHeight) {
    swiper.updateAutoHeight();
  }

  (0,_transitionEmit_js__WEBPACK_IMPORTED_MODULE_0__["default"])({
    swiper,
    runCallbacks,
    direction,
    step: 'Start'
  });
}

/***/ }),

/***/ "./node_modules/swiper/core/translate/getTranslate.js":
/*!************************************************************!*\
  !*** ./node_modules/swiper/core/translate/getTranslate.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getSwiperTranslate)
/* harmony export */ });
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/swiper/shared/utils.js");

function getSwiperTranslate(axis) {
  if (axis === void 0) {
    axis = this.isHorizontal() ? 'x' : 'y';
  }

  const swiper = this;
  const {
    params,
    rtlTranslate: rtl,
    translate,
    $wrapperEl
  } = swiper;

  if (params.virtualTranslate) {
    return rtl ? -translate : translate;
  }

  if (params.cssMode) {
    return translate;
  }

  let currentTranslate = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_0__.getTranslate)($wrapperEl[0], axis);
  if (rtl) currentTranslate = -currentTranslate;
  return currentTranslate || 0;
}

/***/ }),

/***/ "./node_modules/swiper/core/translate/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/swiper/core/translate/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _getTranslate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getTranslate.js */ "./node_modules/swiper/core/translate/getTranslate.js");
/* harmony import */ var _setTranslate_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./setTranslate.js */ "./node_modules/swiper/core/translate/setTranslate.js");
/* harmony import */ var _minTranslate_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./minTranslate.js */ "./node_modules/swiper/core/translate/minTranslate.js");
/* harmony import */ var _maxTranslate_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./maxTranslate.js */ "./node_modules/swiper/core/translate/maxTranslate.js");
/* harmony import */ var _translateTo_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./translateTo.js */ "./node_modules/swiper/core/translate/translateTo.js");





/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  getTranslate: _getTranslate_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  setTranslate: _setTranslate_js__WEBPACK_IMPORTED_MODULE_1__["default"],
  minTranslate: _minTranslate_js__WEBPACK_IMPORTED_MODULE_2__["default"],
  maxTranslate: _maxTranslate_js__WEBPACK_IMPORTED_MODULE_3__["default"],
  translateTo: _translateTo_js__WEBPACK_IMPORTED_MODULE_4__["default"]
});

/***/ }),

/***/ "./node_modules/swiper/core/translate/maxTranslate.js":
/*!************************************************************!*\
  !*** ./node_modules/swiper/core/translate/maxTranslate.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ maxTranslate)
/* harmony export */ });
function maxTranslate() {
  return -this.snapGrid[this.snapGrid.length - 1];
}

/***/ }),

/***/ "./node_modules/swiper/core/translate/minTranslate.js":
/*!************************************************************!*\
  !*** ./node_modules/swiper/core/translate/minTranslate.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ minTranslate)
/* harmony export */ });
function minTranslate() {
  return -this.snapGrid[0];
}

/***/ }),

/***/ "./node_modules/swiper/core/translate/setTranslate.js":
/*!************************************************************!*\
  !*** ./node_modules/swiper/core/translate/setTranslate.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ setTranslate)
/* harmony export */ });
function setTranslate(translate, byController) {
  const swiper = this;
  const {
    rtlTranslate: rtl,
    params,
    $wrapperEl,
    wrapperEl,
    progress
  } = swiper;
  let x = 0;
  let y = 0;
  const z = 0;

  if (swiper.isHorizontal()) {
    x = rtl ? -translate : translate;
  } else {
    y = translate;
  }

  if (params.roundLengths) {
    x = Math.floor(x);
    y = Math.floor(y);
  }

  if (params.cssMode) {
    wrapperEl[swiper.isHorizontal() ? 'scrollLeft' : 'scrollTop'] = swiper.isHorizontal() ? -x : -y;
  } else if (!params.virtualTranslate) {
    $wrapperEl.transform(`translate3d(${x}px, ${y}px, ${z}px)`);
  }

  swiper.previousTranslate = swiper.translate;
  swiper.translate = swiper.isHorizontal() ? x : y; // Check if we need to update progress

  let newProgress;
  const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();

  if (translatesDiff === 0) {
    newProgress = 0;
  } else {
    newProgress = (translate - swiper.minTranslate()) / translatesDiff;
  }

  if (newProgress !== progress) {
    swiper.updateProgress(translate);
  }

  swiper.emit('setTranslate', swiper.translate, byController);
}

/***/ }),

/***/ "./node_modules/swiper/core/translate/translateTo.js":
/*!***********************************************************!*\
  !*** ./node_modules/swiper/core/translate/translateTo.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ translateTo)
/* harmony export */ });
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/swiper/shared/utils.js");

function translateTo(translate, speed, runCallbacks, translateBounds, internal) {
  if (translate === void 0) {
    translate = 0;
  }

  if (speed === void 0) {
    speed = this.params.speed;
  }

  if (runCallbacks === void 0) {
    runCallbacks = true;
  }

  if (translateBounds === void 0) {
    translateBounds = true;
  }

  const swiper = this;
  const {
    params,
    wrapperEl
  } = swiper;

  if (swiper.animating && params.preventInteractionOnTransition) {
    return false;
  }

  const minTranslate = swiper.minTranslate();
  const maxTranslate = swiper.maxTranslate();
  let newTranslate;
  if (translateBounds && translate > minTranslate) newTranslate = minTranslate;else if (translateBounds && translate < maxTranslate) newTranslate = maxTranslate;else newTranslate = translate; // Update progress

  swiper.updateProgress(newTranslate);

  if (params.cssMode) {
    const isH = swiper.isHorizontal();

    if (speed === 0) {
      wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = -newTranslate;
    } else {
      if (!swiper.support.smoothScroll) {
        (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_0__.animateCSSModeScroll)({
          swiper,
          targetPosition: -newTranslate,
          side: isH ? 'left' : 'top'
        });
        return true;
      }

      wrapperEl.scrollTo({
        [isH ? 'left' : 'top']: -newTranslate,
        behavior: 'smooth'
      });
    }

    return true;
  }

  if (speed === 0) {
    swiper.setTransition(0);
    swiper.setTranslate(newTranslate);

    if (runCallbacks) {
      swiper.emit('beforeTransitionStart', speed, internal);
      swiper.emit('transitionEnd');
    }
  } else {
    swiper.setTransition(speed);
    swiper.setTranslate(newTranslate);

    if (runCallbacks) {
      swiper.emit('beforeTransitionStart', speed, internal);
      swiper.emit('transitionStart');
    }

    if (!swiper.animating) {
      swiper.animating = true;

      if (!swiper.onTranslateToWrapperTransitionEnd) {
        swiper.onTranslateToWrapperTransitionEnd = function transitionEnd(e) {
          if (!swiper || swiper.destroyed) return;
          if (e.target !== this) return;
          swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);
          swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.onTranslateToWrapperTransitionEnd);
          swiper.onTranslateToWrapperTransitionEnd = null;
          delete swiper.onTranslateToWrapperTransitionEnd;

          if (runCallbacks) {
            swiper.emit('transitionEnd');
          }
        };
      }

      swiper.$wrapperEl[0].addEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);
      swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.onTranslateToWrapperTransitionEnd);
    }
  }

  return true;
}

/***/ }),

/***/ "./node_modules/swiper/core/update/index.js":
/*!**************************************************!*\
  !*** ./node_modules/swiper/core/update/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _updateSize_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./updateSize.js */ "./node_modules/swiper/core/update/updateSize.js");
/* harmony import */ var _updateSlides_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./updateSlides.js */ "./node_modules/swiper/core/update/updateSlides.js");
/* harmony import */ var _updateAutoHeight_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./updateAutoHeight.js */ "./node_modules/swiper/core/update/updateAutoHeight.js");
/* harmony import */ var _updateSlidesOffset_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./updateSlidesOffset.js */ "./node_modules/swiper/core/update/updateSlidesOffset.js");
/* harmony import */ var _updateSlidesProgress_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./updateSlidesProgress.js */ "./node_modules/swiper/core/update/updateSlidesProgress.js");
/* harmony import */ var _updateProgress_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./updateProgress.js */ "./node_modules/swiper/core/update/updateProgress.js");
/* harmony import */ var _updateSlidesClasses_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./updateSlidesClasses.js */ "./node_modules/swiper/core/update/updateSlidesClasses.js");
/* harmony import */ var _updateActiveIndex_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./updateActiveIndex.js */ "./node_modules/swiper/core/update/updateActiveIndex.js");
/* harmony import */ var _updateClickedSlide_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./updateClickedSlide.js */ "./node_modules/swiper/core/update/updateClickedSlide.js");









/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  updateSize: _updateSize_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  updateSlides: _updateSlides_js__WEBPACK_IMPORTED_MODULE_1__["default"],
  updateAutoHeight: _updateAutoHeight_js__WEBPACK_IMPORTED_MODULE_2__["default"],
  updateSlidesOffset: _updateSlidesOffset_js__WEBPACK_IMPORTED_MODULE_3__["default"],
  updateSlidesProgress: _updateSlidesProgress_js__WEBPACK_IMPORTED_MODULE_4__["default"],
  updateProgress: _updateProgress_js__WEBPACK_IMPORTED_MODULE_5__["default"],
  updateSlidesClasses: _updateSlidesClasses_js__WEBPACK_IMPORTED_MODULE_6__["default"],
  updateActiveIndex: _updateActiveIndex_js__WEBPACK_IMPORTED_MODULE_7__["default"],
  updateClickedSlide: _updateClickedSlide_js__WEBPACK_IMPORTED_MODULE_8__["default"]
});

/***/ }),

/***/ "./node_modules/swiper/core/update/updateActiveIndex.js":
/*!**************************************************************!*\
  !*** ./node_modules/swiper/core/update/updateActiveIndex.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ updateActiveIndex)
/* harmony export */ });
function updateActiveIndex(newActiveIndex) {
  const swiper = this;
  const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
  const {
    slidesGrid,
    snapGrid,
    params,
    activeIndex: previousIndex,
    realIndex: previousRealIndex,
    snapIndex: previousSnapIndex
  } = swiper;
  let activeIndex = newActiveIndex;
  let snapIndex;

  if (typeof activeIndex === 'undefined') {
    for (let i = 0; i < slidesGrid.length; i += 1) {
      if (typeof slidesGrid[i + 1] !== 'undefined') {
        if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1] - (slidesGrid[i + 1] - slidesGrid[i]) / 2) {
          activeIndex = i;
        } else if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1]) {
          activeIndex = i + 1;
        }
      } else if (translate >= slidesGrid[i]) {
        activeIndex = i;
      }
    } // Normalize slideIndex


    if (params.normalizeSlideIndex) {
      if (activeIndex < 0 || typeof activeIndex === 'undefined') activeIndex = 0;
    }
  }

  if (snapGrid.indexOf(translate) >= 0) {
    snapIndex = snapGrid.indexOf(translate);
  } else {
    const skip = Math.min(params.slidesPerGroupSkip, activeIndex);
    snapIndex = skip + Math.floor((activeIndex - skip) / params.slidesPerGroup);
  }

  if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;

  if (activeIndex === previousIndex) {
    if (snapIndex !== previousSnapIndex) {
      swiper.snapIndex = snapIndex;
      swiper.emit('snapIndexChange');
    }

    return;
  } // Get real index


  const realIndex = parseInt(swiper.slides.eq(activeIndex).attr('data-swiper-slide-index') || activeIndex, 10);
  Object.assign(swiper, {
    snapIndex,
    realIndex,
    previousIndex,
    activeIndex
  });
  swiper.emit('activeIndexChange');
  swiper.emit('snapIndexChange');

  if (previousRealIndex !== realIndex) {
    swiper.emit('realIndexChange');
  }

  if (swiper.initialized || swiper.params.runCallbacksOnInit) {
    swiper.emit('slideChange');
  }
}

/***/ }),

/***/ "./node_modules/swiper/core/update/updateAutoHeight.js":
/*!*************************************************************!*\
  !*** ./node_modules/swiper/core/update/updateAutoHeight.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ updateAutoHeight)
/* harmony export */ });
function updateAutoHeight(speed) {
  const swiper = this;
  const activeSlides = [];
  const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
  let newHeight = 0;
  let i;

  if (typeof speed === 'number') {
    swiper.setTransition(speed);
  } else if (speed === true) {
    swiper.setTransition(swiper.params.speed);
  }

  const getSlideByIndex = index => {
    if (isVirtual) {
      return swiper.slides.filter(el => parseInt(el.getAttribute('data-swiper-slide-index'), 10) === index)[0];
    }

    return swiper.slides.eq(index)[0];
  }; // Find slides currently in view


  if (swiper.params.slidesPerView !== 'auto' && swiper.params.slidesPerView > 1) {
    if (swiper.params.centeredSlides) {
      swiper.visibleSlides.each(slide => {
        activeSlides.push(slide);
      });
    } else {
      for (i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1) {
        const index = swiper.activeIndex + i;
        if (index > swiper.slides.length && !isVirtual) break;
        activeSlides.push(getSlideByIndex(index));
      }
    }
  } else {
    activeSlides.push(getSlideByIndex(swiper.activeIndex));
  } // Find new height from highest slide in view


  for (i = 0; i < activeSlides.length; i += 1) {
    if (typeof activeSlides[i] !== 'undefined') {
      const height = activeSlides[i].offsetHeight;
      newHeight = height > newHeight ? height : newHeight;
    }
  } // Update Height


  if (newHeight || newHeight === 0) swiper.$wrapperEl.css('height', `${newHeight}px`);
}

/***/ }),

/***/ "./node_modules/swiper/core/update/updateClickedSlide.js":
/*!***************************************************************!*\
  !*** ./node_modules/swiper/core/update/updateClickedSlide.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ updateClickedSlide)
/* harmony export */ });
/* harmony import */ var _shared_dom_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/dom.js */ "./node_modules/swiper/shared/dom.js");

function updateClickedSlide(e) {
  const swiper = this;
  const params = swiper.params;
  const slide = (0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_0__["default"])(e).closest(`.${params.slideClass}`)[0];
  let slideFound = false;
  let slideIndex;

  if (slide) {
    for (let i = 0; i < swiper.slides.length; i += 1) {
      if (swiper.slides[i] === slide) {
        slideFound = true;
        slideIndex = i;
        break;
      }
    }
  }

  if (slide && slideFound) {
    swiper.clickedSlide = slide;

    if (swiper.virtual && swiper.params.virtual.enabled) {
      swiper.clickedIndex = parseInt((0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_0__["default"])(slide).attr('data-swiper-slide-index'), 10);
    } else {
      swiper.clickedIndex = slideIndex;
    }
  } else {
    swiper.clickedSlide = undefined;
    swiper.clickedIndex = undefined;
    return;
  }

  if (params.slideToClickedSlide && swiper.clickedIndex !== undefined && swiper.clickedIndex !== swiper.activeIndex) {
    swiper.slideToClickedSlide();
  }
}

/***/ }),

/***/ "./node_modules/swiper/core/update/updateProgress.js":
/*!***********************************************************!*\
  !*** ./node_modules/swiper/core/update/updateProgress.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ updateProgress)
/* harmony export */ });
function updateProgress(translate) {
  const swiper = this;

  if (typeof translate === 'undefined') {
    const multiplier = swiper.rtlTranslate ? -1 : 1; // eslint-disable-next-line

    translate = swiper && swiper.translate && swiper.translate * multiplier || 0;
  }

  const params = swiper.params;
  const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
  let {
    progress,
    isBeginning,
    isEnd
  } = swiper;
  const wasBeginning = isBeginning;
  const wasEnd = isEnd;

  if (translatesDiff === 0) {
    progress = 0;
    isBeginning = true;
    isEnd = true;
  } else {
    progress = (translate - swiper.minTranslate()) / translatesDiff;
    isBeginning = progress <= 0;
    isEnd = progress >= 1;
  }

  Object.assign(swiper, {
    progress,
    isBeginning,
    isEnd
  });
  if (params.watchSlidesProgress || params.centeredSlides && params.autoHeight) swiper.updateSlidesProgress(translate);

  if (isBeginning && !wasBeginning) {
    swiper.emit('reachBeginning toEdge');
  }

  if (isEnd && !wasEnd) {
    swiper.emit('reachEnd toEdge');
  }

  if (wasBeginning && !isBeginning || wasEnd && !isEnd) {
    swiper.emit('fromEdge');
  }

  swiper.emit('progress', progress);
}

/***/ }),

/***/ "./node_modules/swiper/core/update/updateSize.js":
/*!*******************************************************!*\
  !*** ./node_modules/swiper/core/update/updateSize.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ updateSize)
/* harmony export */ });
function updateSize() {
  const swiper = this;
  let width;
  let height;
  const $el = swiper.$el;

  if (typeof swiper.params.width !== 'undefined' && swiper.params.width !== null) {
    width = swiper.params.width;
  } else {
    width = $el[0].clientWidth;
  }

  if (typeof swiper.params.height !== 'undefined' && swiper.params.height !== null) {
    height = swiper.params.height;
  } else {
    height = $el[0].clientHeight;
  }

  if (width === 0 && swiper.isHorizontal() || height === 0 && swiper.isVertical()) {
    return;
  } // Subtract paddings


  width = width - parseInt($el.css('padding-left') || 0, 10) - parseInt($el.css('padding-right') || 0, 10);
  height = height - parseInt($el.css('padding-top') || 0, 10) - parseInt($el.css('padding-bottom') || 0, 10);
  if (Number.isNaN(width)) width = 0;
  if (Number.isNaN(height)) height = 0;
  Object.assign(swiper, {
    width,
    height,
    size: swiper.isHorizontal() ? width : height
  });
}

/***/ }),

/***/ "./node_modules/swiper/core/update/updateSlides.js":
/*!*********************************************************!*\
  !*** ./node_modules/swiper/core/update/updateSlides.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ updateSlides)
/* harmony export */ });
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/swiper/shared/utils.js");

function updateSlides() {
  const swiper = this;

  function getDirectionLabel(property) {
    if (swiper.isHorizontal()) {
      return property;
    } // prettier-ignore


    return {
      'width': 'height',
      'margin-top': 'margin-left',
      'margin-bottom ': 'margin-right',
      'margin-left': 'margin-top',
      'margin-right': 'margin-bottom',
      'padding-left': 'padding-top',
      'padding-right': 'padding-bottom',
      'marginRight': 'marginBottom'
    }[property];
  }

  function getDirectionPropertyValue(node, label) {
    return parseFloat(node.getPropertyValue(getDirectionLabel(label)) || 0);
  }

  const params = swiper.params;
  const {
    $wrapperEl,
    size: swiperSize,
    rtlTranslate: rtl,
    wrongRTL
  } = swiper;
  const isVirtual = swiper.virtual && params.virtual.enabled;
  const previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;
  const slides = $wrapperEl.children(`.${swiper.params.slideClass}`);
  const slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;
  let snapGrid = [];
  const slidesGrid = [];
  const slidesSizesGrid = [];
  let offsetBefore = params.slidesOffsetBefore;

  if (typeof offsetBefore === 'function') {
    offsetBefore = params.slidesOffsetBefore.call(swiper);
  }

  let offsetAfter = params.slidesOffsetAfter;

  if (typeof offsetAfter === 'function') {
    offsetAfter = params.slidesOffsetAfter.call(swiper);
  }

  const previousSnapGridLength = swiper.snapGrid.length;
  const previousSlidesGridLength = swiper.slidesGrid.length;
  let spaceBetween = params.spaceBetween;
  let slidePosition = -offsetBefore;
  let prevSlideSize = 0;
  let index = 0;

  if (typeof swiperSize === 'undefined') {
    return;
  }

  if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {
    spaceBetween = parseFloat(spaceBetween.replace('%', '')) / 100 * swiperSize;
  }

  swiper.virtualSize = -spaceBetween; // reset margins

  if (rtl) slides.css({
    marginLeft: '',
    marginBottom: '',
    marginTop: ''
  });else slides.css({
    marginRight: '',
    marginBottom: '',
    marginTop: ''
  }); // reset cssMode offsets

  if (params.centeredSlides && params.cssMode) {
    (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_0__.setCSSProperty)(swiper.wrapperEl, '--swiper-centered-offset-before', '');
    (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_0__.setCSSProperty)(swiper.wrapperEl, '--swiper-centered-offset-after', '');
  }

  const gridEnabled = params.grid && params.grid.rows > 1 && swiper.grid;

  if (gridEnabled) {
    swiper.grid.initSlides(slidesLength);
  } // Calc slides


  let slideSize;
  const shouldResetSlideSize = params.slidesPerView === 'auto' && params.breakpoints && Object.keys(params.breakpoints).filter(key => {
    return typeof params.breakpoints[key].slidesPerView !== 'undefined';
  }).length > 0;

  for (let i = 0; i < slidesLength; i += 1) {
    slideSize = 0;
    const slide = slides.eq(i);

    if (gridEnabled) {
      swiper.grid.updateSlide(i, slide, slidesLength, getDirectionLabel);
    }

    if (slide.css('display') === 'none') continue; // eslint-disable-line

    if (params.slidesPerView === 'auto') {
      if (shouldResetSlideSize) {
        slides[i].style[getDirectionLabel('width')] = ``;
      }

      const slideStyles = getComputedStyle(slide[0]);
      const currentTransform = slide[0].style.transform;
      const currentWebKitTransform = slide[0].style.webkitTransform;

      if (currentTransform) {
        slide[0].style.transform = 'none';
      }

      if (currentWebKitTransform) {
        slide[0].style.webkitTransform = 'none';
      }

      if (params.roundLengths) {
        slideSize = swiper.isHorizontal() ? slide.outerWidth(true) : slide.outerHeight(true);
      } else {
        // eslint-disable-next-line
        const width = getDirectionPropertyValue(slideStyles, 'width');
        const paddingLeft = getDirectionPropertyValue(slideStyles, 'padding-left');
        const paddingRight = getDirectionPropertyValue(slideStyles, 'padding-right');
        const marginLeft = getDirectionPropertyValue(slideStyles, 'margin-left');
        const marginRight = getDirectionPropertyValue(slideStyles, 'margin-right');
        const boxSizing = slideStyles.getPropertyValue('box-sizing');

        if (boxSizing && boxSizing === 'border-box') {
          slideSize = width + marginLeft + marginRight;
        } else {
          const {
            clientWidth,
            offsetWidth
          } = slide[0];
          slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight + (offsetWidth - clientWidth);
        }
      }

      if (currentTransform) {
        slide[0].style.transform = currentTransform;
      }

      if (currentWebKitTransform) {
        slide[0].style.webkitTransform = currentWebKitTransform;
      }

      if (params.roundLengths) slideSize = Math.floor(slideSize);
    } else {
      slideSize = (swiperSize - (params.slidesPerView - 1) * spaceBetween) / params.slidesPerView;
      if (params.roundLengths) slideSize = Math.floor(slideSize);

      if (slides[i]) {
        slides[i].style[getDirectionLabel('width')] = `${slideSize}px`;
      }
    }

    if (slides[i]) {
      slides[i].swiperSlideSize = slideSize;
    }

    slidesSizesGrid.push(slideSize);

    if (params.centeredSlides) {
      slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;
      if (prevSlideSize === 0 && i !== 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
      if (i === 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
      if (Math.abs(slidePosition) < 1 / 1000) slidePosition = 0;
      if (params.roundLengths) slidePosition = Math.floor(slidePosition);
      if (index % params.slidesPerGroup === 0) snapGrid.push(slidePosition);
      slidesGrid.push(slidePosition);
    } else {
      if (params.roundLengths) slidePosition = Math.floor(slidePosition);
      if ((index - Math.min(swiper.params.slidesPerGroupSkip, index)) % swiper.params.slidesPerGroup === 0) snapGrid.push(slidePosition);
      slidesGrid.push(slidePosition);
      slidePosition = slidePosition + slideSize + spaceBetween;
    }

    swiper.virtualSize += slideSize + spaceBetween;
    prevSlideSize = slideSize;
    index += 1;
  }

  swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;

  if (rtl && wrongRTL && (params.effect === 'slide' || params.effect === 'coverflow')) {
    $wrapperEl.css({
      width: `${swiper.virtualSize + params.spaceBetween}px`
    });
  }

  if (params.setWrapperSize) {
    $wrapperEl.css({
      [getDirectionLabel('width')]: `${swiper.virtualSize + params.spaceBetween}px`
    });
  }

  if (gridEnabled) {
    swiper.grid.updateWrapperSize(slideSize, snapGrid, getDirectionLabel);
  } // Remove last grid elements depending on width


  if (!params.centeredSlides) {
    const newSlidesGrid = [];

    for (let i = 0; i < snapGrid.length; i += 1) {
      let slidesGridItem = snapGrid[i];
      if (params.roundLengths) slidesGridItem = Math.floor(slidesGridItem);

      if (snapGrid[i] <= swiper.virtualSize - swiperSize) {
        newSlidesGrid.push(slidesGridItem);
      }
    }

    snapGrid = newSlidesGrid;

    if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) {
      snapGrid.push(swiper.virtualSize - swiperSize);
    }
  }

  if (snapGrid.length === 0) snapGrid = [0];

  if (params.spaceBetween !== 0) {
    const key = swiper.isHorizontal() && rtl ? 'marginLeft' : getDirectionLabel('marginRight');
    slides.filter((_, slideIndex) => {
      if (!params.cssMode) return true;

      if (slideIndex === slides.length - 1) {
        return false;
      }

      return true;
    }).css({
      [key]: `${spaceBetween}px`
    });
  }

  if (params.centeredSlides && params.centeredSlidesBounds) {
    let allSlidesSize = 0;
    slidesSizesGrid.forEach(slideSizeValue => {
      allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);
    });
    allSlidesSize -= params.spaceBetween;
    const maxSnap = allSlidesSize - swiperSize;
    snapGrid = snapGrid.map(snap => {
      if (snap < 0) return -offsetBefore;
      if (snap > maxSnap) return maxSnap + offsetAfter;
      return snap;
    });
  }

  if (params.centerInsufficientSlides) {
    let allSlidesSize = 0;
    slidesSizesGrid.forEach(slideSizeValue => {
      allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);
    });
    allSlidesSize -= params.spaceBetween;

    if (allSlidesSize < swiperSize) {
      const allSlidesOffset = (swiperSize - allSlidesSize) / 2;
      snapGrid.forEach((snap, snapIndex) => {
        snapGrid[snapIndex] = snap - allSlidesOffset;
      });
      slidesGrid.forEach((snap, snapIndex) => {
        slidesGrid[snapIndex] = snap + allSlidesOffset;
      });
    }
  }

  Object.assign(swiper, {
    slides,
    snapGrid,
    slidesGrid,
    slidesSizesGrid
  });

  if (params.centeredSlides && params.cssMode && !params.centeredSlidesBounds) {
    (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_0__.setCSSProperty)(swiper.wrapperEl, '--swiper-centered-offset-before', `${-snapGrid[0]}px`);
    (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_0__.setCSSProperty)(swiper.wrapperEl, '--swiper-centered-offset-after', `${swiper.size / 2 - slidesSizesGrid[slidesSizesGrid.length - 1] / 2}px`);
    const addToSnapGrid = -swiper.snapGrid[0];
    const addToSlidesGrid = -swiper.slidesGrid[0];
    swiper.snapGrid = swiper.snapGrid.map(v => v + addToSnapGrid);
    swiper.slidesGrid = swiper.slidesGrid.map(v => v + addToSlidesGrid);
  }

  if (slidesLength !== previousSlidesLength) {
    swiper.emit('slidesLengthChange');
  }

  if (snapGrid.length !== previousSnapGridLength) {
    if (swiper.params.watchOverflow) swiper.checkOverflow();
    swiper.emit('snapGridLengthChange');
  }

  if (slidesGrid.length !== previousSlidesGridLength) {
    swiper.emit('slidesGridLengthChange');
  }

  if (params.watchSlidesProgress) {
    swiper.updateSlidesOffset();
  }

  if (!isVirtual && !params.cssMode && (params.effect === 'slide' || params.effect === 'fade')) {
    const backFaceHiddenClass = `${params.containerModifierClass}backface-hidden`;
    const hasClassBackfaceClassAdded = swiper.$el.hasClass(backFaceHiddenClass);

    if (slidesLength <= params.maxBackfaceHiddenSlides) {
      if (!hasClassBackfaceClassAdded) swiper.$el.addClass(backFaceHiddenClass);
    } else if (hasClassBackfaceClassAdded) {
      swiper.$el.removeClass(backFaceHiddenClass);
    }
  }
}

/***/ }),

/***/ "./node_modules/swiper/core/update/updateSlidesClasses.js":
/*!****************************************************************!*\
  !*** ./node_modules/swiper/core/update/updateSlidesClasses.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ updateSlidesClasses)
/* harmony export */ });
function updateSlidesClasses() {
  const swiper = this;
  const {
    slides,
    params,
    $wrapperEl,
    activeIndex,
    realIndex
  } = swiper;
  const isVirtual = swiper.virtual && params.virtual.enabled;
  slides.removeClass(`${params.slideActiveClass} ${params.slideNextClass} ${params.slidePrevClass} ${params.slideDuplicateActiveClass} ${params.slideDuplicateNextClass} ${params.slideDuplicatePrevClass}`);
  let activeSlide;

  if (isVirtual) {
    activeSlide = swiper.$wrapperEl.find(`.${params.slideClass}[data-swiper-slide-index="${activeIndex}"]`);
  } else {
    activeSlide = slides.eq(activeIndex);
  } // Active classes


  activeSlide.addClass(params.slideActiveClass);

  if (params.loop) {
    // Duplicate to all looped slides
    if (activeSlide.hasClass(params.slideDuplicateClass)) {
      $wrapperEl.children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index="${realIndex}"]`).addClass(params.slideDuplicateActiveClass);
    } else {
      $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index="${realIndex}"]`).addClass(params.slideDuplicateActiveClass);
    }
  } // Next Slide


  let nextSlide = activeSlide.nextAll(`.${params.slideClass}`).eq(0).addClass(params.slideNextClass);

  if (params.loop && nextSlide.length === 0) {
    nextSlide = slides.eq(0);
    nextSlide.addClass(params.slideNextClass);
  } // Prev Slide


  let prevSlide = activeSlide.prevAll(`.${params.slideClass}`).eq(0).addClass(params.slidePrevClass);

  if (params.loop && prevSlide.length === 0) {
    prevSlide = slides.eq(-1);
    prevSlide.addClass(params.slidePrevClass);
  }

  if (params.loop) {
    // Duplicate to all looped slides
    if (nextSlide.hasClass(params.slideDuplicateClass)) {
      $wrapperEl.children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index="${nextSlide.attr('data-swiper-slide-index')}"]`).addClass(params.slideDuplicateNextClass);
    } else {
      $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index="${nextSlide.attr('data-swiper-slide-index')}"]`).addClass(params.slideDuplicateNextClass);
    }

    if (prevSlide.hasClass(params.slideDuplicateClass)) {
      $wrapperEl.children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index="${prevSlide.attr('data-swiper-slide-index')}"]`).addClass(params.slideDuplicatePrevClass);
    } else {
      $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index="${prevSlide.attr('data-swiper-slide-index')}"]`).addClass(params.slideDuplicatePrevClass);
    }
  }

  swiper.emitSlidesClasses();
}

/***/ }),

/***/ "./node_modules/swiper/core/update/updateSlidesOffset.js":
/*!***************************************************************!*\
  !*** ./node_modules/swiper/core/update/updateSlidesOffset.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ updateSlidesOffset)
/* harmony export */ });
function updateSlidesOffset() {
  const swiper = this;
  const slides = swiper.slides;

  for (let i = 0; i < slides.length; i += 1) {
    slides[i].swiperSlideOffset = swiper.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop;
  }
}

/***/ }),

/***/ "./node_modules/swiper/core/update/updateSlidesProgress.js":
/*!*****************************************************************!*\
  !*** ./node_modules/swiper/core/update/updateSlidesProgress.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ updateSlidesProgress)
/* harmony export */ });
/* harmony import */ var _shared_dom_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/dom.js */ "./node_modules/swiper/shared/dom.js");

function updateSlidesProgress(translate) {
  if (translate === void 0) {
    translate = this && this.translate || 0;
  }

  const swiper = this;
  const params = swiper.params;
  const {
    slides,
    rtlTranslate: rtl,
    snapGrid
  } = swiper;
  if (slides.length === 0) return;
  if (typeof slides[0].swiperSlideOffset === 'undefined') swiper.updateSlidesOffset();
  let offsetCenter = -translate;
  if (rtl) offsetCenter = translate; // Visible Slides

  slides.removeClass(params.slideVisibleClass);
  swiper.visibleSlidesIndexes = [];
  swiper.visibleSlides = [];

  for (let i = 0; i < slides.length; i += 1) {
    const slide = slides[i];
    let slideOffset = slide.swiperSlideOffset;

    if (params.cssMode && params.centeredSlides) {
      slideOffset -= slides[0].swiperSlideOffset;
    }

    const slideProgress = (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + params.spaceBetween);
    const originalSlideProgress = (offsetCenter - snapGrid[0] + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + params.spaceBetween);
    const slideBefore = -(offsetCenter - slideOffset);
    const slideAfter = slideBefore + swiper.slidesSizesGrid[i];
    const isVisible = slideBefore >= 0 && slideBefore < swiper.size - 1 || slideAfter > 1 && slideAfter <= swiper.size || slideBefore <= 0 && slideAfter >= swiper.size;

    if (isVisible) {
      swiper.visibleSlides.push(slide);
      swiper.visibleSlidesIndexes.push(i);
      slides.eq(i).addClass(params.slideVisibleClass);
    }

    slide.progress = rtl ? -slideProgress : slideProgress;
    slide.originalProgress = rtl ? -originalSlideProgress : originalSlideProgress;
  }

  swiper.visibleSlides = (0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_0__["default"])(swiper.visibleSlides);
}

/***/ }),

/***/ "./node_modules/swiper/modules/a11y/a11y.js":
/*!**************************************************!*\
  !*** ./node_modules/swiper/modules/a11y/a11y.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ A11y)
/* harmony export */ });
/* harmony import */ var _shared_classes_to_selector_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/classes-to-selector.js */ "./node_modules/swiper/shared/classes-to-selector.js");
/* harmony import */ var _shared_dom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/dom.js */ "./node_modules/swiper/shared/dom.js");


function A11y(_ref) {
  let {
    swiper,
    extendParams,
    on
  } = _ref;
  extendParams({
    a11y: {
      enabled: true,
      notificationClass: 'swiper-notification',
      prevSlideMessage: 'Previous slide',
      nextSlideMessage: 'Next slide',
      firstSlideMessage: 'This is the first slide',
      lastSlideMessage: 'This is the last slide',
      paginationBulletMessage: 'Go to slide {{index}}',
      slideLabelMessage: '{{index}} / {{slidesLength}}',
      containerMessage: null,
      containerRoleDescriptionMessage: null,
      itemRoleDescriptionMessage: null,
      slideRole: 'group'
    }
  });
  let liveRegion = null;

  function notify(message) {
    const notification = liveRegion;
    if (notification.length === 0) return;
    notification.html('');
    notification.html(message);
  }

  function getRandomNumber(size) {
    if (size === void 0) {
      size = 16;
    }

    const randomChar = () => Math.round(16 * Math.random()).toString(16);

    return 'x'.repeat(size).replace(/x/g, randomChar);
  }

  function makeElFocusable($el) {
    $el.attr('tabIndex', '0');
  }

  function makeElNotFocusable($el) {
    $el.attr('tabIndex', '-1');
  }

  function addElRole($el, role) {
    $el.attr('role', role);
  }

  function addElRoleDescription($el, description) {
    $el.attr('aria-roledescription', description);
  }

  function addElControls($el, controls) {
    $el.attr('aria-controls', controls);
  }

  function addElLabel($el, label) {
    $el.attr('aria-label', label);
  }

  function addElId($el, id) {
    $el.attr('id', id);
  }

  function addElLive($el, live) {
    $el.attr('aria-live', live);
  }

  function disableEl($el) {
    $el.attr('aria-disabled', true);
  }

  function enableEl($el) {
    $el.attr('aria-disabled', false);
  }

  function onEnterOrSpaceKey(e) {
    if (e.keyCode !== 13 && e.keyCode !== 32) return;
    const params = swiper.params.a11y;
    const $targetEl = (0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_1__["default"])(e.target);

    if (swiper.navigation && swiper.navigation.$nextEl && $targetEl.is(swiper.navigation.$nextEl)) {
      if (!(swiper.isEnd && !swiper.params.loop)) {
        swiper.slideNext();
      }

      if (swiper.isEnd) {
        notify(params.lastSlideMessage);
      } else {
        notify(params.nextSlideMessage);
      }
    }

    if (swiper.navigation && swiper.navigation.$prevEl && $targetEl.is(swiper.navigation.$prevEl)) {
      if (!(swiper.isBeginning && !swiper.params.loop)) {
        swiper.slidePrev();
      }

      if (swiper.isBeginning) {
        notify(params.firstSlideMessage);
      } else {
        notify(params.prevSlideMessage);
      }
    }

    if (swiper.pagination && $targetEl.is((0,_shared_classes_to_selector_js__WEBPACK_IMPORTED_MODULE_0__["default"])(swiper.params.pagination.bulletClass))) {
      $targetEl[0].click();
    }
  }

  function updateNavigation() {
    if (swiper.params.loop || swiper.params.rewind || !swiper.navigation) return;
    const {
      $nextEl,
      $prevEl
    } = swiper.navigation;

    if ($prevEl && $prevEl.length > 0) {
      if (swiper.isBeginning) {
        disableEl($prevEl);
        makeElNotFocusable($prevEl);
      } else {
        enableEl($prevEl);
        makeElFocusable($prevEl);
      }
    }

    if ($nextEl && $nextEl.length > 0) {
      if (swiper.isEnd) {
        disableEl($nextEl);
        makeElNotFocusable($nextEl);
      } else {
        enableEl($nextEl);
        makeElFocusable($nextEl);
      }
    }
  }

  function hasPagination() {
    return swiper.pagination && swiper.pagination.bullets && swiper.pagination.bullets.length;
  }

  function hasClickablePagination() {
    return hasPagination() && swiper.params.pagination.clickable;
  }

  function updatePagination() {
    const params = swiper.params.a11y;
    if (!hasPagination()) return;
    swiper.pagination.bullets.each(bulletEl => {
      const $bulletEl = (0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_1__["default"])(bulletEl);

      if (swiper.params.pagination.clickable) {
        makeElFocusable($bulletEl);

        if (!swiper.params.pagination.renderBullet) {
          addElRole($bulletEl, 'button');
          addElLabel($bulletEl, params.paginationBulletMessage.replace(/\{\{index\}\}/, $bulletEl.index() + 1));
        }
      }

      if ($bulletEl.is(`.${swiper.params.pagination.bulletActiveClass}`)) {
        $bulletEl.attr('aria-current', 'true');
      } else {
        $bulletEl.removeAttr('aria-current');
      }
    });
  }

  const initNavEl = ($el, wrapperId, message) => {
    makeElFocusable($el);

    if ($el[0].tagName !== 'BUTTON') {
      addElRole($el, 'button');
      $el.on('keydown', onEnterOrSpaceKey);
    }

    addElLabel($el, message);
    addElControls($el, wrapperId);
  };

  const handleFocus = e => {
    const slideEl = e.target.closest(`.${swiper.params.slideClass}`);
    if (!slideEl || !swiper.slides.includes(slideEl)) return;
    const isActive = swiper.slides.indexOf(slideEl) === swiper.activeIndex;
    const isVisible = swiper.params.watchSlidesProgress && swiper.visibleSlides && swiper.visibleSlides.includes(slideEl);
    if (isActive || isVisible) return;
    swiper.slideTo(swiper.slides.indexOf(slideEl), 0);
  };

  function init() {
    const params = swiper.params.a11y;
    swiper.$el.append(liveRegion); // Container

    const $containerEl = swiper.$el;

    if (params.containerRoleDescriptionMessage) {
      addElRoleDescription($containerEl, params.containerRoleDescriptionMessage);
    }

    if (params.containerMessage) {
      addElLabel($containerEl, params.containerMessage);
    } // Wrapper


    const $wrapperEl = swiper.$wrapperEl;
    const wrapperId = $wrapperEl.attr('id') || `swiper-wrapper-${getRandomNumber(16)}`;
    const live = swiper.params.autoplay && swiper.params.autoplay.enabled ? 'off' : 'polite';
    addElId($wrapperEl, wrapperId);
    addElLive($wrapperEl, live); // Slide

    if (params.itemRoleDescriptionMessage) {
      addElRoleDescription((0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_1__["default"])(swiper.slides), params.itemRoleDescriptionMessage);
    }

    addElRole((0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_1__["default"])(swiper.slides), params.slideRole);
    const slidesLength = swiper.params.loop ? swiper.slides.filter(el => !el.classList.contains(swiper.params.slideDuplicateClass)).length : swiper.slides.length;
    swiper.slides.each((slideEl, index) => {
      const $slideEl = (0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_1__["default"])(slideEl);
      const slideIndex = swiper.params.loop ? parseInt($slideEl.attr('data-swiper-slide-index'), 10) : index;
      const ariaLabelMessage = params.slideLabelMessage.replace(/\{\{index\}\}/, slideIndex + 1).replace(/\{\{slidesLength\}\}/, slidesLength);
      addElLabel($slideEl, ariaLabelMessage);
    }); // Navigation

    let $nextEl;
    let $prevEl;

    if (swiper.navigation && swiper.navigation.$nextEl) {
      $nextEl = swiper.navigation.$nextEl;
    }

    if (swiper.navigation && swiper.navigation.$prevEl) {
      $prevEl = swiper.navigation.$prevEl;
    }

    if ($nextEl && $nextEl.length) {
      initNavEl($nextEl, wrapperId, params.nextSlideMessage);
    }

    if ($prevEl && $prevEl.length) {
      initNavEl($prevEl, wrapperId, params.prevSlideMessage);
    } // Pagination


    if (hasClickablePagination()) {
      swiper.pagination.$el.on('keydown', (0,_shared_classes_to_selector_js__WEBPACK_IMPORTED_MODULE_0__["default"])(swiper.params.pagination.bulletClass), onEnterOrSpaceKey);
    } // Tab focus


    swiper.$el.on('focus', handleFocus, true);
  }

  function destroy() {
    if (liveRegion && liveRegion.length > 0) liveRegion.remove();
    let $nextEl;
    let $prevEl;

    if (swiper.navigation && swiper.navigation.$nextEl) {
      $nextEl = swiper.navigation.$nextEl;
    }

    if (swiper.navigation && swiper.navigation.$prevEl) {
      $prevEl = swiper.navigation.$prevEl;
    }

    if ($nextEl) {
      $nextEl.off('keydown', onEnterOrSpaceKey);
    }

    if ($prevEl) {
      $prevEl.off('keydown', onEnterOrSpaceKey);
    } // Pagination


    if (hasClickablePagination()) {
      swiper.pagination.$el.off('keydown', (0,_shared_classes_to_selector_js__WEBPACK_IMPORTED_MODULE_0__["default"])(swiper.params.pagination.bulletClass), onEnterOrSpaceKey);
    } // Tab focus


    swiper.$el.off('focus', handleFocus, true);
  }

  on('beforeInit', () => {
    liveRegion = (0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_1__["default"])(`<span class="${swiper.params.a11y.notificationClass}" aria-live="assertive" aria-atomic="true"></span>`);
  });
  on('afterInit', () => {
    if (!swiper.params.a11y.enabled) return;
    init();
  });
  on('fromEdge toEdge afterInit lock unlock', () => {
    if (!swiper.params.a11y.enabled) return;
    updateNavigation();
  });
  on('paginationUpdate', () => {
    if (!swiper.params.a11y.enabled) return;
    updatePagination();
  });
  on('destroy', () => {
    if (!swiper.params.a11y.enabled) return;
    destroy();
  });
}

/***/ }),

/***/ "./node_modules/swiper/modules/autoplay/autoplay.js":
/*!**********************************************************!*\
  !*** ./node_modules/swiper/modules/autoplay/autoplay.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Autoplay)
/* harmony export */ });
/* harmony import */ var ssr_window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ssr-window */ "./node_modules/ssr-window/ssr-window.esm.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/swiper/shared/utils.js");
/* eslint no-underscore-dangle: "off" */

/* eslint no-use-before-define: "off" */


function Autoplay(_ref) {
  let {
    swiper,
    extendParams,
    on,
    emit
  } = _ref;
  let timeout;
  swiper.autoplay = {
    running: false,
    paused: false
  };
  extendParams({
    autoplay: {
      enabled: false,
      delay: 3000,
      waitForTransition: true,
      disableOnInteraction: true,
      stopOnLastSlide: false,
      reverseDirection: false,
      pauseOnMouseEnter: false
    }
  });

  function run() {
    const $activeSlideEl = swiper.slides.eq(swiper.activeIndex);
    let delay = swiper.params.autoplay.delay;

    if ($activeSlideEl.attr('data-swiper-autoplay')) {
      delay = $activeSlideEl.attr('data-swiper-autoplay') || swiper.params.autoplay.delay;
    }

    clearTimeout(timeout);
    timeout = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.nextTick)(() => {
      let autoplayResult;

      if (swiper.params.autoplay.reverseDirection) {
        if (swiper.params.loop) {
          swiper.loopFix();
          autoplayResult = swiper.slidePrev(swiper.params.speed, true, true);
          emit('autoplay');
        } else if (!swiper.isBeginning) {
          autoplayResult = swiper.slidePrev(swiper.params.speed, true, true);
          emit('autoplay');
        } else if (!swiper.params.autoplay.stopOnLastSlide) {
          autoplayResult = swiper.slideTo(swiper.slides.length - 1, swiper.params.speed, true, true);
          emit('autoplay');
        } else {
          stop();
        }
      } else if (swiper.params.loop) {
        swiper.loopFix();
        autoplayResult = swiper.slideNext(swiper.params.speed, true, true);
        emit('autoplay');
      } else if (!swiper.isEnd) {
        autoplayResult = swiper.slideNext(swiper.params.speed, true, true);
        emit('autoplay');
      } else if (!swiper.params.autoplay.stopOnLastSlide) {
        autoplayResult = swiper.slideTo(0, swiper.params.speed, true, true);
        emit('autoplay');
      } else {
        stop();
      }

      if (swiper.params.cssMode && swiper.autoplay.running) run();else if (autoplayResult === false) {
        run();
      }
    }, delay);
  }

  function start() {
    if (typeof timeout !== 'undefined') return false;
    if (swiper.autoplay.running) return false;
    swiper.autoplay.running = true;
    emit('autoplayStart');
    run();
    return true;
  }

  function stop() {
    if (!swiper.autoplay.running) return false;
    if (typeof timeout === 'undefined') return false;

    if (timeout) {
      clearTimeout(timeout);
      timeout = undefined;
    }

    swiper.autoplay.running = false;
    emit('autoplayStop');
    return true;
  }

  function pause(speed) {
    if (!swiper.autoplay.running) return;
    if (swiper.autoplay.paused) return;
    if (timeout) clearTimeout(timeout);
    swiper.autoplay.paused = true;

    if (speed === 0 || !swiper.params.autoplay.waitForTransition) {
      swiper.autoplay.paused = false;
      run();
    } else {
      ['transitionend', 'webkitTransitionEnd'].forEach(event => {
        swiper.$wrapperEl[0].addEventListener(event, onTransitionEnd);
      });
    }
  }

  function onVisibilityChange() {
    const document = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getDocument)();

    if (document.visibilityState === 'hidden' && swiper.autoplay.running) {
      pause();
    }

    if (document.visibilityState === 'visible' && swiper.autoplay.paused) {
      run();
      swiper.autoplay.paused = false;
    }
  }

  function onTransitionEnd(e) {
    if (!swiper || swiper.destroyed || !swiper.$wrapperEl) return;
    if (e.target !== swiper.$wrapperEl[0]) return;
    ['transitionend', 'webkitTransitionEnd'].forEach(event => {
      swiper.$wrapperEl[0].removeEventListener(event, onTransitionEnd);
    });
    swiper.autoplay.paused = false;

    if (!swiper.autoplay.running) {
      stop();
    } else {
      run();
    }
  }

  function onMouseEnter() {
    if (swiper.params.autoplay.disableOnInteraction) {
      stop();
    } else {
      emit('autoplayPause');
      pause();
    }

    ['transitionend', 'webkitTransitionEnd'].forEach(event => {
      swiper.$wrapperEl[0].removeEventListener(event, onTransitionEnd);
    });
  }

  function onMouseLeave() {
    if (swiper.params.autoplay.disableOnInteraction) {
      return;
    }

    swiper.autoplay.paused = false;
    emit('autoplayResume');
    run();
  }

  function attachMouseEvents() {
    if (swiper.params.autoplay.pauseOnMouseEnter) {
      swiper.$el.on('mouseenter', onMouseEnter);
      swiper.$el.on('mouseleave', onMouseLeave);
    }
  }

  function detachMouseEvents() {
    swiper.$el.off('mouseenter', onMouseEnter);
    swiper.$el.off('mouseleave', onMouseLeave);
  }

  on('init', () => {
    if (swiper.params.autoplay.enabled) {
      start();
      const document = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getDocument)();
      document.addEventListener('visibilitychange', onVisibilityChange);
      attachMouseEvents();
    }
  });
  on('beforeTransitionStart', (_s, speed, internal) => {
    if (swiper.autoplay.running) {
      if (internal || !swiper.params.autoplay.disableOnInteraction) {
        swiper.autoplay.pause(speed);
      } else {
        stop();
      }
    }
  });
  on('sliderFirstMove', () => {
    if (swiper.autoplay.running) {
      if (swiper.params.autoplay.disableOnInteraction) {
        stop();
      } else {
        pause();
      }
    }
  });
  on('touchEnd', () => {
    if (swiper.params.cssMode && swiper.autoplay.paused && !swiper.params.autoplay.disableOnInteraction) {
      run();
    }
  });
  on('destroy', () => {
    detachMouseEvents();

    if (swiper.autoplay.running) {
      stop();
    }

    const document = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getDocument)();
    document.removeEventListener('visibilitychange', onVisibilityChange);
  });
  Object.assign(swiper.autoplay, {
    pause,
    run,
    start,
    stop
  });
}

/***/ }),

/***/ "./node_modules/swiper/modules/controller/controller.js":
/*!**************************************************************!*\
  !*** ./node_modules/swiper/modules/controller/controller.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Controller)
/* harmony export */ });
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/swiper/shared/utils.js");
/* eslint no-bitwise: ["error", { "allow": [">>"] }] */

function Controller(_ref) {
  let {
    swiper,
    extendParams,
    on
  } = _ref;
  extendParams({
    controller: {
      control: undefined,
      inverse: false,
      by: 'slide' // or 'container'

    }
  });
  swiper.controller = {
    control: undefined
  };

  function LinearSpline(x, y) {
    const binarySearch = function search() {
      let maxIndex;
      let minIndex;
      let guess;
      return (array, val) => {
        minIndex = -1;
        maxIndex = array.length;

        while (maxIndex - minIndex > 1) {
          guess = maxIndex + minIndex >> 1;

          if (array[guess] <= val) {
            minIndex = guess;
          } else {
            maxIndex = guess;
          }
        }

        return maxIndex;
      };
    }();

    this.x = x;
    this.y = y;
    this.lastIndex = x.length - 1; // Given an x value (x2), return the expected y2 value:
    // (x1,y1) is the known point before given value,
    // (x3,y3) is the known point after given value.

    let i1;
    let i3;

    this.interpolate = function interpolate(x2) {
      if (!x2) return 0; // Get the indexes of x1 and x3 (the array indexes before and after given x2):

      i3 = binarySearch(this.x, x2);
      i1 = i3 - 1; // We have our indexes i1 & i3, so we can calculate already:
      // y2 := ((x2−x1) × (y3−y1)) ÷ (x3−x1) + y1

      return (x2 - this.x[i1]) * (this.y[i3] - this.y[i1]) / (this.x[i3] - this.x[i1]) + this.y[i1];
    };

    return this;
  } // xxx: for now i will just save one spline function to to


  function getInterpolateFunction(c) {
    if (!swiper.controller.spline) {
      swiper.controller.spline = swiper.params.loop ? new LinearSpline(swiper.slidesGrid, c.slidesGrid) : new LinearSpline(swiper.snapGrid, c.snapGrid);
    }
  }

  function setTranslate(_t, byController) {
    const controlled = swiper.controller.control;
    let multiplier;
    let controlledTranslate;
    const Swiper = swiper.constructor;

    function setControlledTranslate(c) {
      // this will create an Interpolate function based on the snapGrids
      // x is the Grid of the scrolled scroller and y will be the controlled scroller
      // it makes sense to create this only once and recall it for the interpolation
      // the function does a lot of value caching for performance
      const translate = swiper.rtlTranslate ? -swiper.translate : swiper.translate;

      if (swiper.params.controller.by === 'slide') {
        getInterpolateFunction(c); // i am not sure why the values have to be multiplicated this way, tried to invert the snapGrid
        // but it did not work out

        controlledTranslate = -swiper.controller.spline.interpolate(-translate);
      }

      if (!controlledTranslate || swiper.params.controller.by === 'container') {
        multiplier = (c.maxTranslate() - c.minTranslate()) / (swiper.maxTranslate() - swiper.minTranslate());
        controlledTranslate = (translate - swiper.minTranslate()) * multiplier + c.minTranslate();
      }

      if (swiper.params.controller.inverse) {
        controlledTranslate = c.maxTranslate() - controlledTranslate;
      }

      c.updateProgress(controlledTranslate);
      c.setTranslate(controlledTranslate, swiper);
      c.updateActiveIndex();
      c.updateSlidesClasses();
    }

    if (Array.isArray(controlled)) {
      for (let i = 0; i < controlled.length; i += 1) {
        if (controlled[i] !== byController && controlled[i] instanceof Swiper) {
          setControlledTranslate(controlled[i]);
        }
      }
    } else if (controlled instanceof Swiper && byController !== controlled) {
      setControlledTranslate(controlled);
    }
  }

  function setTransition(duration, byController) {
    const Swiper = swiper.constructor;
    const controlled = swiper.controller.control;
    let i;

    function setControlledTransition(c) {
      c.setTransition(duration, swiper);

      if (duration !== 0) {
        c.transitionStart();

        if (c.params.autoHeight) {
          (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_0__.nextTick)(() => {
            c.updateAutoHeight();
          });
        }

        c.$wrapperEl.transitionEnd(() => {
          if (!controlled) return;

          if (c.params.loop && swiper.params.controller.by === 'slide') {
            c.loopFix();
          }

          c.transitionEnd();
        });
      }
    }

    if (Array.isArray(controlled)) {
      for (i = 0; i < controlled.length; i += 1) {
        if (controlled[i] !== byController && controlled[i] instanceof Swiper) {
          setControlledTransition(controlled[i]);
        }
      }
    } else if (controlled instanceof Swiper && byController !== controlled) {
      setControlledTransition(controlled);
    }
  }

  function removeSpline() {
    if (!swiper.controller.control) return;

    if (swiper.controller.spline) {
      swiper.controller.spline = undefined;
      delete swiper.controller.spline;
    }
  }

  on('beforeInit', () => {
    swiper.controller.control = swiper.params.controller.control;
  });
  on('update', () => {
    removeSpline();
  });
  on('resize', () => {
    removeSpline();
  });
  on('observerUpdate', () => {
    removeSpline();
  });
  on('setTranslate', (_s, translate, byController) => {
    if (!swiper.controller.control) return;
    swiper.controller.setTranslate(translate, byController);
  });
  on('setTransition', (_s, duration, byController) => {
    if (!swiper.controller.control) return;
    swiper.controller.setTransition(duration, byController);
  });
  Object.assign(swiper.controller, {
    setTranslate,
    setTransition
  });
}

/***/ }),

/***/ "./node_modules/swiper/modules/effect-cards/effect-cards.js":
/*!******************************************************************!*\
  !*** ./node_modules/swiper/modules/effect-cards/effect-cards.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ EffectCards)
/* harmony export */ });
/* harmony import */ var _shared_create_shadow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/create-shadow.js */ "./node_modules/swiper/shared/create-shadow.js");
/* harmony import */ var _shared_effect_init_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/effect-init.js */ "./node_modules/swiper/shared/effect-init.js");
/* harmony import */ var _shared_effect_target_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../shared/effect-target.js */ "./node_modules/swiper/shared/effect-target.js");
/* harmony import */ var _shared_effect_virtual_transition_end_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../shared/effect-virtual-transition-end.js */ "./node_modules/swiper/shared/effect-virtual-transition-end.js");




function EffectCards(_ref) {
  let {
    swiper,
    extendParams,
    on
  } = _ref;
  extendParams({
    cardsEffect: {
      slideShadows: true,
      transformEl: null
    }
  });

  const setTranslate = () => {
    const {
      slides,
      activeIndex
    } = swiper;
    const params = swiper.params.cardsEffect;
    const {
      startTranslate,
      isTouched
    } = swiper.touchEventsData;
    const currentTranslate = swiper.translate;

    for (let i = 0; i < slides.length; i += 1) {
      const $slideEl = slides.eq(i);
      const slideProgress = $slideEl[0].progress;
      const progress = Math.min(Math.max(slideProgress, -4), 4);
      let offset = $slideEl[0].swiperSlideOffset;

      if (swiper.params.centeredSlides && !swiper.params.cssMode) {
        swiper.$wrapperEl.transform(`translateX(${swiper.minTranslate()}px)`);
      }

      if (swiper.params.centeredSlides && swiper.params.cssMode) {
        offset -= slides[0].swiperSlideOffset;
      }

      let tX = swiper.params.cssMode ? -offset - swiper.translate : -offset;
      let tY = 0;
      const tZ = -100 * Math.abs(progress);
      let scale = 1;
      let rotate = -2 * progress;
      let tXAdd = 8 - Math.abs(progress) * 0.75;
      const isSwipeToNext = (i === activeIndex || i === activeIndex - 1) && progress > 0 && progress < 1 && (isTouched || swiper.params.cssMode) && currentTranslate < startTranslate;
      const isSwipeToPrev = (i === activeIndex || i === activeIndex + 1) && progress < 0 && progress > -1 && (isTouched || swiper.params.cssMode) && currentTranslate > startTranslate;

      if (isSwipeToNext || isSwipeToPrev) {
        const subProgress = (1 - Math.abs((Math.abs(progress) - 0.5) / 0.5)) ** 0.5;
        rotate += -28 * progress * subProgress;
        scale += -0.5 * subProgress;
        tXAdd += 96 * subProgress;
        tY = `${-25 * subProgress * Math.abs(progress)}%`;
      }

      if (progress < 0) {
        // next
        tX = `calc(${tX}px + (${tXAdd * Math.abs(progress)}%))`;
      } else if (progress > 0) {
        // prev
        tX = `calc(${tX}px + (-${tXAdd * Math.abs(progress)}%))`;
      } else {
        tX = `${tX}px`;
      }

      if (!swiper.isHorizontal()) {
        const prevY = tY;
        tY = tX;
        tX = prevY;
      }

      const scaleString = progress < 0 ? `${1 + (1 - scale) * progress}` : `${1 - (1 - scale) * progress}`;
      const transform = `
        translate3d(${tX}, ${tY}, ${tZ}px)
        rotateZ(${rotate}deg)
        scale(${scaleString})
      `;

      if (params.slideShadows) {
        // Set shadows
        let $shadowEl = $slideEl.find('.swiper-slide-shadow');

        if ($shadowEl.length === 0) {
          $shadowEl = (0,_shared_create_shadow_js__WEBPACK_IMPORTED_MODULE_0__["default"])(params, $slideEl);
        }

        if ($shadowEl.length) $shadowEl[0].style.opacity = Math.min(Math.max((Math.abs(progress) - 0.5) / 0.5, 0), 1);
      }

      $slideEl[0].style.zIndex = -Math.abs(Math.round(slideProgress)) + slides.length;
      const $targetEl = (0,_shared_effect_target_js__WEBPACK_IMPORTED_MODULE_2__["default"])(params, $slideEl);
      $targetEl.transform(transform);
    }
  };

  const setTransition = duration => {
    const {
      transformEl
    } = swiper.params.cardsEffect;
    const $transitionElements = transformEl ? swiper.slides.find(transformEl) : swiper.slides;
    $transitionElements.transition(duration).find('.swiper-slide-shadow').transition(duration);
    (0,_shared_effect_virtual_transition_end_js__WEBPACK_IMPORTED_MODULE_3__["default"])({
      swiper,
      duration,
      transformEl
    });
  };

  (0,_shared_effect_init_js__WEBPACK_IMPORTED_MODULE_1__["default"])({
    effect: 'cards',
    swiper,
    on,
    setTranslate,
    setTransition,
    perspective: () => true,
    overwriteParams: () => ({
      watchSlidesProgress: true,
      virtualTranslate: !swiper.params.cssMode
    })
  });
}

/***/ }),

/***/ "./node_modules/swiper/modules/effect-coverflow/effect-coverflow.js":
/*!**************************************************************************!*\
  !*** ./node_modules/swiper/modules/effect-coverflow/effect-coverflow.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ EffectCoverflow)
/* harmony export */ });
/* harmony import */ var _shared_create_shadow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/create-shadow.js */ "./node_modules/swiper/shared/create-shadow.js");
/* harmony import */ var _shared_effect_init_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/effect-init.js */ "./node_modules/swiper/shared/effect-init.js");
/* harmony import */ var _shared_effect_target_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../shared/effect-target.js */ "./node_modules/swiper/shared/effect-target.js");



function EffectCoverflow(_ref) {
  let {
    swiper,
    extendParams,
    on
  } = _ref;
  extendParams({
    coverflowEffect: {
      rotate: 50,
      stretch: 0,
      depth: 100,
      scale: 1,
      modifier: 1,
      slideShadows: true,
      transformEl: null
    }
  });

  const setTranslate = () => {
    const {
      width: swiperWidth,
      height: swiperHeight,
      slides,
      slidesSizesGrid
    } = swiper;
    const params = swiper.params.coverflowEffect;
    const isHorizontal = swiper.isHorizontal();
    const transform = swiper.translate;
    const center = isHorizontal ? -transform + swiperWidth / 2 : -transform + swiperHeight / 2;
    const rotate = isHorizontal ? params.rotate : -params.rotate;
    const translate = params.depth; // Each slide offset from center

    for (let i = 0, length = slides.length; i < length; i += 1) {
      const $slideEl = slides.eq(i);
      const slideSize = slidesSizesGrid[i];
      const slideOffset = $slideEl[0].swiperSlideOffset;
      const offsetMultiplier = (center - slideOffset - slideSize / 2) / slideSize * params.modifier;
      let rotateY = isHorizontal ? rotate * offsetMultiplier : 0;
      let rotateX = isHorizontal ? 0 : rotate * offsetMultiplier; // var rotateZ = 0

      let translateZ = -translate * Math.abs(offsetMultiplier);
      let stretch = params.stretch; // Allow percentage to make a relative stretch for responsive sliders

      if (typeof stretch === 'string' && stretch.indexOf('%') !== -1) {
        stretch = parseFloat(params.stretch) / 100 * slideSize;
      }

      let translateY = isHorizontal ? 0 : stretch * offsetMultiplier;
      let translateX = isHorizontal ? stretch * offsetMultiplier : 0;
      let scale = 1 - (1 - params.scale) * Math.abs(offsetMultiplier); // Fix for ultra small values

      if (Math.abs(translateX) < 0.001) translateX = 0;
      if (Math.abs(translateY) < 0.001) translateY = 0;
      if (Math.abs(translateZ) < 0.001) translateZ = 0;
      if (Math.abs(rotateY) < 0.001) rotateY = 0;
      if (Math.abs(rotateX) < 0.001) rotateX = 0;
      if (Math.abs(scale) < 0.001) scale = 0;
      const slideTransform = `translate3d(${translateX}px,${translateY}px,${translateZ}px)  rotateX(${rotateX}deg) rotateY(${rotateY}deg) scale(${scale})`;
      const $targetEl = (0,_shared_effect_target_js__WEBPACK_IMPORTED_MODULE_2__["default"])(params, $slideEl);
      $targetEl.transform(slideTransform);
      $slideEl[0].style.zIndex = -Math.abs(Math.round(offsetMultiplier)) + 1;

      if (params.slideShadows) {
        // Set shadows
        let $shadowBeforeEl = isHorizontal ? $slideEl.find('.swiper-slide-shadow-left') : $slideEl.find('.swiper-slide-shadow-top');
        let $shadowAfterEl = isHorizontal ? $slideEl.find('.swiper-slide-shadow-right') : $slideEl.find('.swiper-slide-shadow-bottom');

        if ($shadowBeforeEl.length === 0) {
          $shadowBeforeEl = (0,_shared_create_shadow_js__WEBPACK_IMPORTED_MODULE_0__["default"])(params, $slideEl, isHorizontal ? 'left' : 'top');
        }

        if ($shadowAfterEl.length === 0) {
          $shadowAfterEl = (0,_shared_create_shadow_js__WEBPACK_IMPORTED_MODULE_0__["default"])(params, $slideEl, isHorizontal ? 'right' : 'bottom');
        }

        if ($shadowBeforeEl.length) $shadowBeforeEl[0].style.opacity = offsetMultiplier > 0 ? offsetMultiplier : 0;
        if ($shadowAfterEl.length) $shadowAfterEl[0].style.opacity = -offsetMultiplier > 0 ? -offsetMultiplier : 0;
      }
    }
  };

  const setTransition = duration => {
    const {
      transformEl
    } = swiper.params.coverflowEffect;
    const $transitionElements = transformEl ? swiper.slides.find(transformEl) : swiper.slides;
    $transitionElements.transition(duration).find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').transition(duration);
  };

  (0,_shared_effect_init_js__WEBPACK_IMPORTED_MODULE_1__["default"])({
    effect: 'coverflow',
    swiper,
    on,
    setTranslate,
    setTransition,
    perspective: () => true,
    overwriteParams: () => ({
      watchSlidesProgress: true
    })
  });
}

/***/ }),

/***/ "./node_modules/swiper/modules/effect-creative/effect-creative.js":
/*!************************************************************************!*\
  !*** ./node_modules/swiper/modules/effect-creative/effect-creative.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ EffectCreative)
/* harmony export */ });
/* harmony import */ var _shared_create_shadow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/create-shadow.js */ "./node_modules/swiper/shared/create-shadow.js");
/* harmony import */ var _shared_effect_init_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/effect-init.js */ "./node_modules/swiper/shared/effect-init.js");
/* harmony import */ var _shared_effect_target_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../shared/effect-target.js */ "./node_modules/swiper/shared/effect-target.js");
/* harmony import */ var _shared_effect_virtual_transition_end_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../shared/effect-virtual-transition-end.js */ "./node_modules/swiper/shared/effect-virtual-transition-end.js");




function EffectCreative(_ref) {
  let {
    swiper,
    extendParams,
    on
  } = _ref;
  extendParams({
    creativeEffect: {
      transformEl: null,
      limitProgress: 1,
      shadowPerProgress: false,
      progressMultiplier: 1,
      perspective: true,
      prev: {
        translate: [0, 0, 0],
        rotate: [0, 0, 0],
        opacity: 1,
        scale: 1
      },
      next: {
        translate: [0, 0, 0],
        rotate: [0, 0, 0],
        opacity: 1,
        scale: 1
      }
    }
  });

  const getTranslateValue = value => {
    if (typeof value === 'string') return value;
    return `${value}px`;
  };

  const setTranslate = () => {
    const {
      slides,
      $wrapperEl,
      slidesSizesGrid
    } = swiper;
    const params = swiper.params.creativeEffect;
    const {
      progressMultiplier: multiplier
    } = params;
    const isCenteredSlides = swiper.params.centeredSlides;

    if (isCenteredSlides) {
      const margin = slidesSizesGrid[0] / 2 - swiper.params.slidesOffsetBefore || 0;
      $wrapperEl.transform(`translateX(calc(50% - ${margin}px))`);
    }

    for (let i = 0; i < slides.length; i += 1) {
      const $slideEl = slides.eq(i);
      const slideProgress = $slideEl[0].progress;
      const progress = Math.min(Math.max($slideEl[0].progress, -params.limitProgress), params.limitProgress);
      let originalProgress = progress;

      if (!isCenteredSlides) {
        originalProgress = Math.min(Math.max($slideEl[0].originalProgress, -params.limitProgress), params.limitProgress);
      }

      const offset = $slideEl[0].swiperSlideOffset;
      const t = [swiper.params.cssMode ? -offset - swiper.translate : -offset, 0, 0];
      const r = [0, 0, 0];
      let custom = false;

      if (!swiper.isHorizontal()) {
        t[1] = t[0];
        t[0] = 0;
      }

      let data = {
        translate: [0, 0, 0],
        rotate: [0, 0, 0],
        scale: 1,
        opacity: 1
      };

      if (progress < 0) {
        data = params.next;
        custom = true;
      } else if (progress > 0) {
        data = params.prev;
        custom = true;
      } // set translate


      t.forEach((value, index) => {
        t[index] = `calc(${value}px + (${getTranslateValue(data.translate[index])} * ${Math.abs(progress * multiplier)}))`;
      }); // set rotates

      r.forEach((value, index) => {
        r[index] = data.rotate[index] * Math.abs(progress * multiplier);
      });
      $slideEl[0].style.zIndex = -Math.abs(Math.round(slideProgress)) + slides.length;
      const translateString = t.join(', ');
      const rotateString = `rotateX(${r[0]}deg) rotateY(${r[1]}deg) rotateZ(${r[2]}deg)`;
      const scaleString = originalProgress < 0 ? `scale(${1 + (1 - data.scale) * originalProgress * multiplier})` : `scale(${1 - (1 - data.scale) * originalProgress * multiplier})`;
      const opacityString = originalProgress < 0 ? 1 + (1 - data.opacity) * originalProgress * multiplier : 1 - (1 - data.opacity) * originalProgress * multiplier;
      const transform = `translate3d(${translateString}) ${rotateString} ${scaleString}`; // Set shadows

      if (custom && data.shadow || !custom) {
        let $shadowEl = $slideEl.children('.swiper-slide-shadow');

        if ($shadowEl.length === 0 && data.shadow) {
          $shadowEl = (0,_shared_create_shadow_js__WEBPACK_IMPORTED_MODULE_0__["default"])(params, $slideEl);
        }

        if ($shadowEl.length) {
          const shadowOpacity = params.shadowPerProgress ? progress * (1 / params.limitProgress) : progress;
          $shadowEl[0].style.opacity = Math.min(Math.max(Math.abs(shadowOpacity), 0), 1);
        }
      }

      const $targetEl = (0,_shared_effect_target_js__WEBPACK_IMPORTED_MODULE_2__["default"])(params, $slideEl);
      $targetEl.transform(transform).css({
        opacity: opacityString
      });

      if (data.origin) {
        $targetEl.css('transform-origin', data.origin);
      }
    }
  };

  const setTransition = duration => {
    const {
      transformEl
    } = swiper.params.creativeEffect;
    const $transitionElements = transformEl ? swiper.slides.find(transformEl) : swiper.slides;
    $transitionElements.transition(duration).find('.swiper-slide-shadow').transition(duration);
    (0,_shared_effect_virtual_transition_end_js__WEBPACK_IMPORTED_MODULE_3__["default"])({
      swiper,
      duration,
      transformEl,
      allSlides: true
    });
  };

  (0,_shared_effect_init_js__WEBPACK_IMPORTED_MODULE_1__["default"])({
    effect: 'creative',
    swiper,
    on,
    setTranslate,
    setTransition,
    perspective: () => swiper.params.creativeEffect.perspective,
    overwriteParams: () => ({
      watchSlidesProgress: true,
      virtualTranslate: !swiper.params.cssMode
    })
  });
}

/***/ }),

/***/ "./node_modules/swiper/modules/effect-cube/effect-cube.js":
/*!****************************************************************!*\
  !*** ./node_modules/swiper/modules/effect-cube/effect-cube.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ EffectCube)
/* harmony export */ });
/* harmony import */ var _shared_dom_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/dom.js */ "./node_modules/swiper/shared/dom.js");
/* harmony import */ var _shared_effect_init_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/effect-init.js */ "./node_modules/swiper/shared/effect-init.js");


function EffectCube(_ref) {
  let {
    swiper,
    extendParams,
    on
  } = _ref;
  extendParams({
    cubeEffect: {
      slideShadows: true,
      shadow: true,
      shadowOffset: 20,
      shadowScale: 0.94
    }
  });

  const setTranslate = () => {
    const {
      $el,
      $wrapperEl,
      slides,
      width: swiperWidth,
      height: swiperHeight,
      rtlTranslate: rtl,
      size: swiperSize,
      browser
    } = swiper;
    const params = swiper.params.cubeEffect;
    const isHorizontal = swiper.isHorizontal();
    const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
    let wrapperRotate = 0;
    let $cubeShadowEl;

    if (params.shadow) {
      if (isHorizontal) {
        $cubeShadowEl = $wrapperEl.find('.swiper-cube-shadow');

        if ($cubeShadowEl.length === 0) {
          $cubeShadowEl = (0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_0__["default"])('<div class="swiper-cube-shadow"></div>');
          $wrapperEl.append($cubeShadowEl);
        }

        $cubeShadowEl.css({
          height: `${swiperWidth}px`
        });
      } else {
        $cubeShadowEl = $el.find('.swiper-cube-shadow');

        if ($cubeShadowEl.length === 0) {
          $cubeShadowEl = (0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_0__["default"])('<div class="swiper-cube-shadow"></div>');
          $el.append($cubeShadowEl);
        }
      }
    }

    for (let i = 0; i < slides.length; i += 1) {
      const $slideEl = slides.eq(i);
      let slideIndex = i;

      if (isVirtual) {
        slideIndex = parseInt($slideEl.attr('data-swiper-slide-index'), 10);
      }

      let slideAngle = slideIndex * 90;
      let round = Math.floor(slideAngle / 360);

      if (rtl) {
        slideAngle = -slideAngle;
        round = Math.floor(-slideAngle / 360);
      }

      const progress = Math.max(Math.min($slideEl[0].progress, 1), -1);
      let tx = 0;
      let ty = 0;
      let tz = 0;

      if (slideIndex % 4 === 0) {
        tx = -round * 4 * swiperSize;
        tz = 0;
      } else if ((slideIndex - 1) % 4 === 0) {
        tx = 0;
        tz = -round * 4 * swiperSize;
      } else if ((slideIndex - 2) % 4 === 0) {
        tx = swiperSize + round * 4 * swiperSize;
        tz = swiperSize;
      } else if ((slideIndex - 3) % 4 === 0) {
        tx = -swiperSize;
        tz = 3 * swiperSize + swiperSize * 4 * round;
      }

      if (rtl) {
        tx = -tx;
      }

      if (!isHorizontal) {
        ty = tx;
        tx = 0;
      }

      const transform = `rotateX(${isHorizontal ? 0 : -slideAngle}deg) rotateY(${isHorizontal ? slideAngle : 0}deg) translate3d(${tx}px, ${ty}px, ${tz}px)`;

      if (progress <= 1 && progress > -1) {
        wrapperRotate = slideIndex * 90 + progress * 90;
        if (rtl) wrapperRotate = -slideIndex * 90 - progress * 90;
      }

      $slideEl.transform(transform);

      if (params.slideShadows) {
        // Set shadows
        let shadowBefore = isHorizontal ? $slideEl.find('.swiper-slide-shadow-left') : $slideEl.find('.swiper-slide-shadow-top');
        let shadowAfter = isHorizontal ? $slideEl.find('.swiper-slide-shadow-right') : $slideEl.find('.swiper-slide-shadow-bottom');

        if (shadowBefore.length === 0) {
          shadowBefore = (0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_0__["default"])(`<div class="swiper-slide-shadow-${isHorizontal ? 'left' : 'top'}"></div>`);
          $slideEl.append(shadowBefore);
        }

        if (shadowAfter.length === 0) {
          shadowAfter = (0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_0__["default"])(`<div class="swiper-slide-shadow-${isHorizontal ? 'right' : 'bottom'}"></div>`);
          $slideEl.append(shadowAfter);
        }

        if (shadowBefore.length) shadowBefore[0].style.opacity = Math.max(-progress, 0);
        if (shadowAfter.length) shadowAfter[0].style.opacity = Math.max(progress, 0);
      }
    }

    $wrapperEl.css({
      '-webkit-transform-origin': `50% 50% -${swiperSize / 2}px`,
      'transform-origin': `50% 50% -${swiperSize / 2}px`
    });

    if (params.shadow) {
      if (isHorizontal) {
        $cubeShadowEl.transform(`translate3d(0px, ${swiperWidth / 2 + params.shadowOffset}px, ${-swiperWidth / 2}px) rotateX(90deg) rotateZ(0deg) scale(${params.shadowScale})`);
      } else {
        const shadowAngle = Math.abs(wrapperRotate) - Math.floor(Math.abs(wrapperRotate) / 90) * 90;
        const multiplier = 1.5 - (Math.sin(shadowAngle * 2 * Math.PI / 360) / 2 + Math.cos(shadowAngle * 2 * Math.PI / 360) / 2);
        const scale1 = params.shadowScale;
        const scale2 = params.shadowScale / multiplier;
        const offset = params.shadowOffset;
        $cubeShadowEl.transform(`scale3d(${scale1}, 1, ${scale2}) translate3d(0px, ${swiperHeight / 2 + offset}px, ${-swiperHeight / 2 / scale2}px) rotateX(-90deg)`);
      }
    }

    const zFactor = browser.isSafari || browser.isWebView ? -swiperSize / 2 : 0;
    $wrapperEl.transform(`translate3d(0px,0,${zFactor}px) rotateX(${swiper.isHorizontal() ? 0 : wrapperRotate}deg) rotateY(${swiper.isHorizontal() ? -wrapperRotate : 0}deg)`);
  };

  const setTransition = duration => {
    const {
      $el,
      slides
    } = swiper;
    slides.transition(duration).find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').transition(duration);

    if (swiper.params.cubeEffect.shadow && !swiper.isHorizontal()) {
      $el.find('.swiper-cube-shadow').transition(duration);
    }
  };

  (0,_shared_effect_init_js__WEBPACK_IMPORTED_MODULE_1__["default"])({
    effect: 'cube',
    swiper,
    on,
    setTranslate,
    setTransition,
    perspective: () => true,
    overwriteParams: () => ({
      slidesPerView: 1,
      slidesPerGroup: 1,
      watchSlidesProgress: true,
      resistanceRatio: 0,
      spaceBetween: 0,
      centeredSlides: false,
      virtualTranslate: true
    })
  });
}

/***/ }),

/***/ "./node_modules/swiper/modules/effect-fade/effect-fade.js":
/*!****************************************************************!*\
  !*** ./node_modules/swiper/modules/effect-fade/effect-fade.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ EffectFade)
/* harmony export */ });
/* harmony import */ var _shared_effect_init_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/effect-init.js */ "./node_modules/swiper/shared/effect-init.js");
/* harmony import */ var _shared_effect_target_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/effect-target.js */ "./node_modules/swiper/shared/effect-target.js");
/* harmony import */ var _shared_effect_virtual_transition_end_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../shared/effect-virtual-transition-end.js */ "./node_modules/swiper/shared/effect-virtual-transition-end.js");



function EffectFade(_ref) {
  let {
    swiper,
    extendParams,
    on
  } = _ref;
  extendParams({
    fadeEffect: {
      crossFade: false,
      transformEl: null
    }
  });

  const setTranslate = () => {
    const {
      slides
    } = swiper;
    const params = swiper.params.fadeEffect;

    for (let i = 0; i < slides.length; i += 1) {
      const $slideEl = swiper.slides.eq(i);
      const offset = $slideEl[0].swiperSlideOffset;
      let tx = -offset;
      if (!swiper.params.virtualTranslate) tx -= swiper.translate;
      let ty = 0;

      if (!swiper.isHorizontal()) {
        ty = tx;
        tx = 0;
      }

      const slideOpacity = swiper.params.fadeEffect.crossFade ? Math.max(1 - Math.abs($slideEl[0].progress), 0) : 1 + Math.min(Math.max($slideEl[0].progress, -1), 0);
      const $targetEl = (0,_shared_effect_target_js__WEBPACK_IMPORTED_MODULE_1__["default"])(params, $slideEl);
      $targetEl.css({
        opacity: slideOpacity
      }).transform(`translate3d(${tx}px, ${ty}px, 0px)`);
    }
  };

  const setTransition = duration => {
    const {
      transformEl
    } = swiper.params.fadeEffect;
    const $transitionElements = transformEl ? swiper.slides.find(transformEl) : swiper.slides;
    $transitionElements.transition(duration);
    (0,_shared_effect_virtual_transition_end_js__WEBPACK_IMPORTED_MODULE_2__["default"])({
      swiper,
      duration,
      transformEl,
      allSlides: true
    });
  };

  (0,_shared_effect_init_js__WEBPACK_IMPORTED_MODULE_0__["default"])({
    effect: 'fade',
    swiper,
    on,
    setTranslate,
    setTransition,
    overwriteParams: () => ({
      slidesPerView: 1,
      slidesPerGroup: 1,
      watchSlidesProgress: true,
      spaceBetween: 0,
      virtualTranslate: !swiper.params.cssMode
    })
  });
}

/***/ }),

/***/ "./node_modules/swiper/modules/effect-flip/effect-flip.js":
/*!****************************************************************!*\
  !*** ./node_modules/swiper/modules/effect-flip/effect-flip.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ EffectFlip)
/* harmony export */ });
/* harmony import */ var _shared_create_shadow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/create-shadow.js */ "./node_modules/swiper/shared/create-shadow.js");
/* harmony import */ var _shared_effect_init_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/effect-init.js */ "./node_modules/swiper/shared/effect-init.js");
/* harmony import */ var _shared_effect_target_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../shared/effect-target.js */ "./node_modules/swiper/shared/effect-target.js");
/* harmony import */ var _shared_effect_virtual_transition_end_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../shared/effect-virtual-transition-end.js */ "./node_modules/swiper/shared/effect-virtual-transition-end.js");




function EffectFlip(_ref) {
  let {
    swiper,
    extendParams,
    on
  } = _ref;
  extendParams({
    flipEffect: {
      slideShadows: true,
      limitRotation: true,
      transformEl: null
    }
  });

  const setTranslate = () => {
    const {
      slides,
      rtlTranslate: rtl
    } = swiper;
    const params = swiper.params.flipEffect;

    for (let i = 0; i < slides.length; i += 1) {
      const $slideEl = slides.eq(i);
      let progress = $slideEl[0].progress;

      if (swiper.params.flipEffect.limitRotation) {
        progress = Math.max(Math.min($slideEl[0].progress, 1), -1);
      }

      const offset = $slideEl[0].swiperSlideOffset;
      const rotate = -180 * progress;
      let rotateY = rotate;
      let rotateX = 0;
      let tx = swiper.params.cssMode ? -offset - swiper.translate : -offset;
      let ty = 0;

      if (!swiper.isHorizontal()) {
        ty = tx;
        tx = 0;
        rotateX = -rotateY;
        rotateY = 0;
      } else if (rtl) {
        rotateY = -rotateY;
      }

      $slideEl[0].style.zIndex = -Math.abs(Math.round(progress)) + slides.length;

      if (params.slideShadows) {
        // Set shadows
        let shadowBefore = swiper.isHorizontal() ? $slideEl.find('.swiper-slide-shadow-left') : $slideEl.find('.swiper-slide-shadow-top');
        let shadowAfter = swiper.isHorizontal() ? $slideEl.find('.swiper-slide-shadow-right') : $slideEl.find('.swiper-slide-shadow-bottom');

        if (shadowBefore.length === 0) {
          shadowBefore = (0,_shared_create_shadow_js__WEBPACK_IMPORTED_MODULE_0__["default"])(params, $slideEl, swiper.isHorizontal() ? 'left' : 'top');
        }

        if (shadowAfter.length === 0) {
          shadowAfter = (0,_shared_create_shadow_js__WEBPACK_IMPORTED_MODULE_0__["default"])(params, $slideEl, swiper.isHorizontal() ? 'right' : 'bottom');
        }

        if (shadowBefore.length) shadowBefore[0].style.opacity = Math.max(-progress, 0);
        if (shadowAfter.length) shadowAfter[0].style.opacity = Math.max(progress, 0);
      }

      const transform = `translate3d(${tx}px, ${ty}px, 0px) rotateX(${rotateX}deg) rotateY(${rotateY}deg)`;
      const $targetEl = (0,_shared_effect_target_js__WEBPACK_IMPORTED_MODULE_2__["default"])(params, $slideEl);
      $targetEl.transform(transform);
    }
  };

  const setTransition = duration => {
    const {
      transformEl
    } = swiper.params.flipEffect;
    const $transitionElements = transformEl ? swiper.slides.find(transformEl) : swiper.slides;
    $transitionElements.transition(duration).find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').transition(duration);
    (0,_shared_effect_virtual_transition_end_js__WEBPACK_IMPORTED_MODULE_3__["default"])({
      swiper,
      duration,
      transformEl
    });
  };

  (0,_shared_effect_init_js__WEBPACK_IMPORTED_MODULE_1__["default"])({
    effect: 'flip',
    swiper,
    on,
    setTranslate,
    setTransition,
    perspective: () => true,
    overwriteParams: () => ({
      slidesPerView: 1,
      slidesPerGroup: 1,
      watchSlidesProgress: true,
      spaceBetween: 0,
      virtualTranslate: !swiper.params.cssMode
    })
  });
}

/***/ }),

/***/ "./node_modules/swiper/modules/free-mode/free-mode.js":
/*!************************************************************!*\
  !*** ./node_modules/swiper/modules/free-mode/free-mode.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ freeMode)
/* harmony export */ });
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/swiper/shared/utils.js");

function freeMode(_ref) {
  let {
    swiper,
    extendParams,
    emit,
    once
  } = _ref;
  extendParams({
    freeMode: {
      enabled: false,
      momentum: true,
      momentumRatio: 1,
      momentumBounce: true,
      momentumBounceRatio: 1,
      momentumVelocityRatio: 1,
      sticky: false,
      minimumVelocity: 0.02
    }
  });

  function onTouchStart() {
    const translate = swiper.getTranslate();
    swiper.setTranslate(translate);
    swiper.setTransition(0);
    swiper.touchEventsData.velocities.length = 0;
    swiper.freeMode.onTouchEnd({
      currentPos: swiper.rtl ? swiper.translate : -swiper.translate
    });
  }

  function onTouchMove() {
    const {
      touchEventsData: data,
      touches
    } = swiper; // Velocity

    if (data.velocities.length === 0) {
      data.velocities.push({
        position: touches[swiper.isHorizontal() ? 'startX' : 'startY'],
        time: data.touchStartTime
      });
    }

    data.velocities.push({
      position: touches[swiper.isHorizontal() ? 'currentX' : 'currentY'],
      time: (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_0__.now)()
    });
  }

  function onTouchEnd(_ref2) {
    let {
      currentPos
    } = _ref2;
    const {
      params,
      $wrapperEl,
      rtlTranslate: rtl,
      snapGrid,
      touchEventsData: data
    } = swiper; // Time diff

    const touchEndTime = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_0__.now)();
    const timeDiff = touchEndTime - data.touchStartTime;

    if (currentPos < -swiper.minTranslate()) {
      swiper.slideTo(swiper.activeIndex);
      return;
    }

    if (currentPos > -swiper.maxTranslate()) {
      if (swiper.slides.length < snapGrid.length) {
        swiper.slideTo(snapGrid.length - 1);
      } else {
        swiper.slideTo(swiper.slides.length - 1);
      }

      return;
    }

    if (params.freeMode.momentum) {
      if (data.velocities.length > 1) {
        const lastMoveEvent = data.velocities.pop();
        const velocityEvent = data.velocities.pop();
        const distance = lastMoveEvent.position - velocityEvent.position;
        const time = lastMoveEvent.time - velocityEvent.time;
        swiper.velocity = distance / time;
        swiper.velocity /= 2;

        if (Math.abs(swiper.velocity) < params.freeMode.minimumVelocity) {
          swiper.velocity = 0;
        } // this implies that the user stopped moving a finger then released.
        // There would be no events with distance zero, so the last event is stale.


        if (time > 150 || (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_0__.now)() - lastMoveEvent.time > 300) {
          swiper.velocity = 0;
        }
      } else {
        swiper.velocity = 0;
      }

      swiper.velocity *= params.freeMode.momentumVelocityRatio;
      data.velocities.length = 0;
      let momentumDuration = 1000 * params.freeMode.momentumRatio;
      const momentumDistance = swiper.velocity * momentumDuration;
      let newPosition = swiper.translate + momentumDistance;
      if (rtl) newPosition = -newPosition;
      let doBounce = false;
      let afterBouncePosition;
      const bounceAmount = Math.abs(swiper.velocity) * 20 * params.freeMode.momentumBounceRatio;
      let needsLoopFix;

      if (newPosition < swiper.maxTranslate()) {
        if (params.freeMode.momentumBounce) {
          if (newPosition + swiper.maxTranslate() < -bounceAmount) {
            newPosition = swiper.maxTranslate() - bounceAmount;
          }

          afterBouncePosition = swiper.maxTranslate();
          doBounce = true;
          data.allowMomentumBounce = true;
        } else {
          newPosition = swiper.maxTranslate();
        }

        if (params.loop && params.centeredSlides) needsLoopFix = true;
      } else if (newPosition > swiper.minTranslate()) {
        if (params.freeMode.momentumBounce) {
          if (newPosition - swiper.minTranslate() > bounceAmount) {
            newPosition = swiper.minTranslate() + bounceAmount;
          }

          afterBouncePosition = swiper.minTranslate();
          doBounce = true;
          data.allowMomentumBounce = true;
        } else {
          newPosition = swiper.minTranslate();
        }

        if (params.loop && params.centeredSlides) needsLoopFix = true;
      } else if (params.freeMode.sticky) {
        let nextSlide;

        for (let j = 0; j < snapGrid.length; j += 1) {
          if (snapGrid[j] > -newPosition) {
            nextSlide = j;
            break;
          }
        }

        if (Math.abs(snapGrid[nextSlide] - newPosition) < Math.abs(snapGrid[nextSlide - 1] - newPosition) || swiper.swipeDirection === 'next') {
          newPosition = snapGrid[nextSlide];
        } else {
          newPosition = snapGrid[nextSlide - 1];
        }

        newPosition = -newPosition;
      }

      if (needsLoopFix) {
        once('transitionEnd', () => {
          swiper.loopFix();
        });
      } // Fix duration


      if (swiper.velocity !== 0) {
        if (rtl) {
          momentumDuration = Math.abs((-newPosition - swiper.translate) / swiper.velocity);
        } else {
          momentumDuration = Math.abs((newPosition - swiper.translate) / swiper.velocity);
        }

        if (params.freeMode.sticky) {
          // If freeMode.sticky is active and the user ends a swipe with a slow-velocity
          // event, then durations can be 20+ seconds to slide one (or zero!) slides.
          // It's easy to see this when simulating touch with mouse events. To fix this,
          // limit single-slide swipes to the default slide duration. This also has the
          // nice side effect of matching slide speed if the user stopped moving before
          // lifting finger or mouse vs. moving slowly before lifting the finger/mouse.
          // For faster swipes, also apply limits (albeit higher ones).
          const moveDistance = Math.abs((rtl ? -newPosition : newPosition) - swiper.translate);
          const currentSlideSize = swiper.slidesSizesGrid[swiper.activeIndex];

          if (moveDistance < currentSlideSize) {
            momentumDuration = params.speed;
          } else if (moveDistance < 2 * currentSlideSize) {
            momentumDuration = params.speed * 1.5;
          } else {
            momentumDuration = params.speed * 2.5;
          }
        }
      } else if (params.freeMode.sticky) {
        swiper.slideToClosest();
        return;
      }

      if (params.freeMode.momentumBounce && doBounce) {
        swiper.updateProgress(afterBouncePosition);
        swiper.setTransition(momentumDuration);
        swiper.setTranslate(newPosition);
        swiper.transitionStart(true, swiper.swipeDirection);
        swiper.animating = true;
        $wrapperEl.transitionEnd(() => {
          if (!swiper || swiper.destroyed || !data.allowMomentumBounce) return;
          emit('momentumBounce');
          swiper.setTransition(params.speed);
          setTimeout(() => {
            swiper.setTranslate(afterBouncePosition);
            $wrapperEl.transitionEnd(() => {
              if (!swiper || swiper.destroyed) return;
              swiper.transitionEnd();
            });
          }, 0);
        });
      } else if (swiper.velocity) {
        emit('_freeModeNoMomentumRelease');
        swiper.updateProgress(newPosition);
        swiper.setTransition(momentumDuration);
        swiper.setTranslate(newPosition);
        swiper.transitionStart(true, swiper.swipeDirection);

        if (!swiper.animating) {
          swiper.animating = true;
          $wrapperEl.transitionEnd(() => {
            if (!swiper || swiper.destroyed) return;
            swiper.transitionEnd();
          });
        }
      } else {
        swiper.updateProgress(newPosition);
      }

      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();
    } else if (params.freeMode.sticky) {
      swiper.slideToClosest();
      return;
    } else if (params.freeMode) {
      emit('_freeModeNoMomentumRelease');
    }

    if (!params.freeMode.momentum || timeDiff >= params.longSwipesMs) {
      swiper.updateProgress();
      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();
    }
  }

  Object.assign(swiper, {
    freeMode: {
      onTouchStart,
      onTouchMove,
      onTouchEnd
    }
  });
}

/***/ }),

/***/ "./node_modules/swiper/modules/grid/grid.js":
/*!**************************************************!*\
  !*** ./node_modules/swiper/modules/grid/grid.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Grid)
/* harmony export */ });
function Grid(_ref) {
  let {
    swiper,
    extendParams
  } = _ref;
  extendParams({
    grid: {
      rows: 1,
      fill: 'column'
    }
  });
  let slidesNumberEvenToRows;
  let slidesPerRow;
  let numFullColumns;

  const initSlides = slidesLength => {
    const {
      slidesPerView
    } = swiper.params;
    const {
      rows,
      fill
    } = swiper.params.grid;
    slidesPerRow = slidesNumberEvenToRows / rows;
    numFullColumns = Math.floor(slidesLength / rows);

    if (Math.floor(slidesLength / rows) === slidesLength / rows) {
      slidesNumberEvenToRows = slidesLength;
    } else {
      slidesNumberEvenToRows = Math.ceil(slidesLength / rows) * rows;
    }

    if (slidesPerView !== 'auto' && fill === 'row') {
      slidesNumberEvenToRows = Math.max(slidesNumberEvenToRows, slidesPerView * rows);
    }
  };

  const updateSlide = (i, slide, slidesLength, getDirectionLabel) => {
    const {
      slidesPerGroup,
      spaceBetween
    } = swiper.params;
    const {
      rows,
      fill
    } = swiper.params.grid; // Set slides order

    let newSlideOrderIndex;
    let column;
    let row;

    if (fill === 'row' && slidesPerGroup > 1) {
      const groupIndex = Math.floor(i / (slidesPerGroup * rows));
      const slideIndexInGroup = i - rows * slidesPerGroup * groupIndex;
      const columnsInGroup = groupIndex === 0 ? slidesPerGroup : Math.min(Math.ceil((slidesLength - groupIndex * rows * slidesPerGroup) / rows), slidesPerGroup);
      row = Math.floor(slideIndexInGroup / columnsInGroup);
      column = slideIndexInGroup - row * columnsInGroup + groupIndex * slidesPerGroup;
      newSlideOrderIndex = column + row * slidesNumberEvenToRows / rows;
      slide.css({
        '-webkit-order': newSlideOrderIndex,
        order: newSlideOrderIndex
      });
    } else if (fill === 'column') {
      column = Math.floor(i / rows);
      row = i - column * rows;

      if (column > numFullColumns || column === numFullColumns && row === rows - 1) {
        row += 1;

        if (row >= rows) {
          row = 0;
          column += 1;
        }
      }
    } else {
      row = Math.floor(i / slidesPerRow);
      column = i - row * slidesPerRow;
    }

    slide.css(getDirectionLabel('margin-top'), row !== 0 ? spaceBetween && `${spaceBetween}px` : '');
  };

  const updateWrapperSize = (slideSize, snapGrid, getDirectionLabel) => {
    const {
      spaceBetween,
      centeredSlides,
      roundLengths
    } = swiper.params;
    const {
      rows
    } = swiper.params.grid;
    swiper.virtualSize = (slideSize + spaceBetween) * slidesNumberEvenToRows;
    swiper.virtualSize = Math.ceil(swiper.virtualSize / rows) - spaceBetween;
    swiper.$wrapperEl.css({
      [getDirectionLabel('width')]: `${swiper.virtualSize + spaceBetween}px`
    });

    if (centeredSlides) {
      snapGrid.splice(0, snapGrid.length);
      const newSlidesGrid = [];

      for (let i = 0; i < snapGrid.length; i += 1) {
        let slidesGridItem = snapGrid[i];
        if (roundLengths) slidesGridItem = Math.floor(slidesGridItem);
        if (snapGrid[i] < swiper.virtualSize + snapGrid[0]) newSlidesGrid.push(slidesGridItem);
      }

      snapGrid.push(...newSlidesGrid);
    }
  };

  swiper.grid = {
    initSlides,
    updateSlide,
    updateWrapperSize
  };
}

/***/ }),

/***/ "./node_modules/swiper/modules/hash-navigation/hash-navigation.js":
/*!************************************************************************!*\
  !*** ./node_modules/swiper/modules/hash-navigation/hash-navigation.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ HashNavigation)
/* harmony export */ });
/* harmony import */ var ssr_window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ssr-window */ "./node_modules/ssr-window/ssr-window.esm.js");
/* harmony import */ var _shared_dom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/dom.js */ "./node_modules/swiper/shared/dom.js");


function HashNavigation(_ref) {
  let {
    swiper,
    extendParams,
    emit,
    on
  } = _ref;
  let initialized = false;
  const document = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getDocument)();
  const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();
  extendParams({
    hashNavigation: {
      enabled: false,
      replaceState: false,
      watchState: false
    }
  });

  const onHashChange = () => {
    emit('hashChange');
    const newHash = document.location.hash.replace('#', '');
    const activeSlideHash = swiper.slides.eq(swiper.activeIndex).attr('data-hash');

    if (newHash !== activeSlideHash) {
      const newIndex = swiper.$wrapperEl.children(`.${swiper.params.slideClass}[data-hash="${newHash}"]`).index();
      if (typeof newIndex === 'undefined') return;
      swiper.slideTo(newIndex);
    }
  };

  const setHash = () => {
    if (!initialized || !swiper.params.hashNavigation.enabled) return;

    if (swiper.params.hashNavigation.replaceState && window.history && window.history.replaceState) {
      window.history.replaceState(null, null, `#${swiper.slides.eq(swiper.activeIndex).attr('data-hash')}` || '');
      emit('hashSet');
    } else {
      const slide = swiper.slides.eq(swiper.activeIndex);
      const hash = slide.attr('data-hash') || slide.attr('data-history');
      document.location.hash = hash || '';
      emit('hashSet');
    }
  };

  const init = () => {
    if (!swiper.params.hashNavigation.enabled || swiper.params.history && swiper.params.history.enabled) return;
    initialized = true;
    const hash = document.location.hash.replace('#', '');

    if (hash) {
      const speed = 0;

      for (let i = 0, length = swiper.slides.length; i < length; i += 1) {
        const slide = swiper.slides.eq(i);
        const slideHash = slide.attr('data-hash') || slide.attr('data-history');

        if (slideHash === hash && !slide.hasClass(swiper.params.slideDuplicateClass)) {
          const index = slide.index();
          swiper.slideTo(index, speed, swiper.params.runCallbacksOnInit, true);
        }
      }
    }

    if (swiper.params.hashNavigation.watchState) {
      (0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_1__["default"])(window).on('hashchange', onHashChange);
    }
  };

  const destroy = () => {
    if (swiper.params.hashNavigation.watchState) {
      (0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_1__["default"])(window).off('hashchange', onHashChange);
    }
  };

  on('init', () => {
    if (swiper.params.hashNavigation.enabled) {
      init();
    }
  });
  on('destroy', () => {
    if (swiper.params.hashNavigation.enabled) {
      destroy();
    }
  });
  on('transitionEnd _freeModeNoMomentumRelease', () => {
    if (initialized) {
      setHash();
    }
  });
  on('slideChange', () => {
    if (initialized && swiper.params.cssMode) {
      setHash();
    }
  });
}

/***/ }),

/***/ "./node_modules/swiper/modules/history/history.js":
/*!********************************************************!*\
  !*** ./node_modules/swiper/modules/history/history.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ History)
/* harmony export */ });
/* harmony import */ var ssr_window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ssr-window */ "./node_modules/ssr-window/ssr-window.esm.js");

function History(_ref) {
  let {
    swiper,
    extendParams,
    on
  } = _ref;
  extendParams({
    history: {
      enabled: false,
      root: '',
      replaceState: false,
      key: 'slides'
    }
  });
  let initialized = false;
  let paths = {};

  const slugify = text => {
    return text.toString().replace(/\s+/g, '-').replace(/[^\w-]+/g, '').replace(/--+/g, '-').replace(/^-+/, '').replace(/-+$/, '');
  };

  const getPathValues = urlOverride => {
    const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();
    let location;

    if (urlOverride) {
      location = new URL(urlOverride);
    } else {
      location = window.location;
    }

    const pathArray = location.pathname.slice(1).split('/').filter(part => part !== '');
    const total = pathArray.length;
    const key = pathArray[total - 2];
    const value = pathArray[total - 1];
    return {
      key,
      value
    };
  };

  const setHistory = (key, index) => {
    const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();
    if (!initialized || !swiper.params.history.enabled) return;
    let location;

    if (swiper.params.url) {
      location = new URL(swiper.params.url);
    } else {
      location = window.location;
    }

    const slide = swiper.slides.eq(index);
    let value = slugify(slide.attr('data-history'));

    if (swiper.params.history.root.length > 0) {
      let root = swiper.params.history.root;
      if (root[root.length - 1] === '/') root = root.slice(0, root.length - 1);
      value = `${root}/${key}/${value}`;
    } else if (!location.pathname.includes(key)) {
      value = `${key}/${value}`;
    }

    const currentState = window.history.state;

    if (currentState && currentState.value === value) {
      return;
    }

    if (swiper.params.history.replaceState) {
      window.history.replaceState({
        value
      }, null, value);
    } else {
      window.history.pushState({
        value
      }, null, value);
    }
  };

  const scrollToSlide = (speed, value, runCallbacks) => {
    if (value) {
      for (let i = 0, length = swiper.slides.length; i < length; i += 1) {
        const slide = swiper.slides.eq(i);
        const slideHistory = slugify(slide.attr('data-history'));

        if (slideHistory === value && !slide.hasClass(swiper.params.slideDuplicateClass)) {
          const index = slide.index();
          swiper.slideTo(index, speed, runCallbacks);
        }
      }
    } else {
      swiper.slideTo(0, speed, runCallbacks);
    }
  };

  const setHistoryPopState = () => {
    paths = getPathValues(swiper.params.url);
    scrollToSlide(swiper.params.speed, swiper.paths.value, false);
  };

  const init = () => {
    const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();
    if (!swiper.params.history) return;

    if (!window.history || !window.history.pushState) {
      swiper.params.history.enabled = false;
      swiper.params.hashNavigation.enabled = true;
      return;
    }

    initialized = true;
    paths = getPathValues(swiper.params.url);
    if (!paths.key && !paths.value) return;
    scrollToSlide(0, paths.value, swiper.params.runCallbacksOnInit);

    if (!swiper.params.history.replaceState) {
      window.addEventListener('popstate', setHistoryPopState);
    }
  };

  const destroy = () => {
    const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();

    if (!swiper.params.history.replaceState) {
      window.removeEventListener('popstate', setHistoryPopState);
    }
  };

  on('init', () => {
    if (swiper.params.history.enabled) {
      init();
    }
  });
  on('destroy', () => {
    if (swiper.params.history.enabled) {
      destroy();
    }
  });
  on('transitionEnd _freeModeNoMomentumRelease', () => {
    if (initialized) {
      setHistory(swiper.params.history.key, swiper.activeIndex);
    }
  });
  on('slideChange', () => {
    if (initialized && swiper.params.cssMode) {
      setHistory(swiper.params.history.key, swiper.activeIndex);
    }
  });
}

/***/ }),

/***/ "./node_modules/swiper/modules/keyboard/keyboard.js":
/*!**********************************************************!*\
  !*** ./node_modules/swiper/modules/keyboard/keyboard.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Keyboard)
/* harmony export */ });
/* harmony import */ var ssr_window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ssr-window */ "./node_modules/ssr-window/ssr-window.esm.js");
/* harmony import */ var _shared_dom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/dom.js */ "./node_modules/swiper/shared/dom.js");
/* eslint-disable consistent-return */


function Keyboard(_ref) {
  let {
    swiper,
    extendParams,
    on,
    emit
  } = _ref;
  const document = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getDocument)();
  const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();
  swiper.keyboard = {
    enabled: false
  };
  extendParams({
    keyboard: {
      enabled: false,
      onlyInViewport: true,
      pageUpDown: true
    }
  });

  function handle(event) {
    if (!swiper.enabled) return;
    const {
      rtlTranslate: rtl
    } = swiper;
    let e = event;
    if (e.originalEvent) e = e.originalEvent; // jquery fix

    const kc = e.keyCode || e.charCode;
    const pageUpDown = swiper.params.keyboard.pageUpDown;
    const isPageUp = pageUpDown && kc === 33;
    const isPageDown = pageUpDown && kc === 34;
    const isArrowLeft = kc === 37;
    const isArrowRight = kc === 39;
    const isArrowUp = kc === 38;
    const isArrowDown = kc === 40; // Directions locks

    if (!swiper.allowSlideNext && (swiper.isHorizontal() && isArrowRight || swiper.isVertical() && isArrowDown || isPageDown)) {
      return false;
    }

    if (!swiper.allowSlidePrev && (swiper.isHorizontal() && isArrowLeft || swiper.isVertical() && isArrowUp || isPageUp)) {
      return false;
    }

    if (e.shiftKey || e.altKey || e.ctrlKey || e.metaKey) {
      return undefined;
    }

    if (document.activeElement && document.activeElement.nodeName && (document.activeElement.nodeName.toLowerCase() === 'input' || document.activeElement.nodeName.toLowerCase() === 'textarea')) {
      return undefined;
    }

    if (swiper.params.keyboard.onlyInViewport && (isPageUp || isPageDown || isArrowLeft || isArrowRight || isArrowUp || isArrowDown)) {
      let inView = false; // Check that swiper should be inside of visible area of window

      if (swiper.$el.parents(`.${swiper.params.slideClass}`).length > 0 && swiper.$el.parents(`.${swiper.params.slideActiveClass}`).length === 0) {
        return undefined;
      }

      const $el = swiper.$el;
      const swiperWidth = $el[0].clientWidth;
      const swiperHeight = $el[0].clientHeight;
      const windowWidth = window.innerWidth;
      const windowHeight = window.innerHeight;
      const swiperOffset = swiper.$el.offset();
      if (rtl) swiperOffset.left -= swiper.$el[0].scrollLeft;
      const swiperCoord = [[swiperOffset.left, swiperOffset.top], [swiperOffset.left + swiperWidth, swiperOffset.top], [swiperOffset.left, swiperOffset.top + swiperHeight], [swiperOffset.left + swiperWidth, swiperOffset.top + swiperHeight]];

      for (let i = 0; i < swiperCoord.length; i += 1) {
        const point = swiperCoord[i];

        if (point[0] >= 0 && point[0] <= windowWidth && point[1] >= 0 && point[1] <= windowHeight) {
          if (point[0] === 0 && point[1] === 0) continue; // eslint-disable-line

          inView = true;
        }
      }

      if (!inView) return undefined;
    }

    if (swiper.isHorizontal()) {
      if (isPageUp || isPageDown || isArrowLeft || isArrowRight) {
        if (e.preventDefault) e.preventDefault();else e.returnValue = false;
      }

      if ((isPageDown || isArrowRight) && !rtl || (isPageUp || isArrowLeft) && rtl) swiper.slideNext();
      if ((isPageUp || isArrowLeft) && !rtl || (isPageDown || isArrowRight) && rtl) swiper.slidePrev();
    } else {
      if (isPageUp || isPageDown || isArrowUp || isArrowDown) {
        if (e.preventDefault) e.preventDefault();else e.returnValue = false;
      }

      if (isPageDown || isArrowDown) swiper.slideNext();
      if (isPageUp || isArrowUp) swiper.slidePrev();
    }

    emit('keyPress', kc);
    return undefined;
  }

  function enable() {
    if (swiper.keyboard.enabled) return;
    (0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_1__["default"])(document).on('keydown', handle);
    swiper.keyboard.enabled = true;
  }

  function disable() {
    if (!swiper.keyboard.enabled) return;
    (0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_1__["default"])(document).off('keydown', handle);
    swiper.keyboard.enabled = false;
  }

  on('init', () => {
    if (swiper.params.keyboard.enabled) {
      enable();
    }
  });
  on('destroy', () => {
    if (swiper.keyboard.enabled) {
      disable();
    }
  });
  Object.assign(swiper.keyboard, {
    enable,
    disable
  });
}

/***/ }),

/***/ "./node_modules/swiper/modules/lazy/lazy.js":
/*!**************************************************!*\
  !*** ./node_modules/swiper/modules/lazy/lazy.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Lazy)
/* harmony export */ });
/* harmony import */ var ssr_window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ssr-window */ "./node_modules/ssr-window/ssr-window.esm.js");
/* harmony import */ var _shared_dom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/dom.js */ "./node_modules/swiper/shared/dom.js");


function Lazy(_ref) {
  let {
    swiper,
    extendParams,
    on,
    emit
  } = _ref;
  extendParams({
    lazy: {
      checkInView: false,
      enabled: false,
      loadPrevNext: false,
      loadPrevNextAmount: 1,
      loadOnTransitionStart: false,
      scrollingElement: '',
      elementClass: 'swiper-lazy',
      loadingClass: 'swiper-lazy-loading',
      loadedClass: 'swiper-lazy-loaded',
      preloaderClass: 'swiper-lazy-preloader'
    }
  });
  swiper.lazy = {};
  let scrollHandlerAttached = false;
  let initialImageLoaded = false;

  function loadInSlide(index, loadInDuplicate) {
    if (loadInDuplicate === void 0) {
      loadInDuplicate = true;
    }

    const params = swiper.params.lazy;
    if (typeof index === 'undefined') return;
    if (swiper.slides.length === 0) return;
    const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
    const $slideEl = isVirtual ? swiper.$wrapperEl.children(`.${swiper.params.slideClass}[data-swiper-slide-index="${index}"]`) : swiper.slides.eq(index);
    const $images = $slideEl.find(`.${params.elementClass}:not(.${params.loadedClass}):not(.${params.loadingClass})`);

    if ($slideEl.hasClass(params.elementClass) && !$slideEl.hasClass(params.loadedClass) && !$slideEl.hasClass(params.loadingClass)) {
      $images.push($slideEl[0]);
    }

    if ($images.length === 0) return;
    $images.each(imageEl => {
      const $imageEl = (0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_1__["default"])(imageEl);
      $imageEl.addClass(params.loadingClass);
      const background = $imageEl.attr('data-background');
      const src = $imageEl.attr('data-src');
      const srcset = $imageEl.attr('data-srcset');
      const sizes = $imageEl.attr('data-sizes');
      const $pictureEl = $imageEl.parent('picture');
      swiper.loadImage($imageEl[0], src || background, srcset, sizes, false, () => {
        if (typeof swiper === 'undefined' || swiper === null || !swiper || swiper && !swiper.params || swiper.destroyed) return;

        if (background) {
          $imageEl.css('background-image', `url("${background}")`);
          $imageEl.removeAttr('data-background');
        } else {
          if (srcset) {
            $imageEl.attr('srcset', srcset);
            $imageEl.removeAttr('data-srcset');
          }

          if (sizes) {
            $imageEl.attr('sizes', sizes);
            $imageEl.removeAttr('data-sizes');
          }

          if ($pictureEl.length) {
            $pictureEl.children('source').each(sourceEl => {
              const $source = (0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_1__["default"])(sourceEl);

              if ($source.attr('data-srcset')) {
                $source.attr('srcset', $source.attr('data-srcset'));
                $source.removeAttr('data-srcset');
              }
            });
          }

          if (src) {
            $imageEl.attr('src', src);
            $imageEl.removeAttr('data-src');
          }
        }

        $imageEl.addClass(params.loadedClass).removeClass(params.loadingClass);
        $slideEl.find(`.${params.preloaderClass}`).remove();

        if (swiper.params.loop && loadInDuplicate) {
          const slideOriginalIndex = $slideEl.attr('data-swiper-slide-index');

          if ($slideEl.hasClass(swiper.params.slideDuplicateClass)) {
            const originalSlide = swiper.$wrapperEl.children(`[data-swiper-slide-index="${slideOriginalIndex}"]:not(.${swiper.params.slideDuplicateClass})`);
            loadInSlide(originalSlide.index(), false);
          } else {
            const duplicatedSlide = swiper.$wrapperEl.children(`.${swiper.params.slideDuplicateClass}[data-swiper-slide-index="${slideOriginalIndex}"]`);
            loadInSlide(duplicatedSlide.index(), false);
          }
        }

        emit('lazyImageReady', $slideEl[0], $imageEl[0]);

        if (swiper.params.autoHeight) {
          swiper.updateAutoHeight();
        }
      });
      emit('lazyImageLoad', $slideEl[0], $imageEl[0]);
    });
  }

  function load() {
    const {
      $wrapperEl,
      params: swiperParams,
      slides,
      activeIndex
    } = swiper;
    const isVirtual = swiper.virtual && swiperParams.virtual.enabled;
    const params = swiperParams.lazy;
    let slidesPerView = swiperParams.slidesPerView;

    if (slidesPerView === 'auto') {
      slidesPerView = 0;
    }

    function slideExist(index) {
      if (isVirtual) {
        if ($wrapperEl.children(`.${swiperParams.slideClass}[data-swiper-slide-index="${index}"]`).length) {
          return true;
        }
      } else if (slides[index]) return true;

      return false;
    }

    function slideIndex(slideEl) {
      if (isVirtual) {
        return (0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_1__["default"])(slideEl).attr('data-swiper-slide-index');
      }

      return (0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_1__["default"])(slideEl).index();
    }

    if (!initialImageLoaded) initialImageLoaded = true;

    if (swiper.params.watchSlidesProgress) {
      $wrapperEl.children(`.${swiperParams.slideVisibleClass}`).each(slideEl => {
        const index = isVirtual ? (0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_1__["default"])(slideEl).attr('data-swiper-slide-index') : (0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_1__["default"])(slideEl).index();
        loadInSlide(index);
      });
    } else if (slidesPerView > 1) {
      for (let i = activeIndex; i < activeIndex + slidesPerView; i += 1) {
        if (slideExist(i)) loadInSlide(i);
      }
    } else {
      loadInSlide(activeIndex);
    }

    if (params.loadPrevNext) {
      if (slidesPerView > 1 || params.loadPrevNextAmount && params.loadPrevNextAmount > 1) {
        const amount = params.loadPrevNextAmount;
        const spv = slidesPerView;
        const maxIndex = Math.min(activeIndex + spv + Math.max(amount, spv), slides.length);
        const minIndex = Math.max(activeIndex - Math.max(spv, amount), 0); // Next Slides

        for (let i = activeIndex + slidesPerView; i < maxIndex; i += 1) {
          if (slideExist(i)) loadInSlide(i);
        } // Prev Slides


        for (let i = minIndex; i < activeIndex; i += 1) {
          if (slideExist(i)) loadInSlide(i);
        }
      } else {
        const nextSlide = $wrapperEl.children(`.${swiperParams.slideNextClass}`);
        if (nextSlide.length > 0) loadInSlide(slideIndex(nextSlide));
        const prevSlide = $wrapperEl.children(`.${swiperParams.slidePrevClass}`);
        if (prevSlide.length > 0) loadInSlide(slideIndex(prevSlide));
      }
    }
  }

  function checkInViewOnLoad() {
    const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();
    if (!swiper || swiper.destroyed) return;
    const $scrollElement = swiper.params.lazy.scrollingElement ? (0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_1__["default"])(swiper.params.lazy.scrollingElement) : (0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_1__["default"])(window);
    const isWindow = $scrollElement[0] === window;
    const scrollElementWidth = isWindow ? window.innerWidth : $scrollElement[0].offsetWidth;
    const scrollElementHeight = isWindow ? window.innerHeight : $scrollElement[0].offsetHeight;
    const swiperOffset = swiper.$el.offset();
    const {
      rtlTranslate: rtl
    } = swiper;
    let inView = false;
    if (rtl) swiperOffset.left -= swiper.$el[0].scrollLeft;
    const swiperCoord = [[swiperOffset.left, swiperOffset.top], [swiperOffset.left + swiper.width, swiperOffset.top], [swiperOffset.left, swiperOffset.top + swiper.height], [swiperOffset.left + swiper.width, swiperOffset.top + swiper.height]];

    for (let i = 0; i < swiperCoord.length; i += 1) {
      const point = swiperCoord[i];

      if (point[0] >= 0 && point[0] <= scrollElementWidth && point[1] >= 0 && point[1] <= scrollElementHeight) {
        if (point[0] === 0 && point[1] === 0) continue; // eslint-disable-line

        inView = true;
      }
    }

    const passiveListener = swiper.touchEvents.start === 'touchstart' && swiper.support.passiveListener && swiper.params.passiveListeners ? {
      passive: true,
      capture: false
    } : false;

    if (inView) {
      load();
      $scrollElement.off('scroll', checkInViewOnLoad, passiveListener);
    } else if (!scrollHandlerAttached) {
      scrollHandlerAttached = true;
      $scrollElement.on('scroll', checkInViewOnLoad, passiveListener);
    }
  }

  on('beforeInit', () => {
    if (swiper.params.lazy.enabled && swiper.params.preloadImages) {
      swiper.params.preloadImages = false;
    }
  });
  on('init', () => {
    if (swiper.params.lazy.enabled) {
      if (swiper.params.lazy.checkInView) {
        checkInViewOnLoad();
      } else {
        load();
      }
    }
  });
  on('scroll', () => {
    if (swiper.params.freeMode && swiper.params.freeMode.enabled && !swiper.params.freeMode.sticky) {
      load();
    }
  });
  on('scrollbarDragMove resize _freeModeNoMomentumRelease', () => {
    if (swiper.params.lazy.enabled) {
      if (swiper.params.lazy.checkInView) {
        checkInViewOnLoad();
      } else {
        load();
      }
    }
  });
  on('transitionStart', () => {
    if (swiper.params.lazy.enabled) {
      if (swiper.params.lazy.loadOnTransitionStart || !swiper.params.lazy.loadOnTransitionStart && !initialImageLoaded) {
        if (swiper.params.lazy.checkInView) {
          checkInViewOnLoad();
        } else {
          load();
        }
      }
    }
  });
  on('transitionEnd', () => {
    if (swiper.params.lazy.enabled && !swiper.params.lazy.loadOnTransitionStart) {
      if (swiper.params.lazy.checkInView) {
        checkInViewOnLoad();
      } else {
        load();
      }
    }
  });
  on('slideChange', () => {
    const {
      lazy,
      cssMode,
      watchSlidesProgress,
      touchReleaseOnEdges,
      resistanceRatio
    } = swiper.params;

    if (lazy.enabled && (cssMode || watchSlidesProgress && (touchReleaseOnEdges || resistanceRatio === 0))) {
      load();
    }
  });
  Object.assign(swiper.lazy, {
    load,
    loadInSlide
  });
}

/***/ }),

/***/ "./node_modules/swiper/modules/manipulation/manipulation.js":
/*!******************************************************************!*\
  !*** ./node_modules/swiper/modules/manipulation/manipulation.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Manipulation)
/* harmony export */ });
/* harmony import */ var _methods_appendSlide_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./methods/appendSlide.js */ "./node_modules/swiper/modules/manipulation/methods/appendSlide.js");
/* harmony import */ var _methods_prependSlide_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./methods/prependSlide.js */ "./node_modules/swiper/modules/manipulation/methods/prependSlide.js");
/* harmony import */ var _methods_addSlide_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./methods/addSlide.js */ "./node_modules/swiper/modules/manipulation/methods/addSlide.js");
/* harmony import */ var _methods_removeSlide_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./methods/removeSlide.js */ "./node_modules/swiper/modules/manipulation/methods/removeSlide.js");
/* harmony import */ var _methods_removeAllSlides_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./methods/removeAllSlides.js */ "./node_modules/swiper/modules/manipulation/methods/removeAllSlides.js");





function Manipulation(_ref) {
  let {
    swiper
  } = _ref;
  Object.assign(swiper, {
    appendSlide: _methods_appendSlide_js__WEBPACK_IMPORTED_MODULE_0__["default"].bind(swiper),
    prependSlide: _methods_prependSlide_js__WEBPACK_IMPORTED_MODULE_1__["default"].bind(swiper),
    addSlide: _methods_addSlide_js__WEBPACK_IMPORTED_MODULE_2__["default"].bind(swiper),
    removeSlide: _methods_removeSlide_js__WEBPACK_IMPORTED_MODULE_3__["default"].bind(swiper),
    removeAllSlides: _methods_removeAllSlides_js__WEBPACK_IMPORTED_MODULE_4__["default"].bind(swiper)
  });
}

/***/ }),

/***/ "./node_modules/swiper/modules/manipulation/methods/addSlide.js":
/*!**********************************************************************!*\
  !*** ./node_modules/swiper/modules/manipulation/methods/addSlide.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ addSlide)
/* harmony export */ });
function addSlide(index, slides) {
  const swiper = this;
  const {
    $wrapperEl,
    params,
    activeIndex
  } = swiper;
  let activeIndexBuffer = activeIndex;

  if (params.loop) {
    activeIndexBuffer -= swiper.loopedSlides;
    swiper.loopDestroy();
    swiper.slides = $wrapperEl.children(`.${params.slideClass}`);
  }

  const baseLength = swiper.slides.length;

  if (index <= 0) {
    swiper.prependSlide(slides);
    return;
  }

  if (index >= baseLength) {
    swiper.appendSlide(slides);
    return;
  }

  let newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + 1 : activeIndexBuffer;
  const slidesBuffer = [];

  for (let i = baseLength - 1; i >= index; i -= 1) {
    const currentSlide = swiper.slides.eq(i);
    currentSlide.remove();
    slidesBuffer.unshift(currentSlide);
  }

  if (typeof slides === 'object' && 'length' in slides) {
    for (let i = 0; i < slides.length; i += 1) {
      if (slides[i]) $wrapperEl.append(slides[i]);
    }

    newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + slides.length : activeIndexBuffer;
  } else {
    $wrapperEl.append(slides);
  }

  for (let i = 0; i < slidesBuffer.length; i += 1) {
    $wrapperEl.append(slidesBuffer[i]);
  }

  if (params.loop) {
    swiper.loopCreate();
  }

  if (!params.observer) {
    swiper.update();
  }

  if (params.loop) {
    swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);
  } else {
    swiper.slideTo(newActiveIndex, 0, false);
  }
}

/***/ }),

/***/ "./node_modules/swiper/modules/manipulation/methods/appendSlide.js":
/*!*************************************************************************!*\
  !*** ./node_modules/swiper/modules/manipulation/methods/appendSlide.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ appendSlide)
/* harmony export */ });
function appendSlide(slides) {
  const swiper = this;
  const {
    $wrapperEl,
    params
  } = swiper;

  if (params.loop) {
    swiper.loopDestroy();
  }

  if (typeof slides === 'object' && 'length' in slides) {
    for (let i = 0; i < slides.length; i += 1) {
      if (slides[i]) $wrapperEl.append(slides[i]);
    }
  } else {
    $wrapperEl.append(slides);
  }

  if (params.loop) {
    swiper.loopCreate();
  }

  if (!params.observer) {
    swiper.update();
  }
}

/***/ }),

/***/ "./node_modules/swiper/modules/manipulation/methods/prependSlide.js":
/*!**************************************************************************!*\
  !*** ./node_modules/swiper/modules/manipulation/methods/prependSlide.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ prependSlide)
/* harmony export */ });
function prependSlide(slides) {
  const swiper = this;
  const {
    params,
    $wrapperEl,
    activeIndex
  } = swiper;

  if (params.loop) {
    swiper.loopDestroy();
  }

  let newActiveIndex = activeIndex + 1;

  if (typeof slides === 'object' && 'length' in slides) {
    for (let i = 0; i < slides.length; i += 1) {
      if (slides[i]) $wrapperEl.prepend(slides[i]);
    }

    newActiveIndex = activeIndex + slides.length;
  } else {
    $wrapperEl.prepend(slides);
  }

  if (params.loop) {
    swiper.loopCreate();
  }

  if (!params.observer) {
    swiper.update();
  }

  swiper.slideTo(newActiveIndex, 0, false);
}

/***/ }),

/***/ "./node_modules/swiper/modules/manipulation/methods/removeAllSlides.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/swiper/modules/manipulation/methods/removeAllSlides.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ removeAllSlides)
/* harmony export */ });
function removeAllSlides() {
  const swiper = this;
  const slidesIndexes = [];

  for (let i = 0; i < swiper.slides.length; i += 1) {
    slidesIndexes.push(i);
  }

  swiper.removeSlide(slidesIndexes);
}

/***/ }),

/***/ "./node_modules/swiper/modules/manipulation/methods/removeSlide.js":
/*!*************************************************************************!*\
  !*** ./node_modules/swiper/modules/manipulation/methods/removeSlide.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ removeSlide)
/* harmony export */ });
function removeSlide(slidesIndexes) {
  const swiper = this;
  const {
    params,
    $wrapperEl,
    activeIndex
  } = swiper;
  let activeIndexBuffer = activeIndex;

  if (params.loop) {
    activeIndexBuffer -= swiper.loopedSlides;
    swiper.loopDestroy();
    swiper.slides = $wrapperEl.children(`.${params.slideClass}`);
  }

  let newActiveIndex = activeIndexBuffer;
  let indexToRemove;

  if (typeof slidesIndexes === 'object' && 'length' in slidesIndexes) {
    for (let i = 0; i < slidesIndexes.length; i += 1) {
      indexToRemove = slidesIndexes[i];
      if (swiper.slides[indexToRemove]) swiper.slides.eq(indexToRemove).remove();
      if (indexToRemove < newActiveIndex) newActiveIndex -= 1;
    }

    newActiveIndex = Math.max(newActiveIndex, 0);
  } else {
    indexToRemove = slidesIndexes;
    if (swiper.slides[indexToRemove]) swiper.slides.eq(indexToRemove).remove();
    if (indexToRemove < newActiveIndex) newActiveIndex -= 1;
    newActiveIndex = Math.max(newActiveIndex, 0);
  }

  if (params.loop) {
    swiper.loopCreate();
  }

  if (!params.observer) {
    swiper.update();
  }

  if (params.loop) {
    swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);
  } else {
    swiper.slideTo(newActiveIndex, 0, false);
  }
}

/***/ }),

/***/ "./node_modules/swiper/modules/mousewheel/mousewheel.js":
/*!**************************************************************!*\
  !*** ./node_modules/swiper/modules/mousewheel/mousewheel.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Mousewheel)
/* harmony export */ });
/* harmony import */ var ssr_window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ssr-window */ "./node_modules/ssr-window/ssr-window.esm.js");
/* harmony import */ var _shared_dom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/dom.js */ "./node_modules/swiper/shared/dom.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/swiper/shared/utils.js");
/* eslint-disable consistent-return */



function Mousewheel(_ref) {
  let {
    swiper,
    extendParams,
    on,
    emit
  } = _ref;
  const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();
  extendParams({
    mousewheel: {
      enabled: false,
      releaseOnEdges: false,
      invert: false,
      forceToAxis: false,
      sensitivity: 1,
      eventsTarget: 'container',
      thresholdDelta: null,
      thresholdTime: null
    }
  });
  swiper.mousewheel = {
    enabled: false
  };
  let timeout;
  let lastScrollTime = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.now)();
  let lastEventBeforeSnap;
  const recentWheelEvents = [];

  function normalize(e) {
    // Reasonable defaults
    const PIXEL_STEP = 10;
    const LINE_HEIGHT = 40;
    const PAGE_HEIGHT = 800;
    let sX = 0;
    let sY = 0; // spinX, spinY

    let pX = 0;
    let pY = 0; // pixelX, pixelY
    // Legacy

    if ('detail' in e) {
      sY = e.detail;
    }

    if ('wheelDelta' in e) {
      sY = -e.wheelDelta / 120;
    }

    if ('wheelDeltaY' in e) {
      sY = -e.wheelDeltaY / 120;
    }

    if ('wheelDeltaX' in e) {
      sX = -e.wheelDeltaX / 120;
    } // side scrolling on FF with DOMMouseScroll


    if ('axis' in e && e.axis === e.HORIZONTAL_AXIS) {
      sX = sY;
      sY = 0;
    }

    pX = sX * PIXEL_STEP;
    pY = sY * PIXEL_STEP;

    if ('deltaY' in e) {
      pY = e.deltaY;
    }

    if ('deltaX' in e) {
      pX = e.deltaX;
    }

    if (e.shiftKey && !pX) {
      // if user scrolls with shift he wants horizontal scroll
      pX = pY;
      pY = 0;
    }

    if ((pX || pY) && e.deltaMode) {
      if (e.deltaMode === 1) {
        // delta in LINE units
        pX *= LINE_HEIGHT;
        pY *= LINE_HEIGHT;
      } else {
        // delta in PAGE units
        pX *= PAGE_HEIGHT;
        pY *= PAGE_HEIGHT;
      }
    } // Fall-back if spin cannot be determined


    if (pX && !sX) {
      sX = pX < 1 ? -1 : 1;
    }

    if (pY && !sY) {
      sY = pY < 1 ? -1 : 1;
    }

    return {
      spinX: sX,
      spinY: sY,
      pixelX: pX,
      pixelY: pY
    };
  }

  function handleMouseEnter() {
    if (!swiper.enabled) return;
    swiper.mouseEntered = true;
  }

  function handleMouseLeave() {
    if (!swiper.enabled) return;
    swiper.mouseEntered = false;
  }

  function animateSlider(newEvent) {
    if (swiper.params.mousewheel.thresholdDelta && newEvent.delta < swiper.params.mousewheel.thresholdDelta) {
      // Prevent if delta of wheel scroll delta is below configured threshold
      return false;
    }

    if (swiper.params.mousewheel.thresholdTime && (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.now)() - lastScrollTime < swiper.params.mousewheel.thresholdTime) {
      // Prevent if time between scrolls is below configured threshold
      return false;
    } // If the movement is NOT big enough and
    // if the last time the user scrolled was too close to the current one (avoid continuously triggering the slider):
    //   Don't go any further (avoid insignificant scroll movement).


    if (newEvent.delta >= 6 && (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.now)() - lastScrollTime < 60) {
      // Return false as a default
      return true;
    } // If user is scrolling towards the end:
    //   If the slider hasn't hit the latest slide or
    //   if the slider is a loop and
    //   if the slider isn't moving right now:
    //     Go to next slide and
    //     emit a scroll event.
    // Else (the user is scrolling towards the beginning) and
    // if the slider hasn't hit the first slide or
    // if the slider is a loop and
    // if the slider isn't moving right now:
    //   Go to prev slide and
    //   emit a scroll event.


    if (newEvent.direction < 0) {
      if ((!swiper.isEnd || swiper.params.loop) && !swiper.animating) {
        swiper.slideNext();
        emit('scroll', newEvent.raw);
      }
    } else if ((!swiper.isBeginning || swiper.params.loop) && !swiper.animating) {
      swiper.slidePrev();
      emit('scroll', newEvent.raw);
    } // If you got here is because an animation has been triggered so store the current time


    lastScrollTime = new window.Date().getTime(); // Return false as a default

    return false;
  }

  function releaseScroll(newEvent) {
    const params = swiper.params.mousewheel;

    if (newEvent.direction < 0) {
      if (swiper.isEnd && !swiper.params.loop && params.releaseOnEdges) {
        // Return true to animate scroll on edges
        return true;
      }
    } else if (swiper.isBeginning && !swiper.params.loop && params.releaseOnEdges) {
      // Return true to animate scroll on edges
      return true;
    }

    return false;
  }

  function handle(event) {
    let e = event;
    let disableParentSwiper = true;
    if (!swiper.enabled) return;
    const params = swiper.params.mousewheel;

    if (swiper.params.cssMode) {
      e.preventDefault();
    }

    let target = swiper.$el;

    if (swiper.params.mousewheel.eventsTarget !== 'container') {
      target = (0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_1__["default"])(swiper.params.mousewheel.eventsTarget);
    }

    if (!swiper.mouseEntered && !target[0].contains(e.target) && !params.releaseOnEdges) return true;
    if (e.originalEvent) e = e.originalEvent; // jquery fix

    let delta = 0;
    const rtlFactor = swiper.rtlTranslate ? -1 : 1;
    const data = normalize(e);

    if (params.forceToAxis) {
      if (swiper.isHorizontal()) {
        if (Math.abs(data.pixelX) > Math.abs(data.pixelY)) delta = -data.pixelX * rtlFactor;else return true;
      } else if (Math.abs(data.pixelY) > Math.abs(data.pixelX)) delta = -data.pixelY;else return true;
    } else {
      delta = Math.abs(data.pixelX) > Math.abs(data.pixelY) ? -data.pixelX * rtlFactor : -data.pixelY;
    }

    if (delta === 0) return true;
    if (params.invert) delta = -delta; // Get the scroll positions

    let positions = swiper.getTranslate() + delta * params.sensitivity;
    if (positions >= swiper.minTranslate()) positions = swiper.minTranslate();
    if (positions <= swiper.maxTranslate()) positions = swiper.maxTranslate(); // When loop is true:
    //     the disableParentSwiper will be true.
    // When loop is false:
    //     if the scroll positions is not on edge,
    //     then the disableParentSwiper will be true.
    //     if the scroll on edge positions,
    //     then the disableParentSwiper will be false.

    disableParentSwiper = swiper.params.loop ? true : !(positions === swiper.minTranslate() || positions === swiper.maxTranslate());
    if (disableParentSwiper && swiper.params.nested) e.stopPropagation();

    if (!swiper.params.freeMode || !swiper.params.freeMode.enabled) {
      // Register the new event in a variable which stores the relevant data
      const newEvent = {
        time: (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.now)(),
        delta: Math.abs(delta),
        direction: Math.sign(delta),
        raw: event
      }; // Keep the most recent events

      if (recentWheelEvents.length >= 2) {
        recentWheelEvents.shift(); // only store the last N events
      }

      const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : undefined;
      recentWheelEvents.push(newEvent); // If there is at least one previous recorded event:
      //   If direction has changed or
      //   if the scroll is quicker than the previous one:
      //     Animate the slider.
      // Else (this is the first time the wheel is moved):
      //     Animate the slider.

      if (prevEvent) {
        if (newEvent.direction !== prevEvent.direction || newEvent.delta > prevEvent.delta || newEvent.time > prevEvent.time + 150) {
          animateSlider(newEvent);
        }
      } else {
        animateSlider(newEvent);
      } // If it's time to release the scroll:
      //   Return now so you don't hit the preventDefault.


      if (releaseScroll(newEvent)) {
        return true;
      }
    } else {
      // Freemode or scrollContainer:
      // If we recently snapped after a momentum scroll, then ignore wheel events
      // to give time for the deceleration to finish. Stop ignoring after 500 msecs
      // or if it's a new scroll (larger delta or inverse sign as last event before
      // an end-of-momentum snap).
      const newEvent = {
        time: (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.now)(),
        delta: Math.abs(delta),
        direction: Math.sign(delta)
      };
      const ignoreWheelEvents = lastEventBeforeSnap && newEvent.time < lastEventBeforeSnap.time + 500 && newEvent.delta <= lastEventBeforeSnap.delta && newEvent.direction === lastEventBeforeSnap.direction;

      if (!ignoreWheelEvents) {
        lastEventBeforeSnap = undefined;

        if (swiper.params.loop) {
          swiper.loopFix();
        }

        let position = swiper.getTranslate() + delta * params.sensitivity;
        const wasBeginning = swiper.isBeginning;
        const wasEnd = swiper.isEnd;
        if (position >= swiper.minTranslate()) position = swiper.minTranslate();
        if (position <= swiper.maxTranslate()) position = swiper.maxTranslate();
        swiper.setTransition(0);
        swiper.setTranslate(position);
        swiper.updateProgress();
        swiper.updateActiveIndex();
        swiper.updateSlidesClasses();

        if (!wasBeginning && swiper.isBeginning || !wasEnd && swiper.isEnd) {
          swiper.updateSlidesClasses();
        }

        if (swiper.params.freeMode.sticky) {
          // When wheel scrolling starts with sticky (aka snap) enabled, then detect
          // the end of a momentum scroll by storing recent (N=15?) wheel events.
          // 1. do all N events have decreasing or same (absolute value) delta?
          // 2. did all N events arrive in the last M (M=500?) msecs?
          // 3. does the earliest event have an (absolute value) delta that's
          //    at least P (P=1?) larger than the most recent event's delta?
          // 4. does the latest event have a delta that's smaller than Q (Q=6?) pixels?
          // If 1-4 are "yes" then we're near the end of a momentum scroll deceleration.
          // Snap immediately and ignore remaining wheel events in this scroll.
          // See comment above for "remaining wheel events in this scroll" determination.
          // If 1-4 aren't satisfied, then wait to snap until 500ms after the last event.
          clearTimeout(timeout);
          timeout = undefined;

          if (recentWheelEvents.length >= 15) {
            recentWheelEvents.shift(); // only store the last N events
          }

          const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : undefined;
          const firstEvent = recentWheelEvents[0];
          recentWheelEvents.push(newEvent);

          if (prevEvent && (newEvent.delta > prevEvent.delta || newEvent.direction !== prevEvent.direction)) {
            // Increasing or reverse-sign delta means the user started scrolling again. Clear the wheel event log.
            recentWheelEvents.splice(0);
          } else if (recentWheelEvents.length >= 15 && newEvent.time - firstEvent.time < 500 && firstEvent.delta - newEvent.delta >= 1 && newEvent.delta <= 6) {
            // We're at the end of the deceleration of a momentum scroll, so there's no need
            // to wait for more events. Snap ASAP on the next tick.
            // Also, because there's some remaining momentum we'll bias the snap in the
            // direction of the ongoing scroll because it's better UX for the scroll to snap
            // in the same direction as the scroll instead of reversing to snap.  Therefore,
            // if it's already scrolled more than 20% in the current direction, keep going.
            const snapToThreshold = delta > 0 ? 0.8 : 0.2;
            lastEventBeforeSnap = newEvent;
            recentWheelEvents.splice(0);
            timeout = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.nextTick)(() => {
              swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);
            }, 0); // no delay; move on next tick
          }

          if (!timeout) {
            // if we get here, then we haven't detected the end of a momentum scroll, so
            // we'll consider a scroll "complete" when there haven't been any wheel events
            // for 500ms.
            timeout = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.nextTick)(() => {
              const snapToThreshold = 0.5;
              lastEventBeforeSnap = newEvent;
              recentWheelEvents.splice(0);
              swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);
            }, 500);
          }
        } // Emit event


        if (!ignoreWheelEvents) emit('scroll', e); // Stop autoplay

        if (swiper.params.autoplay && swiper.params.autoplayDisableOnInteraction) swiper.autoplay.stop(); // Return page scroll on edge positions

        if (position === swiper.minTranslate() || position === swiper.maxTranslate()) return true;
      }
    }

    if (e.preventDefault) e.preventDefault();else e.returnValue = false;
    return false;
  }

  function events(method) {
    let target = swiper.$el;

    if (swiper.params.mousewheel.eventsTarget !== 'container') {
      target = (0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_1__["default"])(swiper.params.mousewheel.eventsTarget);
    }

    target[method]('mouseenter', handleMouseEnter);
    target[method]('mouseleave', handleMouseLeave);
    target[method]('wheel', handle);
  }

  function enable() {
    if (swiper.params.cssMode) {
      swiper.wrapperEl.removeEventListener('wheel', handle);
      return true;
    }

    if (swiper.mousewheel.enabled) return false;
    events('on');
    swiper.mousewheel.enabled = true;
    return true;
  }

  function disable() {
    if (swiper.params.cssMode) {
      swiper.wrapperEl.addEventListener(event, handle);
      return true;
    }

    if (!swiper.mousewheel.enabled) return false;
    events('off');
    swiper.mousewheel.enabled = false;
    return true;
  }

  on('init', () => {
    if (!swiper.params.mousewheel.enabled && swiper.params.cssMode) {
      disable();
    }

    if (swiper.params.mousewheel.enabled) enable();
  });
  on('destroy', () => {
    if (swiper.params.cssMode) {
      enable();
    }

    if (swiper.mousewheel.enabled) disable();
  });
  Object.assign(swiper.mousewheel, {
    enable,
    disable
  });
}

/***/ }),

/***/ "./node_modules/swiper/modules/navigation/navigation.js":
/*!**************************************************************!*\
  !*** ./node_modules/swiper/modules/navigation/navigation.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Navigation)
/* harmony export */ });
/* harmony import */ var _shared_create_element_if_not_defined_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/create-element-if-not-defined.js */ "./node_modules/swiper/shared/create-element-if-not-defined.js");
/* harmony import */ var _shared_dom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/dom.js */ "./node_modules/swiper/shared/dom.js");


function Navigation(_ref) {
  let {
    swiper,
    extendParams,
    on,
    emit
  } = _ref;
  extendParams({
    navigation: {
      nextEl: null,
      prevEl: null,
      hideOnClick: false,
      disabledClass: 'swiper-button-disabled',
      hiddenClass: 'swiper-button-hidden',
      lockClass: 'swiper-button-lock'
    }
  });
  swiper.navigation = {
    nextEl: null,
    $nextEl: null,
    prevEl: null,
    $prevEl: null
  };

  function getEl(el) {
    let $el;

    if (el) {
      $el = (0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_1__["default"])(el);

      if (swiper.params.uniqueNavElements && typeof el === 'string' && $el.length > 1 && swiper.$el.find(el).length === 1) {
        $el = swiper.$el.find(el);
      }
    }

    return $el;
  }

  function toggleEl($el, disabled) {
    const params = swiper.params.navigation;

    if ($el && $el.length > 0) {
      $el[disabled ? 'addClass' : 'removeClass'](params.disabledClass);
      if ($el[0] && $el[0].tagName === 'BUTTON') $el[0].disabled = disabled;

      if (swiper.params.watchOverflow && swiper.enabled) {
        $el[swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);
      }
    }
  }

  function update() {
    // Update Navigation Buttons
    if (swiper.params.loop) return;
    const {
      $nextEl,
      $prevEl
    } = swiper.navigation;
    toggleEl($prevEl, swiper.isBeginning && !swiper.params.rewind);
    toggleEl($nextEl, swiper.isEnd && !swiper.params.rewind);
  }

  function onPrevClick(e) {
    e.preventDefault();
    if (swiper.isBeginning && !swiper.params.loop && !swiper.params.rewind) return;
    swiper.slidePrev();
  }

  function onNextClick(e) {
    e.preventDefault();
    if (swiper.isEnd && !swiper.params.loop && !swiper.params.rewind) return;
    swiper.slideNext();
  }

  function init() {
    const params = swiper.params.navigation;
    swiper.params.navigation = (0,_shared_create_element_if_not_defined_js__WEBPACK_IMPORTED_MODULE_0__["default"])(swiper, swiper.originalParams.navigation, swiper.params.navigation, {
      nextEl: 'swiper-button-next',
      prevEl: 'swiper-button-prev'
    });
    if (!(params.nextEl || params.prevEl)) return;
    const $nextEl = getEl(params.nextEl);
    const $prevEl = getEl(params.prevEl);

    if ($nextEl && $nextEl.length > 0) {
      $nextEl.on('click', onNextClick);
    }

    if ($prevEl && $prevEl.length > 0) {
      $prevEl.on('click', onPrevClick);
    }

    Object.assign(swiper.navigation, {
      $nextEl,
      nextEl: $nextEl && $nextEl[0],
      $prevEl,
      prevEl: $prevEl && $prevEl[0]
    });

    if (!swiper.enabled) {
      if ($nextEl) $nextEl.addClass(params.lockClass);
      if ($prevEl) $prevEl.addClass(params.lockClass);
    }
  }

  function destroy() {
    const {
      $nextEl,
      $prevEl
    } = swiper.navigation;

    if ($nextEl && $nextEl.length) {
      $nextEl.off('click', onNextClick);
      $nextEl.removeClass(swiper.params.navigation.disabledClass);
    }

    if ($prevEl && $prevEl.length) {
      $prevEl.off('click', onPrevClick);
      $prevEl.removeClass(swiper.params.navigation.disabledClass);
    }
  }

  on('init', () => {
    init();
    update();
  });
  on('toEdge fromEdge lock unlock', () => {
    update();
  });
  on('destroy', () => {
    destroy();
  });
  on('enable disable', () => {
    const {
      $nextEl,
      $prevEl
    } = swiper.navigation;

    if ($nextEl) {
      $nextEl[swiper.enabled ? 'removeClass' : 'addClass'](swiper.params.navigation.lockClass);
    }

    if ($prevEl) {
      $prevEl[swiper.enabled ? 'removeClass' : 'addClass'](swiper.params.navigation.lockClass);
    }
  });
  on('click', (_s, e) => {
    const {
      $nextEl,
      $prevEl
    } = swiper.navigation;
    const targetEl = e.target;

    if (swiper.params.navigation.hideOnClick && !(0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_1__["default"])(targetEl).is($prevEl) && !(0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_1__["default"])(targetEl).is($nextEl)) {
      if (swiper.pagination && swiper.params.pagination && swiper.params.pagination.clickable && (swiper.pagination.el === targetEl || swiper.pagination.el.contains(targetEl))) return;
      let isHidden;

      if ($nextEl) {
        isHidden = $nextEl.hasClass(swiper.params.navigation.hiddenClass);
      } else if ($prevEl) {
        isHidden = $prevEl.hasClass(swiper.params.navigation.hiddenClass);
      }

      if (isHidden === true) {
        emit('navigationShow');
      } else {
        emit('navigationHide');
      }

      if ($nextEl) {
        $nextEl.toggleClass(swiper.params.navigation.hiddenClass);
      }

      if ($prevEl) {
        $prevEl.toggleClass(swiper.params.navigation.hiddenClass);
      }
    }
  });
  Object.assign(swiper.navigation, {
    update,
    init,
    destroy
  });
}

/***/ }),

/***/ "./node_modules/swiper/modules/pagination/pagination.js":
/*!**************************************************************!*\
  !*** ./node_modules/swiper/modules/pagination/pagination.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Pagination)
/* harmony export */ });
/* harmony import */ var _shared_dom_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/dom.js */ "./node_modules/swiper/shared/dom.js");
/* harmony import */ var _shared_classes_to_selector_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/classes-to-selector.js */ "./node_modules/swiper/shared/classes-to-selector.js");
/* harmony import */ var _shared_create_element_if_not_defined_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../shared/create-element-if-not-defined.js */ "./node_modules/swiper/shared/create-element-if-not-defined.js");



function Pagination(_ref) {
  let {
    swiper,
    extendParams,
    on,
    emit
  } = _ref;
  const pfx = 'swiper-pagination';
  extendParams({
    pagination: {
      el: null,
      bulletElement: 'span',
      clickable: false,
      hideOnClick: false,
      renderBullet: null,
      renderProgressbar: null,
      renderFraction: null,
      renderCustom: null,
      progressbarOpposite: false,
      type: 'bullets',
      // 'bullets' or 'progressbar' or 'fraction' or 'custom'
      dynamicBullets: false,
      dynamicMainBullets: 1,
      formatFractionCurrent: number => number,
      formatFractionTotal: number => number,
      bulletClass: `${pfx}-bullet`,
      bulletActiveClass: `${pfx}-bullet-active`,
      modifierClass: `${pfx}-`,
      currentClass: `${pfx}-current`,
      totalClass: `${pfx}-total`,
      hiddenClass: `${pfx}-hidden`,
      progressbarFillClass: `${pfx}-progressbar-fill`,
      progressbarOppositeClass: `${pfx}-progressbar-opposite`,
      clickableClass: `${pfx}-clickable`,
      lockClass: `${pfx}-lock`,
      horizontalClass: `${pfx}-horizontal`,
      verticalClass: `${pfx}-vertical`
    }
  });
  swiper.pagination = {
    el: null,
    $el: null,
    bullets: []
  };
  let bulletSize;
  let dynamicBulletIndex = 0;

  function isPaginationDisabled() {
    return !swiper.params.pagination.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0;
  }

  function setSideBullets($bulletEl, position) {
    const {
      bulletActiveClass
    } = swiper.params.pagination;
    $bulletEl[position]().addClass(`${bulletActiveClass}-${position}`)[position]().addClass(`${bulletActiveClass}-${position}-${position}`);
  }

  function update() {
    // Render || Update Pagination bullets/items
    const rtl = swiper.rtl;
    const params = swiper.params.pagination;
    if (isPaginationDisabled()) return;
    const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;
    const $el = swiper.pagination.$el; // Current/Total

    let current;
    const total = swiper.params.loop ? Math.ceil((slidesLength - swiper.loopedSlides * 2) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;

    if (swiper.params.loop) {
      current = Math.ceil((swiper.activeIndex - swiper.loopedSlides) / swiper.params.slidesPerGroup);

      if (current > slidesLength - 1 - swiper.loopedSlides * 2) {
        current -= slidesLength - swiper.loopedSlides * 2;
      }

      if (current > total - 1) current -= total;
      if (current < 0 && swiper.params.paginationType !== 'bullets') current = total + current;
    } else if (typeof swiper.snapIndex !== 'undefined') {
      current = swiper.snapIndex;
    } else {
      current = swiper.activeIndex || 0;
    } // Types


    if (params.type === 'bullets' && swiper.pagination.bullets && swiper.pagination.bullets.length > 0) {
      const bullets = swiper.pagination.bullets;
      let firstIndex;
      let lastIndex;
      let midIndex;

      if (params.dynamicBullets) {
        bulletSize = bullets.eq(0)[swiper.isHorizontal() ? 'outerWidth' : 'outerHeight'](true);
        $el.css(swiper.isHorizontal() ? 'width' : 'height', `${bulletSize * (params.dynamicMainBullets + 4)}px`);

        if (params.dynamicMainBullets > 1 && swiper.previousIndex !== undefined) {
          dynamicBulletIndex += current - (swiper.previousIndex - swiper.loopedSlides || 0);

          if (dynamicBulletIndex > params.dynamicMainBullets - 1) {
            dynamicBulletIndex = params.dynamicMainBullets - 1;
          } else if (dynamicBulletIndex < 0) {
            dynamicBulletIndex = 0;
          }
        }

        firstIndex = Math.max(current - dynamicBulletIndex, 0);
        lastIndex = firstIndex + (Math.min(bullets.length, params.dynamicMainBullets) - 1);
        midIndex = (lastIndex + firstIndex) / 2;
      }

      bullets.removeClass(['', '-next', '-next-next', '-prev', '-prev-prev', '-main'].map(suffix => `${params.bulletActiveClass}${suffix}`).join(' '));

      if ($el.length > 1) {
        bullets.each(bullet => {
          const $bullet = (0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_0__["default"])(bullet);
          const bulletIndex = $bullet.index();

          if (bulletIndex === current) {
            $bullet.addClass(params.bulletActiveClass);
          }

          if (params.dynamicBullets) {
            if (bulletIndex >= firstIndex && bulletIndex <= lastIndex) {
              $bullet.addClass(`${params.bulletActiveClass}-main`);
            }

            if (bulletIndex === firstIndex) {
              setSideBullets($bullet, 'prev');
            }

            if (bulletIndex === lastIndex) {
              setSideBullets($bullet, 'next');
            }
          }
        });
      } else {
        const $bullet = bullets.eq(current);
        const bulletIndex = $bullet.index();
        $bullet.addClass(params.bulletActiveClass);

        if (params.dynamicBullets) {
          const $firstDisplayedBullet = bullets.eq(firstIndex);
          const $lastDisplayedBullet = bullets.eq(lastIndex);

          for (let i = firstIndex; i <= lastIndex; i += 1) {
            bullets.eq(i).addClass(`${params.bulletActiveClass}-main`);
          }

          if (swiper.params.loop) {
            if (bulletIndex >= bullets.length) {
              for (let i = params.dynamicMainBullets; i >= 0; i -= 1) {
                bullets.eq(bullets.length - i).addClass(`${params.bulletActiveClass}-main`);
              }

              bullets.eq(bullets.length - params.dynamicMainBullets - 1).addClass(`${params.bulletActiveClass}-prev`);
            } else {
              setSideBullets($firstDisplayedBullet, 'prev');
              setSideBullets($lastDisplayedBullet, 'next');
            }
          } else {
            setSideBullets($firstDisplayedBullet, 'prev');
            setSideBullets($lastDisplayedBullet, 'next');
          }
        }
      }

      if (params.dynamicBullets) {
        const dynamicBulletsLength = Math.min(bullets.length, params.dynamicMainBullets + 4);
        const bulletsOffset = (bulletSize * dynamicBulletsLength - bulletSize) / 2 - midIndex * bulletSize;
        const offsetProp = rtl ? 'right' : 'left';
        bullets.css(swiper.isHorizontal() ? offsetProp : 'top', `${bulletsOffset}px`);
      }
    }

    if (params.type === 'fraction') {
      $el.find((0,_shared_classes_to_selector_js__WEBPACK_IMPORTED_MODULE_1__["default"])(params.currentClass)).text(params.formatFractionCurrent(current + 1));
      $el.find((0,_shared_classes_to_selector_js__WEBPACK_IMPORTED_MODULE_1__["default"])(params.totalClass)).text(params.formatFractionTotal(total));
    }

    if (params.type === 'progressbar') {
      let progressbarDirection;

      if (params.progressbarOpposite) {
        progressbarDirection = swiper.isHorizontal() ? 'vertical' : 'horizontal';
      } else {
        progressbarDirection = swiper.isHorizontal() ? 'horizontal' : 'vertical';
      }

      const scale = (current + 1) / total;
      let scaleX = 1;
      let scaleY = 1;

      if (progressbarDirection === 'horizontal') {
        scaleX = scale;
      } else {
        scaleY = scale;
      }

      $el.find((0,_shared_classes_to_selector_js__WEBPACK_IMPORTED_MODULE_1__["default"])(params.progressbarFillClass)).transform(`translate3d(0,0,0) scaleX(${scaleX}) scaleY(${scaleY})`).transition(swiper.params.speed);
    }

    if (params.type === 'custom' && params.renderCustom) {
      $el.html(params.renderCustom(swiper, current + 1, total));
      emit('paginationRender', $el[0]);
    } else {
      emit('paginationUpdate', $el[0]);
    }

    if (swiper.params.watchOverflow && swiper.enabled) {
      $el[swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);
    }
  }

  function render() {
    // Render Container
    const params = swiper.params.pagination;
    if (isPaginationDisabled()) return;
    const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;
    const $el = swiper.pagination.$el;
    let paginationHTML = '';

    if (params.type === 'bullets') {
      let numberOfBullets = swiper.params.loop ? Math.ceil((slidesLength - swiper.loopedSlides * 2) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;

      if (swiper.params.freeMode && swiper.params.freeMode.enabled && !swiper.params.loop && numberOfBullets > slidesLength) {
        numberOfBullets = slidesLength;
      }

      for (let i = 0; i < numberOfBullets; i += 1) {
        if (params.renderBullet) {
          paginationHTML += params.renderBullet.call(swiper, i, params.bulletClass);
        } else {
          paginationHTML += `<${params.bulletElement} class="${params.bulletClass}"></${params.bulletElement}>`;
        }
      }

      $el.html(paginationHTML);
      swiper.pagination.bullets = $el.find((0,_shared_classes_to_selector_js__WEBPACK_IMPORTED_MODULE_1__["default"])(params.bulletClass));
    }

    if (params.type === 'fraction') {
      if (params.renderFraction) {
        paginationHTML = params.renderFraction.call(swiper, params.currentClass, params.totalClass);
      } else {
        paginationHTML = `<span class="${params.currentClass}"></span>` + ' / ' + `<span class="${params.totalClass}"></span>`;
      }

      $el.html(paginationHTML);
    }

    if (params.type === 'progressbar') {
      if (params.renderProgressbar) {
        paginationHTML = params.renderProgressbar.call(swiper, params.progressbarFillClass);
      } else {
        paginationHTML = `<span class="${params.progressbarFillClass}"></span>`;
      }

      $el.html(paginationHTML);
    }

    if (params.type !== 'custom') {
      emit('paginationRender', swiper.pagination.$el[0]);
    }
  }

  function init() {
    swiper.params.pagination = (0,_shared_create_element_if_not_defined_js__WEBPACK_IMPORTED_MODULE_2__["default"])(swiper, swiper.originalParams.pagination, swiper.params.pagination, {
      el: 'swiper-pagination'
    });
    const params = swiper.params.pagination;
    if (!params.el) return;
    let $el = (0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_0__["default"])(params.el);
    if ($el.length === 0) return;

    if (swiper.params.uniqueNavElements && typeof params.el === 'string' && $el.length > 1) {
      $el = swiper.$el.find(params.el); // check if it belongs to another nested Swiper

      if ($el.length > 1) {
        $el = $el.filter(el => {
          if ((0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_0__["default"])(el).parents('.swiper')[0] !== swiper.el) return false;
          return true;
        });
      }
    }

    if (params.type === 'bullets' && params.clickable) {
      $el.addClass(params.clickableClass);
    }

    $el.addClass(params.modifierClass + params.type);
    $el.addClass(params.modifierClass + swiper.params.direction);

    if (params.type === 'bullets' && params.dynamicBullets) {
      $el.addClass(`${params.modifierClass}${params.type}-dynamic`);
      dynamicBulletIndex = 0;

      if (params.dynamicMainBullets < 1) {
        params.dynamicMainBullets = 1;
      }
    }

    if (params.type === 'progressbar' && params.progressbarOpposite) {
      $el.addClass(params.progressbarOppositeClass);
    }

    if (params.clickable) {
      $el.on('click', (0,_shared_classes_to_selector_js__WEBPACK_IMPORTED_MODULE_1__["default"])(params.bulletClass), function onClick(e) {
        e.preventDefault();
        let index = (0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_0__["default"])(this).index() * swiper.params.slidesPerGroup;
        if (swiper.params.loop) index += swiper.loopedSlides;
        swiper.slideTo(index);
      });
    }

    Object.assign(swiper.pagination, {
      $el,
      el: $el[0]
    });

    if (!swiper.enabled) {
      $el.addClass(params.lockClass);
    }
  }

  function destroy() {
    const params = swiper.params.pagination;
    if (isPaginationDisabled()) return;
    const $el = swiper.pagination.$el;
    $el.removeClass(params.hiddenClass);
    $el.removeClass(params.modifierClass + params.type);
    $el.removeClass(params.modifierClass + swiper.params.direction);
    if (swiper.pagination.bullets && swiper.pagination.bullets.removeClass) swiper.pagination.bullets.removeClass(params.bulletActiveClass);

    if (params.clickable) {
      $el.off('click', (0,_shared_classes_to_selector_js__WEBPACK_IMPORTED_MODULE_1__["default"])(params.bulletClass));
    }
  }

  on('init', () => {
    init();
    render();
    update();
  });
  on('activeIndexChange', () => {
    if (swiper.params.loop) {
      update();
    } else if (typeof swiper.snapIndex === 'undefined') {
      update();
    }
  });
  on('snapIndexChange', () => {
    if (!swiper.params.loop) {
      update();
    }
  });
  on('slidesLengthChange', () => {
    if (swiper.params.loop) {
      render();
      update();
    }
  });
  on('snapGridLengthChange', () => {
    if (!swiper.params.loop) {
      render();
      update();
    }
  });
  on('destroy', () => {
    destroy();
  });
  on('enable disable', () => {
    const {
      $el
    } = swiper.pagination;

    if ($el) {
      $el[swiper.enabled ? 'removeClass' : 'addClass'](swiper.params.pagination.lockClass);
    }
  });
  on('lock unlock', () => {
    update();
  });
  on('click', (_s, e) => {
    const targetEl = e.target;
    const {
      $el
    } = swiper.pagination;

    if (swiper.params.pagination.el && swiper.params.pagination.hideOnClick && $el.length > 0 && !(0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_0__["default"])(targetEl).hasClass(swiper.params.pagination.bulletClass)) {
      if (swiper.navigation && (swiper.navigation.nextEl && targetEl === swiper.navigation.nextEl || swiper.navigation.prevEl && targetEl === swiper.navigation.prevEl)) return;
      const isHidden = $el.hasClass(swiper.params.pagination.hiddenClass);

      if (isHidden === true) {
        emit('paginationShow');
      } else {
        emit('paginationHide');
      }

      $el.toggleClass(swiper.params.pagination.hiddenClass);
    }
  });
  Object.assign(swiper.pagination, {
    render,
    update,
    init,
    destroy
  });
}

/***/ }),

/***/ "./node_modules/swiper/modules/parallax/parallax.js":
/*!**********************************************************!*\
  !*** ./node_modules/swiper/modules/parallax/parallax.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Parallax)
/* harmony export */ });
/* harmony import */ var _shared_dom_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/dom.js */ "./node_modules/swiper/shared/dom.js");

function Parallax(_ref) {
  let {
    swiper,
    extendParams,
    on
  } = _ref;
  extendParams({
    parallax: {
      enabled: false
    }
  });

  const setTransform = (el, progress) => {
    const {
      rtl
    } = swiper;
    const $el = (0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_0__["default"])(el);
    const rtlFactor = rtl ? -1 : 1;
    const p = $el.attr('data-swiper-parallax') || '0';
    let x = $el.attr('data-swiper-parallax-x');
    let y = $el.attr('data-swiper-parallax-y');
    const scale = $el.attr('data-swiper-parallax-scale');
    const opacity = $el.attr('data-swiper-parallax-opacity');

    if (x || y) {
      x = x || '0';
      y = y || '0';
    } else if (swiper.isHorizontal()) {
      x = p;
      y = '0';
    } else {
      y = p;
      x = '0';
    }

    if (x.indexOf('%') >= 0) {
      x = `${parseInt(x, 10) * progress * rtlFactor}%`;
    } else {
      x = `${x * progress * rtlFactor}px`;
    }

    if (y.indexOf('%') >= 0) {
      y = `${parseInt(y, 10) * progress}%`;
    } else {
      y = `${y * progress}px`;
    }

    if (typeof opacity !== 'undefined' && opacity !== null) {
      const currentOpacity = opacity - (opacity - 1) * (1 - Math.abs(progress));
      $el[0].style.opacity = currentOpacity;
    }

    if (typeof scale === 'undefined' || scale === null) {
      $el.transform(`translate3d(${x}, ${y}, 0px)`);
    } else {
      const currentScale = scale - (scale - 1) * (1 - Math.abs(progress));
      $el.transform(`translate3d(${x}, ${y}, 0px) scale(${currentScale})`);
    }
  };

  const setTranslate = () => {
    const {
      $el,
      slides,
      progress,
      snapGrid
    } = swiper;
    $el.children('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]').each(el => {
      setTransform(el, progress);
    });
    slides.each((slideEl, slideIndex) => {
      let slideProgress = slideEl.progress;

      if (swiper.params.slidesPerGroup > 1 && swiper.params.slidesPerView !== 'auto') {
        slideProgress += Math.ceil(slideIndex / 2) - progress * (snapGrid.length - 1);
      }

      slideProgress = Math.min(Math.max(slideProgress, -1), 1);
      (0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_0__["default"])(slideEl).find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]').each(el => {
        setTransform(el, slideProgress);
      });
    });
  };

  const setTransition = function (duration) {
    if (duration === void 0) {
      duration = swiper.params.speed;
    }

    const {
      $el
    } = swiper;
    $el.find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]').each(parallaxEl => {
      const $parallaxEl = (0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_0__["default"])(parallaxEl);
      let parallaxDuration = parseInt($parallaxEl.attr('data-swiper-parallax-duration'), 10) || duration;
      if (duration === 0) parallaxDuration = 0;
      $parallaxEl.transition(parallaxDuration);
    });
  };

  on('beforeInit', () => {
    if (!swiper.params.parallax.enabled) return;
    swiper.params.watchSlidesProgress = true;
    swiper.originalParams.watchSlidesProgress = true;
  });
  on('init', () => {
    if (!swiper.params.parallax.enabled) return;
    setTranslate();
  });
  on('setTranslate', () => {
    if (!swiper.params.parallax.enabled) return;
    setTranslate();
  });
  on('setTransition', (_swiper, duration) => {
    if (!swiper.params.parallax.enabled) return;
    setTransition(duration);
  });
}

/***/ }),

/***/ "./node_modules/swiper/modules/scrollbar/scrollbar.js":
/*!************************************************************!*\
  !*** ./node_modules/swiper/modules/scrollbar/scrollbar.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Scrollbar)
/* harmony export */ });
/* harmony import */ var ssr_window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ssr-window */ "./node_modules/ssr-window/ssr-window.esm.js");
/* harmony import */ var _shared_dom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/dom.js */ "./node_modules/swiper/shared/dom.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/swiper/shared/utils.js");
/* harmony import */ var _shared_create_element_if_not_defined_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../shared/create-element-if-not-defined.js */ "./node_modules/swiper/shared/create-element-if-not-defined.js");




function Scrollbar(_ref) {
  let {
    swiper,
    extendParams,
    on,
    emit
  } = _ref;
  const document = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getDocument)();
  let isTouched = false;
  let timeout = null;
  let dragTimeout = null;
  let dragStartPos;
  let dragSize;
  let trackSize;
  let divider;
  extendParams({
    scrollbar: {
      el: null,
      dragSize: 'auto',
      hide: false,
      draggable: false,
      snapOnRelease: true,
      lockClass: 'swiper-scrollbar-lock',
      dragClass: 'swiper-scrollbar-drag'
    }
  });
  swiper.scrollbar = {
    el: null,
    dragEl: null,
    $el: null,
    $dragEl: null
  };

  function setTranslate() {
    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
    const {
      scrollbar,
      rtlTranslate: rtl,
      progress
    } = swiper;
    const {
      $dragEl,
      $el
    } = scrollbar;
    const params = swiper.params.scrollbar;
    let newSize = dragSize;
    let newPos = (trackSize - dragSize) * progress;

    if (rtl) {
      newPos = -newPos;

      if (newPos > 0) {
        newSize = dragSize - newPos;
        newPos = 0;
      } else if (-newPos + dragSize > trackSize) {
        newSize = trackSize + newPos;
      }
    } else if (newPos < 0) {
      newSize = dragSize + newPos;
      newPos = 0;
    } else if (newPos + dragSize > trackSize) {
      newSize = trackSize - newPos;
    }

    if (swiper.isHorizontal()) {
      $dragEl.transform(`translate3d(${newPos}px, 0, 0)`);
      $dragEl[0].style.width = `${newSize}px`;
    } else {
      $dragEl.transform(`translate3d(0px, ${newPos}px, 0)`);
      $dragEl[0].style.height = `${newSize}px`;
    }

    if (params.hide) {
      clearTimeout(timeout);
      $el[0].style.opacity = 1;
      timeout = setTimeout(() => {
        $el[0].style.opacity = 0;
        $el.transition(400);
      }, 1000);
    }
  }

  function setTransition(duration) {
    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
    swiper.scrollbar.$dragEl.transition(duration);
  }

  function updateSize() {
    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
    const {
      scrollbar
    } = swiper;
    const {
      $dragEl,
      $el
    } = scrollbar;
    $dragEl[0].style.width = '';
    $dragEl[0].style.height = '';
    trackSize = swiper.isHorizontal() ? $el[0].offsetWidth : $el[0].offsetHeight;
    divider = swiper.size / (swiper.virtualSize + swiper.params.slidesOffsetBefore - (swiper.params.centeredSlides ? swiper.snapGrid[0] : 0));

    if (swiper.params.scrollbar.dragSize === 'auto') {
      dragSize = trackSize * divider;
    } else {
      dragSize = parseInt(swiper.params.scrollbar.dragSize, 10);
    }

    if (swiper.isHorizontal()) {
      $dragEl[0].style.width = `${dragSize}px`;
    } else {
      $dragEl[0].style.height = `${dragSize}px`;
    }

    if (divider >= 1) {
      $el[0].style.display = 'none';
    } else {
      $el[0].style.display = '';
    }

    if (swiper.params.scrollbar.hide) {
      $el[0].style.opacity = 0;
    }

    if (swiper.params.watchOverflow && swiper.enabled) {
      scrollbar.$el[swiper.isLocked ? 'addClass' : 'removeClass'](swiper.params.scrollbar.lockClass);
    }
  }

  function getPointerPosition(e) {
    if (swiper.isHorizontal()) {
      return e.type === 'touchstart' || e.type === 'touchmove' ? e.targetTouches[0].clientX : e.clientX;
    }

    return e.type === 'touchstart' || e.type === 'touchmove' ? e.targetTouches[0].clientY : e.clientY;
  }

  function setDragPosition(e) {
    const {
      scrollbar,
      rtlTranslate: rtl
    } = swiper;
    const {
      $el
    } = scrollbar;
    let positionRatio;
    positionRatio = (getPointerPosition(e) - $el.offset()[swiper.isHorizontal() ? 'left' : 'top'] - (dragStartPos !== null ? dragStartPos : dragSize / 2)) / (trackSize - dragSize);
    positionRatio = Math.max(Math.min(positionRatio, 1), 0);

    if (rtl) {
      positionRatio = 1 - positionRatio;
    }

    const position = swiper.minTranslate() + (swiper.maxTranslate() - swiper.minTranslate()) * positionRatio;
    swiper.updateProgress(position);
    swiper.setTranslate(position);
    swiper.updateActiveIndex();
    swiper.updateSlidesClasses();
  }

  function onDragStart(e) {
    const params = swiper.params.scrollbar;
    const {
      scrollbar,
      $wrapperEl
    } = swiper;
    const {
      $el,
      $dragEl
    } = scrollbar;
    isTouched = true;
    dragStartPos = e.target === $dragEl[0] || e.target === $dragEl ? getPointerPosition(e) - e.target.getBoundingClientRect()[swiper.isHorizontal() ? 'left' : 'top'] : null;
    e.preventDefault();
    e.stopPropagation();
    $wrapperEl.transition(100);
    $dragEl.transition(100);
    setDragPosition(e);
    clearTimeout(dragTimeout);
    $el.transition(0);

    if (params.hide) {
      $el.css('opacity', 1);
    }

    if (swiper.params.cssMode) {
      swiper.$wrapperEl.css('scroll-snap-type', 'none');
    }

    emit('scrollbarDragStart', e);
  }

  function onDragMove(e) {
    const {
      scrollbar,
      $wrapperEl
    } = swiper;
    const {
      $el,
      $dragEl
    } = scrollbar;
    if (!isTouched) return;
    if (e.preventDefault) e.preventDefault();else e.returnValue = false;
    setDragPosition(e);
    $wrapperEl.transition(0);
    $el.transition(0);
    $dragEl.transition(0);
    emit('scrollbarDragMove', e);
  }

  function onDragEnd(e) {
    const params = swiper.params.scrollbar;
    const {
      scrollbar,
      $wrapperEl
    } = swiper;
    const {
      $el
    } = scrollbar;
    if (!isTouched) return;
    isTouched = false;

    if (swiper.params.cssMode) {
      swiper.$wrapperEl.css('scroll-snap-type', '');
      $wrapperEl.transition('');
    }

    if (params.hide) {
      clearTimeout(dragTimeout);
      dragTimeout = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.nextTick)(() => {
        $el.css('opacity', 0);
        $el.transition(400);
      }, 1000);
    }

    emit('scrollbarDragEnd', e);

    if (params.snapOnRelease) {
      swiper.slideToClosest();
    }
  }

  function events(method) {
    const {
      scrollbar,
      touchEventsTouch,
      touchEventsDesktop,
      params,
      support
    } = swiper;
    const $el = scrollbar.$el;
    const target = $el[0];
    const activeListener = support.passiveListener && params.passiveListeners ? {
      passive: false,
      capture: false
    } : false;
    const passiveListener = support.passiveListener && params.passiveListeners ? {
      passive: true,
      capture: false
    } : false;
    if (!target) return;
    const eventMethod = method === 'on' ? 'addEventListener' : 'removeEventListener';

    if (!support.touch) {
      target[eventMethod](touchEventsDesktop.start, onDragStart, activeListener);
      document[eventMethod](touchEventsDesktop.move, onDragMove, activeListener);
      document[eventMethod](touchEventsDesktop.end, onDragEnd, passiveListener);
    } else {
      target[eventMethod](touchEventsTouch.start, onDragStart, activeListener);
      target[eventMethod](touchEventsTouch.move, onDragMove, activeListener);
      target[eventMethod](touchEventsTouch.end, onDragEnd, passiveListener);
    }
  }

  function enableDraggable() {
    if (!swiper.params.scrollbar.el) return;
    events('on');
  }

  function disableDraggable() {
    if (!swiper.params.scrollbar.el) return;
    events('off');
  }

  function init() {
    const {
      scrollbar,
      $el: $swiperEl
    } = swiper;
    swiper.params.scrollbar = (0,_shared_create_element_if_not_defined_js__WEBPACK_IMPORTED_MODULE_3__["default"])(swiper, swiper.originalParams.scrollbar, swiper.params.scrollbar, {
      el: 'swiper-scrollbar'
    });
    const params = swiper.params.scrollbar;
    if (!params.el) return;
    let $el = (0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_1__["default"])(params.el);

    if (swiper.params.uniqueNavElements && typeof params.el === 'string' && $el.length > 1 && $swiperEl.find(params.el).length === 1) {
      $el = $swiperEl.find(params.el);
    }

    let $dragEl = $el.find(`.${swiper.params.scrollbar.dragClass}`);

    if ($dragEl.length === 0) {
      $dragEl = (0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_1__["default"])(`<div class="${swiper.params.scrollbar.dragClass}"></div>`);
      $el.append($dragEl);
    }

    Object.assign(scrollbar, {
      $el,
      el: $el[0],
      $dragEl,
      dragEl: $dragEl[0]
    });

    if (params.draggable) {
      enableDraggable();
    }

    if ($el) {
      $el[swiper.enabled ? 'removeClass' : 'addClass'](swiper.params.scrollbar.lockClass);
    }
  }

  function destroy() {
    disableDraggable();
  }

  on('init', () => {
    init();
    updateSize();
    setTranslate();
  });
  on('update resize observerUpdate lock unlock', () => {
    updateSize();
  });
  on('setTranslate', () => {
    setTranslate();
  });
  on('setTransition', (_s, duration) => {
    setTransition(duration);
  });
  on('enable disable', () => {
    const {
      $el
    } = swiper.scrollbar;

    if ($el) {
      $el[swiper.enabled ? 'removeClass' : 'addClass'](swiper.params.scrollbar.lockClass);
    }
  });
  on('destroy', () => {
    destroy();
  });
  Object.assign(swiper.scrollbar, {
    updateSize,
    setTranslate,
    init,
    destroy
  });
}

/***/ }),

/***/ "./node_modules/swiper/modules/thumbs/thumbs.js":
/*!******************************************************!*\
  !*** ./node_modules/swiper/modules/thumbs/thumbs.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Thumb)
/* harmony export */ });
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/swiper/shared/utils.js");
/* harmony import */ var _shared_dom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/dom.js */ "./node_modules/swiper/shared/dom.js");


function Thumb(_ref) {
  let {
    swiper,
    extendParams,
    on
  } = _ref;
  extendParams({
    thumbs: {
      swiper: null,
      multipleActiveThumbs: true,
      autoScrollOffset: 0,
      slideThumbActiveClass: 'swiper-slide-thumb-active',
      thumbsContainerClass: 'swiper-thumbs'
    }
  });
  let initialized = false;
  let swiperCreated = false;
  swiper.thumbs = {
    swiper: null
  };

  function onThumbClick() {
    const thumbsSwiper = swiper.thumbs.swiper;
    if (!thumbsSwiper) return;
    const clickedIndex = thumbsSwiper.clickedIndex;
    const clickedSlide = thumbsSwiper.clickedSlide;
    if (clickedSlide && (0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_1__["default"])(clickedSlide).hasClass(swiper.params.thumbs.slideThumbActiveClass)) return;
    if (typeof clickedIndex === 'undefined' || clickedIndex === null) return;
    let slideToIndex;

    if (thumbsSwiper.params.loop) {
      slideToIndex = parseInt((0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_1__["default"])(thumbsSwiper.clickedSlide).attr('data-swiper-slide-index'), 10);
    } else {
      slideToIndex = clickedIndex;
    }

    if (swiper.params.loop) {
      let currentIndex = swiper.activeIndex;

      if (swiper.slides.eq(currentIndex).hasClass(swiper.params.slideDuplicateClass)) {
        swiper.loopFix(); // eslint-disable-next-line

        swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
        currentIndex = swiper.activeIndex;
      }

      const prevIndex = swiper.slides.eq(currentIndex).prevAll(`[data-swiper-slide-index="${slideToIndex}"]`).eq(0).index();
      const nextIndex = swiper.slides.eq(currentIndex).nextAll(`[data-swiper-slide-index="${slideToIndex}"]`).eq(0).index();
      if (typeof prevIndex === 'undefined') slideToIndex = nextIndex;else if (typeof nextIndex === 'undefined') slideToIndex = prevIndex;else if (nextIndex - currentIndex < currentIndex - prevIndex) slideToIndex = nextIndex;else slideToIndex = prevIndex;
    }

    swiper.slideTo(slideToIndex);
  }

  function init() {
    const {
      thumbs: thumbsParams
    } = swiper.params;
    if (initialized) return false;
    initialized = true;
    const SwiperClass = swiper.constructor;

    if (thumbsParams.swiper instanceof SwiperClass) {
      swiper.thumbs.swiper = thumbsParams.swiper;
      Object.assign(swiper.thumbs.swiper.originalParams, {
        watchSlidesProgress: true,
        slideToClickedSlide: false
      });
      Object.assign(swiper.thumbs.swiper.params, {
        watchSlidesProgress: true,
        slideToClickedSlide: false
      });
    } else if ((0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_0__.isObject)(thumbsParams.swiper)) {
      const thumbsSwiperParams = Object.assign({}, thumbsParams.swiper);
      Object.assign(thumbsSwiperParams, {
        watchSlidesProgress: true,
        slideToClickedSlide: false
      });
      swiper.thumbs.swiper = new SwiperClass(thumbsSwiperParams);
      swiperCreated = true;
    }

    swiper.thumbs.swiper.$el.addClass(swiper.params.thumbs.thumbsContainerClass);
    swiper.thumbs.swiper.on('tap', onThumbClick);
    return true;
  }

  function update(initial) {
    const thumbsSwiper = swiper.thumbs.swiper;
    if (!thumbsSwiper) return;
    const slidesPerView = thumbsSwiper.params.slidesPerView === 'auto' ? thumbsSwiper.slidesPerViewDynamic() : thumbsSwiper.params.slidesPerView;
    const autoScrollOffset = swiper.params.thumbs.autoScrollOffset;
    const useOffset = autoScrollOffset && !thumbsSwiper.params.loop;

    if (swiper.realIndex !== thumbsSwiper.realIndex || useOffset) {
      let currentThumbsIndex = thumbsSwiper.activeIndex;
      let newThumbsIndex;
      let direction;

      if (thumbsSwiper.params.loop) {
        if (thumbsSwiper.slides.eq(currentThumbsIndex).hasClass(thumbsSwiper.params.slideDuplicateClass)) {
          thumbsSwiper.loopFix(); // eslint-disable-next-line

          thumbsSwiper._clientLeft = thumbsSwiper.$wrapperEl[0].clientLeft;
          currentThumbsIndex = thumbsSwiper.activeIndex;
        } // Find actual thumbs index to slide to


        const prevThumbsIndex = thumbsSwiper.slides.eq(currentThumbsIndex).prevAll(`[data-swiper-slide-index="${swiper.realIndex}"]`).eq(0).index();
        const nextThumbsIndex = thumbsSwiper.slides.eq(currentThumbsIndex).nextAll(`[data-swiper-slide-index="${swiper.realIndex}"]`).eq(0).index();

        if (typeof prevThumbsIndex === 'undefined') {
          newThumbsIndex = nextThumbsIndex;
        } else if (typeof nextThumbsIndex === 'undefined') {
          newThumbsIndex = prevThumbsIndex;
        } else if (nextThumbsIndex - currentThumbsIndex === currentThumbsIndex - prevThumbsIndex) {
          newThumbsIndex = thumbsSwiper.params.slidesPerGroup > 1 ? nextThumbsIndex : currentThumbsIndex;
        } else if (nextThumbsIndex - currentThumbsIndex < currentThumbsIndex - prevThumbsIndex) {
          newThumbsIndex = nextThumbsIndex;
        } else {
          newThumbsIndex = prevThumbsIndex;
        }

        direction = swiper.activeIndex > swiper.previousIndex ? 'next' : 'prev';
      } else {
        newThumbsIndex = swiper.realIndex;
        direction = newThumbsIndex > swiper.previousIndex ? 'next' : 'prev';
      }

      if (useOffset) {
        newThumbsIndex += direction === 'next' ? autoScrollOffset : -1 * autoScrollOffset;
      }

      if (thumbsSwiper.visibleSlidesIndexes && thumbsSwiper.visibleSlidesIndexes.indexOf(newThumbsIndex) < 0) {
        if (thumbsSwiper.params.centeredSlides) {
          if (newThumbsIndex > currentThumbsIndex) {
            newThumbsIndex = newThumbsIndex - Math.floor(slidesPerView / 2) + 1;
          } else {
            newThumbsIndex = newThumbsIndex + Math.floor(slidesPerView / 2) - 1;
          }
        } else if (newThumbsIndex > currentThumbsIndex && thumbsSwiper.params.slidesPerGroup === 1) {// newThumbsIndex = newThumbsIndex - slidesPerView + 1;
        }

        thumbsSwiper.slideTo(newThumbsIndex, initial ? 0 : undefined);
      }
    } // Activate thumbs


    let thumbsToActivate = 1;
    const thumbActiveClass = swiper.params.thumbs.slideThumbActiveClass;

    if (swiper.params.slidesPerView > 1 && !swiper.params.centeredSlides) {
      thumbsToActivate = swiper.params.slidesPerView;
    }

    if (!swiper.params.thumbs.multipleActiveThumbs) {
      thumbsToActivate = 1;
    }

    thumbsToActivate = Math.floor(thumbsToActivate);
    thumbsSwiper.slides.removeClass(thumbActiveClass);

    if (thumbsSwiper.params.loop || thumbsSwiper.params.virtual && thumbsSwiper.params.virtual.enabled) {
      for (let i = 0; i < thumbsToActivate; i += 1) {
        thumbsSwiper.$wrapperEl.children(`[data-swiper-slide-index="${swiper.realIndex + i}"]`).addClass(thumbActiveClass);
      }
    } else {
      for (let i = 0; i < thumbsToActivate; i += 1) {
        thumbsSwiper.slides.eq(swiper.realIndex + i).addClass(thumbActiveClass);
      }
    }
  }

  on('beforeInit', () => {
    const {
      thumbs
    } = swiper.params;
    if (!thumbs || !thumbs.swiper) return;
    init();
    update(true);
  });
  on('slideChange update resize observerUpdate', () => {
    if (!swiper.thumbs.swiper) return;
    update();
  });
  on('setTransition', (_s, duration) => {
    const thumbsSwiper = swiper.thumbs.swiper;
    if (!thumbsSwiper) return;
    thumbsSwiper.setTransition(duration);
  });
  on('beforeDestroy', () => {
    const thumbsSwiper = swiper.thumbs.swiper;
    if (!thumbsSwiper) return;

    if (swiperCreated && thumbsSwiper) {
      thumbsSwiper.destroy();
    }
  });
  Object.assign(swiper.thumbs, {
    init,
    update
  });
}

/***/ }),

/***/ "./node_modules/swiper/modules/virtual/virtual.js":
/*!********************************************************!*\
  !*** ./node_modules/swiper/modules/virtual/virtual.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Virtual)
/* harmony export */ });
/* harmony import */ var _shared_dom_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/dom.js */ "./node_modules/swiper/shared/dom.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/swiper/shared/utils.js");


function Virtual(_ref) {
  let {
    swiper,
    extendParams,
    on
  } = _ref;
  extendParams({
    virtual: {
      enabled: false,
      slides: [],
      cache: true,
      renderSlide: null,
      renderExternal: null,
      renderExternalUpdate: true,
      addSlidesBefore: 0,
      addSlidesAfter: 0
    }
  });
  let cssModeTimeout;
  swiper.virtual = {
    cache: {},
    from: undefined,
    to: undefined,
    slides: [],
    offset: 0,
    slidesGrid: []
  };

  function renderSlide(slide, index) {
    const params = swiper.params.virtual;

    if (params.cache && swiper.virtual.cache[index]) {
      return swiper.virtual.cache[index];
    }

    const $slideEl = params.renderSlide ? (0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_0__["default"])(params.renderSlide.call(swiper, slide, index)) : (0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_0__["default"])(`<div class="${swiper.params.slideClass}" data-swiper-slide-index="${index}">${slide}</div>`);
    if (!$slideEl.attr('data-swiper-slide-index')) $slideEl.attr('data-swiper-slide-index', index);
    if (params.cache) swiper.virtual.cache[index] = $slideEl;
    return $slideEl;
  }

  function update(force) {
    const {
      slidesPerView,
      slidesPerGroup,
      centeredSlides
    } = swiper.params;
    const {
      addSlidesBefore,
      addSlidesAfter
    } = swiper.params.virtual;
    const {
      from: previousFrom,
      to: previousTo,
      slides,
      slidesGrid: previousSlidesGrid,
      offset: previousOffset
    } = swiper.virtual;

    if (!swiper.params.cssMode) {
      swiper.updateActiveIndex();
    }

    const activeIndex = swiper.activeIndex || 0;
    let offsetProp;
    if (swiper.rtlTranslate) offsetProp = 'right';else offsetProp = swiper.isHorizontal() ? 'left' : 'top';
    let slidesAfter;
    let slidesBefore;

    if (centeredSlides) {
      slidesAfter = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesAfter;
      slidesBefore = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesBefore;
    } else {
      slidesAfter = slidesPerView + (slidesPerGroup - 1) + addSlidesAfter;
      slidesBefore = slidesPerGroup + addSlidesBefore;
    }

    const from = Math.max((activeIndex || 0) - slidesBefore, 0);
    const to = Math.min((activeIndex || 0) + slidesAfter, slides.length - 1);
    const offset = (swiper.slidesGrid[from] || 0) - (swiper.slidesGrid[0] || 0);
    Object.assign(swiper.virtual, {
      from,
      to,
      offset,
      slidesGrid: swiper.slidesGrid
    });

    function onRendered() {
      swiper.updateSlides();
      swiper.updateProgress();
      swiper.updateSlidesClasses();

      if (swiper.lazy && swiper.params.lazy.enabled) {
        swiper.lazy.load();
      }
    }

    if (previousFrom === from && previousTo === to && !force) {
      if (swiper.slidesGrid !== previousSlidesGrid && offset !== previousOffset) {
        swiper.slides.css(offsetProp, `${offset}px`);
      }

      swiper.updateProgress();
      return;
    }

    if (swiper.params.virtual.renderExternal) {
      swiper.params.virtual.renderExternal.call(swiper, {
        offset,
        from,
        to,
        slides: function getSlides() {
          const slidesToRender = [];

          for (let i = from; i <= to; i += 1) {
            slidesToRender.push(slides[i]);
          }

          return slidesToRender;
        }()
      });

      if (swiper.params.virtual.renderExternalUpdate) {
        onRendered();
      }

      return;
    }

    const prependIndexes = [];
    const appendIndexes = [];

    if (force) {
      swiper.$wrapperEl.find(`.${swiper.params.slideClass}`).remove();
    } else {
      for (let i = previousFrom; i <= previousTo; i += 1) {
        if (i < from || i > to) {
          swiper.$wrapperEl.find(`.${swiper.params.slideClass}[data-swiper-slide-index="${i}"]`).remove();
        }
      }
    }

    for (let i = 0; i < slides.length; i += 1) {
      if (i >= from && i <= to) {
        if (typeof previousTo === 'undefined' || force) {
          appendIndexes.push(i);
        } else {
          if (i > previousTo) appendIndexes.push(i);
          if (i < previousFrom) prependIndexes.push(i);
        }
      }
    }

    appendIndexes.forEach(index => {
      swiper.$wrapperEl.append(renderSlide(slides[index], index));
    });
    prependIndexes.sort((a, b) => b - a).forEach(index => {
      swiper.$wrapperEl.prepend(renderSlide(slides[index], index));
    });
    swiper.$wrapperEl.children('.swiper-slide').css(offsetProp, `${offset}px`);
    onRendered();
  }

  function appendSlide(slides) {
    if (typeof slides === 'object' && 'length' in slides) {
      for (let i = 0; i < slides.length; i += 1) {
        if (slides[i]) swiper.virtual.slides.push(slides[i]);
      }
    } else {
      swiper.virtual.slides.push(slides);
    }

    update(true);
  }

  function prependSlide(slides) {
    const activeIndex = swiper.activeIndex;
    let newActiveIndex = activeIndex + 1;
    let numberOfNewSlides = 1;

    if (Array.isArray(slides)) {
      for (let i = 0; i < slides.length; i += 1) {
        if (slides[i]) swiper.virtual.slides.unshift(slides[i]);
      }

      newActiveIndex = activeIndex + slides.length;
      numberOfNewSlides = slides.length;
    } else {
      swiper.virtual.slides.unshift(slides);
    }

    if (swiper.params.virtual.cache) {
      const cache = swiper.virtual.cache;
      const newCache = {};
      Object.keys(cache).forEach(cachedIndex => {
        const $cachedEl = cache[cachedIndex];
        const cachedElIndex = $cachedEl.attr('data-swiper-slide-index');

        if (cachedElIndex) {
          $cachedEl.attr('data-swiper-slide-index', parseInt(cachedElIndex, 10) + numberOfNewSlides);
        }

        newCache[parseInt(cachedIndex, 10) + numberOfNewSlides] = $cachedEl;
      });
      swiper.virtual.cache = newCache;
    }

    update(true);
    swiper.slideTo(newActiveIndex, 0);
  }

  function removeSlide(slidesIndexes) {
    if (typeof slidesIndexes === 'undefined' || slidesIndexes === null) return;
    let activeIndex = swiper.activeIndex;

    if (Array.isArray(slidesIndexes)) {
      for (let i = slidesIndexes.length - 1; i >= 0; i -= 1) {
        swiper.virtual.slides.splice(slidesIndexes[i], 1);

        if (swiper.params.virtual.cache) {
          delete swiper.virtual.cache[slidesIndexes[i]];
        }

        if (slidesIndexes[i] < activeIndex) activeIndex -= 1;
        activeIndex = Math.max(activeIndex, 0);
      }
    } else {
      swiper.virtual.slides.splice(slidesIndexes, 1);

      if (swiper.params.virtual.cache) {
        delete swiper.virtual.cache[slidesIndexes];
      }

      if (slidesIndexes < activeIndex) activeIndex -= 1;
      activeIndex = Math.max(activeIndex, 0);
    }

    update(true);
    swiper.slideTo(activeIndex, 0);
  }

  function removeAllSlides() {
    swiper.virtual.slides = [];

    if (swiper.params.virtual.cache) {
      swiper.virtual.cache = {};
    }

    update(true);
    swiper.slideTo(0, 0);
  }

  on('beforeInit', () => {
    if (!swiper.params.virtual.enabled) return;
    swiper.virtual.slides = swiper.params.virtual.slides;
    swiper.classNames.push(`${swiper.params.containerModifierClass}virtual`);
    swiper.params.watchSlidesProgress = true;
    swiper.originalParams.watchSlidesProgress = true;

    if (!swiper.params.initialSlide) {
      update();
    }
  });
  on('setTranslate', () => {
    if (!swiper.params.virtual.enabled) return;

    if (swiper.params.cssMode && !swiper._immediateVirtual) {
      clearTimeout(cssModeTimeout);
      cssModeTimeout = setTimeout(() => {
        update();
      }, 100);
    } else {
      update();
    }
  });
  on('init update resize', () => {
    if (!swiper.params.virtual.enabled) return;

    if (swiper.params.cssMode) {
      (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.setCSSProperty)(swiper.wrapperEl, '--swiper-virtual-size', `${swiper.virtualSize}px`);
    }
  });
  Object.assign(swiper.virtual, {
    appendSlide,
    prependSlide,
    removeSlide,
    removeAllSlides,
    update
  });
}

/***/ }),

/***/ "./node_modules/swiper/modules/zoom/zoom.js":
/*!**************************************************!*\
  !*** ./node_modules/swiper/modules/zoom/zoom.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Zoom)
/* harmony export */ });
/* harmony import */ var ssr_window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ssr-window */ "./node_modules/ssr-window/ssr-window.esm.js");
/* harmony import */ var _shared_dom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/dom.js */ "./node_modules/swiper/shared/dom.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/swiper/shared/utils.js");



function Zoom(_ref) {
  let {
    swiper,
    extendParams,
    on,
    emit
  } = _ref;
  const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();
  extendParams({
    zoom: {
      enabled: false,
      maxRatio: 3,
      minRatio: 1,
      toggle: true,
      containerClass: 'swiper-zoom-container',
      zoomedSlideClass: 'swiper-slide-zoomed'
    }
  });
  swiper.zoom = {
    enabled: false
  };
  let currentScale = 1;
  let isScaling = false;
  let gesturesEnabled;
  let fakeGestureTouched;
  let fakeGestureMoved;
  const gesture = {
    $slideEl: undefined,
    slideWidth: undefined,
    slideHeight: undefined,
    $imageEl: undefined,
    $imageWrapEl: undefined,
    maxRatio: 3
  };
  const image = {
    isTouched: undefined,
    isMoved: undefined,
    currentX: undefined,
    currentY: undefined,
    minX: undefined,
    minY: undefined,
    maxX: undefined,
    maxY: undefined,
    width: undefined,
    height: undefined,
    startX: undefined,
    startY: undefined,
    touchesStart: {},
    touchesCurrent: {}
  };
  const velocity = {
    x: undefined,
    y: undefined,
    prevPositionX: undefined,
    prevPositionY: undefined,
    prevTime: undefined
  };
  let scale = 1;
  Object.defineProperty(swiper.zoom, 'scale', {
    get() {
      return scale;
    },

    set(value) {
      if (scale !== value) {
        const imageEl = gesture.$imageEl ? gesture.$imageEl[0] : undefined;
        const slideEl = gesture.$slideEl ? gesture.$slideEl[0] : undefined;
        emit('zoomChange', value, imageEl, slideEl);
      }

      scale = value;
    }

  });

  function getDistanceBetweenTouches(e) {
    if (e.targetTouches.length < 2) return 1;
    const x1 = e.targetTouches[0].pageX;
    const y1 = e.targetTouches[0].pageY;
    const x2 = e.targetTouches[1].pageX;
    const y2 = e.targetTouches[1].pageY;
    const distance = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
    return distance;
  } // Events


  function onGestureStart(e) {
    const support = swiper.support;
    const params = swiper.params.zoom;
    fakeGestureTouched = false;
    fakeGestureMoved = false;

    if (!support.gestures) {
      if (e.type !== 'touchstart' || e.type === 'touchstart' && e.targetTouches.length < 2) {
        return;
      }

      fakeGestureTouched = true;
      gesture.scaleStart = getDistanceBetweenTouches(e);
    }

    if (!gesture.$slideEl || !gesture.$slideEl.length) {
      gesture.$slideEl = (0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_1__["default"])(e.target).closest(`.${swiper.params.slideClass}`);
      if (gesture.$slideEl.length === 0) gesture.$slideEl = swiper.slides.eq(swiper.activeIndex);
      gesture.$imageEl = gesture.$slideEl.find(`.${params.containerClass}`).eq(0).find('picture, img, svg, canvas, .swiper-zoom-target').eq(0);
      gesture.$imageWrapEl = gesture.$imageEl.parent(`.${params.containerClass}`);
      gesture.maxRatio = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;

      if (gesture.$imageWrapEl.length === 0) {
        gesture.$imageEl = undefined;
        return;
      }
    }

    if (gesture.$imageEl) {
      gesture.$imageEl.transition(0);
    }

    isScaling = true;
  }

  function onGestureChange(e) {
    const support = swiper.support;
    const params = swiper.params.zoom;
    const zoom = swiper.zoom;

    if (!support.gestures) {
      if (e.type !== 'touchmove' || e.type === 'touchmove' && e.targetTouches.length < 2) {
        return;
      }

      fakeGestureMoved = true;
      gesture.scaleMove = getDistanceBetweenTouches(e);
    }

    if (!gesture.$imageEl || gesture.$imageEl.length === 0) {
      if (e.type === 'gesturechange') onGestureStart(e);
      return;
    }

    if (support.gestures) {
      zoom.scale = e.scale * currentScale;
    } else {
      zoom.scale = gesture.scaleMove / gesture.scaleStart * currentScale;
    }

    if (zoom.scale > gesture.maxRatio) {
      zoom.scale = gesture.maxRatio - 1 + (zoom.scale - gesture.maxRatio + 1) ** 0.5;
    }

    if (zoom.scale < params.minRatio) {
      zoom.scale = params.minRatio + 1 - (params.minRatio - zoom.scale + 1) ** 0.5;
    }

    gesture.$imageEl.transform(`translate3d(0,0,0) scale(${zoom.scale})`);
  }

  function onGestureEnd(e) {
    const device = swiper.device;
    const support = swiper.support;
    const params = swiper.params.zoom;
    const zoom = swiper.zoom;

    if (!support.gestures) {
      if (!fakeGestureTouched || !fakeGestureMoved) {
        return;
      }

      if (e.type !== 'touchend' || e.type === 'touchend' && e.changedTouches.length < 2 && !device.android) {
        return;
      }

      fakeGestureTouched = false;
      fakeGestureMoved = false;
    }

    if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
    zoom.scale = Math.max(Math.min(zoom.scale, gesture.maxRatio), params.minRatio);
    gesture.$imageEl.transition(swiper.params.speed).transform(`translate3d(0,0,0) scale(${zoom.scale})`);
    currentScale = zoom.scale;
    isScaling = false;
    if (zoom.scale === 1) gesture.$slideEl = undefined;
  }

  function onTouchStart(e) {
    const device = swiper.device;
    if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
    if (image.isTouched) return;
    if (device.android && e.cancelable) e.preventDefault();
    image.isTouched = true;
    image.touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
    image.touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
  }

  function onTouchMove(e) {
    const zoom = swiper.zoom;
    if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
    swiper.allowClick = false;
    if (!image.isTouched || !gesture.$slideEl) return;

    if (!image.isMoved) {
      image.width = gesture.$imageEl[0].offsetWidth;
      image.height = gesture.$imageEl[0].offsetHeight;
      image.startX = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.getTranslate)(gesture.$imageWrapEl[0], 'x') || 0;
      image.startY = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.getTranslate)(gesture.$imageWrapEl[0], 'y') || 0;
      gesture.slideWidth = gesture.$slideEl[0].offsetWidth;
      gesture.slideHeight = gesture.$slideEl[0].offsetHeight;
      gesture.$imageWrapEl.transition(0);
    } // Define if we need image drag


    const scaledWidth = image.width * zoom.scale;
    const scaledHeight = image.height * zoom.scale;
    if (scaledWidth < gesture.slideWidth && scaledHeight < gesture.slideHeight) return;
    image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);
    image.maxX = -image.minX;
    image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);
    image.maxY = -image.minY;
    image.touchesCurrent.x = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
    image.touchesCurrent.y = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;

    if (!image.isMoved && !isScaling) {
      if (swiper.isHorizontal() && (Math.floor(image.minX) === Math.floor(image.startX) && image.touchesCurrent.x < image.touchesStart.x || Math.floor(image.maxX) === Math.floor(image.startX) && image.touchesCurrent.x > image.touchesStart.x)) {
        image.isTouched = false;
        return;
      }

      if (!swiper.isHorizontal() && (Math.floor(image.minY) === Math.floor(image.startY) && image.touchesCurrent.y < image.touchesStart.y || Math.floor(image.maxY) === Math.floor(image.startY) && image.touchesCurrent.y > image.touchesStart.y)) {
        image.isTouched = false;
        return;
      }
    }

    if (e.cancelable) {
      e.preventDefault();
    }

    e.stopPropagation();
    image.isMoved = true;
    image.currentX = image.touchesCurrent.x - image.touchesStart.x + image.startX;
    image.currentY = image.touchesCurrent.y - image.touchesStart.y + image.startY;

    if (image.currentX < image.minX) {
      image.currentX = image.minX + 1 - (image.minX - image.currentX + 1) ** 0.8;
    }

    if (image.currentX > image.maxX) {
      image.currentX = image.maxX - 1 + (image.currentX - image.maxX + 1) ** 0.8;
    }

    if (image.currentY < image.minY) {
      image.currentY = image.minY + 1 - (image.minY - image.currentY + 1) ** 0.8;
    }

    if (image.currentY > image.maxY) {
      image.currentY = image.maxY - 1 + (image.currentY - image.maxY + 1) ** 0.8;
    } // Velocity


    if (!velocity.prevPositionX) velocity.prevPositionX = image.touchesCurrent.x;
    if (!velocity.prevPositionY) velocity.prevPositionY = image.touchesCurrent.y;
    if (!velocity.prevTime) velocity.prevTime = Date.now();
    velocity.x = (image.touchesCurrent.x - velocity.prevPositionX) / (Date.now() - velocity.prevTime) / 2;
    velocity.y = (image.touchesCurrent.y - velocity.prevPositionY) / (Date.now() - velocity.prevTime) / 2;
    if (Math.abs(image.touchesCurrent.x - velocity.prevPositionX) < 2) velocity.x = 0;
    if (Math.abs(image.touchesCurrent.y - velocity.prevPositionY) < 2) velocity.y = 0;
    velocity.prevPositionX = image.touchesCurrent.x;
    velocity.prevPositionY = image.touchesCurrent.y;
    velocity.prevTime = Date.now();
    gesture.$imageWrapEl.transform(`translate3d(${image.currentX}px, ${image.currentY}px,0)`);
  }

  function onTouchEnd() {
    const zoom = swiper.zoom;
    if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;

    if (!image.isTouched || !image.isMoved) {
      image.isTouched = false;
      image.isMoved = false;
      return;
    }

    image.isTouched = false;
    image.isMoved = false;
    let momentumDurationX = 300;
    let momentumDurationY = 300;
    const momentumDistanceX = velocity.x * momentumDurationX;
    const newPositionX = image.currentX + momentumDistanceX;
    const momentumDistanceY = velocity.y * momentumDurationY;
    const newPositionY = image.currentY + momentumDistanceY; // Fix duration

    if (velocity.x !== 0) momentumDurationX = Math.abs((newPositionX - image.currentX) / velocity.x);
    if (velocity.y !== 0) momentumDurationY = Math.abs((newPositionY - image.currentY) / velocity.y);
    const momentumDuration = Math.max(momentumDurationX, momentumDurationY);
    image.currentX = newPositionX;
    image.currentY = newPositionY; // Define if we need image drag

    const scaledWidth = image.width * zoom.scale;
    const scaledHeight = image.height * zoom.scale;
    image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);
    image.maxX = -image.minX;
    image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);
    image.maxY = -image.minY;
    image.currentX = Math.max(Math.min(image.currentX, image.maxX), image.minX);
    image.currentY = Math.max(Math.min(image.currentY, image.maxY), image.minY);
    gesture.$imageWrapEl.transition(momentumDuration).transform(`translate3d(${image.currentX}px, ${image.currentY}px,0)`);
  }

  function onTransitionEnd() {
    const zoom = swiper.zoom;

    if (gesture.$slideEl && swiper.previousIndex !== swiper.activeIndex) {
      if (gesture.$imageEl) {
        gesture.$imageEl.transform('translate3d(0,0,0) scale(1)');
      }

      if (gesture.$imageWrapEl) {
        gesture.$imageWrapEl.transform('translate3d(0,0,0)');
      }

      zoom.scale = 1;
      currentScale = 1;
      gesture.$slideEl = undefined;
      gesture.$imageEl = undefined;
      gesture.$imageWrapEl = undefined;
    }
  }

  function zoomIn(e) {
    const zoom = swiper.zoom;
    const params = swiper.params.zoom;

    if (!gesture.$slideEl) {
      if (e && e.target) {
        gesture.$slideEl = (0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_1__["default"])(e.target).closest(`.${swiper.params.slideClass}`);
      }

      if (!gesture.$slideEl) {
        if (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) {
          gesture.$slideEl = swiper.$wrapperEl.children(`.${swiper.params.slideActiveClass}`);
        } else {
          gesture.$slideEl = swiper.slides.eq(swiper.activeIndex);
        }
      }

      gesture.$imageEl = gesture.$slideEl.find(`.${params.containerClass}`).eq(0).find('picture, img, svg, canvas, .swiper-zoom-target').eq(0);
      gesture.$imageWrapEl = gesture.$imageEl.parent(`.${params.containerClass}`);
    }

    if (!gesture.$imageEl || gesture.$imageEl.length === 0 || !gesture.$imageWrapEl || gesture.$imageWrapEl.length === 0) return;

    if (swiper.params.cssMode) {
      swiper.wrapperEl.style.overflow = 'hidden';
      swiper.wrapperEl.style.touchAction = 'none';
    }

    gesture.$slideEl.addClass(`${params.zoomedSlideClass}`);
    let touchX;
    let touchY;
    let offsetX;
    let offsetY;
    let diffX;
    let diffY;
    let translateX;
    let translateY;
    let imageWidth;
    let imageHeight;
    let scaledWidth;
    let scaledHeight;
    let translateMinX;
    let translateMinY;
    let translateMaxX;
    let translateMaxY;
    let slideWidth;
    let slideHeight;

    if (typeof image.touchesStart.x === 'undefined' && e) {
      touchX = e.type === 'touchend' ? e.changedTouches[0].pageX : e.pageX;
      touchY = e.type === 'touchend' ? e.changedTouches[0].pageY : e.pageY;
    } else {
      touchX = image.touchesStart.x;
      touchY = image.touchesStart.y;
    }

    zoom.scale = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;
    currentScale = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;

    if (e) {
      slideWidth = gesture.$slideEl[0].offsetWidth;
      slideHeight = gesture.$slideEl[0].offsetHeight;
      offsetX = gesture.$slideEl.offset().left + window.scrollX;
      offsetY = gesture.$slideEl.offset().top + window.scrollY;
      diffX = offsetX + slideWidth / 2 - touchX;
      diffY = offsetY + slideHeight / 2 - touchY;
      imageWidth = gesture.$imageEl[0].offsetWidth;
      imageHeight = gesture.$imageEl[0].offsetHeight;
      scaledWidth = imageWidth * zoom.scale;
      scaledHeight = imageHeight * zoom.scale;
      translateMinX = Math.min(slideWidth / 2 - scaledWidth / 2, 0);
      translateMinY = Math.min(slideHeight / 2 - scaledHeight / 2, 0);
      translateMaxX = -translateMinX;
      translateMaxY = -translateMinY;
      translateX = diffX * zoom.scale;
      translateY = diffY * zoom.scale;

      if (translateX < translateMinX) {
        translateX = translateMinX;
      }

      if (translateX > translateMaxX) {
        translateX = translateMaxX;
      }

      if (translateY < translateMinY) {
        translateY = translateMinY;
      }

      if (translateY > translateMaxY) {
        translateY = translateMaxY;
      }
    } else {
      translateX = 0;
      translateY = 0;
    }

    gesture.$imageWrapEl.transition(300).transform(`translate3d(${translateX}px, ${translateY}px,0)`);
    gesture.$imageEl.transition(300).transform(`translate3d(0,0,0) scale(${zoom.scale})`);
  }

  function zoomOut() {
    const zoom = swiper.zoom;
    const params = swiper.params.zoom;

    if (!gesture.$slideEl) {
      if (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) {
        gesture.$slideEl = swiper.$wrapperEl.children(`.${swiper.params.slideActiveClass}`);
      } else {
        gesture.$slideEl = swiper.slides.eq(swiper.activeIndex);
      }

      gesture.$imageEl = gesture.$slideEl.find(`.${params.containerClass}`).eq(0).find('picture, img, svg, canvas, .swiper-zoom-target').eq(0);
      gesture.$imageWrapEl = gesture.$imageEl.parent(`.${params.containerClass}`);
    }

    if (!gesture.$imageEl || gesture.$imageEl.length === 0 || !gesture.$imageWrapEl || gesture.$imageWrapEl.length === 0) return;

    if (swiper.params.cssMode) {
      swiper.wrapperEl.style.overflow = '';
      swiper.wrapperEl.style.touchAction = '';
    }

    zoom.scale = 1;
    currentScale = 1;
    gesture.$imageWrapEl.transition(300).transform('translate3d(0,0,0)');
    gesture.$imageEl.transition(300).transform('translate3d(0,0,0) scale(1)');
    gesture.$slideEl.removeClass(`${params.zoomedSlideClass}`);
    gesture.$slideEl = undefined;
  } // Toggle Zoom


  function zoomToggle(e) {
    const zoom = swiper.zoom;

    if (zoom.scale && zoom.scale !== 1) {
      // Zoom Out
      zoomOut();
    } else {
      // Zoom In
      zoomIn(e);
    }
  }

  function getListeners() {
    const support = swiper.support;
    const passiveListener = swiper.touchEvents.start === 'touchstart' && support.passiveListener && swiper.params.passiveListeners ? {
      passive: true,
      capture: false
    } : false;
    const activeListenerWithCapture = support.passiveListener ? {
      passive: false,
      capture: true
    } : true;
    return {
      passiveListener,
      activeListenerWithCapture
    };
  }

  function getSlideSelector() {
    return `.${swiper.params.slideClass}`;
  }

  function toggleGestures(method) {
    const {
      passiveListener
    } = getListeners();
    const slideSelector = getSlideSelector();
    swiper.$wrapperEl[method]('gesturestart', slideSelector, onGestureStart, passiveListener);
    swiper.$wrapperEl[method]('gesturechange', slideSelector, onGestureChange, passiveListener);
    swiper.$wrapperEl[method]('gestureend', slideSelector, onGestureEnd, passiveListener);
  }

  function enableGestures() {
    if (gesturesEnabled) return;
    gesturesEnabled = true;
    toggleGestures('on');
  }

  function disableGestures() {
    if (!gesturesEnabled) return;
    gesturesEnabled = false;
    toggleGestures('off');
  } // Attach/Detach Events


  function enable() {
    const zoom = swiper.zoom;
    if (zoom.enabled) return;
    zoom.enabled = true;
    const support = swiper.support;
    const {
      passiveListener,
      activeListenerWithCapture
    } = getListeners();
    const slideSelector = getSlideSelector(); // Scale image

    if (support.gestures) {
      swiper.$wrapperEl.on(swiper.touchEvents.start, enableGestures, passiveListener);
      swiper.$wrapperEl.on(swiper.touchEvents.end, disableGestures, passiveListener);
    } else if (swiper.touchEvents.start === 'touchstart') {
      swiper.$wrapperEl.on(swiper.touchEvents.start, slideSelector, onGestureStart, passiveListener);
      swiper.$wrapperEl.on(swiper.touchEvents.move, slideSelector, onGestureChange, activeListenerWithCapture);
      swiper.$wrapperEl.on(swiper.touchEvents.end, slideSelector, onGestureEnd, passiveListener);

      if (swiper.touchEvents.cancel) {
        swiper.$wrapperEl.on(swiper.touchEvents.cancel, slideSelector, onGestureEnd, passiveListener);
      }
    } // Move image


    swiper.$wrapperEl.on(swiper.touchEvents.move, `.${swiper.params.zoom.containerClass}`, onTouchMove, activeListenerWithCapture);
  }

  function disable() {
    const zoom = swiper.zoom;
    if (!zoom.enabled) return;
    const support = swiper.support;
    zoom.enabled = false;
    const {
      passiveListener,
      activeListenerWithCapture
    } = getListeners();
    const slideSelector = getSlideSelector(); // Scale image

    if (support.gestures) {
      swiper.$wrapperEl.off(swiper.touchEvents.start, enableGestures, passiveListener);
      swiper.$wrapperEl.off(swiper.touchEvents.end, disableGestures, passiveListener);
    } else if (swiper.touchEvents.start === 'touchstart') {
      swiper.$wrapperEl.off(swiper.touchEvents.start, slideSelector, onGestureStart, passiveListener);
      swiper.$wrapperEl.off(swiper.touchEvents.move, slideSelector, onGestureChange, activeListenerWithCapture);
      swiper.$wrapperEl.off(swiper.touchEvents.end, slideSelector, onGestureEnd, passiveListener);

      if (swiper.touchEvents.cancel) {
        swiper.$wrapperEl.off(swiper.touchEvents.cancel, slideSelector, onGestureEnd, passiveListener);
      }
    } // Move image


    swiper.$wrapperEl.off(swiper.touchEvents.move, `.${swiper.params.zoom.containerClass}`, onTouchMove, activeListenerWithCapture);
  }

  on('init', () => {
    if (swiper.params.zoom.enabled) {
      enable();
    }
  });
  on('destroy', () => {
    disable();
  });
  on('touchStart', (_s, e) => {
    if (!swiper.zoom.enabled) return;
    onTouchStart(e);
  });
  on('touchEnd', (_s, e) => {
    if (!swiper.zoom.enabled) return;
    onTouchEnd(e);
  });
  on('doubleTap', (_s, e) => {
    if (!swiper.animating && swiper.params.zoom.enabled && swiper.zoom.enabled && swiper.params.zoom.toggle) {
      zoomToggle(e);
    }
  });
  on('transitionEnd', () => {
    if (swiper.zoom.enabled && swiper.params.zoom.enabled) {
      onTransitionEnd();
    }
  });
  on('slideChange', () => {
    if (swiper.zoom.enabled && swiper.params.zoom.enabled && swiper.params.cssMode) {
      onTransitionEnd();
    }
  });
  Object.assign(swiper.zoom, {
    enable,
    disable,
    in: zoomIn,
    out: zoomOut,
    toggle: zoomToggle
  });
}

/***/ }),

/***/ "./node_modules/swiper/shared/classes-to-selector.js":
/*!***********************************************************!*\
  !*** ./node_modules/swiper/shared/classes-to-selector.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ classesToSelector)
/* harmony export */ });
function classesToSelector(classes) {
  if (classes === void 0) {
    classes = '';
  }

  return `.${classes.trim().replace(/([\.:!\/])/g, '\\$1') // eslint-disable-line
  .replace(/ /g, '.')}`;
}

/***/ }),

/***/ "./node_modules/swiper/shared/create-element-if-not-defined.js":
/*!*********************************************************************!*\
  !*** ./node_modules/swiper/shared/create-element-if-not-defined.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ createElementIfNotDefined)
/* harmony export */ });
/* harmony import */ var ssr_window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ssr-window */ "./node_modules/ssr-window/ssr-window.esm.js");

function createElementIfNotDefined(swiper, originalParams, params, checkProps) {
  const document = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getDocument)();

  if (swiper.params.createElements) {
    Object.keys(checkProps).forEach(key => {
      if (!params[key] && params.auto === true) {
        let element = swiper.$el.children(`.${checkProps[key]}`)[0];

        if (!element) {
          element = document.createElement('div');
          element.className = checkProps[key];
          swiper.$el.append(element);
        }

        params[key] = element;
        originalParams[key] = element;
      }
    });
  }

  return params;
}

/***/ }),

/***/ "./node_modules/swiper/shared/create-shadow.js":
/*!*****************************************************!*\
  !*** ./node_modules/swiper/shared/create-shadow.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ createShadow)
/* harmony export */ });
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dom.js */ "./node_modules/swiper/shared/dom.js");

function createShadow(params, $slideEl, side) {
  const shadowClass = `swiper-slide-shadow${side ? `-${side}` : ''}`;
  const $shadowContainer = params.transformEl ? $slideEl.find(params.transformEl) : $slideEl;
  let $shadowEl = $shadowContainer.children(`.${shadowClass}`);

  if (!$shadowEl.length) {
    $shadowEl = (0,_dom_js__WEBPACK_IMPORTED_MODULE_0__["default"])(`<div class="swiper-slide-shadow${side ? `-${side}` : ''}"></div>`);
    $shadowContainer.append($shadowEl);
  }

  return $shadowEl;
}

/***/ }),

/***/ "./node_modules/swiper/shared/dom.js":
/*!*******************************************!*\
  !*** ./node_modules/swiper/shared/dom.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var dom7__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! dom7 */ "./node_modules/dom7/dom7.esm.js");

const Methods = {
  addClass: dom7__WEBPACK_IMPORTED_MODULE_0__.addClass,
  removeClass: dom7__WEBPACK_IMPORTED_MODULE_0__.removeClass,
  hasClass: dom7__WEBPACK_IMPORTED_MODULE_0__.hasClass,
  toggleClass: dom7__WEBPACK_IMPORTED_MODULE_0__.toggleClass,
  attr: dom7__WEBPACK_IMPORTED_MODULE_0__.attr,
  removeAttr: dom7__WEBPACK_IMPORTED_MODULE_0__.removeAttr,
  transform: dom7__WEBPACK_IMPORTED_MODULE_0__.transform,
  transition: dom7__WEBPACK_IMPORTED_MODULE_0__.transition,
  on: dom7__WEBPACK_IMPORTED_MODULE_0__.on,
  off: dom7__WEBPACK_IMPORTED_MODULE_0__.off,
  trigger: dom7__WEBPACK_IMPORTED_MODULE_0__.trigger,
  transitionEnd: dom7__WEBPACK_IMPORTED_MODULE_0__.transitionEnd,
  outerWidth: dom7__WEBPACK_IMPORTED_MODULE_0__.outerWidth,
  outerHeight: dom7__WEBPACK_IMPORTED_MODULE_0__.outerHeight,
  styles: dom7__WEBPACK_IMPORTED_MODULE_0__.styles,
  offset: dom7__WEBPACK_IMPORTED_MODULE_0__.offset,
  css: dom7__WEBPACK_IMPORTED_MODULE_0__.css,
  each: dom7__WEBPACK_IMPORTED_MODULE_0__.each,
  html: dom7__WEBPACK_IMPORTED_MODULE_0__.html,
  text: dom7__WEBPACK_IMPORTED_MODULE_0__.text,
  is: dom7__WEBPACK_IMPORTED_MODULE_0__.is,
  index: dom7__WEBPACK_IMPORTED_MODULE_0__.index,
  eq: dom7__WEBPACK_IMPORTED_MODULE_0__.eq,
  append: dom7__WEBPACK_IMPORTED_MODULE_0__.append,
  prepend: dom7__WEBPACK_IMPORTED_MODULE_0__.prepend,
  next: dom7__WEBPACK_IMPORTED_MODULE_0__.next,
  nextAll: dom7__WEBPACK_IMPORTED_MODULE_0__.nextAll,
  prev: dom7__WEBPACK_IMPORTED_MODULE_0__.prev,
  prevAll: dom7__WEBPACK_IMPORTED_MODULE_0__.prevAll,
  parent: dom7__WEBPACK_IMPORTED_MODULE_0__.parent,
  parents: dom7__WEBPACK_IMPORTED_MODULE_0__.parents,
  closest: dom7__WEBPACK_IMPORTED_MODULE_0__.closest,
  find: dom7__WEBPACK_IMPORTED_MODULE_0__.find,
  children: dom7__WEBPACK_IMPORTED_MODULE_0__.children,
  filter: dom7__WEBPACK_IMPORTED_MODULE_0__.filter,
  remove: dom7__WEBPACK_IMPORTED_MODULE_0__.remove
};
Object.keys(Methods).forEach(methodName => {
  Object.defineProperty(dom7__WEBPACK_IMPORTED_MODULE_0__.$.fn, methodName, {
    value: Methods[methodName],
    writable: true
  });
});
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (dom7__WEBPACK_IMPORTED_MODULE_0__.$);

/***/ }),

/***/ "./node_modules/swiper/shared/effect-init.js":
/*!***************************************************!*\
  !*** ./node_modules/swiper/shared/effect-init.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ effectInit)
/* harmony export */ });
function effectInit(params) {
  const {
    effect,
    swiper,
    on,
    setTranslate,
    setTransition,
    overwriteParams,
    perspective
  } = params;
  on('beforeInit', () => {
    if (swiper.params.effect !== effect) return;
    swiper.classNames.push(`${swiper.params.containerModifierClass}${effect}`);

    if (perspective && perspective()) {
      swiper.classNames.push(`${swiper.params.containerModifierClass}3d`);
    }

    const overwriteParamsResult = overwriteParams ? overwriteParams() : {};
    Object.assign(swiper.params, overwriteParamsResult);
    Object.assign(swiper.originalParams, overwriteParamsResult);
  });
  on('setTranslate', () => {
    if (swiper.params.effect !== effect) return;
    setTranslate();
  });
  on('setTransition', (_s, duration) => {
    if (swiper.params.effect !== effect) return;
    setTransition(duration);
  });
}

/***/ }),

/***/ "./node_modules/swiper/shared/effect-target.js":
/*!*****************************************************!*\
  !*** ./node_modules/swiper/shared/effect-target.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ effectTarget)
/* harmony export */ });
function effectTarget(effectParams, $slideEl) {
  if (effectParams.transformEl) {
    return $slideEl.find(effectParams.transformEl).css({
      'backface-visibility': 'hidden',
      '-webkit-backface-visibility': 'hidden'
    });
  }

  return $slideEl;
}

/***/ }),

/***/ "./node_modules/swiper/shared/effect-virtual-transition-end.js":
/*!*********************************************************************!*\
  !*** ./node_modules/swiper/shared/effect-virtual-transition-end.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ effectVirtualTransitionEnd)
/* harmony export */ });
function effectVirtualTransitionEnd(_ref) {
  let {
    swiper,
    duration,
    transformEl,
    allSlides
  } = _ref;
  const {
    slides,
    activeIndex,
    $wrapperEl
  } = swiper;

  if (swiper.params.virtualTranslate && duration !== 0) {
    let eventTriggered = false;
    let $transitionEndTarget;

    if (allSlides) {
      $transitionEndTarget = transformEl ? slides.find(transformEl) : slides;
    } else {
      $transitionEndTarget = transformEl ? slides.eq(activeIndex).find(transformEl) : slides.eq(activeIndex);
    }

    $transitionEndTarget.transitionEnd(() => {
      if (eventTriggered) return;
      if (!swiper || swiper.destroyed) return;
      eventTriggered = true;
      swiper.animating = false;
      const triggerEvents = ['webkitTransitionEnd', 'transitionend'];

      for (let i = 0; i < triggerEvents.length; i += 1) {
        $wrapperEl.trigger(triggerEvents[i]);
      }
    });
  }
}

/***/ }),

/***/ "./node_modules/swiper/shared/get-browser.js":
/*!***************************************************!*\
  !*** ./node_modules/swiper/shared/get-browser.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getBrowser": () => (/* binding */ getBrowser)
/* harmony export */ });
/* harmony import */ var ssr_window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ssr-window */ "./node_modules/ssr-window/ssr-window.esm.js");

let browser;

function calcBrowser() {
  const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();

  function isSafari() {
    const ua = window.navigator.userAgent.toLowerCase();
    return ua.indexOf('safari') >= 0 && ua.indexOf('chrome') < 0 && ua.indexOf('android') < 0;
  }

  return {
    isSafari: isSafari(),
    isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(window.navigator.userAgent)
  };
}

function getBrowser() {
  if (!browser) {
    browser = calcBrowser();
  }

  return browser;
}



/***/ }),

/***/ "./node_modules/swiper/shared/get-device.js":
/*!**************************************************!*\
  !*** ./node_modules/swiper/shared/get-device.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getDevice": () => (/* binding */ getDevice)
/* harmony export */ });
/* harmony import */ var ssr_window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ssr-window */ "./node_modules/ssr-window/ssr-window.esm.js");
/* harmony import */ var _get_support_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./get-support.js */ "./node_modules/swiper/shared/get-support.js");


let deviceCached;

function calcDevice(_temp) {
  let {
    userAgent
  } = _temp === void 0 ? {} : _temp;
  const support = (0,_get_support_js__WEBPACK_IMPORTED_MODULE_1__.getSupport)();
  const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();
  const platform = window.navigator.platform;
  const ua = userAgent || window.navigator.userAgent;
  const device = {
    ios: false,
    android: false
  };
  const screenWidth = window.screen.width;
  const screenHeight = window.screen.height;
  const android = ua.match(/(Android);?[\s\/]+([\d.]+)?/); // eslint-disable-line

  let ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
  const ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
  const iphone = !ipad && ua.match(/(iPhone\sOS|iOS)\s([\d_]+)/);
  const windows = platform === 'Win32';
  let macos = platform === 'MacIntel'; // iPadOs 13 fix

  const iPadScreens = ['1024x1366', '1366x1024', '834x1194', '1194x834', '834x1112', '1112x834', '768x1024', '1024x768', '820x1180', '1180x820', '810x1080', '1080x810'];

  if (!ipad && macos && support.touch && iPadScreens.indexOf(`${screenWidth}x${screenHeight}`) >= 0) {
    ipad = ua.match(/(Version)\/([\d.]+)/);
    if (!ipad) ipad = [0, 1, '13_0_0'];
    macos = false;
  } // Android


  if (android && !windows) {
    device.os = 'android';
    device.android = true;
  }

  if (ipad || iphone || ipod) {
    device.os = 'ios';
    device.ios = true;
  } // Export object


  return device;
}

function getDevice(overrides) {
  if (overrides === void 0) {
    overrides = {};
  }

  if (!deviceCached) {
    deviceCached = calcDevice(overrides);
  }

  return deviceCached;
}



/***/ }),

/***/ "./node_modules/swiper/shared/get-support.js":
/*!***************************************************!*\
  !*** ./node_modules/swiper/shared/get-support.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getSupport": () => (/* binding */ getSupport)
/* harmony export */ });
/* harmony import */ var ssr_window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ssr-window */ "./node_modules/ssr-window/ssr-window.esm.js");

let support;

function calcSupport() {
  const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();
  const document = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getDocument)();
  return {
    smoothScroll: document.documentElement && 'scrollBehavior' in document.documentElement.style,
    touch: !!('ontouchstart' in window || window.DocumentTouch && document instanceof window.DocumentTouch),
    passiveListener: function checkPassiveListener() {
      let supportsPassive = false;

      try {
        const opts = Object.defineProperty({}, 'passive', {
          // eslint-disable-next-line
          get() {
            supportsPassive = true;
          }

        });
        window.addEventListener('testPassiveListener', null, opts);
      } catch (e) {// No support
      }

      return supportsPassive;
    }(),
    gestures: function checkGestures() {
      return 'ongesturestart' in window;
    }()
  };
}

function getSupport() {
  if (!support) {
    support = calcSupport();
  }

  return support;
}



/***/ }),

/***/ "./node_modules/swiper/shared/utils.js":
/*!*********************************************!*\
  !*** ./node_modules/swiper/shared/utils.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "animateCSSModeScroll": () => (/* binding */ animateCSSModeScroll),
/* harmony export */   "deleteProps": () => (/* binding */ deleteProps),
/* harmony export */   "nextTick": () => (/* binding */ nextTick),
/* harmony export */   "now": () => (/* binding */ now),
/* harmony export */   "getTranslate": () => (/* binding */ getTranslate),
/* harmony export */   "isObject": () => (/* binding */ isObject),
/* harmony export */   "extend": () => (/* binding */ extend),
/* harmony export */   "getComputedStyle": () => (/* binding */ getComputedStyle),
/* harmony export */   "setCSSProperty": () => (/* binding */ setCSSProperty)
/* harmony export */ });
/* harmony import */ var ssr_window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ssr-window */ "./node_modules/ssr-window/ssr-window.esm.js");


function deleteProps(obj) {
  const object = obj;
  Object.keys(object).forEach(key => {
    try {
      object[key] = null;
    } catch (e) {// no getter for object
    }

    try {
      delete object[key];
    } catch (e) {// something got wrong
    }
  });
}

function nextTick(callback, delay) {
  if (delay === void 0) {
    delay = 0;
  }

  return setTimeout(callback, delay);
}

function now() {
  return Date.now();
}

function getComputedStyle(el) {
  const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();
  let style;

  if (window.getComputedStyle) {
    style = window.getComputedStyle(el, null);
  }

  if (!style && el.currentStyle) {
    style = el.currentStyle;
  }

  if (!style) {
    style = el.style;
  }

  return style;
}

function getTranslate(el, axis) {
  if (axis === void 0) {
    axis = 'x';
  }

  const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();
  let matrix;
  let curTransform;
  let transformMatrix;
  const curStyle = getComputedStyle(el, null);

  if (window.WebKitCSSMatrix) {
    curTransform = curStyle.transform || curStyle.webkitTransform;

    if (curTransform.split(',').length > 6) {
      curTransform = curTransform.split(', ').map(a => a.replace(',', '.')).join(', ');
    } // Some old versions of Webkit choke when 'none' is passed; pass
    // empty string instead in this case


    transformMatrix = new window.WebKitCSSMatrix(curTransform === 'none' ? '' : curTransform);
  } else {
    transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue('transform').replace('translate(', 'matrix(1, 0, 0, 1,');
    matrix = transformMatrix.toString().split(',');
  }

  if (axis === 'x') {
    // Latest Chrome and webkits Fix
    if (window.WebKitCSSMatrix) curTransform = transformMatrix.m41; // Crazy IE10 Matrix
    else if (matrix.length === 16) curTransform = parseFloat(matrix[12]); // Normal Browsers
    else curTransform = parseFloat(matrix[4]);
  }

  if (axis === 'y') {
    // Latest Chrome and webkits Fix
    if (window.WebKitCSSMatrix) curTransform = transformMatrix.m42; // Crazy IE10 Matrix
    else if (matrix.length === 16) curTransform = parseFloat(matrix[13]); // Normal Browsers
    else curTransform = parseFloat(matrix[5]);
  }

  return curTransform || 0;
}

function isObject(o) {
  return typeof o === 'object' && o !== null && o.constructor && Object.prototype.toString.call(o).slice(8, -1) === 'Object';
}

function isNode(node) {
  // eslint-disable-next-line
  if (typeof window !== 'undefined' && typeof window.HTMLElement !== 'undefined') {
    return node instanceof HTMLElement;
  }

  return node && (node.nodeType === 1 || node.nodeType === 11);
}

function extend() {
  const to = Object(arguments.length <= 0 ? undefined : arguments[0]);
  const noExtend = ['__proto__', 'constructor', 'prototype'];

  for (let i = 1; i < arguments.length; i += 1) {
    const nextSource = i < 0 || arguments.length <= i ? undefined : arguments[i];

    if (nextSource !== undefined && nextSource !== null && !isNode(nextSource)) {
      const keysArray = Object.keys(Object(nextSource)).filter(key => noExtend.indexOf(key) < 0);

      for (let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
        const nextKey = keysArray[nextIndex];
        const desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);

        if (desc !== undefined && desc.enumerable) {
          if (isObject(to[nextKey]) && isObject(nextSource[nextKey])) {
            if (nextSource[nextKey].__swiper__) {
              to[nextKey] = nextSource[nextKey];
            } else {
              extend(to[nextKey], nextSource[nextKey]);
            }
          } else if (!isObject(to[nextKey]) && isObject(nextSource[nextKey])) {
            to[nextKey] = {};

            if (nextSource[nextKey].__swiper__) {
              to[nextKey] = nextSource[nextKey];
            } else {
              extend(to[nextKey], nextSource[nextKey]);
            }
          } else {
            to[nextKey] = nextSource[nextKey];
          }
        }
      }
    }
  }

  return to;
}

function setCSSProperty(el, varName, varValue) {
  el.style.setProperty(varName, varValue);
}

function animateCSSModeScroll(_ref) {
  let {
    swiper,
    targetPosition,
    side
  } = _ref;
  const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();
  const startPosition = -swiper.translate;
  let startTime = null;
  let time;
  const duration = swiper.params.speed;
  swiper.wrapperEl.style.scrollSnapType = 'none';
  window.cancelAnimationFrame(swiper.cssModeFrameID);
  const dir = targetPosition > startPosition ? 'next' : 'prev';

  const isOutOfBound = (current, target) => {
    return dir === 'next' && current >= target || dir === 'prev' && current <= target;
  };

  const animate = () => {
    time = new Date().getTime();

    if (startTime === null) {
      startTime = time;
    }

    const progress = Math.max(Math.min((time - startTime) / duration, 1), 0);
    const easeProgress = 0.5 - Math.cos(progress * Math.PI) / 2;
    let currentPosition = startPosition + easeProgress * (targetPosition - startPosition);

    if (isOutOfBound(currentPosition, targetPosition)) {
      currentPosition = targetPosition;
    }

    swiper.wrapperEl.scrollTo({
      [side]: currentPosition
    });

    if (isOutOfBound(currentPosition, targetPosition)) {
      swiper.wrapperEl.style.overflow = 'hidden';
      swiper.wrapperEl.style.scrollSnapType = '';
      setTimeout(() => {
        swiper.wrapperEl.style.overflow = '';
        swiper.wrapperEl.scrollTo({
          [side]: currentPosition
        });
      });
      window.cancelAnimationFrame(swiper.cssModeFrameID);
      return;
    }

    swiper.cssModeFrameID = window.requestAnimationFrame(animate);
  };

  animate();
}



/***/ }),

/***/ "./node_modules/swiper/swiper.esm.js":
/*!*******************************************!*\
  !*** ./node_modules/swiper/swiper.esm.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Swiper": () => (/* reexport safe */ _core_core_js__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   "default": () => (/* reexport safe */ _core_core_js__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   "Virtual": () => (/* reexport safe */ _modules_virtual_virtual_js__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   "Keyboard": () => (/* reexport safe */ _modules_keyboard_keyboard_js__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   "Mousewheel": () => (/* reexport safe */ _modules_mousewheel_mousewheel_js__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   "Navigation": () => (/* reexport safe */ _modules_navigation_navigation_js__WEBPACK_IMPORTED_MODULE_4__["default"]),
/* harmony export */   "Pagination": () => (/* reexport safe */ _modules_pagination_pagination_js__WEBPACK_IMPORTED_MODULE_5__["default"]),
/* harmony export */   "Scrollbar": () => (/* reexport safe */ _modules_scrollbar_scrollbar_js__WEBPACK_IMPORTED_MODULE_6__["default"]),
/* harmony export */   "Parallax": () => (/* reexport safe */ _modules_parallax_parallax_js__WEBPACK_IMPORTED_MODULE_7__["default"]),
/* harmony export */   "Zoom": () => (/* reexport safe */ _modules_zoom_zoom_js__WEBPACK_IMPORTED_MODULE_8__["default"]),
/* harmony export */   "Lazy": () => (/* reexport safe */ _modules_lazy_lazy_js__WEBPACK_IMPORTED_MODULE_9__["default"]),
/* harmony export */   "Controller": () => (/* reexport safe */ _modules_controller_controller_js__WEBPACK_IMPORTED_MODULE_10__["default"]),
/* harmony export */   "A11y": () => (/* reexport safe */ _modules_a11y_a11y_js__WEBPACK_IMPORTED_MODULE_11__["default"]),
/* harmony export */   "History": () => (/* reexport safe */ _modules_history_history_js__WEBPACK_IMPORTED_MODULE_12__["default"]),
/* harmony export */   "HashNavigation": () => (/* reexport safe */ _modules_hash_navigation_hash_navigation_js__WEBPACK_IMPORTED_MODULE_13__["default"]),
/* harmony export */   "Autoplay": () => (/* reexport safe */ _modules_autoplay_autoplay_js__WEBPACK_IMPORTED_MODULE_14__["default"]),
/* harmony export */   "Thumbs": () => (/* reexport safe */ _modules_thumbs_thumbs_js__WEBPACK_IMPORTED_MODULE_15__["default"]),
/* harmony export */   "FreeMode": () => (/* reexport safe */ _modules_free_mode_free_mode_js__WEBPACK_IMPORTED_MODULE_16__["default"]),
/* harmony export */   "Grid": () => (/* reexport safe */ _modules_grid_grid_js__WEBPACK_IMPORTED_MODULE_17__["default"]),
/* harmony export */   "Manipulation": () => (/* reexport safe */ _modules_manipulation_manipulation_js__WEBPACK_IMPORTED_MODULE_18__["default"]),
/* harmony export */   "EffectFade": () => (/* reexport safe */ _modules_effect_fade_effect_fade_js__WEBPACK_IMPORTED_MODULE_19__["default"]),
/* harmony export */   "EffectCube": () => (/* reexport safe */ _modules_effect_cube_effect_cube_js__WEBPACK_IMPORTED_MODULE_20__["default"]),
/* harmony export */   "EffectFlip": () => (/* reexport safe */ _modules_effect_flip_effect_flip_js__WEBPACK_IMPORTED_MODULE_21__["default"]),
/* harmony export */   "EffectCoverflow": () => (/* reexport safe */ _modules_effect_coverflow_effect_coverflow_js__WEBPACK_IMPORTED_MODULE_22__["default"]),
/* harmony export */   "EffectCreative": () => (/* reexport safe */ _modules_effect_creative_effect_creative_js__WEBPACK_IMPORTED_MODULE_23__["default"]),
/* harmony export */   "EffectCards": () => (/* reexport safe */ _modules_effect_cards_effect_cards_js__WEBPACK_IMPORTED_MODULE_24__["default"])
/* harmony export */ });
/* harmony import */ var _core_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core/core.js */ "./node_modules/swiper/core/core.js");
/* harmony import */ var _modules_virtual_virtual_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modules/virtual/virtual.js */ "./node_modules/swiper/modules/virtual/virtual.js");
/* harmony import */ var _modules_keyboard_keyboard_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modules/keyboard/keyboard.js */ "./node_modules/swiper/modules/keyboard/keyboard.js");
/* harmony import */ var _modules_mousewheel_mousewheel_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./modules/mousewheel/mousewheel.js */ "./node_modules/swiper/modules/mousewheel/mousewheel.js");
/* harmony import */ var _modules_navigation_navigation_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./modules/navigation/navigation.js */ "./node_modules/swiper/modules/navigation/navigation.js");
/* harmony import */ var _modules_pagination_pagination_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./modules/pagination/pagination.js */ "./node_modules/swiper/modules/pagination/pagination.js");
/* harmony import */ var _modules_scrollbar_scrollbar_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./modules/scrollbar/scrollbar.js */ "./node_modules/swiper/modules/scrollbar/scrollbar.js");
/* harmony import */ var _modules_parallax_parallax_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./modules/parallax/parallax.js */ "./node_modules/swiper/modules/parallax/parallax.js");
/* harmony import */ var _modules_zoom_zoom_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./modules/zoom/zoom.js */ "./node_modules/swiper/modules/zoom/zoom.js");
/* harmony import */ var _modules_lazy_lazy_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./modules/lazy/lazy.js */ "./node_modules/swiper/modules/lazy/lazy.js");
/* harmony import */ var _modules_controller_controller_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./modules/controller/controller.js */ "./node_modules/swiper/modules/controller/controller.js");
/* harmony import */ var _modules_a11y_a11y_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./modules/a11y/a11y.js */ "./node_modules/swiper/modules/a11y/a11y.js");
/* harmony import */ var _modules_history_history_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./modules/history/history.js */ "./node_modules/swiper/modules/history/history.js");
/* harmony import */ var _modules_hash_navigation_hash_navigation_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./modules/hash-navigation/hash-navigation.js */ "./node_modules/swiper/modules/hash-navigation/hash-navigation.js");
/* harmony import */ var _modules_autoplay_autoplay_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./modules/autoplay/autoplay.js */ "./node_modules/swiper/modules/autoplay/autoplay.js");
/* harmony import */ var _modules_thumbs_thumbs_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./modules/thumbs/thumbs.js */ "./node_modules/swiper/modules/thumbs/thumbs.js");
/* harmony import */ var _modules_free_mode_free_mode_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./modules/free-mode/free-mode.js */ "./node_modules/swiper/modules/free-mode/free-mode.js");
/* harmony import */ var _modules_grid_grid_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./modules/grid/grid.js */ "./node_modules/swiper/modules/grid/grid.js");
/* harmony import */ var _modules_manipulation_manipulation_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./modules/manipulation/manipulation.js */ "./node_modules/swiper/modules/manipulation/manipulation.js");
/* harmony import */ var _modules_effect_fade_effect_fade_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./modules/effect-fade/effect-fade.js */ "./node_modules/swiper/modules/effect-fade/effect-fade.js");
/* harmony import */ var _modules_effect_cube_effect_cube_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./modules/effect-cube/effect-cube.js */ "./node_modules/swiper/modules/effect-cube/effect-cube.js");
/* harmony import */ var _modules_effect_flip_effect_flip_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./modules/effect-flip/effect-flip.js */ "./node_modules/swiper/modules/effect-flip/effect-flip.js");
/* harmony import */ var _modules_effect_coverflow_effect_coverflow_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./modules/effect-coverflow/effect-coverflow.js */ "./node_modules/swiper/modules/effect-coverflow/effect-coverflow.js");
/* harmony import */ var _modules_effect_creative_effect_creative_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./modules/effect-creative/effect-creative.js */ "./node_modules/swiper/modules/effect-creative/effect-creative.js");
/* harmony import */ var _modules_effect_cards_effect_cards_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./modules/effect-cards/effect-cards.js */ "./node_modules/swiper/modules/effect-cards/effect-cards.js");
/**
 * Swiper 8.0.6
 * Most modern mobile touch slider and framework with hardware accelerated transitions
 * https://swiperjs.com
 *
 * Copyright 2014-2022 Vladimir Kharlampidi
 *
 * Released under the MIT License
 *
 * Released on: February 14, 2022
 */



























/***/ }),

/***/ "./node_modules/axios/package.json":
/*!*****************************************!*\
  !*** ./node_modules/axios/package.json ***!
  \*****************************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"name":"axios","version":"0.21.4","description":"Promise based HTTP client for the browser and node.js","main":"index.js","scripts":{"test":"grunt test","start":"node ./sandbox/server.js","build":"NODE_ENV=production grunt build","preversion":"npm test","version":"npm run build && grunt version && git add -A dist && git add CHANGELOG.md bower.json package.json","postversion":"git push && git push --tags","examples":"node ./examples/server.js","coveralls":"cat coverage/lcov.info | ./node_modules/coveralls/bin/coveralls.js","fix":"eslint --fix lib/**/*.js"},"repository":{"type":"git","url":"https://github.com/axios/axios.git"},"keywords":["xhr","http","ajax","promise","node"],"author":"Matt Zabriskie","license":"MIT","bugs":{"url":"https://github.com/axios/axios/issues"},"homepage":"https://axios-http.com","devDependencies":{"coveralls":"^3.0.0","es6-promise":"^4.2.4","grunt":"^1.3.0","grunt-banner":"^0.6.0","grunt-cli":"^1.2.0","grunt-contrib-clean":"^1.1.0","grunt-contrib-watch":"^1.0.0","grunt-eslint":"^23.0.0","grunt-karma":"^4.0.0","grunt-mocha-test":"^0.13.3","grunt-ts":"^6.0.0-beta.19","grunt-webpack":"^4.0.2","istanbul-instrumenter-loader":"^1.0.0","jasmine-core":"^2.4.1","karma":"^6.3.2","karma-chrome-launcher":"^3.1.0","karma-firefox-launcher":"^2.1.0","karma-jasmine":"^1.1.1","karma-jasmine-ajax":"^0.1.13","karma-safari-launcher":"^1.0.0","karma-sauce-launcher":"^4.3.6","karma-sinon":"^1.0.5","karma-sourcemap-loader":"^0.3.8","karma-webpack":"^4.0.2","load-grunt-tasks":"^3.5.2","minimist":"^1.2.0","mocha":"^8.2.1","sinon":"^4.5.0","terser-webpack-plugin":"^4.2.3","typescript":"^4.0.5","url-search-params":"^0.10.0","webpack":"^4.44.2","webpack-dev-server":"^3.11.0"},"browser":{"./lib/adapters/http.js":"./lib/adapters/xhr.js"},"jsdelivr":"dist/axios.min.js","unpkg":"dist/axios.min.js","typings":"./index.d.ts","dependencies":{"follow-redirects":"^1.14.0"},"bundlesize":[{"path":"./dist/axios.min.js","threshold":"5kB"}]}');

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/chunk loaded */
/******/ 	(() => {
/******/ 		var deferred = [];
/******/ 		__webpack_require__.O = (result, chunkIds, fn, priority) => {
/******/ 			if(chunkIds) {
/******/ 				priority = priority || 0;
/******/ 				for(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];
/******/ 				deferred[i] = [chunkIds, fn, priority];
/******/ 				return;
/******/ 			}
/******/ 			var notFulfilled = Infinity;
/******/ 			for (var i = 0; i < deferred.length; i++) {
/******/ 				var [chunkIds, fn, priority] = deferred[i];
/******/ 				var fulfilled = true;
/******/ 				for (var j = 0; j < chunkIds.length; j++) {
/******/ 					if ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {
/******/ 						chunkIds.splice(j--, 1);
/******/ 					} else {
/******/ 						fulfilled = false;
/******/ 						if(priority < notFulfilled) notFulfilled = priority;
/******/ 					}
/******/ 				}
/******/ 				if(fulfilled) {
/******/ 					deferred.splice(i--, 1)
/******/ 					var r = fn();
/******/ 					if (r !== undefined) result = r;
/******/ 				}
/******/ 			}
/******/ 			return result;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"/js/app": 0,
/******/ 			"css/app": 0
/******/ 		};
/******/ 		
/******/ 		// no chunk on demand loading
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		__webpack_require__.O.j = (chunkId) => (installedChunks[chunkId] === 0);
/******/ 		
/******/ 		// install a JSONP callback for chunk loading
/******/ 		var webpackJsonpCallback = (parentChunkLoadingFunction, data) => {
/******/ 			var [chunkIds, moreModules, runtime] = data;
/******/ 			// add "moreModules" to the modules object,
/******/ 			// then flag all "chunkIds" as loaded and fire callback
/******/ 			var moduleId, chunkId, i = 0;
/******/ 			if(chunkIds.some((id) => (installedChunks[id] !== 0))) {
/******/ 				for(moduleId in moreModules) {
/******/ 					if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 						__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 					}
/******/ 				}
/******/ 				if(runtime) var result = runtime(__webpack_require__);
/******/ 			}
/******/ 			if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);
/******/ 			for(;i < chunkIds.length; i++) {
/******/ 				chunkId = chunkIds[i];
/******/ 				if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 					installedChunks[chunkId][0]();
/******/ 				}
/******/ 				installedChunks[chunkId] = 0;
/******/ 			}
/******/ 			return __webpack_require__.O(result);
/******/ 		}
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunk"] = self["webpackChunk"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module depends on other loaded chunks and execution need to be delayed
/******/ 	__webpack_require__.O(undefined, ["css/app"], () => (__webpack_require__("./resources/js/app.js")))
/******/ 	var __webpack_exports__ = __webpack_require__.O(undefined, ["css/app"], () => (__webpack_require__("./resources/css/app.css")))
/******/ 	__webpack_exports__ = __webpack_require__.O(__webpack_exports__);
/******/ 	
/******/ })()
;